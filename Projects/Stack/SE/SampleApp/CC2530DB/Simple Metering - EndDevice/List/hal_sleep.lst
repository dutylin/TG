###############################################################################
#                                                                             #
# IAR C/C++ Compiler V8.20.2.41139 for 8051             13/Jun/2013  14:25:20 #
# Copyright 2004-2013 IAR Systems AB.                                         #
#                                                                             #
#    Core               =  plain                                              #
#    Code model         =  banked                                             #
#    Data model         =  large                                              #
#    Calling convention =  xdata reentrant                                    #
#    Constant location  =  data_rom                                           #
#    Dptr setup         =  1,16                                               #
#                                                                             #
#    Source file        =  C:\Users\PedroZ\Documents\GitHub\TG\Components\hal #
#                          \target\CC2530EB\hal_sleep.c                       #
#    Command line       =  -f C:\Users\PedroZ\Documents\GitHub\TG\Projects\St #
#                          ack\SE\SampleApp\CC2530DB\..\..\..\Tools\CC2530DB\ #
#                          f8wEndev.cfg (-DCPU32MHZ -DROOT=__near_func        #
#                          -DMAC_CFG_TX_DATA_MAX=3 -DMAC_CFG_TX_MAX=6         #
#                          -DMAC_CFG_RX_MAX=3) -f C:\Users\PedroZ\Documents\G #
#                          itHub\TG\Projects\Stack\SE\SampleApp\CC2530DB\..\. #
#                          .\..\Tools\CC2530DB\f8wConfig.cfg (-DZIGBEEPRO     #
#                          -DSECURE=0 -DZG_SECURE_DYNAMIC=0 -DREFLECTOR       #
#                          -DDEFAULT_CHANLIST=0x00000800                      #
#                          -DZDAPP_CONFIG_PAN_ID=0xFFFF                       #
#                          -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MA #
#                          SK=0x007F -DBEACON_REQUEST_DELAY=100               #
#                          -DBEACON_REQ_DELAY_MASK=0x00FF                     #
#                          -DLINK_STATUS_JITTER_MASK=0x007F                   #
#                          -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_PO #
#                          LLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7             #
#                          -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3    #
#                          -DNWK_MAX_DATA_RETRIES=2                           #
#                          -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9         #
#                          -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40           #
#                          -DNWK_MAX_BINDING_ENTRIES=4                        #
#                          -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01,  #
#                          0x03, 0x05, 0x07, 0x09, 0x0B, 0x0D, 0x0F, 0x00,    #
#                          0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C, 0x0D}"         #
#                          -DMAC_MAX_FRAME_SIZE=116                           #
#                          -DZDNWKMGR_MIN_TRANSMISSIONS=20 "-DCONST=const     #
#                          __code" -DGENERIC=__generic                        #
#                          -DRFD_RCVC_ALWAYS_ON=FALSE -DPOLL_RATE=1000        #
#                          -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100    #
#                          -DREJOIN_POLL_RATE=440) -f                         #
#                          C:\Users\PedroZ\Documents\GitHub\TG\Projects\Stack #
#                          \SE\SampleApp\CC2530DB\..\..\..\Tools\CC2530DB\f8w #
#                          ZCL.cfg (-DZCL_READ -DZCL_WRITE -DZCL_BASIC        #
#                          -DZCL_IDENTIFY -DZCL_ON_OFF -DZCL_KEY_ESTABLISH    #
#                          -DZCL_KEY_ESTABLISHMENT_KEY_GENERATE_TIMEOUT=4     #
#                          -DZCL_KEY_ESTABLISHMENT_MAC_GENERATE_TIMEOUT=10    #
#                          -DZCL_KEY_ESTABLISHMENT_EKEY_GENERATE_TIMEOUT=10   #
#                          -DZCL_LOAD_CONTROL -DZCL_SIMPLE_METERING           #
#                          -DZCL_PRICING -DZCL_MESSAGE -DZCL_TUNNELING        #
#                          -DZCL_TOU) -DZCL_DEVICE_MGMT                       #
#                          C:\Users\PedroZ\Documents\GitHub\TG\Components\hal #
#                          \target\CC2530EB\hal_sleep.c -D TC_LINKKEY_JOIN    #
#                          -D ZTOOL_P1 -D MT_TASK -D MT_APP_FUNC -D           #
#                          MT_SYS_FUNC -D LCD_SUPPORTED -D NV_INIT -D         #
#                          xNV_RESTORE -D HOLD_AUTO_START -D NWK_AUTO_POLL    #
#                          -D ZCL_REPORT -D POWER_SAVING -D                   #
#                          MAX_POLL_FAILURE_RETRIES=20 -D TEST_CERT_DATA -lC  #
#                          "C:\Users\PedroZ\Documents\GitHub\TG\Projects\Stac #
#                          k\SE\SampleApp\CC2530DB\Simple Metering -          #
#                          EndDevice\List\" -lA "C:\Users\PedroZ\Documents\Gi #
#                          tHub\TG\Projects\Stack\SE\SampleApp\CC2530DB\Simpl #
#                          e Metering - EndDevice\List\" --diag_suppress      #
#                          Pe001,Pa010 -o "C:\Users\PedroZ\Documents\GitHub\T #
#                          G\Projects\Stack\SE\SampleApp\CC2530DB\Simple      #
#                          Metering - EndDevice\Obj\" -e --no_cse             #
#                          --no_unroll --no_inline --no_code_motion           #
#                          --no_tbaa --debug --core=plain --dptr=16,1         #
#                          --data_model=large --code_model=banked             #
#                          --calling_convention=xdata_reentrant               #
#                          --place_constants=data_rom --nr_virtual_regs 16    #
#                          -I C:\Users\PedroZ\Documents\GitHub\TG\Projects\St #
#                          ack\SE\SampleApp\CC2530DB\ -I                      #
#                          C:\Users\PedroZ\Documents\GitHub\TG\Projects\Stack #
#                          \SE\SampleApp\CC2530DB\..\Source\ -I               #
#                          C:\Users\PedroZ\Documents\GitHub\TG\Projects\Stack #
#                          \SE\SampleApp\CC2530DB\..\..\Source\ -I            #
#                          C:\Users\PedroZ\Documents\GitHub\TG\Projects\Stack #
#                          \SE\SampleApp\CC2530DB\..\..\..\ZMain\TI2530DB\    #
#                          -I C:\Users\PedroZ\Documents\GitHub\TG\Projects\St #
#                          ack\SE\SampleApp\CC2530DB\..\..\..\..\..\Component #
#                          s\hal\include\ -I C:\Users\PedroZ\Documents\GitHub #
#                          \TG\Projects\Stack\SE\SampleApp\CC2530DB\..\..\..\ #
#                          ..\..\Components\hal\target\CC2530EB\ -I           #
#                          C:\Users\PedroZ\Documents\GitHub\TG\Projects\Stack #
#                          \SE\SampleApp\CC2530DB\..\..\..\..\..\Components\m #
#                          ac\include\ -I C:\Users\PedroZ\Documents\GitHub\TG #
#                          \Projects\Stack\SE\SampleApp\CC2530DB\..\..\..\..\ #
#                          ..\Components\mac\high_level\ -I                   #
#                          C:\Users\PedroZ\Documents\GitHub\TG\Projects\Stack #
#                          \SE\SampleApp\CC2530DB\..\..\..\..\..\Components\m #
#                          ac\low_level\srf04\ -I C:\Users\PedroZ\Documents\G #
#                          itHub\TG\Projects\Stack\SE\SampleApp\CC2530DB\..\. #
#                          .\..\..\..\Components\mac\low_level\srf04\single_c #
#                          hip\ -I C:\Users\PedroZ\Documents\GitHub\TG\Projec #
#                          ts\Stack\SE\SampleApp\CC2530DB\..\..\..\..\..\Comp #
#                          onents\mt\ -I C:\Users\PedroZ\Documents\GitHub\TG\ #
#                          Projects\Stack\SE\SampleApp\CC2530DB\..\..\..\..\. #
#                          .\Components\osal\include\ -I                      #
#                          C:\Users\PedroZ\Documents\GitHub\TG\Projects\Stack #
#                          \SE\SampleApp\CC2530DB\..\..\..\..\..\Components\s #
#                          ervices\saddr\ -I C:\Users\PedroZ\Documents\GitHub #
#                          \TG\Projects\Stack\SE\SampleApp\CC2530DB\..\..\..\ #
#                          ..\..\Components\services\sdata\ -I                #
#                          C:\Users\PedroZ\Documents\GitHub\TG\Projects\Stack #
#                          \SE\SampleApp\CC2530DB\..\..\..\..\..\Components\s #
#                          tack\af\ -I C:\Users\PedroZ\Documents\GitHub\TG\Pr #
#                          ojects\Stack\SE\SampleApp\CC2530DB\..\..\..\..\..\ #
#                          Components\stack\nwk\ -I                           #
#                          C:\Users\PedroZ\Documents\GitHub\TG\Projects\Stack #
#                          \SE\SampleApp\CC2530DB\..\..\..\..\..\Components\s #
#                          tack\sapi\ -I C:\Users\PedroZ\Documents\GitHub\TG\ #
#                          Projects\Stack\SE\SampleApp\CC2530DB\..\..\..\..\. #
#                          .\Components\stack\sec\ -I                         #
#                          C:\Users\PedroZ\Documents\GitHub\TG\Projects\Stack #
#                          \SE\SampleApp\CC2530DB\..\..\..\..\..\Components\s #
#                          tack\sys\ -I C:\Users\PedroZ\Documents\GitHub\TG\P #
#                          rojects\Stack\SE\SampleApp\CC2530DB\..\..\..\..\.. #
#                          \Components\stack\zcl\ -I                          #
#                          C:\Users\PedroZ\Documents\GitHub\TG\Projects\Stack #
#                          \SE\SampleApp\CC2530DB\..\..\..\..\..\Components\s #
#                          tack\zdo\ -I C:\Users\PedroZ\Documents\GitHub\TG\P #
#                          rojects\Stack\SE\SampleApp\CC2530DB\..\..\..\..\.. #
#                          \Components\zmac\ -I C:\Users\PedroZ\Documents\Git #
#                          Hub\TG\Projects\Stack\SE\SampleApp\CC2530DB\..\..\ #
#                          ..\..\..\Components\zmac\f8w\ -On                  #
#                          --require_prototypes                               #
#    List file          =  C:\Users\PedroZ\Documents\GitHub\TG\Projects\Stack #
#                          \SE\SampleApp\CC2530DB\Simple Metering -           #
#                          EndDevice\List\hal_sleep.lst                       #
#    Object file        =  C:\Users\PedroZ\Documents\GitHub\TG\Projects\Stack #
#                          \SE\SampleApp\CC2530DB\Simple Metering -           #
#                          EndDevice\Obj\hal_sleep.r51                        #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\PedroZ\Documents\GitHub\TG\Components\hal\target\CC2530EB\hal_sleep.c
      1          /**************************************************************************************************
      2            Filename:       hal_sleep.c
      3            Revised:        $Date: 2012-03-07 11:55:12 -0800 (Wed, 07 Mar 2012) $
      4            Revision:       $Revision: 29664 $
      5          
      6            Description:    This module contains the HAL power management procedures for the CC2530.
      7          
      8          
      9            Copyright 2006-2012 Texas Instruments Incorporated. All rights reserved.
     10          
     11            IMPORTANT: Your use of this Software is limited to those specific rights
     12            granted under the terms of a software license agreement between the user
     13            who downloaded the software, his/her employer (which must be your employer)
     14            and Texas Instruments Incorporated (the "License").  You may not use this
     15            Software unless you agree to abide by the terms of the License. The License
     16            limits your use, and you acknowledge, that the Software may not be modified,
     17            copied or distributed unless embedded on a Texas Instruments microcontroller
     18            or used solely and exclusively in conjunction with a Texas Instruments radio
     19            frequency transceiver, which is integrated into your product.  Other than for
     20            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     21            works of, modify, distribute, perform, display or sell this Software and/or
     22            its documentation for any purpose.
     23          
     24            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     25            PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     26            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     27            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     28            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     29            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     30            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     31            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     32            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     33            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     34            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     35          
     36            Should you have any questions regarding your right to use this Software,
     37            contact Texas Instruments Incorporated at www.TI.com.
     38          **************************************************************************************************/
     39          
     40          /* ------------------------------------------------------------------------------------------------
     41           *                                          Includes
     42           * ------------------------------------------------------------------------------------------------
     43           */
     44          #include "hal_types.h"
     45          #include "hal_mcu.h"

   \                                 In  segment SFR_AN, at 0x87
   \   unsigned char volatile __sfr PCON
   \                     PCON:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x95
   \   unsigned char volatile __sfr ST0
   \                     ST0:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x96
   \   unsigned char volatile __sfr ST1
   \                     ST1:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x97
   \   unsigned char volatile __sfr ST2
   \                     ST2:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x9a
   \   unsigned char volatile __sfr IEN2
   \                     IEN2:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xa8
   \   union <unnamed> volatile __sfr _A_IEN0
   \                     _A_IEN0:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xad
   \   unsigned char volatile __sfr STLOAD
   \                     STLOAD:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xb8
   \   union <unnamed> volatile __sfr _A_IEN1
   \                     _A_IEN1:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xbe
   \   unsigned char volatile __sfr SLEEPCMD
   \                     SLEEPCMD:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xc0
   \   union <unnamed> volatile __sfr _A_IRCON
   \                     _A_IRCON:
   \   000000                DS 1
     46          #include "hal_board.h"
     47          #include "hal_sleep.h"
     48          #include "hal_led.h"
     49          #include "hal_key.h"
     50          #include "mac_api.h"
     51          #include "OSAL.h"
     52          #include "OSAL_Timers.h"
     53          #include "OSAL_Tasks.h"
     54          #include "OSAL_PwrMgr.h"
     55          #include "OnBoard.h"
     56          #include "hal_drivers.h"
     57          #include "hal_assert.h"
     58          #include "mac_mcu.h"
     59          
     60          #ifndef ZG_BUILD_ENDDEVICE_TYPE
     61          # define ZG_BUILD_ENDDEVICE_TYPE FALSE
     62          #endif
     63          
     64          #if ZG_BUILD_ENDDEVICE_TYPE && defined (NWK_AUTO_POLL)
     65          #include "nwk_globals.h"
     66          #include "ZGlobals.h"
     67          #endif
     68          
     69          /* ------------------------------------------------------------------------------------------------
     70           *                                           Macros
     71           * ------------------------------------------------------------------------------------------------
     72           */
     73          
     74          /* POWER CONSERVATION DEFINITIONS
     75           * Sleep mode H/W definitions (enabled with POWER_SAVING compile option)
     76           */
     77          #define CC2530_PM0            0  /* PM0, Clock oscillators on, voltage regulator on */
     78          #define CC2530_PM1            1  /* PM1, 32.768 kHz oscillators on, voltage regulator on */
     79          #define CC2530_PM2            2  /* PM2, 32.768 kHz oscillators on, voltage regulator off */
     80          #define CC2530_PM3            3  /* PM3, All clock oscillators off, voltage regulator off */
     81          
     82          /* HAL power management mode is set according to the power management state. The default
     83           * setting is HAL_SLEEP_OFF. The actual value is tailored to different HW platform. Both
     84           * HAL_SLEEP_TIMER and HAL_SLEEP_DEEP selections will:
     85           *   1. turn off the system clock, and
     86           *   2. halt the MCU.
     87           * HAL_SLEEP_TIMER can be woken up by sleep timer interrupt, I/O interrupt and reset.
     88           * HAL_SLEEP_DEEP can be woken up by I/O interrupt and reset.
     89           */
     90          #define HAL_SLEEP_OFF         CC2530_PM0
     91          #define HAL_SLEEP_TIMER       CC2530_PM2
     92          #define HAL_SLEEP_DEEP        CC2530_PM3
     93          
     94          /* MAX_SLEEP_TIME calculation:
     95           *   Sleep timer maximum duration = 0xFFFF7F / 32768 Hz = 511.996 seconds
     96           *   Round it to 510 seconds or 510000 ms
     97           */
     98          #define MAX_SLEEP_TIME                   510000             /* maximum time to sleep allowed by ST */
     99          #define TICKS_SUBTRACTED                 2
    100          
    101          /* minimum time to sleep, this macro is to:
    102           * 1. avoid thrashing in-and-out of sleep with short OSAL timer (~2ms)
    103           * 2. define minimum safe sleep period
    104           */
    105          #if !defined (PM_MIN_SLEEP_TIME)
    106          #define PM_MIN_SLEEP_TIME                14                 /* default to minimum safe sleep time minimum CAP */
    107          #endif
    108          
    109          /* The PCON instruction must be 4-byte aligned. The following code may cause excessive power
    110           * consumption if not aligned. See linker file ".xcl" for actual placement.
    111           */
    112          #pragma location = "SLEEP_CODE"
    113          void halSetSleepMode(void);
    114          
    115          /* This value is used to adjust the sleep timer compare value such that the sleep timer
    116           * compare takes into account the amount of processing time spent in function halSleep().
    117           * The first value is determined by measuring the number of sleep timer ticks it from
    118           * the beginning of the function to entering sleep mode or more precisely, when
    119           * MAC_PwrNextTimeout() is called.  The second value is determined by measuring the number
    120           * of sleep timer ticks from exit of sleep mode to the call to MAC_PwrOnReq() where the
    121           * MAC timer is restarted.
    122           */
    123          #define HAL_SLEEP_ADJ_TICKS   (11 + 12)
    124          
    125          #ifndef HAL_SLEEP_DEBUG_POWER_MODE
    126          /* set CC2530 power mode; always use PM2 */
    127          #define HAL_SLEEP_PREP_POWER_MODE(mode)     st( SLEEPCMD &= ~PMODE; /* clear mode bits */    \
    128                                                          SLEEPCMD |= mode;   /* set mode bits   */    \
    129                                                          while (!(STLOAD & LDRDY));                   \
    130                                                          halSleepPconValue = PCON_IDLE;               \
    131                                                        )
    132          #define HAL_SLEEP_SET_POWER_MODE()          halSetSleepMode()
    133          #else
    134          /* Debug: don't set power mode, just block until sleep timer interrupt */
    135          #define HAL_SLEEP_PREP_POWER_MODE(mode)     /* nothing */
    136          #define HAL_SLEEP_SET_POWER_MODE()          st( while(halSleepInt == FALSE); \
    137                                                          halSleepInt = FALSE;         \
    138                                                          HAL_DISABLE_INTERRUPTS();    \
    139                                                        )
    140          #endif
    141          
    142          /* sleep and external interrupt port masks */
    143          #define STIE_BV                             BV(5)
    144          #define P0IE_BV                             BV(5)
    145          #define P1IE_BV                             BV(4)
    146          #define P2IE_BV                             BV(1)
    147          
    148          /* sleep timer interrupt control */
    149          #define HAL_SLEEP_TIMER_ENABLE_INT()        st(IEN0 |= STIE_BV;)     /* enable sleep timer interrupt */
    150          #define HAL_SLEEP_TIMER_DISABLE_INT()       st(IEN0 &= ~STIE_BV;)    /* disable sleep timer interrupt */
    151          #define HAL_SLEEP_TIMER_CLEAR_INT()         st(STIF = 0;)            /* clear sleep interrupt flag */
    152          // STIF deternmina que a INT veio do SLEEP e não do pulso 
    153          
    154          /* backup interrupt enable registers before sleep */
    155          #define HAL_SLEEP_IE_BACKUP_AND_DISABLE(ien0, ien1, ien2) st(ien0  = IEN0;    /* backup IEN0 register */ \
    156                                                                       ien1  = IEN1;    /* backup IEN1 register */ \
    157                                                                       ien2  = IEN2;    /* backup IEN2 register */ \
    158                                                                       IEN0 &= STIE_BV; /* disable IEN0 except STIE */ \
    159                                                                       IEN1 &= P0IE_BV; /* disable IEN1 except P0IE */ \
    160                                                                       IEN2 &= (P1IE_BV|P2IE_BV);) /* disable IEN2 except P1IE, P2IE */
    161          
    162          // Lembrar de deixar somente as interrupções necessarias ativadas pra evitar que ele saia do sleep atoa
    163          
    164          /* restore interrupt enable registers before sleep */
    165          #define HAL_SLEEP_IE_RESTORE(ien0, ien1, ien2) st(IEN0 = ien0;   /* restore IEN0 register */ \
    166                                                            IEN1 = ien1;   /* restore IEN1 register */ \
    167                                                            IEN2 = ien2;)  /* restore IEN2 register */
    168          
    169          /* convert msec to 320 usec units with round */
    170          #define HAL_SLEEP_MS_TO_320US(ms)           (((((uint32) (ms)) * 100) + 31) / 32)
    171          
    172          /* for optimized indexing of uint32's */
    173          #if HAL_MCU_LITTLE_ENDIAN()
    174          #define UINT32_NDX0   0
    175          #define UINT32_NDX1   1
    176          #define UINT32_NDX2   2
    177          #define UINT32_NDX3   3
    178          #else
    179          #define UINT32_NDX0   3
    180          #define UINT32_NDX1   2
    181          #define UINT32_NDX2   1
    182          #define UINT32_NDX3   0
    183          #endif
    184          

   \                                 In  segment XDATA_I, align 1, keep-with-next
    185          static uint32 maxSleepLoopTime =  HAL_SLEEP_MS_TO_320US(MAX_SLEEP_TIME);
   \                     maxSleepLoopTime:
   \   000000                DS 4
   \   000004                REQUIRE `?<Initializer for maxSleepLoopTime>`
   \   000004                REQUIRE __INIT_XDATA_I
    186          
    187          /* ------------------------------------------------------------------------------------------------
    188           *                                        Global Variables
    189           * ------------------------------------------------------------------------------------------------
    190           */
    191          /* PCON register value to program when setting power mode */

   \                                 In  segment DATA_I, align 1, keep-with-next
    192          volatile __data uint8 halSleepPconValue = PCON_IDLE;
   \                     halSleepPconValue:
   \   000000                DS 1
   \   000001                REQUIRE `?<Initializer for halSleepPconValue>`
   \   000001                REQUIRE __INIT_DATA_I
    193          
    194          /* ------------------------------------------------------------------------------------------------
    195           *                                        Local Variables
    196           * ------------------------------------------------------------------------------------------------
    197           */
    198          
    199          /* HAL power management mode is set according to the power management state.
    200           */

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    201          static uint8 halPwrMgtMode = HAL_SLEEP_OFF;
   \                     halPwrMgtMode:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    202          
    203          #ifdef HAL_SLEEP_DEBUG_POWER_MODE
    204          static bool halSleepInt = FALSE;
    205          #endif
    206          
    207          /* ------------------------------------------------------------------------------------------------
    208           *                                      Function Prototypes
    209           * ------------------------------------------------------------------------------------------------
    210           */
    211          
    212          void halSleepSetTimer(uint32 timeout);
    213          
    214          /**************************************************************************************************
    215           * @fn          halSleep
    216           *
    217           * @brief       This function put the CC2530 to sleep. The PCON instruction must be 4-byte aligned.
    218           *              The following code may cause excessive power consumption if not aligned. See linker
    219           *              file ".xcl" for actual placement.
    220           *
    221           * input parameters
    222           *
    223           * @param       None.
    224           *
    225           * output parameters
    226           *
    227           * None.
    228           *
    229           * @return      None.
    230           **************************************************************************************************
    231           */

   \                                 In  segment SLEEP_CODE, align 1, keep-with-next
    232          void halSetSleepMode(void)
   \                     halSetSleepMode:
    233          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    234            PCON = halSleepPconValue;
   \   000000   85..87       MOV     0x87,halSleepPconValue
    235            HAL_DISABLE_INTERRUPTS();
   \   000003   C2AF         CLR     0xa8.7
    236          }
   \   000005   02....       LJMP    ?BRET
   \   000008                REQUIRE PCON
   \   000008                REQUIRE _A_IEN0
    237          
    238          /**************************************************************************************************
    239           * @fn          halSetMaxSleepLoopTime
    240           *
    241           * @brief       This function is to used to setup the maximum sleep loop time. This sleep loop time 
    242           *              should be lesser than T2 rollover so that a maximum of only one rollover occurs 
    243           *              when cc2530 is in sleep. This function should be called whenever rolloverTime is 
    244           *              changed using the function macBackoffTimerSetRollover(macTimerRollover);
    245           *
    246           * input parameters
    247           *
    248           * @param       rolloverTime.
    249           *
    250           * output parameters
    251           *
    252           * None.
    253           *
    254           * @return      None.
    255           **************************************************************************************************
    256           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    257          void halSetMaxSleepLoopTime(uint32 rolloverTime)
   \                     halSetMaxSleepLoopTime:
    258          {
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV     ?V0 + 0,R2
   \   000007   8B..         MOV     ?V0 + 1,R3
   \   000009   8C..         MOV     ?V0 + 2,R4
   \   00000B   8D..         MOV     ?V0 + 3,R5
    259            if( rolloverTime > HAL_SLEEP_MS_TO_320US(MAX_SLEEP_TIME) )
   \   00000D   90....       MOV     DPTR,#__Constant_185197
   \   000010   78..         MOV     R0,#?V0 + 0
   \   000012   12....       LCALL   ?UL_GE_X
   \   000015   5016         JNC     ??halSetMaxSleepLoopTime_0
    260            {
    261              maxSleepLoopTime = HAL_SLEEP_MS_TO_320US(MAX_SLEEP_TIME);
   \   000017   7C96         MOV     R4,#-0x6a
   \   000019   7D51         MOV     R5,#0x51
   \   00001B   7E18         MOV     R6,#0x18
   \   00001D   7F00         MOV     R7,#0x0
   \   00001F   90....       MOV     DPTR,#maxSleepLoopTime
   \   000022   EC           MOV     A,R4
   \   000023   F0           MOVX    @DPTR,A
   \   000024   A3           INC     DPTR
   \   000025   ED           MOV     A,R5
   \   000026   F0           MOVX    @DPTR,A
   \   000027   A3           INC     DPTR
   \   000028   EE           MOV     A,R6
   \   000029   F0           MOVX    @DPTR,A
   \   00002A   A3           INC     DPTR
   \   00002B   EF           MOV     A,R7
   \   00002C   F0           MOVX    @DPTR,A
    262            }
    263            maxSleepLoopTime = (rolloverTime - TICKS_SUBTRACTED);
   \                     ??halSetMaxSleepLoopTime_0:
   \   00002D   85....       MOV     ?V0 + 4,?V0 + 0
   \   000030   85....       MOV     ?V0 + 5,?V0 + 1
   \   000033   85....       MOV     ?V0 + 6,?V0 + 2
   \   000036   85....       MOV     ?V0 + 7,?V0 + 3
   \   000039   90....       MOV     DPTR,#__Constant_fffffffe
   \   00003C   78..         MOV     R0,#?V0 + 4
   \   00003E   12....       LCALL   ?L_ADD_X
   \   000041   90....       MOV     DPTR,#maxSleepLoopTime
   \   000044   78..         MOV     R0,#?V0 + 4
   \   000046   12....       LCALL   ?L_MOV_TO_X
    264          }
   \   000049   7F08         MOV     R7,#0x8
   \   00004B   02....       LJMP    ?BANKED_LEAVE_XDATA
    265          
    266          /**************************************************************************************************
    267           * @fn          halSleep
    268           *
    269           * @brief       This function is called from the OSAL task loop using and existing OSAL
    270           *              interface.  It sets the low power mode of the MAC and the CC2530.
    271           *
    272           * input parameters
    273           *
    274           * @param       osal_timeout - Next OSAL timer timeout.
    275           *
    276           * output parameters
    277           *
    278           * None.
    279           *
    280           * @return      None.
    281           **************************************************************************************************
    282           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    283          void halSleep( uint16 osal_timeout )
   \                     halSleep:
    284          {
   \   000000   74E8         MOV     A,#-0x18
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 24
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
    285            uint32        timeout;
    286            uint32        macTimeout = 0;
   \   000009   75..00       MOV     ?V0 + 4,#0x0
   \   00000C   75..00       MOV     ?V0 + 5,#0x0
   \   00000F   75..00       MOV     ?V0 + 6,#0x0
   \   000012   75..00       MOV     ?V0 + 7,#0x0
    287          
    288            /* get next OSAL timer expiration converted to 320 usec units */
    289            timeout = HAL_SLEEP_MS_TO_320US(osal_timeout);
   \   000015   8E..         MOV     ?V0 + 12,R6
   \   000017   8F..         MOV     ?V0 + 13,R7
   \   000019   E4           CLR     A
   \   00001A   F5..         MOV     ?V0 + 14,A
   \   00001C   F5..         MOV     ?V0 + 15,A
   \   00001E   90....       MOV     DPTR,#__Constant_64
   \   000021   78..         MOV     R0,#?V0 + 8
   \   000023   12....       LCALL   ?L_MOV_X
   \   000026   78..         MOV     R0,#?V0 + 12
   \   000028   79..         MOV     R1,#?V0 + 8
   \   00002A   12....       LCALL   ?L_MUL
   \   00002D   90....       MOV     DPTR,#__Constant_1f
   \   000030   78..         MOV     R0,#?V0 + 12
   \   000032   12....       LCALL   ?L_ADD_X
   \   000035   7405         MOV     A,#0x5
   \   000037   78..         MOV     R0,#?V0 + 12
   \   000039   12....       LCALL   ?UL_SHR
   \   00003C   85....       MOV     ?V0 + 0,?V0 + 12
   \   00003F   85....       MOV     ?V0 + 1,?V0 + 13
   \   000042   85....       MOV     ?V0 + 2,?V0 + 14
   \   000045   85....       MOV     ?V0 + 3,?V0 + 15
    290            if (timeout == 0)
   \   000048   E5..         MOV     A,?V0 + 0
   \   00004A   45..         ORL     A,?V0 + 1
   \   00004C   45..         ORL     A,?V0 + 2
   \   00004E   45..         ORL     A,?V0 + 3
   \   000050   7019         JNZ     ??halSleep_0
    291            {
    292              timeout = MAC_PwrNextTimeout();
   \   000052                ; Setup parameters for call to function MAC_PwrNextTimeout
   \   000052   12....       LCALL   ??MAC_PwrNextTimeout?relay
   \   000055   8A..         MOV     ?V0 + 8,R2
   \   000057   8B..         MOV     ?V0 + 9,R3
   \   000059   8C..         MOV     ?V0 + 10,R4
   \   00005B   8D..         MOV     ?V0 + 11,R5
   \   00005D   85....       MOV     ?V0 + 0,?V0 + 8
   \   000060   85....       MOV     ?V0 + 1,?V0 + 9
   \   000063   85....       MOV     ?V0 + 2,?V0 + 10
   \   000066   85....       MOV     ?V0 + 3,?V0 + 11
   \   000069   8036         SJMP    ??halSleep_1
    293            }
    294            else
    295            {
    296              /* get next MAC timer expiration */
    297              macTimeout = MAC_PwrNextTimeout();
   \                     ??halSleep_0:
   \   00006B                ; Setup parameters for call to function MAC_PwrNextTimeout
   \   00006B   12....       LCALL   ??MAC_PwrNextTimeout?relay
   \   00006E   8A..         MOV     ?V0 + 8,R2
   \   000070   8B..         MOV     ?V0 + 9,R3
   \   000072   8C..         MOV     ?V0 + 10,R4
   \   000074   8D..         MOV     ?V0 + 11,R5
   \   000076   85....       MOV     ?V0 + 4,?V0 + 8
   \   000079   85....       MOV     ?V0 + 5,?V0 + 9
   \   00007C   85....       MOV     ?V0 + 6,?V0 + 10
   \   00007F   85....       MOV     ?V0 + 7,?V0 + 11
    298          
    299              /* get lesser of two timeouts */
    300              if ((macTimeout != 0) && (macTimeout < timeout))
   \   000082   E5..         MOV     A,?V0 + 4
   \   000084   45..         ORL     A,?V0 + 5
   \   000086   45..         ORL     A,?V0 + 6
   \   000088   45..         ORL     A,?V0 + 7
   \   00008A   6015         JZ      ??halSleep_1
   \   00008C   78..         MOV     R0,#?V0 + 0
   \   00008E   79..         MOV     R1,#?V0 + 4
   \   000090   12....       LCALL   ?UL_GT
   \   000093   500C         JNC     ??halSleep_1
    301              {
    302                timeout = macTimeout;
   \   000095   85....       MOV     ?V0 + 0,?V0 + 4
   \   000098   85....       MOV     ?V0 + 1,?V0 + 5
   \   00009B   85....       MOV     ?V0 + 2,?V0 + 6
   \   00009E   85....       MOV     ?V0 + 3,?V0 + 7
    303              }
    304            }
    305          
    306            /* HAL_SLEEP_PM2 is entered only if the timeout is zero and
    307             * the device is a stimulated device.
    308             */
    309            halPwrMgtMode = (timeout == 0) ? HAL_SLEEP_DEEP : HAL_SLEEP_TIMER;
   \                     ??halSleep_1:
   \   0000A1   E5..         MOV     A,?V0 + 0
   \   0000A3   45..         ORL     A,?V0 + 1
   \   0000A5   45..         ORL     A,?V0 + 2
   \   0000A7   45..         ORL     A,?V0 + 3
   \   0000A9   7004         JNZ     ??halSleep_2
   \   0000AB   7403         MOV     A,#0x3
   \   0000AD   8002         SJMP    ??halSleep_3
   \                     ??halSleep_2:
   \   0000AF   7402         MOV     A,#0x2
   \                     ??halSleep_3:
   \   0000B1   90....       MOV     DPTR,#halPwrMgtMode
   \   0000B4   F0           MOVX    @DPTR,A
    310          
    311            /* DEEP sleep can only be entered when zgPollRate == 0.
    312             * This is to eliminate any possibility of entering PM3 between
    313             * two network timers.
    314             */
    315          #if ZG_BUILD_ENDDEVICE_TYPE && defined (NWK_AUTO_POLL)
    316            if ((timeout > HAL_SLEEP_MS_TO_320US(PM_MIN_SLEEP_TIME)) ||
    317                (timeout == 0 && zgPollRate == 0))
    318          #else
    319            if ((timeout > HAL_SLEEP_MS_TO_320US(PM_MIN_SLEEP_TIME)) ||
    320                (timeout == 0))
   \   0000B5   90....       MOV     DPTR,#__Constant_2d
   \   0000B8   78..         MOV     R0,#?V0 + 0
   \   0000BA   12....       LCALL   ?UL_GE_X
   \   0000BD   400D         JC      ??halSleep_4
   \   0000BF   E5..         MOV     A,?V0 + 0
   \   0000C1   45..         ORL     A,?V0 + 1
   \   0000C3   45..         ORL     A,?V0 + 2
   \   0000C5   45..         ORL     A,?V0 + 3
   \   0000C7   6003         JZ      $+5
   \   0000C9   02....       LJMP    ??halSleep_5 & 0xFFFF
    321          #endif
    322            {
    323              halIntState_t ien0, ien1, ien2;
    324          
    325              HAL_ASSERT(HAL_INTERRUPTS_ARE_ENABLED());
   \                     ??halSleep_4:
   \   0000CC   A2AF         MOV     C,0xa8.7
   \   0000CE   4003         JC      ??halSleep_6
   \   0000D0                ; Setup parameters for call to function halAssertHandler
   \   0000D0   12....       LCALL   ??halAssertHandler?relay
    326              HAL_DISABLE_INTERRUPTS();
   \                     ??halSleep_6:
   \   0000D3   C2AF         CLR     0xa8.7
    327          
    328              /* always use "deep sleep" to turn off radio VREG on CC2530 */
    329              if (halSleepPconValue != 0 && MAC_PwrOffReq(MAC_PWR_SLEEP_DEEP) == MAC_SUCCESS)
   \   0000D5   E5..         MOV     A,halSleepPconValue
   \   0000D7   7003         JNZ     $+5
   \   0000D9   02....       LJMP    ??halSleep_7 & 0xFFFF
   \   0000DC                ; Setup parameters for call to function MAC_PwrOffReq
   \   0000DC   7902         MOV     R1,#0x2
   \   0000DE   12....       LCALL   ??MAC_PwrOffReq?relay
   \   0000E1   E9           MOV     A,R1
   \   0000E2   6003         JZ      $+5
   \   0000E4   02....       LJMP    ??halSleep_7 & 0xFFFF
    330              {
    331                /* The PCON value is not zero. There is no interrupt overriding the 
    332                 * sleep decision. Also, the radio granted the sleep request.
    333                 */
    334          
    335          #if ((defined HAL_KEY) && (HAL_KEY == TRUE))
    336                /* get peripherals ready for sleep */
    337                HalKeyEnterSleep();
   \   0000E7                ; Setup parameters for call to function HalKeyEnterSleep
   \   0000E7   12....       LCALL   ??HalKeyEnterSleep?relay
    338          #endif
    339          
    340          #ifdef HAL_SLEEP_DEBUG_LED
    341                HAL_TURN_OFF_LED3();
    342          #else
    343                /* use this to turn LEDs off during sleep */
    344                HalLedEnterSleep();
   \   0000EA                ; Setup parameters for call to function HalLedEnterSleep
   \   0000EA   12....       LCALL   ??HalLedEnterSleep?relay
    345          #endif
    346          
    347                if(timeout > maxSleepLoopTime)
   \   0000ED   90....       MOV     DPTR,#maxSleepLoopTime
   \   0000F0   78..         MOV     R0,#?V0 + 0
   \   0000F2   12....       LCALL   ?UL_GT_X
   \   0000F5   5014         JNC     ??halSleep_8
    348                {
    349                  timeout = maxSleepLoopTime;
   \   0000F7   90....       MOV     DPTR,#maxSleepLoopTime
   \   0000FA   78..         MOV     R0,#?V0 + 8
   \   0000FC   12....       LCALL   ?L_MOV_X
   \   0000FF   85....       MOV     ?V0 + 0,?V0 + 8
   \   000102   85....       MOV     ?V0 + 1,?V0 + 9
   \   000105   85....       MOV     ?V0 + 2,?V0 + 10
   \   000108   85....       MOV     ?V0 + 3,?V0 + 11
    350                }  
    351          
    352                /* enable sleep timer interrupt */
    353                if (timeout != 0)
   \                     ??halSleep_8:
   \   00010B   E5..         MOV     A,?V0 + 0
   \   00010D   45..         ORL     A,?V0 + 1
   \   00010F   45..         ORL     A,?V0 + 2
   \   000111   45..         ORL     A,?V0 + 3
   \   000113   602C         JZ      ??halSleep_9
    354                {
    355                  if (timeout > HAL_SLEEP_MS_TO_320US( MAX_SLEEP_TIME ))
   \   000115   90....       MOV     DPTR,#__Constant_185197
   \   000118   78..         MOV     R0,#?V0 + 0
   \   00011A   12....       LCALL   ?UL_GE_X
   \   00011D   5013         JNC     ??halSleep_10
    356                  {
    357                    timeout -= HAL_SLEEP_MS_TO_320US( MAX_SLEEP_TIME );
   \   00011F   90....       MOV     DPTR,#__Constant_ffe7ae6a
   \   000122   78..         MOV     R0,#?V0 + 0
   \   000124   12....       LCALL   ?L_ADD_X
    358                    halSleepSetTimer(HAL_SLEEP_MS_TO_320US( MAX_SLEEP_TIME ));
   \   000127                ; Setup parameters for call to function halSleepSetTimer
   \   000127   90....       MOV     DPTR,#__Constant_185196
   \   00012A   12....       LCALL   ?XLOAD_R2345
   \   00012D   12....       LCALL   ??halSleepSetTimer?relay
   \   000130   800B         SJMP    ??halSleep_11
    359                  }
    360                  else
    361                  {
    362                    /* set sleep timer */
    363                    halSleepSetTimer(timeout);
   \                     ??halSleep_10:
   \   000132                ; Setup parameters for call to function halSleepSetTimer
   \   000132   AA..         MOV     R2,?V0 + 0
   \   000134   AB..         MOV     R3,?V0 + 1
   \   000136   AC..         MOV     R4,?V0 + 2
   \   000138   AD..         MOV     R5,?V0 + 3
   \   00013A   12....       LCALL   ??halSleepSetTimer?relay
    364                  }
    365          
    366                  /* set up sleep timer interrupt */
    367                  HAL_SLEEP_TIMER_CLEAR_INT();
   \                     ??halSleep_11:
   \   00013D   C2C7         CLR     0xc0.7
    368                  HAL_SLEEP_TIMER_ENABLE_INT();
   \   00013F   D2AD         SETB    0xa8.5
    369                }
    370          
    371          #ifdef HAL_SLEEP_DEBUG_LED
    372                if (halPwrMgtMode == CC2530_PM1)
    373                {
    374                  HAL_TURN_ON_LED1();
    375                }
    376                else
    377                {
    378                  HAL_TURN_OFF_LED1();
    379                }
    380          #endif
    381          
    382                /* Prep CC2530 power mode */
    383                HAL_SLEEP_PREP_POWER_MODE(halPwrMgtMode);
   \                     ??halSleep_9:
   \   000141   53BEFC       ANL     0xbe,#0xfc
   \   000144   90....       MOV     DPTR,#halPwrMgtMode
   \   000147   E0           MOVX    A,@DPTR
   \   000148   42BE         ORL     0xbe,A
   \                     ??halSleep_12:
   \   00014A   E5AD         MOV     A,0xad
   \   00014C   A2E0         MOV     C,0xE0 /* A   */.0
   \   00014E   50FA         JNC     ??halSleep_12
   \   000150   75..01       MOV     halSleepPconValue,#0x1
    384          
    385                /* save interrupt enable registers and disable all interrupts */
    386                HAL_SLEEP_IE_BACKUP_AND_DISABLE(ien0, ien1, ien2);
   \   000153   E5A8         MOV     A,0xa8
   \   000155   F5..         MOV     ?V0 + 14,A
   \   000157   E5B8         MOV     A,0xb8
   \   000159   F5..         MOV     ?V0 + 13,A
   \   00015B   E59A         MOV     A,0x9a
   \   00015D   F5..         MOV     ?V0 + 12,A
   \   00015F   53A820       ANL     0xa8,#0x20
   \   000162   53B820       ANL     0xb8,#0x20
   \   000165   539A12       ANL     0x9a,#0x12
    387                HAL_ENABLE_INTERRUPTS();
   \   000168   D2AF         SETB    0xa8.7
    388          
    389                /* set CC2530 power mode, interrupt is disabled after this function
    390                 * Note that an ISR (that could wake up from power mode) which runs
    391                 * between the previous instruction enabling interrupts and before
    392                 * power mode is set would switch the halSleepPconValue so that
    393                 * power mode shall not be entered in such a case. 
    394                 */
    395                HAL_SLEEP_SET_POWER_MODE();
   \   00016A                ; Setup parameters for call to function halSetSleepMode
   \   00016A   12....       LCALL   ??halSetSleepMode?relay
    396          
    397                /* the interrupt is disabled - see halSetSleepMode() */
    398          
    399                /* restore interrupt enable registers */
    400                HAL_SLEEP_IE_RESTORE(ien0, ien1, ien2);
   \   00016D   85..A8       MOV     0xa8,?V0 + 14
   \   000170   85..B8       MOV     0xb8,?V0 + 13
   \   000173   85..9A       MOV     0x9a,?V0 + 12
    401          
    402                /* disable sleep timer interrupt */
    403                HAL_SLEEP_TIMER_DISABLE_INT();
   \   000176   C2AD         CLR     0xa8.5
    404          
    405          #ifdef HAL_SLEEP_DEBUG_LED
    406                HAL_TURN_ON_LED3();
    407          #else
    408                /* use this to turn LEDs back on after sleep */
    409                HalLedExitSleep();
   \   000178                ; Setup parameters for call to function HalLedExitSleep
   \   000178   12....       LCALL   ??HalLedExitSleep?relay
    410          #endif
    411          
    412          #if ((defined HAL_KEY) && (HAL_KEY == TRUE))
    413                /* handle peripherals */
    414                (void)HalKeyExitSleep();
   \   00017B                ; Setup parameters for call to function HalKeyExitSleep
   \   00017B   12....       LCALL   ??HalKeyExitSleep?relay
   \   00017E   E9           MOV     A,R1
   \   00017F   F5..         MOV     ?V0 + 8,A
    415          #endif
    416          
    417                /* power on the MAC; blocks until completion */
    418                MAC_PwrOnReq();
   \   000181                ; Setup parameters for call to function MAC_PwrOnReq
   \   000181   12....       LCALL   ??MAC_PwrOnReq?relay
    419          
    420                HAL_ENABLE_INTERRUPTS();
   \   000184   D2AF         SETB    0xa8.7
    421          
    422                /* For CC2530, T2 interrupt won’t be generated when the current count is greater than
    423                 * the comparator. The interrupt is only generated when the current count is equal to
    424                 * the comparator. When the CC2530 is waking up from sleep, there is a small window
    425                 * that the count may be grater than the comparator, therefore, missing the interrupt.
    426                 * This workaround will call the T2 ISR when the current T2 count is greater than the
    427                 * comparator. The problem only occurs when POWER_SAVING is turned on, i.e. the 32KHz
    428                 * drives the chip in sleep and SYNC start is used.
    429                 */
    430                macMcuTimer2OverflowWorkaround();
   \   000186                ; Setup parameters for call to function macMcuTimer2OverflowWorkaround
   \   000186   12....       LCALL   ??macMcuTimer2OverflowWorkaround?relay
   \   000189   8002         SJMP    ??halSleep_5
    431              }
    432              else
    433              {
    434                /* An interrupt may have changed the sleep decision. Do not sleep at all. Turn on
    435                 * the interrupt, exit normally, and the next sleep will be allowed.
    436                 */
    437                HAL_ENABLE_INTERRUPTS();
   \                     ??halSleep_7:
   \   00018B   D2AF         SETB    0xa8.7
    438              }
    439            }
    440          }
   \                     ??halSleep_5:
   \   00018D   7F10         MOV     R7,#0x10
   \   00018F   02....       LJMP    ?BANKED_LEAVE_XDATA
   \   000192                REQUIRE _A_IEN0
   \   000192                REQUIRE _A_IRCON
   \   000192                REQUIRE SLEEPCMD
   \   000192                REQUIRE STLOAD
   \   000192                REQUIRE _A_IEN1
   \   000192                REQUIRE IEN2
    441          
    442          /**************************************************************************************************
    443           * @fn          halSleepSetTimer
    444           *
    445           * @brief       This function sets the CC2530 sleep timer compare value.  First it reads and
    446           *              stores the value of the sleep timer; this value is used later to update OSAL
    447           *              timers.  Then the timeout value is converted from 320 usec units to 32 kHz
    448           *              period units and the compare value is set to the timeout.
    449           *
    450           * input parameters
    451           *
    452           * @param       timeout - Timeout value in 320 usec units.  The sleep timer compare is set to
    453           *                        this value.
    454           *
    455           * output parameters
    456           *
    457           * None.
    458           *
    459           * @return      None.
    460           **************************************************************************************************
    461           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    462          void halSleepSetTimer(uint32 timeout)
   \                     halSleepSetTimer:
    463          {
   \   000000   74EC         MOV     A,#-0x14
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 20
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV     A,#-0x4
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V0 + 4,R2
   \   00000C   8B..         MOV     ?V0 + 5,R3
   \   00000E   8C..         MOV     ?V0 + 6,R4
   \   000010   8D..         MOV     ?V0 + 7,R5
    464            uint32 ticks;
    465          
    466            /* read the sleep timer; ST0 must be read first */
    467            ((uint8 *) &ticks)[UINT32_NDX0] = ST0;
   \   000012   E595         MOV     A,0x95
   \   000014   85..82       MOV     DPL,?XSP + 0
   \   000017   85..83       MOV     DPH,?XSP + 1
   \   00001A   F0           MOVX    @DPTR,A
    468            ((uint8 *) &ticks)[UINT32_NDX1] = ST1;
   \   00001B   E596         MOV     A,0x96
   \   00001D   C0E0         PUSH    A
   \   00001F   7401         MOV     A,#0x1
   \   000021   12....       LCALL   ?XSTACK_DISP0_8
   \   000024   D0E0         POP     A
   \   000026   F0           MOVX    @DPTR,A
    469            ((uint8 *) &ticks)[UINT32_NDX2] = ST2;
   \   000027   E597         MOV     A,0x97
   \   000029   C0E0         PUSH    A
   \   00002B   7402         MOV     A,#0x2
   \   00002D   12....       LCALL   ?XSTACK_DISP0_8
   \   000030   D0E0         POP     A
   \   000032   F0           MOVX    @DPTR,A
    470            ((uint8 *) &ticks)[UINT32_NDX3] = 0;
   \   000033   7403         MOV     A,#0x3
   \   000035   12....       LCALL   ?XSTACK_DISP0_8
   \   000038   7400         MOV     A,#0x0
   \   00003A   F0           MOVX    @DPTR,A
    471          
    472            /* Compute sleep timer compare value.  The ratio of 32 kHz ticks to 320 usec ticks
    473             * is 32768/3125 = 10.48576.  This is nearly 671/64 = 10.484375.
    474             */
    475            ticks += (timeout * 671) / 64;
   \   00003B   85....       MOV     ?V0 + 0,?V0 + 4
   \   00003E   85....       MOV     ?V0 + 1,?V0 + 5
   \   000041   85....       MOV     ?V0 + 2,?V0 + 6
   \   000044   85....       MOV     ?V0 + 3,?V0 + 7
   \   000047   90....       MOV     DPTR,#__Constant_29f
   \   00004A   78..         MOV     R0,#?V0 + 8
   \   00004C   12....       LCALL   ?L_MOV_X
   \   00004F   78..         MOV     R0,#?V0 + 0
   \   000051   79..         MOV     R1,#?V0 + 8
   \   000053   12....       LCALL   ?L_MUL
   \   000056   7406         MOV     A,#0x6
   \   000058   78..         MOV     R0,#?V0 + 0
   \   00005A   12....       LCALL   ?UL_SHR
   \   00005D   85..82       MOV     DPL,?XSP + 0
   \   000060   85..83       MOV     DPH,?XSP + 1
   \   000063   78..         MOV     R0,#?V0 + 0
   \   000065   12....       LCALL   ?L_ADD_TO_X
    476          
    477            /* subtract the processing time spent in function halSleep() */
    478            ticks -= HAL_SLEEP_ADJ_TICKS;
   \   000068   90....       MOV     DPTR,#__Constant_ffffffe9
   \   00006B   78..         MOV     R0,#?V0 + 0
   \   00006D   12....       LCALL   ?L_MOV_X
   \   000070   85..82       MOV     DPL,?XSP + 0
   \   000073   85..83       MOV     DPH,?XSP + 1
   \   000076   78..         MOV     R0,#?V0 + 0
   \   000078   12....       LCALL   ?L_ADD_TO_X
    479          
    480            /* set sleep timer compare; ST0 must be written last */
    481            ST2 = ((uint8 *) &ticks)[UINT32_NDX2];
   \   00007B   7402         MOV     A,#0x2
   \   00007D   12....       LCALL   ?XSTACK_DISP0_8
   \   000080   E0           MOVX    A,@DPTR
   \   000081   F597         MOV     0x97,A
    482            ST1 = ((uint8 *) &ticks)[UINT32_NDX1];
   \   000083   7401         MOV     A,#0x1
   \   000085   12....       LCALL   ?XSTACK_DISP0_8
   \   000088   E0           MOVX    A,@DPTR
   \   000089   F596         MOV     0x96,A
    483            ST0 = ((uint8 *) &ticks)[UINT32_NDX0];
   \   00008B   85..82       MOV     DPL,?XSP + 0
   \   00008E   85..83       MOV     DPH,?XSP + 1
   \   000091   E0           MOVX    A,@DPTR
   \   000092   F595         MOV     0x95,A
    484          }
   \   000094   7404         MOV     A,#0x4
   \   000096   12....       LCALL   ?DEALLOC_XSTACK8
   \   000099   7F0C         MOV     R7,#0xc
   \   00009B   02....       LJMP    ?BANKED_LEAVE_XDATA
   \   00009E                REQUIRE ST0
   \   00009E                REQUIRE ST1
   \   00009E                REQUIRE ST2
    485          
    486          /**************************************************************************************************
    487           * @fn          TimerElapsed
    488           *
    489           * @brief       Determine the number of OSAL timer ticks elapsed during sleep.
    490           *              Deprecated for CC2530 and CC2430 SoC.
    491           *
    492           * input parameters
    493           *
    494           * @param       None.
    495           *
    496           * output parameters
    497           *
    498           * None.
    499           *
    500           * @return      Number of timer ticks elapsed during sleep.
    501           **************************************************************************************************
    502           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    503          uint32 TimerElapsed( void )
   \                     TimerElapsed:
    504          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    505            /* Stubs */
    506            return (0);
   \   000000   7A00         MOV     R2,#0x0
   \   000002   7B00         MOV     R3,#0x0
   \   000004   7C00         MOV     R4,#0x0
   \   000006   7D00         MOV     R5,#0x0
   \   000008   02....       LJMP    ?BRET
    507          }
    508          
    509          /**************************************************************************************************
    510           * @fn          halRestoreSleepLevel
    511           *
    512           * @brief       Restore the deepest timer sleep level.
    513           *
    514           * input parameters
    515           *
    516           * @param       None
    517           *
    518           * output parameters
    519           *
    520           *              None.
    521           *
    522           * @return      None.
    523           **************************************************************************************************
    524           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    525          void halRestoreSleepLevel( void )
   \                     halRestoreSleepLevel:
    526          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    527            /* Stubs */
    528          }
   \   000000   02....       LJMP    ?BRET
    529          
    530          /**************************************************************************************************
    531           * @fn          halSleepTimerIsr
    532           *
    533           * @brief       Sleep timer ISR.
    534           *
    535           * input parameters
    536           *
    537           * None.
    538           *
    539           * output parameters
    540           *
    541           * None.
    542           *
    543           * @return      None.
    544           **************************************************************************************************
    545           */

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    546          HAL_ISR_FUNCTION(halSleepTimerIsr, ST_VECTOR)
   \                     halSleepTimerIsr:
    547          {
   \   000000   C0E0         PUSH    A
   \   000002   C0D0         PUSH    PSW
   \   000004   E8           MOV     A,R0
   \   000005   C0E0         PUSH    A
   \   000007   E9           MOV     A,R1
   \   000008   C0E0         PUSH    A
   \   00000A                ; Saved register size: 4
   \   00000A                ; Auto size: 0
    548            HAL_ENTER_ISR();
   \   00000A   A2AF         MOV     C,0xa8.7
   \   00000C   E4           CLR     A
   \   00000D   33           RLC     A
   \   00000E   F8           MOV     R0,A
   \   00000F   D2AF         SETB    0xa8.7
    549            HAL_SLEEP_TIMER_CLEAR_INT(); // limpa o STIF -> Flag de sleeptimer
   \   000011   C2C7         CLR     0xc0.7
    550            // Tirar essa parte ou colocar uma FLAG pra dizer que veio do SLEEP
    551            
    552          
    553          #ifdef HAL_SLEEP_DEBUG_POWER_MODE
    554            halSleepInt = TRUE;
    555          #endif
    556            
    557            CLEAR_SLEEP_MODE(); // 
   \   000013   75..00       MOV     halSleepPconValue,#0x0
    558            HAL_EXIT_ISR();
   \   000016   E8           MOV     A,R0
   \   000017   F9           MOV     R1,A
   \   000018   E8           MOV     A,R0
   \   000019   A2E0         MOV     C,0xE0 /* A   */.0
   \   00001B   92AF         MOV     0xa8.7,C
    559          }
   \   00001D   D0E0         POP     A
   \   00001F   F9           MOV     R1,A
   \   000020   D0E0         POP     A
   \   000022   F8           MOV     R0,A
   \   000023   D0D0         POP     PSW
   \   000025   D0E0         POP     A
   \   000027   32           RETI
   \   000028                REQUIRE _A_IEN0
   \   000028                REQUIRE _A_IRCON

   \                                 In  segment INTVEC, offset 0x2b, root
   \                     `??halSleepTimerIsr??INTVEC 43`:
   \   00002B   02....       LJMP       (halSleepTimerIsr)

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for maxSleepLoopTime>`:
   \   000000   96511800     DD 1593750

   \                                 In  segment DATA_ID, align 1, keep-with-next
   \                     `?<Initializer for halSleepPconValue>`:
   \   000000   01           DB 1

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_185197:
   \   000000   97511800     DD 1593751

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_fffffffe:
   \   000000   FEFFFFFF     DD 4294967294

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_64:
   \   000000   64000000     DD 100

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_1f:
   \   000000   1F000000     DD 31

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_2d:
   \   000000   2D000000     DD 45

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_ffe7ae6a:
   \   000000   6AAEE7FF     DD 4293373546

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_185196:
   \   000000   96511800     DD 1593750

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_29f:
   \   000000   9F020000     DD 671

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_ffffffe9:
   \   000000   E9FFFFFF     DD 4294967273

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??halSetSleepMode?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    halSetSleepMode

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??halSetMaxSleepLoopTime?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    halSetMaxSleepLoopTime

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??halSleep?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    halSleep

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??halSleepSetTimer?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    halSleepSetTimer

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??TimerElapsed?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    TimerElapsed

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??halRestoreSleepLevel?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    halRestoreSleepLevel
    560          

   Maximum stack usage in bytes:

   ISTACK PSTACK XSTACK Function
   ------ ------ ------ --------
       0      0      0  TimerElapsed
       0      0      0  halRestoreSleepLevel
       0      0     16  halSetMaxSleepLoopTime
       0      0     24  halSetSleepMode
       0      0     24  halSleep
                          0 0 24 -> HalKeyEnterSleep
                          0 0 24 -> HalKeyExitSleep
                          0 0 24 -> HalLedEnterSleep
                          0 0 24 -> HalLedExitSleep
                          0 0 24 -> MAC_PwrNextTimeout
                          0 0 24 -> MAC_PwrOffReq
                          0 0 24 -> MAC_PwrOnReq
                          0 0 24 -> halAssertHandler
                          0 0 24 -> halSetSleepMode
                          0 0 24 -> halSleepSetTimer
                          0 0 24 -> macMcuTimer2OverflowWorkaround
       1      0     48  halSleepSetTimer
       4      0      0  halSleepTimerIsr


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       1  ?<Initializer for halSleepPconValue>
       4  ?<Initializer for maxSleepLoopTime>
       6  ??TimerElapsed?relay
       6  ??halRestoreSleepLevel?relay
       6  ??halSetMaxSleepLoopTime?relay
       6  ??halSetSleepMode?relay
       6  ??halSleep?relay
       6  ??halSleepSetTimer?relay
       3  ??halSleepTimerIsr??INTVEC 43
       1  IEN2
       1  PCON
       1  SLEEPCMD
       1  ST0
       1  ST1
       1  ST2
       1  STLOAD
      11  TimerElapsed
       1  _A_IEN0
       1  _A_IEN1
       1  _A_IRCON
       4  __Constant_185196
       4  __Constant_185197
       4  __Constant_1f
       4  __Constant_29f
       4  __Constant_2d
       4  __Constant_64
       4  __Constant_ffe7ae6a
       4  __Constant_ffffffe9
       4  __Constant_fffffffe
       1  halPwrMgtMode
       3  halRestoreSleepLevel
      78  halSetMaxSleepLoopTime
       8  halSetSleepMode
     402  halSleep
       1  halSleepPconValue
     158  halSleepSetTimer
      40  halSleepTimerIsr
       4  maxSleepLoopTime

 
 652 bytes in segment BANKED_CODE
  36 bytes in segment BANK_RELAYS
   1 byte  in segment DATA_I
   1 byte  in segment DATA_ID
   3 bytes in segment INTVEC
  40 bytes in segment NEAR_CODE
  10 bytes in segment SFR_AN
   8 bytes in segment SLEEP_CODE
   4 bytes in segment XDATA_I
   4 bytes in segment XDATA_ID
  36 bytes in segment XDATA_ROM_C
   1 byte  in segment XDATA_Z
 
 741 bytes of CODE  memory (+  3 bytes shared)
   0 bytes of CONST memory (+ 36 bytes shared)
   1 byte  of DATA  memory (+ 10 bytes shared)
   5 bytes of XDATA memory

Errors: none
Warnings: none

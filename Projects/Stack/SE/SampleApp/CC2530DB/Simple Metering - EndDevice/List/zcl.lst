###############################################################################
#                                                                             #
# IAR C/C++ Compiler V8.20.2.41139 for 8051             13/Jun/2013  14:25:27 #
# Copyright 2004-2013 IAR Systems AB.                                         #
#                                                                             #
#    Core               =  plain                                              #
#    Code model         =  banked                                             #
#    Data model         =  large                                              #
#    Calling convention =  xdata reentrant                                    #
#    Constant location  =  data_rom                                           #
#    Dptr setup         =  1,16                                               #
#                                                                             #
#    Source file        =  C:\Users\PedroZ\Documents\GitHub\TG\Components\sta #
#                          ck\zcl\zcl.c                                       #
#    Command line       =  -f C:\Users\PedroZ\Documents\GitHub\TG\Projects\St #
#                          ack\SE\SampleApp\CC2530DB\..\..\..\Tools\CC2530DB\ #
#                          f8wEndev.cfg (-DCPU32MHZ -DROOT=__near_func        #
#                          -DMAC_CFG_TX_DATA_MAX=3 -DMAC_CFG_TX_MAX=6         #
#                          -DMAC_CFG_RX_MAX=3) -f C:\Users\PedroZ\Documents\G #
#                          itHub\TG\Projects\Stack\SE\SampleApp\CC2530DB\..\. #
#                          .\..\Tools\CC2530DB\f8wConfig.cfg (-DZIGBEEPRO     #
#                          -DSECURE=0 -DZG_SECURE_DYNAMIC=0 -DREFLECTOR       #
#                          -DDEFAULT_CHANLIST=0x00000800                      #
#                          -DZDAPP_CONFIG_PAN_ID=0xFFFF                       #
#                          -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MA #
#                          SK=0x007F -DBEACON_REQUEST_DELAY=100               #
#                          -DBEACON_REQ_DELAY_MASK=0x00FF                     #
#                          -DLINK_STATUS_JITTER_MASK=0x007F                   #
#                          -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_PO #
#                          LLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7             #
#                          -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3    #
#                          -DNWK_MAX_DATA_RETRIES=2                           #
#                          -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9         #
#                          -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40           #
#                          -DNWK_MAX_BINDING_ENTRIES=4                        #
#                          -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01,  #
#                          0x03, 0x05, 0x07, 0x09, 0x0B, 0x0D, 0x0F, 0x00,    #
#                          0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C, 0x0D}"         #
#                          -DMAC_MAX_FRAME_SIZE=116                           #
#                          -DZDNWKMGR_MIN_TRANSMISSIONS=20 "-DCONST=const     #
#                          __code" -DGENERIC=__generic                        #
#                          -DRFD_RCVC_ALWAYS_ON=FALSE -DPOLL_RATE=1000        #
#                          -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100    #
#                          -DREJOIN_POLL_RATE=440) -f                         #
#                          C:\Users\PedroZ\Documents\GitHub\TG\Projects\Stack #
#                          \SE\SampleApp\CC2530DB\..\..\..\Tools\CC2530DB\f8w #
#                          ZCL.cfg (-DZCL_READ -DZCL_WRITE -DZCL_BASIC        #
#                          -DZCL_IDENTIFY -DZCL_ON_OFF -DZCL_KEY_ESTABLISH    #
#                          -DZCL_KEY_ESTABLISHMENT_KEY_GENERATE_TIMEOUT=4     #
#                          -DZCL_KEY_ESTABLISHMENT_MAC_GENERATE_TIMEOUT=10    #
#                          -DZCL_KEY_ESTABLISHMENT_EKEY_GENERATE_TIMEOUT=10   #
#                          -DZCL_LOAD_CONTROL -DZCL_SIMPLE_METERING           #
#                          -DZCL_PRICING -DZCL_MESSAGE -DZCL_TUNNELING        #
#                          -DZCL_TOU) -DZCL_DEVICE_MGMT                       #
#                          C:\Users\PedroZ\Documents\GitHub\TG\Components\sta #
#                          ck\zcl\zcl.c -D TC_LINKKEY_JOIN -D ZTOOL_P1 -D     #
#                          MT_TASK -D MT_APP_FUNC -D MT_SYS_FUNC -D           #
#                          LCD_SUPPORTED -D NV_INIT -D xNV_RESTORE -D         #
#                          HOLD_AUTO_START -D NWK_AUTO_POLL -D ZCL_REPORT -D  #
#                          POWER_SAVING -D MAX_POLL_FAILURE_RETRIES=20 -D     #
#                          TEST_CERT_DATA -lC "C:\Users\PedroZ\Documents\GitH #
#                          ub\TG\Projects\Stack\SE\SampleApp\CC2530DB\Simple  #
#                          Metering - EndDevice\List\" -lA                    #
#                          "C:\Users\PedroZ\Documents\GitHub\TG\Projects\Stac #
#                          k\SE\SampleApp\CC2530DB\Simple Metering -          #
#                          EndDevice\List\" --diag_suppress Pe001,Pa010 -o    #
#                          "C:\Users\PedroZ\Documents\GitHub\TG\Projects\Stac #
#                          k\SE\SampleApp\CC2530DB\Simple Metering -          #
#                          EndDevice\Obj\" -e --no_cse --no_unroll            #
#                          --no_inline --no_code_motion --no_tbaa --debug     #
#                          --core=plain --dptr=16,1 --data_model=large        #
#                          --code_model=banked --calling_convention=xdata_ree #
#                          ntrant --place_constants=data_rom                  #
#                          --nr_virtual_regs 16 -I C:\Users\PedroZ\Documents\ #
#                          GitHub\TG\Projects\Stack\SE\SampleApp\CC2530DB\    #
#                          -I C:\Users\PedroZ\Documents\GitHub\TG\Projects\St #
#                          ack\SE\SampleApp\CC2530DB\..\Source\ -I            #
#                          C:\Users\PedroZ\Documents\GitHub\TG\Projects\Stack #
#                          \SE\SampleApp\CC2530DB\..\..\Source\ -I            #
#                          C:\Users\PedroZ\Documents\GitHub\TG\Projects\Stack #
#                          \SE\SampleApp\CC2530DB\..\..\..\ZMain\TI2530DB\    #
#                          -I C:\Users\PedroZ\Documents\GitHub\TG\Projects\St #
#                          ack\SE\SampleApp\CC2530DB\..\..\..\..\..\Component #
#                          s\hal\include\ -I C:\Users\PedroZ\Documents\GitHub #
#                          \TG\Projects\Stack\SE\SampleApp\CC2530DB\..\..\..\ #
#                          ..\..\Components\hal\target\CC2530EB\ -I           #
#                          C:\Users\PedroZ\Documents\GitHub\TG\Projects\Stack #
#                          \SE\SampleApp\CC2530DB\..\..\..\..\..\Components\m #
#                          ac\include\ -I C:\Users\PedroZ\Documents\GitHub\TG #
#                          \Projects\Stack\SE\SampleApp\CC2530DB\..\..\..\..\ #
#                          ..\Components\mac\high_level\ -I                   #
#                          C:\Users\PedroZ\Documents\GitHub\TG\Projects\Stack #
#                          \SE\SampleApp\CC2530DB\..\..\..\..\..\Components\m #
#                          ac\low_level\srf04\ -I C:\Users\PedroZ\Documents\G #
#                          itHub\TG\Projects\Stack\SE\SampleApp\CC2530DB\..\. #
#                          .\..\..\..\Components\mac\low_level\srf04\single_c #
#                          hip\ -I C:\Users\PedroZ\Documents\GitHub\TG\Projec #
#                          ts\Stack\SE\SampleApp\CC2530DB\..\..\..\..\..\Comp #
#                          onents\mt\ -I C:\Users\PedroZ\Documents\GitHub\TG\ #
#                          Projects\Stack\SE\SampleApp\CC2530DB\..\..\..\..\. #
#                          .\Components\osal\include\ -I                      #
#                          C:\Users\PedroZ\Documents\GitHub\TG\Projects\Stack #
#                          \SE\SampleApp\CC2530DB\..\..\..\..\..\Components\s #
#                          ervices\saddr\ -I C:\Users\PedroZ\Documents\GitHub #
#                          \TG\Projects\Stack\SE\SampleApp\CC2530DB\..\..\..\ #
#                          ..\..\Components\services\sdata\ -I                #
#                          C:\Users\PedroZ\Documents\GitHub\TG\Projects\Stack #
#                          \SE\SampleApp\CC2530DB\..\..\..\..\..\Components\s #
#                          tack\af\ -I C:\Users\PedroZ\Documents\GitHub\TG\Pr #
#                          ojects\Stack\SE\SampleApp\CC2530DB\..\..\..\..\..\ #
#                          Components\stack\nwk\ -I                           #
#                          C:\Users\PedroZ\Documents\GitHub\TG\Projects\Stack #
#                          \SE\SampleApp\CC2530DB\..\..\..\..\..\Components\s #
#                          tack\sapi\ -I C:\Users\PedroZ\Documents\GitHub\TG\ #
#                          Projects\Stack\SE\SampleApp\CC2530DB\..\..\..\..\. #
#                          .\Components\stack\sec\ -I                         #
#                          C:\Users\PedroZ\Documents\GitHub\TG\Projects\Stack #
#                          \SE\SampleApp\CC2530DB\..\..\..\..\..\Components\s #
#                          tack\sys\ -I C:\Users\PedroZ\Documents\GitHub\TG\P #
#                          rojects\Stack\SE\SampleApp\CC2530DB\..\..\..\..\.. #
#                          \Components\stack\zcl\ -I                          #
#                          C:\Users\PedroZ\Documents\GitHub\TG\Projects\Stack #
#                          \SE\SampleApp\CC2530DB\..\..\..\..\..\Components\s #
#                          tack\zdo\ -I C:\Users\PedroZ\Documents\GitHub\TG\P #
#                          rojects\Stack\SE\SampleApp\CC2530DB\..\..\..\..\.. #
#                          \Components\zmac\ -I C:\Users\PedroZ\Documents\Git #
#                          Hub\TG\Projects\Stack\SE\SampleApp\CC2530DB\..\..\ #
#                          ..\..\..\Components\zmac\f8w\ -On                  #
#                          --require_prototypes                               #
#    List file          =  C:\Users\PedroZ\Documents\GitHub\TG\Projects\Stack #
#                          \SE\SampleApp\CC2530DB\Simple Metering -           #
#                          EndDevice\List\zcl.lst                             #
#    Object file        =  C:\Users\PedroZ\Documents\GitHub\TG\Projects\Stack #
#                          \SE\SampleApp\CC2530DB\Simple Metering -           #
#                          EndDevice\Obj\zcl.r51                              #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\PedroZ\Documents\GitHub\TG\Components\stack\zcl\zcl.c
      1          /**************************************************************************************************
      2            Filename:       zcl.c
      3            Revised:        $Date: 2012-01-30 10:40:08 -0800 (Mon, 30 Jan 2012) $
      4            Revision:       $Revision: 29096 $
      5          
      6            Description:    This file contains the Zigbee Cluster Library Foundation functions.
      7          
      8          
      9            Copyright 2006-2012 Texas Instruments Incorporated. All rights reserved.
     10          
     11            IMPORTANT: Your use of this Software is limited to those specific rights
     12            granted under the terms of a software license agreement between the user
     13            who downloaded the software, his/her employer (which must be your employer)
     14            and Texas Instruments Incorporated (the "License").  You may not use this
     15            Software unless you agree to abide by the terms of the License. The License
     16            limits your use, and you acknowledge, that the Software may not be modified,
     17            copied or distributed unless embedded on a Texas Instruments microcontroller
     18            or used solely and exclusively in conjunction with a Texas Instruments radio
     19            frequency transceiver, which is integrated into your product.  Other than for
     20            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     21            works of, modify, distribute, perform, display or sell this Software and/or
     22            its documentation for any purpose.
     23          
     24            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     25            PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     26            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     27            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     28            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     29            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     30            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     31            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     32            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     33            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     34            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     35          
     36            Should you have any questions regarding your right to use this Software,
     37            contact Texas Instruments Incorporated at www.TI.com.
     38          **************************************************************************************************/
     39          
     40          /*********************************************************************
     41           * INCLUDES
     42           */
     43          #include "ZComDef.h"
     44          #include "OSAL.h"
     45          #include "OSAL_Tasks.h"
     46          #include "AF.h"
     47          #include "ZDConfig.h"
     48          
     49          #include "zcl.h"
     50          #include "zcl_general.h"
     51          
     52          #if defined ( INTER_PAN )
     53            #include "stub_aps.h"
     54          #endif
     55          
     56          /*********************************************************************
     57           * MACROS
     58           */
     59          /*** Frame Control ***/
     60          #define zcl_FCType( a )               ( (a) & ZCL_FRAME_CONTROL_TYPE )
     61          #define zcl_FCManuSpecific( a )       ( (a) & ZCL_FRAME_CONTROL_MANU_SPECIFIC )
     62          #define zcl_FCDirection( a )          ( (a) & ZCL_FRAME_CONTROL_DIRECTION )
     63          #define zcl_FCDisableDefaultRsp( a )  ( (a) & ZCL_FRAME_CONTROL_DISABLE_DEFAULT_RSP )
     64          
     65          /*** Attribute Access Control ***/
     66          #define zcl_AccessCtrlRead( a )       ( (a) & ACCESS_CONTROL_READ )
     67          #define zcl_AccessCtrlWrite( a )      ( (a) & ACCESS_CONTROL_WRITE )
     68          #define zcl_AccessCtrlCmd( a )        ( (a) & ACCESS_CONTROL_CMD )
     69          #define zcl_AccessCtrlAuthRead( a )   ( (a) & ACCESS_CONTROL_AUTH_READ )
     70          #define zcl_AccessCtrlAuthWrite( a )  ( (a) & ACCESS_CONTROL_AUTH_WRITE )
     71          
     72          #define zclParseCmd( a, b )           zclCmdTable[(a)].pfnParseInProfile( (b) )
     73          #define zclProcessCmd( a, b )         zclCmdTable[(a)].pfnProcessInProfile( (b) )
     74          
     75          #define zcl_DefaultRspCmd( zclHdr )   ( zcl_ProfileCmd( (zclHdr).fc.type )     && \
     76                                                  (zclHdr).fc.manuSpecific == 0          && \
     77                                                  (zclHdr).commandID == ZCL_CMD_DEFAULT_RSP )
     78          
     79          // Commands that have corresponding responses
     80          #define CMD_HAS_RSP( cmd )            ( (cmd) == ZCL_CMD_READ            || \
     81                                                  (cmd) == ZCL_CMD_WRITE           || \
     82                                                  (cmd) == ZCL_CMD_WRITE_UNDIVIDED || \
     83                                                  (cmd) == ZCL_CMD_CONFIG_REPORT   || \
     84                                                  (cmd) == ZCL_CMD_READ_REPORT_CFG || \
     85                                                  (cmd) == ZCL_CMD_DISCOVER        || \
     86                                                  (cmd) == ZCL_CMD_DEFAULT_RSP ) // exception
     87          
     88          /*********************************************************************
     89           * CONSTANTS
     90           */
     91          
     92          /*********************************************************************
     93           * TYPEDEFS
     94           */
     95          typedef struct zclLibPlugin
     96          {
     97            struct zclLibPlugin *next;
     98            uint16              startClusterID;    // starting cluster ID
     99            uint16              endClusterID;      // ending cluster ID
    100            zclInHdlr_t         pfnIncomingHdlr;    // function to handle incoming message
    101          } zclLibPlugin_t;
    102          
    103          // Attribute record list item
    104          typedef struct zclAttrRecsList
    105          {
    106            struct zclAttrRecsList *next;
    107            uint8                  endpoint;      // Used to link it into the endpoint descriptor
    108            zclReadWriteCB_t       pfnReadWriteCB;// Read or Write attribute value callback function
    109            zclAuthorizeCB_t       pfnAuthorizeCB;// Authorize Read or Write operation
    110            uint8                  numAttributes; // Number of the following records
    111            CONST zclAttrRec_t     *attrs;        // attribute records
    112          } zclAttrRecsList;
    113          
    114          // Cluster option list item
    115          typedef struct zclClusterOptionList
    116          {
    117            struct zclClusterOptionList *next;
    118            uint8                       endpoint;   // Used to link it into the endpoint descriptor
    119            uint8                       numOptions; // Number of the following records
    120            zclOptionRec_t              *options;   // option records
    121          } zclClusterOptionList;
    122          
    123          typedef void *(*zclParseInProfileCmd_t)( zclParseCmd_t *pCmd );
    124          typedef uint8 (*zclProcessInProfileCmd_t)( zclIncoming_t *pInMsg );
    125          
    126          typedef struct
    127          {
    128            zclParseInProfileCmd_t   pfnParseInProfile;
    129            zclProcessInProfileCmd_t pfnProcessInProfile;
    130          } zclCmdItems_t;
    131          
    132          
    133          /*********************************************************************
    134           * GLOBAL VARIABLES
    135           */

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    136          uint8 zcl_TaskID;
   \                     zcl_TaskID:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    137          
    138          // The task Id of the Application where the unprocessed Foundation
    139          // Command/Response messages will be sent to.

   \                                 In  segment XDATA_I, align 1, keep-with-next
    140          uint8 zcl_RegisteredMsgTaskID = TASK_NO_TASK;
   \                     zcl_RegisteredMsgTaskID:
   \   000000                DS 1
   \   000001                REQUIRE `?<Initializer for zcl_RegisteredMsgTaskID>`
   \   000001                REQUIRE __INIT_XDATA_I
    141          
    142          // The Application should register its attribute data validation function

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    143          zclValidateAttrData_t zcl_ValidateAttrDataCB = NULL;
   \                     zcl_ValidateAttrDataCB:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
    144          
    145          // ZCL Sequence number

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    146          uint8 zcl_SeqNum = 0x00;
   \                     zcl_SeqNum:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    147          
    148          /*********************************************************************
    149           * EXTERNAL VARIABLES
    150           */
    151          
    152          /*********************************************************************
    153           * EXTERNAL FUNCTIONS
    154           */
    155          
    156          /*********************************************************************
    157           * LOCAL VARIABLES
    158           */

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    159          static zclLibPlugin_t *plugins;
   \                     plugins:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    160          static zclAttrRecsList *attrList;
   \                     attrList:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    161          static zclClusterOptionList *clusterOptionList;
   \                     clusterOptionList:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    162          static uint8 zcl_TransID = 0;  // This is the unique message ID (counter)
   \                     zcl_TransID:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    163          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    164          static afIncomingMSGPacket_t *rawAFMsg = NULL;
   \                     rawAFMsg:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
    165          
    166          /*********************************************************************
    167           * LOCAL FUNCTIONS
    168           */
    169          void zclProcessMessageMSG( afIncomingMSGPacket_t *pkt );  // Not static for ZNP build.
    170          static uint8 *zclBuildHdr( zclFrameHdr_t *hdr, uint8 *pData );
    171          static uint8 zclCalcHdrSize( zclFrameHdr_t *hdr );
    172          static zclLibPlugin_t *zclFindPlugin( uint16 clusterID, uint16 profileID );
    173          static zclAttrRecsList *zclFindAttrRecsList( uint8 endpoint );
    174          static zclOptionRec_t *zclFindClusterOption( uint8 endpoint, uint16 clusterID );
    175          static uint8 zclGetClusterOption( uint8 endpoint, uint16 clusterID );
    176          static void zclSetSecurityOption( uint8 endpoint, uint16 clusterID, uint8 enable );
    177          
    178          static uint8 zcl_DeviceOperational( uint8 srcEP, uint16 clusterID, uint8 frameType, uint8 cmd, uint16 profileID );
    179          
    180          #if defined ( ZCL_READ ) || defined ( ZCL_WRITE )
    181          static zclReadWriteCB_t zclGetReadWriteCB( uint8 endpoint );
    182          static zclAuthorizeCB_t zclGetAuthorizeCB( uint8 endpoint );
    183          #endif // ZCL_READ || ZCL_WRITE
    184          
    185          #ifdef ZCL_READ
    186          static uint16 zclGetAttrDataLengthUsingCB( uint8 endpoint, uint16 clusterID, uint16 attrId );
    187          static ZStatus_t zclReadAttrDataUsingCB( uint8 endpoint, uint16 clusterId, uint16 attrId,
    188                                                   uint8 *pAttrData, uint16 *pDataLen );
    189          static ZStatus_t zclAuthorizeRead( uint8 endpoint, afAddrType_t *srcAddr, zclAttrRec_t *pAttr );
    190          static void *zclParseInReadRspCmd( zclParseCmd_t *pCmd );
    191          static uint8 zclProcessInReadCmd( zclIncoming_t *pInMsg );
    192          #endif // ZCL_READ
    193          
    194          #ifdef ZCL_WRITE
    195          static ZStatus_t zclWriteAttrData( uint8 endpoint, afAddrType_t *srcAddr,
    196                                             zclAttrRec_t *pAttr, zclWriteRec_t *pWriteRec );
    197          static ZStatus_t zclWriteAttrDataUsingCB( uint8 endpoint, afAddrType_t *srcAddr,
    198                                                    zclAttrRec_t *pAttr, uint8 *pAttrData );
    199          static ZStatus_t zclAuthorizeWrite( uint8 endpoint, afAddrType_t *srcAddr, zclAttrRec_t *pAttr );
    200          static void *zclParseInWriteRspCmd( zclParseCmd_t *pCmd );
    201          static uint8 zclProcessInWriteCmd( zclIncoming_t *pInMsg );
    202          static uint8 zclProcessInWriteUndividedCmd( zclIncoming_t *pInMsg );
    203          #endif // ZCL_WRITE
    204          
    205          #ifdef ZCL_REPORT
    206          static void *zclParseInConfigReportRspCmd( zclParseCmd_t *pCmd );
    207          static void *zclParseInReadReportCfgRspCmd( zclParseCmd_t *pCmd );
    208          #endif // ZCL_REPORT
    209          
    210          static void *zclParseInDefaultRspCmd( zclParseCmd_t *pCmd );
    211          
    212          #ifdef ZCL_DISCOVER
    213          static uint8 zclFindNextAttrRec( uint8 endpoint, uint16 clusterID, uint16 *attrId, zclAttrRec_t *pAttr );
    214          static void *zclParseInDiscRspCmd( zclParseCmd_t *pCmd );
    215          static uint8 zclProcessInDiscCmd( zclIncoming_t *pInMsg );
    216          #endif // ZCL_DISCOVER
    217          
    218          static uint8 zclSendMsg( zclIncoming_t *pInMsg );
    219          
    220          /*********************************************************************
    221           * Parse Profile Command Function Table
    222           */

   \                                 In  segment CODE_C, align 1
    223          static CONST zclCmdItems_t zclCmdTable[] =
   \                     zclCmdTable:
   \   000000   ....         DW ??zclParseInReadCmd?relay
   \   000002   ....         DW ??zclProcessInReadCmd?relay
   \   000004   ....         DW ??zclParseInReadRspCmd?relay
   \   000006   ....         DW ??zclSendMsg?relay
   \   000008   ....         DW ??zclParseInWriteCmd?relay
   \   00000A   ....         DW ??zclProcessInWriteCmd?relay
   \   00000C   ....         DW ??zclParseInWriteCmd?relay
   \   00000E   ....         DW ??zclProcessInWriteUndividedCmd?relay
   \   000010   ....         DW ??zclParseInWriteRspCmd?relay
   \   000012   ....         DW ??zclSendMsg?relay
   \   000014   ....         DW ??zclParseInWriteCmd?relay
   \   000016   ....         DW ??zclProcessInWriteCmd?relay
   \   000018   ....         DW ??zclParseInConfigReportCmd?relay
   \   00001A   ....         DW ??zclSendMsg?relay
   \   00001C   ....         DW ??zclParseInConfigReportRspCmd?relay
   \   00001E   ....         DW ??zclSendMsg?relay
   \   000020   ....         DW ??zclParseInReadReportCfgCmd?relay
   \   000022   ....         DW ??zclSendMsg?relay
   \   000024   ....         DW ??zclParseInReadReportCfgRspCmd?relay
   \   000026   ....         DW ??zclSendMsg?relay
   \   000028   ....         DW ??zclParseInReportCmd?relay
   \   00002A   ....         DW ??zclSendMsg?relay
   \   00002C   ....         DW ??zclParseInDefaultRspCmd?relay
   \   00002E   ....         DW ??zclSendMsg?relay
   \   000030   0000         DW 0H
   \   000032   0000         DW 0H
   \   000034   0000         DW 0H
   \   000036   0000         DW 0H
    224          {
    225          #ifdef ZCL_READ
    226            /* ZCL_CMD_READ */                { zclParseInReadCmd,             zclProcessInReadCmd             },
    227            /* ZCL_CMD_READ_RSP */            { zclParseInReadRspCmd,          zclSendMsg                      },
    228          #else
    229            /* ZCL_CMD_READ */                { NULL,                          NULL                            },
    230            /* ZCL_CMD_READ_RSP */            { NULL,                          NULL                            },
    231          #endif // ZCL_READ
    232          
    233          #ifdef ZCL_WRITE
    234            /* ZCL_CMD_WRITE */               { zclParseInWriteCmd,            zclProcessInWriteCmd            },
    235            /* ZCL_CMD_WRITE_UNDIVIDED */     { zclParseInWriteCmd,            zclProcessInWriteUndividedCmd   },
    236            /* ZCL_CMD_WRITE_RSP */           { zclParseInWriteRspCmd,         zclSendMsg                      },
    237            /* ZCL_CMD_WRITE_NO_RSP */        { zclParseInWriteCmd,            zclProcessInWriteCmd            },
    238          #else
    239            /* ZCL_CMD_WRITE */               { NULL,                          NULL                            },
    240            /* ZCL_CMD_WRITE_UNDIVIDED */     { NULL,                          NULL                            },
    241            /* ZCL_CMD_WRITE_RSP */           { NULL,                          NULL                            },
    242            /* ZCL_CMD_WRITE_NO_RSP */        { NULL,                          NULL                            },
    243          #endif // ZCL_WRITE
    244          
    245          #ifdef ZCL_REPORT
    246            /* ZCL_CMD_CONFIG_REPORT */       { zclParseInConfigReportCmd,     zclSendMsg                      },
    247            /* ZCL_CMD_CONFIG_REPORT_RSP */   { zclParseInConfigReportRspCmd,  zclSendMsg                      },
    248            /* ZCL_CMD_READ_REPORT_CFG */     { zclParseInReadReportCfgCmd,    zclSendMsg                      },
    249            /* ZCL_CMD_READ_REPORT_CFG_RSP */ { zclParseInReadReportCfgRspCmd, zclSendMsg                      },
    250            /* ZCL_CMD_REPORT */              { zclParseInReportCmd,           zclSendMsg                      },
    251          #else
    252            /* ZCL_CMD_CONFIG_REPORT */       { NULL,                          NULL                            },
    253            /* ZCL_CMD_CONFIG_REPORT_RSP */   { NULL,                          NULL                            },
    254            /* ZCL_CMD_READ_REPORT_CFG */     { NULL,                          NULL                            },
    255            /* ZCL_CMD_READ_REPORT_CFG_RSP */ { NULL,                          NULL                            },
    256            /* ZCL_CMD_REPORT */              { NULL,                          NULL                            },
    257          #endif // ZCL_REPORT
    258          
    259            /* ZCL_CMD_DEFAULT_RSP */         { zclParseInDefaultRspCmd,       zclSendMsg                      },
    260          
    261          #ifdef ZCL_DISCOVER
    262            /* ZCL_CMD_DISCOVER */            { zclParseInDiscCmd,             zclProcessInDiscCmd             },
    263            /* ZCL_CMD_DISCOVER_RSP */        { zclParseInDiscRspCmd,          zclSendMsg                      }
    264          #else
    265            /* ZCL_CMD_DISCOVER */            { NULL,                          NULL                            },
    266            /* ZCL_CMD_DISCOVER_RSP */        { NULL,                          NULL                            }
    267          #endif // ZCL_DISCOVER
    268          };
    269          
    270          /*********************************************************************
    271           * PUBLIC FUNCTIONS
    272           *********************************************************************/
    273          
    274          /*********************************************************************
    275           * @fn          zcl_Init
    276           *
    277           * @brief       Initialization function for the zcl layer.
    278           *
    279           * @param       task_id - ZCL task id
    280           *
    281           * @return      none
    282           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    283          void zcl_Init( uint8 task_id )
   \                     zcl_Init:
    284          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    285            zcl_TaskID = task_id;
   \   000004   E9           MOV     A,R1
   \   000005   90....       MOV     DPTR,#zcl_TaskID
   \   000008   F0           MOVX    @DPTR,A
    286          
    287            plugins = (zclLibPlugin_t  *)NULL;
   \   000009   90....       MOV     DPTR,#plugins
   \   00000C   7400         MOV     A,#0x0
   \   00000E   F0           MOVX    @DPTR,A
   \   00000F   A3           INC     DPTR
   \   000010   7400         MOV     A,#0x0
   \   000012   F0           MOVX    @DPTR,A
    288            attrList = (zclAttrRecsList *)NULL;
   \   000013   90....       MOV     DPTR,#attrList
   \   000016   7400         MOV     A,#0x0
   \   000018   F0           MOVX    @DPTR,A
   \   000019   A3           INC     DPTR
   \   00001A   7400         MOV     A,#0x0
   \   00001C   F0           MOVX    @DPTR,A
    289            clusterOptionList = (zclClusterOptionList *)NULL;
   \   00001D   90....       MOV     DPTR,#clusterOptionList
   \   000020   7400         MOV     A,#0x0
   \   000022   F0           MOVX    @DPTR,A
   \   000023   A3           INC     DPTR
   \   000024   7400         MOV     A,#0x0
   \   000026   F0           MOVX    @DPTR,A
    290          }
   \   000027   D083         POP     DPH
   \   000029   D082         POP     DPL
   \   00002B   02....       LJMP    ?BRET
    291          
    292          /*********************************************************************
    293           * @fn          zcl_event_loop
    294           *
    295           * @brief       Event Loop Processor for zcl.
    296           *
    297           * @param       task_id - task id
    298           * @param       events - event bitmap
    299           *
    300           * @return      unprocessed events
    301           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    302          uint16 zcl_event_loop( uint8 task_id, uint16 events )
   \                     zcl_event_loop:
    303          {
   \   000000   74F2         MOV     A,#-0xe
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V0 + 2,R1
   \   000007   8A..         MOV     ?V0 + 0,R2
   \   000009   8B..         MOV     ?V0 + 1,R3
    304            uint8 *msgPtr;
    305          
    306            (void)task_id;  // Intentionally unreferenced parameter
    307          
    308            if ( events & SYS_EVENT_MSG )
   \   00000B   E5..         MOV     A,?V0 + 0
   \   00000D   5400         ANL     A,#0x0
   \   00000F   F8           MOV     R0,A
   \   000010   E5..         MOV     A,?V0 + 1
   \   000012   5480         ANL     A,#0x80
   \   000014   F9           MOV     R1,A
   \   000015   E8           MOV     A,R0
   \   000016   49           ORL     A,R1
   \   000017   7003         JNZ     $+5
   \   000019   02....       LJMP    ??zcl_event_loop_0 & 0xFFFF
    309            {
    310              msgPtr = osal_msg_receive( zcl_TaskID );
   \   00001C                ; Setup parameters for call to function osal_msg_receive
   \   00001C   90....       MOV     DPTR,#zcl_TaskID
   \   00001F   E0           MOVX    A,@DPTR
   \   000020   F9           MOV     R1,A
   \   000021   12....       LCALL   ??osal_msg_receive?relay
   \   000024   8A..         MOV     ?V0 + 4,R2
   \   000026   8B..         MOV     ?V0 + 5,R3
   \   000028   AE..         MOV     R6,?V0 + 4
   \   00002A   AF..         MOV     R7,?V0 + 5
    311              while ( msgPtr != NULL )
   \                     ??zcl_event_loop_1:
   \   00002C   EE           MOV     A,R6
   \   00002D   4F           ORL     A,R7
   \   00002E   6061         JZ      ??zcl_event_loop_2
    312              {
    313                uint8 dealloc = TRUE;
   \   000030   75..01       MOV     ?V0 + 3,#0x1
    314          
    315                if ( *msgPtr == AF_INCOMING_MSG_CMD )
   \   000033   8E82         MOV     DPL,R6
   \   000035   8F83         MOV     DPH,R7
   \   000037   E0           MOVX    A,@DPTR
   \   000038   641A         XRL     A,#0x1a
   \   00003A   701F         JNZ     ??zcl_event_loop_3
    316                {
    317                  rawAFMsg = (afIncomingMSGPacket_t *)msgPtr;
   \   00003C   90....       MOV     DPTR,#rawAFMsg
   \   00003F   EE           MOV     A,R6
   \   000040   F0           MOVX    @DPTR,A
   \   000041   A3           INC     DPTR
   \   000042   EF           MOV     A,R7
   \   000043   F0           MOVX    @DPTR,A
    318                  zclProcessMessageMSG( rawAFMsg );
   \   000044                ; Setup parameters for call to function zclProcessMessageMSG
   \   000044   90....       MOV     DPTR,#rawAFMsg
   \   000047   E0           MOVX    A,@DPTR
   \   000048   FA           MOV     R2,A
   \   000049   A3           INC     DPTR
   \   00004A   E0           MOVX    A,@DPTR
   \   00004B   FB           MOV     R3,A
   \   00004C   12....       LCALL   ??zclProcessMessageMSG?relay
    319                  rawAFMsg = NULL;
   \   00004F   90....       MOV     DPTR,#rawAFMsg
   \   000052   7400         MOV     A,#0x0
   \   000054   F0           MOVX    @DPTR,A
   \   000055   A3           INC     DPTR
   \   000056   7400         MOV     A,#0x0
   \   000058   F0           MOVX    @DPTR,A
   \   000059   8018         SJMP    ??zcl_event_loop_4
    320                }
    321                else if ( zcl_RegisteredMsgTaskID != TASK_NO_TASK )
   \                     ??zcl_event_loop_3:
   \   00005B   90....       MOV     DPTR,#zcl_RegisteredMsgTaskID
   \   00005E   E0           MOVX    A,@DPTR
   \   00005F   64FF         XRL     A,#0xff
   \   000061   6010         JZ      ??zcl_event_loop_4
    322                {
    323                  // send it to another task to process.
    324                  osal_msg_send( zcl_RegisteredMsgTaskID, msgPtr );
   \   000063                ; Setup parameters for call to function osal_msg_send
   \   000063   EE           MOV     A,R6
   \   000064   FA           MOV     R2,A
   \   000065   EF           MOV     A,R7
   \   000066   FB           MOV     R3,A
   \   000067   90....       MOV     DPTR,#zcl_RegisteredMsgTaskID
   \   00006A   E0           MOVX    A,@DPTR
   \   00006B   F9           MOV     R1,A
   \   00006C   12....       LCALL   ??osal_msg_send?relay
   \   00006F   E9           MOV     A,R1
    325                  dealloc = FALSE;
   \   000070   75..00       MOV     ?V0 + 3,#0x0
    326                }
    327          
    328                // Release the memory
    329                if ( dealloc )
   \                     ??zcl_event_loop_4:
   \   000073   E5..         MOV     A,?V0 + 3
   \   000075   6008         JZ      ??zcl_event_loop_5
    330                {
    331                  osal_msg_deallocate( msgPtr );
   \   000077                ; Setup parameters for call to function osal_msg_deallocate
   \   000077   EE           MOV     A,R6
   \   000078   FA           MOV     R2,A
   \   000079   EF           MOV     A,R7
   \   00007A   FB           MOV     R3,A
   \   00007B   12....       LCALL   ??osal_msg_deallocate?relay
   \   00007E   E9           MOV     A,R1
    332                }
    333          
    334                // Next
    335                msgPtr = osal_msg_receive( zcl_TaskID );
   \                     ??zcl_event_loop_5:
   \   00007F                ; Setup parameters for call to function osal_msg_receive
   \   00007F   90....       MOV     DPTR,#zcl_TaskID
   \   000082   E0           MOVX    A,@DPTR
   \   000083   F9           MOV     R1,A
   \   000084   12....       LCALL   ??osal_msg_receive?relay
   \   000087   8A..         MOV     ?V0 + 4,R2
   \   000089   8B..         MOV     ?V0 + 5,R3
   \   00008B   AE..         MOV     R6,?V0 + 4
   \   00008D   AF..         MOV     R7,?V0 + 5
   \   00008F   809B         SJMP    ??zcl_event_loop_1
    336              }
    337          
    338              // return unprocessed events
    339              return (events ^ SYS_EVENT_MSG);
   \                     ??zcl_event_loop_2:
   \   000091   E5..         MOV     A,?V0 + 0
   \   000093   6400         XRL     A,#0x0
   \   000095   FA           MOV     R2,A
   \   000096   E5..         MOV     A,?V0 + 1
   \   000098   6480         XRL     A,#0x80
   \   00009A   FB           MOV     R3,A
   \   00009B   8004         SJMP    ??zcl_event_loop_6
    340            }
    341          
    342            // Discard unknown events
    343            return 0;
   \                     ??zcl_event_loop_0:
   \   00009D   7A00         MOV     R2,#0x0
   \   00009F   7B00         MOV     R3,#0x0
   \                     ??zcl_event_loop_6:
   \   0000A1   7F06         MOV     R7,#0x6
   \   0000A3   02....       LJMP    ?BANKED_LEAVE_XDATA
    344          }
    345          
    346          /*********************************************************************
    347           * @fn          zcl_getRawAFMsg
    348           *
    349           * @brief       Call to get original unprocessed AF message
    350           *              (not parsed by ZCL).
    351           *
    352           *   NOTE:  This function can only be called during a ZCL callback function
    353           *          and the calling function must NOT change any data in the message.
    354           *
    355           * @param       none
    356           *
    357           * @return      pointer to original AF message, NULL if not processing
    358           *              AF message.
    359           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    360          afIncomingMSGPacket_t *zcl_getRawAFMsg( void )
   \                     zcl_getRawAFMsg:
    361          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    362            return ( rawAFMsg );
   \   000004   90....       MOV     DPTR,#rawAFMsg
   \   000007   E0           MOVX    A,@DPTR
   \   000008   FA           MOV     R2,A
   \   000009   A3           INC     DPTR
   \   00000A   E0           MOVX    A,@DPTR
   \   00000B   FB           MOV     R3,A
   \   00000C   D083         POP     DPH
   \   00000E   D082         POP     DPL
   \   000010   02....       LJMP    ?BRET
    363          }
    364          
    365          /*********************************************************************
    366           * @fn          zcl_registerPlugin
    367           *
    368           * @brief       Add a Cluster Library handler
    369           *
    370           * @param       startClusterID - starting cluster ID
    371           * @param       endClusterID - ending cluster ID
    372           * @param       pfnHdlr - function pointer to incoming message handler
    373           *
    374           * @return      ZSuccess if OK
    375           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    376          ZStatus_t zcl_registerPlugin( uint16 startClusterID,
   \                     zcl_registerPlugin:
    377                    uint16 endClusterID, zclInHdlr_t pfnIncomingHdlr )
    378          {
   \   000000   74EE         MOV     A,#-0x12
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 18
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV     ?V0 + 0,R2
   \   000007   8B..         MOV     ?V0 + 1,R3
   \   000009   8C..         MOV     ?V0 + 6,R4
   \   00000B   8D..         MOV     ?V0 + 7,R5
   \   00000D   7412         MOV     A,#0x12
   \   00000F   12....       LCALL   ?XSTACK_DISP0_8
   \   000012   E0           MOVX    A,@DPTR
   \   000013   F5..         MOV     ?V0 + 2,A
   \   000015   A3           INC     DPTR
   \   000016   E0           MOVX    A,@DPTR
   \   000017   F5..         MOV     ?V0 + 3,A
    379            zclLibPlugin_t *pNewItem;
    380            zclLibPlugin_t *pLoop;
    381          
    382            // Fill in the new profile list
    383            pNewItem = osal_mem_alloc( sizeof( zclLibPlugin_t ) );
   \   000019                ; Setup parameters for call to function osal_mem_alloc
   \   000019   7A08         MOV     R2,#0x8
   \   00001B   7B00         MOV     R3,#0x0
   \   00001D   12....       LCALL   ??osal_mem_alloc?relay
   \   000020   8A..         MOV     ?V0 + 8,R2
   \   000022   8B..         MOV     ?V0 + 9,R3
   \   000024   AE..         MOV     R6,?V0 + 8
   \   000026   AF..         MOV     R7,?V0 + 9
    384            if ( pNewItem == NULL )
   \   000028   EE           MOV     A,R6
   \   000029   4F           ORL     A,R7
   \   00002A   7005         JNZ     ??zcl_registerPlugin_0
    385            {
    386              return (ZMemError);
   \   00002C   7910         MOV     R1,#0x10
   \   00002E   02....       LJMP    ??zcl_registerPlugin_1 & 0xFFFF
    387            }
    388          
    389            // Fill in the plugin record.
    390            pNewItem->next = (zclLibPlugin_t *)NULL;
   \                     ??zcl_registerPlugin_0:
   \   000031   8E82         MOV     DPL,R6
   \   000033   8F83         MOV     DPH,R7
   \   000035   7400         MOV     A,#0x0
   \   000037   F0           MOVX    @DPTR,A
   \   000038   A3           INC     DPTR
   \   000039   7400         MOV     A,#0x0
   \   00003B   F0           MOVX    @DPTR,A
    391            pNewItem->startClusterID = startClusterID;
   \   00003C   8E82         MOV     DPL,R6
   \   00003E   8F83         MOV     DPH,R7
   \   000040   A3           INC     DPTR
   \   000041   A3           INC     DPTR
   \   000042   E5..         MOV     A,?V0 + 0
   \   000044   F0           MOVX    @DPTR,A
   \   000045   A3           INC     DPTR
   \   000046   E5..         MOV     A,?V0 + 1
   \   000048   F0           MOVX    @DPTR,A
    392            pNewItem->endClusterID = endClusterID;
   \   000049   8E82         MOV     DPL,R6
   \   00004B   8F83         MOV     DPH,R7
   \   00004D   A3           INC     DPTR
   \   00004E   A3           INC     DPTR
   \   00004F   A3           INC     DPTR
   \   000050   A3           INC     DPTR
   \   000051   E5..         MOV     A,?V0 + 6
   \   000053   F0           MOVX    @DPTR,A
   \   000054   A3           INC     DPTR
   \   000055   E5..         MOV     A,?V0 + 7
   \   000057   F0           MOVX    @DPTR,A
    393            pNewItem->pfnIncomingHdlr = pfnIncomingHdlr;
   \   000058   8E82         MOV     DPL,R6
   \   00005A   8F83         MOV     DPH,R7
   \   00005C   A3           INC     DPTR
   \   00005D   A3           INC     DPTR
   \   00005E   A3           INC     DPTR
   \   00005F   A3           INC     DPTR
   \   000060   A3           INC     DPTR
   \   000061   A3           INC     DPTR
   \   000062   E5..         MOV     A,?V0 + 2
   \   000064   F0           MOVX    @DPTR,A
   \   000065   A3           INC     DPTR
   \   000066   E5..         MOV     A,?V0 + 3
   \   000068   F0           MOVX    @DPTR,A
    394          
    395            // Find spot in list
    396            if (  plugins == NULL )
   \   000069   90....       MOV     DPTR,#plugins
   \   00006C   E0           MOVX    A,@DPTR
   \   00006D   F8           MOV     R0,A
   \   00006E   A3           INC     DPTR
   \   00006F   E0           MOVX    A,@DPTR
   \   000070   F9           MOV     R1,A
   \   000071   E8           MOV     A,R0
   \   000072   49           ORL     A,R1
   \   000073   700A         JNZ     ??zcl_registerPlugin_2
    397            {
    398              plugins = pNewItem;
   \   000075   90....       MOV     DPTR,#plugins
   \   000078   EE           MOV     A,R6
   \   000079   F0           MOVX    @DPTR,A
   \   00007A   A3           INC     DPTR
   \   00007B   EF           MOV     A,R7
   \   00007C   F0           MOVX    @DPTR,A
   \   00007D   8035         SJMP    ??zcl_registerPlugin_3
    399            }
    400            else
    401            {
    402              // Look for end of list
    403              pLoop = plugins;
   \                     ??zcl_registerPlugin_2:
   \   00007F   90....       MOV     DPTR,#plugins
   \   000082   E0           MOVX    A,@DPTR
   \   000083   F8           MOV     R0,A
   \   000084   A3           INC     DPTR
   \   000085   E0           MOVX    A,@DPTR
   \   000086   F9           MOV     R1,A
   \   000087   88..         MOV     ?V0 + 4,R0
   \   000089   89..         MOV     ?V0 + 5,R1
    404              while ( pLoop->next != NULL )
   \                     ??zcl_registerPlugin_4:
   \   00008B   85..82       MOV     DPL,?V0 + 4
   \   00008E   85..83       MOV     DPH,?V0 + 5
   \   000091   E0           MOVX    A,@DPTR
   \   000092   F8           MOV     R0,A
   \   000093   A3           INC     DPTR
   \   000094   E0           MOVX    A,@DPTR
   \   000095   F9           MOV     R1,A
   \   000096   E8           MOV     A,R0
   \   000097   49           ORL     A,R1
   \   000098   600F         JZ      ??zcl_registerPlugin_5
    405              {
    406                pLoop = pLoop->next;
   \   00009A   85..82       MOV     DPL,?V0 + 4
   \   00009D   85..83       MOV     DPH,?V0 + 5
   \   0000A0   E0           MOVX    A,@DPTR
   \   0000A1   F5..         MOV     ?V0 + 4,A
   \   0000A3   A3           INC     DPTR
   \   0000A4   E0           MOVX    A,@DPTR
   \   0000A5   F5..         MOV     ?V0 + 5,A
   \   0000A7   80E2         SJMP    ??zcl_registerPlugin_4
    407              }
    408          
    409              // Put new item at end of list
    410              pLoop->next = pNewItem;
   \                     ??zcl_registerPlugin_5:
   \   0000A9   85..82       MOV     DPL,?V0 + 4
   \   0000AC   85..83       MOV     DPH,?V0 + 5
   \   0000AF   EE           MOV     A,R6
   \   0000B0   F0           MOVX    @DPTR,A
   \   0000B1   A3           INC     DPTR
   \   0000B2   EF           MOV     A,R7
   \   0000B3   F0           MOVX    @DPTR,A
    411            }
    412          
    413            return ( ZSuccess );
   \                     ??zcl_registerPlugin_3:
   \   0000B4   7900         MOV     R1,#0x0
   \                     ??zcl_registerPlugin_1:
   \   0000B6   7F0A         MOV     R7,#0xa
   \   0000B8   02....       LJMP    ?BANKED_LEAVE_XDATA
    414          }
    415          
    416          /*********************************************************************
    417           * @fn          zcl_registerAttrList
    418           *
    419           * @brief       Register an Attribute List with ZCL Foundation
    420           *
    421           * @param       endpoint - endpoint the attribute list belongs to
    422           * @param       numAttr - number of attributes in list
    423           * @param       newAttrList - array of Attribute records.
    424           *                            NOTE: THE ATTRIBUTE IDs (FOR A CLUSTER) MUST BE IN
    425           *                            ASCENDING ORDER. OTHERWISE, THE DISCOVERY RESPONSE
    426           *                            COMMAND WILL NOT HAVE THE RIGHT ATTRIBUTE INFO
    427           *
    428           * @return      ZSuccess if OK
    429           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    430          ZStatus_t zcl_registerAttrList( uint8 endpoint, uint8 numAttr, CONST zclAttrRec_t newAttrList[] )
   \                     zcl_registerAttrList:
    431          {
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V0 + 4,R1
   \   000007   8A..         MOV     ?V0 + 5,R2
   \   000009   8C..         MOV     ?V0 + 0,R4
   \   00000B   8D..         MOV     ?V0 + 1,R5
    432            zclAttrRecsList *pNewItem;
    433            zclAttrRecsList *pLoop;
    434          
    435            // Fill in the new profile list
    436            pNewItem = osal_mem_alloc( sizeof( zclAttrRecsList ) );
   \   00000D                ; Setup parameters for call to function osal_mem_alloc
   \   00000D   7A0A         MOV     R2,#0xa
   \   00000F   7B00         MOV     R3,#0x0
   \   000011   12....       LCALL   ??osal_mem_alloc?relay
   \   000014   8A..         MOV     ?V0 + 6,R2
   \   000016   8B..         MOV     ?V0 + 7,R3
   \   000018   AE..         MOV     R6,?V0 + 6
   \   00001A   AF..         MOV     R7,?V0 + 7
    437            if ( pNewItem == NULL )
   \   00001C   EE           MOV     A,R6
   \   00001D   4F           ORL     A,R7
   \   00001E   7005         JNZ     ??zcl_registerAttrList_0
    438            {
    439              return (ZMemError);
   \   000020   7910         MOV     R1,#0x10
   \   000022   02....       LJMP    ??zcl_registerAttrList_1 & 0xFFFF
    440            }
    441          
    442            pNewItem->next = (zclAttrRecsList *)NULL;
   \                     ??zcl_registerAttrList_0:
   \   000025   8E82         MOV     DPL,R6
   \   000027   8F83         MOV     DPH,R7
   \   000029   7400         MOV     A,#0x0
   \   00002B   F0           MOVX    @DPTR,A
   \   00002C   A3           INC     DPTR
   \   00002D   7400         MOV     A,#0x0
   \   00002F   F0           MOVX    @DPTR,A
    443            pNewItem->endpoint = endpoint;
   \   000030   E5..         MOV     A,?V0 + 4
   \   000032   8E82         MOV     DPL,R6
   \   000034   8F83         MOV     DPH,R7
   \   000036   A3           INC     DPTR
   \   000037   A3           INC     DPTR
   \   000038   E5..         MOV     A,?V0 + 4
   \   00003A   F0           MOVX    @DPTR,A
    444            pNewItem->pfnReadWriteCB = NULL;
   \   00003B   8E82         MOV     DPL,R6
   \   00003D   8F83         MOV     DPH,R7
   \   00003F   A3           INC     DPTR
   \   000040   A3           INC     DPTR
   \   000041   A3           INC     DPTR
   \   000042   7400         MOV     A,#0x0
   \   000044   F0           MOVX    @DPTR,A
   \   000045   A3           INC     DPTR
   \   000046   7400         MOV     A,#0x0
   \   000048   F0           MOVX    @DPTR,A
    445            pNewItem->numAttributes = numAttr;
   \   000049   E5..         MOV     A,?V0 + 5
   \   00004B   8E82         MOV     DPL,R6
   \   00004D   8F83         MOV     DPH,R7
   \   00004F   A3           INC     DPTR
   \   000050   A3           INC     DPTR
   \   000051   A3           INC     DPTR
   \   000052   A3           INC     DPTR
   \   000053   A3           INC     DPTR
   \   000054   A3           INC     DPTR
   \   000055   A3           INC     DPTR
   \   000056   E5..         MOV     A,?V0 + 5
   \   000058   F0           MOVX    @DPTR,A
    446            pNewItem->attrs = newAttrList;
   \   000059   8E82         MOV     DPL,R6
   \   00005B   8F83         MOV     DPH,R7
   \   00005D   A3           INC     DPTR
   \   00005E   A3           INC     DPTR
   \   00005F   A3           INC     DPTR
   \   000060   A3           INC     DPTR
   \   000061   A3           INC     DPTR
   \   000062   A3           INC     DPTR
   \   000063   A3           INC     DPTR
   \   000064   A3           INC     DPTR
   \   000065   E5..         MOV     A,?V0 + 0
   \   000067   F0           MOVX    @DPTR,A
   \   000068   A3           INC     DPTR
   \   000069   E5..         MOV     A,?V0 + 1
   \   00006B   F0           MOVX    @DPTR,A
    447          
    448            // Find spot in list
    449            if ( attrList == NULL )
   \   00006C   90....       MOV     DPTR,#attrList
   \   00006F   E0           MOVX    A,@DPTR
   \   000070   F8           MOV     R0,A
   \   000071   A3           INC     DPTR
   \   000072   E0           MOVX    A,@DPTR
   \   000073   F9           MOV     R1,A
   \   000074   E8           MOV     A,R0
   \   000075   49           ORL     A,R1
   \   000076   700A         JNZ     ??zcl_registerAttrList_2
    450            {
    451              attrList = pNewItem;
   \   000078   90....       MOV     DPTR,#attrList
   \   00007B   EE           MOV     A,R6
   \   00007C   F0           MOVX    @DPTR,A
   \   00007D   A3           INC     DPTR
   \   00007E   EF           MOV     A,R7
   \   00007F   F0           MOVX    @DPTR,A
   \   000080   8039         SJMP    ??zcl_registerAttrList_3
    452            }
    453            else
    454            {
    455              // Look for end of list
    456              pLoop = attrList;
   \                     ??zcl_registerAttrList_2:
   \   000082   90....       MOV     DPTR,#attrList
   \   000085   E0           MOVX    A,@DPTR
   \   000086   F8           MOV     R0,A
   \   000087   A3           INC     DPTR
   \   000088   E0           MOVX    A,@DPTR
   \   000089   F9           MOV     R1,A
   \   00008A   88..         MOV     ?V0 + 2,R0
   \   00008C   89..         MOV     ?V0 + 3,R1
    457              while ( pLoop->next != NULL )
   \                     ??zcl_registerAttrList_4:
   \   00008E   85..82       MOV     DPL,?V0 + 2
   \   000091   85..83       MOV     DPH,?V0 + 3
   \   000094   E0           MOVX    A,@DPTR
   \   000095   F8           MOV     R0,A
   \   000096   A3           INC     DPTR
   \   000097   E0           MOVX    A,@DPTR
   \   000098   F9           MOV     R1,A
   \   000099   E8           MOV     A,R0
   \   00009A   49           ORL     A,R1
   \   00009B   600F         JZ      ??zcl_registerAttrList_5
    458              {
    459                pLoop = pLoop->next;
   \   00009D   85..82       MOV     DPL,?V0 + 2
   \   0000A0   85..83       MOV     DPH,?V0 + 3
   \   0000A3   E0           MOVX    A,@DPTR
   \   0000A4   F5..         MOV     ?V0 + 2,A
   \   0000A6   A3           INC     DPTR
   \   0000A7   E0           MOVX    A,@DPTR
   \   0000A8   F5..         MOV     ?V0 + 3,A
   \   0000AA   80E2         SJMP    ??zcl_registerAttrList_4
    460              }
    461          
    462              // Put new item at end of list
    463              pLoop->next = pNewItem;
   \                     ??zcl_registerAttrList_5:
   \   0000AC   EE           MOV     A,R6
   \   0000AD   F8           MOV     R0,A
   \   0000AE   EF           MOV     A,R7
   \   0000AF   F9           MOV     R1,A
   \   0000B0   85..82       MOV     DPL,?V0 + 2
   \   0000B3   85..83       MOV     DPH,?V0 + 3
   \   0000B6   E8           MOV     A,R0
   \   0000B7   F0           MOVX    @DPTR,A
   \   0000B8   A3           INC     DPTR
   \   0000B9   E9           MOV     A,R1
   \   0000BA   F0           MOVX    @DPTR,A
    464            }
    465          
    466            return ( ZSuccess );
   \                     ??zcl_registerAttrList_3:
   \   0000BB   7900         MOV     R1,#0x0
   \                     ??zcl_registerAttrList_1:
   \   0000BD   7F08         MOV     R7,#0x8
   \   0000BF   02....       LJMP    ?BANKED_LEAVE_XDATA
    467          }
    468          
    469          /*********************************************************************
    470           * @fn          zcl_registerClusterOptionList
    471           *
    472           * @brief       Register a Cluster Option List with ZCL Foundation
    473           *
    474           * @param       endpoint - endpoint the option list belongs to
    475           * @param       numOption - number of options in list
    476           * @param       optionList - array of cluster option records.
    477           *
    478           *              NOTE: This API should be called to enable 'Application
    479           *                    Link Key' security and/or 'APS ACK' for a specific
    480           *                    Cluster. The 'Application Link Key' is discarded
    481           *                    if security isn't enabled on the device.
    482           *                    The default behavior is 'Network Key' when security
    483           *                    is enabled and no 'APS ACK' for the ZCL messages.
    484           *
    485           * @return      ZSuccess if OK
    486           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    487          ZStatus_t zcl_registerClusterOptionList( uint8 endpoint, uint8 numOption, zclOptionRec_t optionList[] )
   \                     zcl_registerClusterOptionList:
    488          {
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V0 + 4,R1
   \   000007   8A..         MOV     ?V0 + 5,R2
   \   000009   8C..         MOV     ?V0 + 0,R4
   \   00000B   8D..         MOV     ?V0 + 1,R5
    489            zclClusterOptionList *pNewItem;
    490            zclClusterOptionList *pLoop;
    491          
    492            // Fill in the new profile list
    493            pNewItem = osal_mem_alloc( sizeof( zclClusterOptionList ) );
   \   00000D                ; Setup parameters for call to function osal_mem_alloc
   \   00000D   7A06         MOV     R2,#0x6
   \   00000F   7B00         MOV     R3,#0x0
   \   000011   12....       LCALL   ??osal_mem_alloc?relay
   \   000014   8A..         MOV     ?V0 + 6,R2
   \   000016   8B..         MOV     ?V0 + 7,R3
   \   000018   AE..         MOV     R6,?V0 + 6
   \   00001A   AF..         MOV     R7,?V0 + 7
    494            if ( pNewItem == NULL )
   \   00001C   EE           MOV     A,R6
   \   00001D   4F           ORL     A,R7
   \   00001E   7005         JNZ     ??zcl_registerClusterOptionList_0
    495            {
    496              return (ZMemError);
   \   000020   7910         MOV     R1,#0x10
   \   000022   02....       LJMP    ??zcl_registerClusterOptionList_1 & 0xFFFF
    497            }
    498          
    499            pNewItem->next = (zclClusterOptionList *)NULL;
   \                     ??zcl_registerClusterOptionList_0:
   \   000025   8E82         MOV     DPL,R6
   \   000027   8F83         MOV     DPH,R7
   \   000029   7400         MOV     A,#0x0
   \   00002B   F0           MOVX    @DPTR,A
   \   00002C   A3           INC     DPTR
   \   00002D   7400         MOV     A,#0x0
   \   00002F   F0           MOVX    @DPTR,A
    500            pNewItem->endpoint = endpoint;
   \   000030   E5..         MOV     A,?V0 + 4
   \   000032   8E82         MOV     DPL,R6
   \   000034   8F83         MOV     DPH,R7
   \   000036   A3           INC     DPTR
   \   000037   A3           INC     DPTR
   \   000038   E5..         MOV     A,?V0 + 4
   \   00003A   F0           MOVX    @DPTR,A
    501            pNewItem->numOptions = numOption;
   \   00003B   E5..         MOV     A,?V0 + 5
   \   00003D   8E82         MOV     DPL,R6
   \   00003F   8F83         MOV     DPH,R7
   \   000041   A3           INC     DPTR
   \   000042   A3           INC     DPTR
   \   000043   A3           INC     DPTR
   \   000044   E5..         MOV     A,?V0 + 5
   \   000046   F0           MOVX    @DPTR,A
    502            pNewItem->options = optionList;
   \   000047   8E82         MOV     DPL,R6
   \   000049   8F83         MOV     DPH,R7
   \   00004B   A3           INC     DPTR
   \   00004C   A3           INC     DPTR
   \   00004D   A3           INC     DPTR
   \   00004E   A3           INC     DPTR
   \   00004F   E5..         MOV     A,?V0 + 0
   \   000051   F0           MOVX    @DPTR,A
   \   000052   A3           INC     DPTR
   \   000053   E5..         MOV     A,?V0 + 1
   \   000055   F0           MOVX    @DPTR,A
    503          
    504            // Find spot in list
    505            if ( clusterOptionList == NULL )
   \   000056   90....       MOV     DPTR,#clusterOptionList
   \   000059   E0           MOVX    A,@DPTR
   \   00005A   F8           MOV     R0,A
   \   00005B   A3           INC     DPTR
   \   00005C   E0           MOVX    A,@DPTR
   \   00005D   F9           MOV     R1,A
   \   00005E   E8           MOV     A,R0
   \   00005F   49           ORL     A,R1
   \   000060   700A         JNZ     ??zcl_registerClusterOptionList_2
    506            {
    507              clusterOptionList = pNewItem;
   \   000062   90....       MOV     DPTR,#clusterOptionList
   \   000065   EE           MOV     A,R6
   \   000066   F0           MOVX    @DPTR,A
   \   000067   A3           INC     DPTR
   \   000068   EF           MOV     A,R7
   \   000069   F0           MOVX    @DPTR,A
   \   00006A   8039         SJMP    ??zcl_registerClusterOptionList_3
    508            }
    509            else
    510            {
    511              // Look for end of list
    512              pLoop = clusterOptionList;
   \                     ??zcl_registerClusterOptionList_2:
   \   00006C   90....       MOV     DPTR,#clusterOptionList
   \   00006F   E0           MOVX    A,@DPTR
   \   000070   F8           MOV     R0,A
   \   000071   A3           INC     DPTR
   \   000072   E0           MOVX    A,@DPTR
   \   000073   F9           MOV     R1,A
   \   000074   88..         MOV     ?V0 + 2,R0
   \   000076   89..         MOV     ?V0 + 3,R1
    513              while ( pLoop->next != NULL )
   \                     ??zcl_registerClusterOptionList_4:
   \   000078   85..82       MOV     DPL,?V0 + 2
   \   00007B   85..83       MOV     DPH,?V0 + 3
   \   00007E   E0           MOVX    A,@DPTR
   \   00007F   F8           MOV     R0,A
   \   000080   A3           INC     DPTR
   \   000081   E0           MOVX    A,@DPTR
   \   000082   F9           MOV     R1,A
   \   000083   E8           MOV     A,R0
   \   000084   49           ORL     A,R1
   \   000085   600F         JZ      ??zcl_registerClusterOptionList_5
    514              {
    515                pLoop = pLoop->next;
   \   000087   85..82       MOV     DPL,?V0 + 2
   \   00008A   85..83       MOV     DPH,?V0 + 3
   \   00008D   E0           MOVX    A,@DPTR
   \   00008E   F5..         MOV     ?V0 + 2,A
   \   000090   A3           INC     DPTR
   \   000091   E0           MOVX    A,@DPTR
   \   000092   F5..         MOV     ?V0 + 3,A
   \   000094   80E2         SJMP    ??zcl_registerClusterOptionList_4
    516              }
    517          
    518              // Put new item at end of list
    519              pLoop->next = pNewItem;
   \                     ??zcl_registerClusterOptionList_5:
   \   000096   EE           MOV     A,R6
   \   000097   F8           MOV     R0,A
   \   000098   EF           MOV     A,R7
   \   000099   F9           MOV     R1,A
   \   00009A   85..82       MOV     DPL,?V0 + 2
   \   00009D   85..83       MOV     DPH,?V0 + 3
   \   0000A0   E8           MOV     A,R0
   \   0000A1   F0           MOVX    @DPTR,A
   \   0000A2   A3           INC     DPTR
   \   0000A3   E9           MOV     A,R1
   \   0000A4   F0           MOVX    @DPTR,A
    520            }
    521          
    522            return ( ZSuccess );
   \                     ??zcl_registerClusterOptionList_3:
   \   0000A5   7900         MOV     R1,#0x0
   \                     ??zcl_registerClusterOptionList_1:
   \   0000A7   7F08         MOV     R7,#0x8
   \   0000A9   02....       LJMP    ?BANKED_LEAVE_XDATA
    523          }
    524          
    525          /*********************************************************************
    526           * @fn          zcl_registerValidateAttrData
    527           *
    528           * @brief       Add a validation function for attribute data
    529           *
    530           * @param       pfnValidateAttrData - function pointer to validate routine
    531           *
    532           * @return      ZSuccess if OK
    533           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    534          ZStatus_t zcl_registerValidateAttrData( zclValidateAttrData_t pfnValidateAttrData )
   \                     zcl_registerValidateAttrData:
    535          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    536            zcl_ValidateAttrDataCB = pfnValidateAttrData;
   \   000004   90....       MOV     DPTR,#zcl_ValidateAttrDataCB
   \   000007   EA           MOV     A,R2
   \   000008   F0           MOVX    @DPTR,A
   \   000009   A3           INC     DPTR
   \   00000A   EB           MOV     A,R3
   \   00000B   F0           MOVX    @DPTR,A
    537          
    538            return ( ZSuccess );
   \   00000C   7900         MOV     R1,#0x0
   \   00000E   D083         POP     DPH
   \   000010   D082         POP     DPL
   \   000012   02....       LJMP    ?BRET
    539          }
    540          
    541          /*********************************************************************
    542           * @fn          zcl_registerReadWriteCB
    543           *
    544           * @brief       Register the application's callback function to read/write
    545           *              attribute data, and authorize read/write operation.
    546           *
    547           *              Note: The pfnReadWriteCB callback function is only required
    548           *                    when the attribute data format is unknown to ZCL. The
    549           *                    callback function gets called when the pointer 'dataPtr'
    550           *                    to the attribute value is NULL in the attribute database
    551           *                    registered with the ZCL.
    552           *
    553           *              Note: The pfnAuthorizeCB callback function is only required
    554           *                    when the Read/Write operation on an attribute requires
    555           *                    authorization (i.e., attributes with ACCESS_CONTROL_AUTH_READ
    556           *                    or ACCESS_CONTROL_AUTH_WRITE access permissions).
    557           *
    558           * @param       endpoint - application's endpoint
    559           * @param       pfnReadWriteCB - function pointer to read/write routine
    560           * @param       pfnAuthorizeCB - function pointer to authorize read/write operation
    561           *
    562           * @return      ZSuccess if successful. ZFailure, otherwise.
    563           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    564          ZStatus_t zcl_registerReadWriteCB( uint8 endpoint, zclReadWriteCB_t pfnReadWriteCB,
   \                     zcl_registerReadWriteCB:
    565                                             zclAuthorizeCB_t pfnAuthorizeCB )
    566          {
   \   000000   74F2         MOV     A,#-0xe
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V0 + 2,R1
   \   000007   8A..         MOV     ?V0 + 0,R2
   \   000009   8B..         MOV     ?V0 + 1,R3
   \   00000B   EC           MOV     A,R4
   \   00000C   FE           MOV     R6,A
   \   00000D   ED           MOV     A,R5
   \   00000E   FF           MOV     R7,A
    567            zclAttrRecsList *pRec = zclFindAttrRecsList( endpoint );
   \   00000F                ; Setup parameters for call to function zclFindAttrRecsList
   \   00000F   A9..         MOV     R1,?V0 + 2
   \   000011   12....       LCALL   ??zclFindAttrRecsList?relay
   \   000014   8A..         MOV     ?V0 + 4,R2
   \   000016   8B..         MOV     ?V0 + 5,R3
   \   000018   AA..         MOV     R2,?V0 + 4
   \   00001A   AB..         MOV     R3,?V0 + 5
    568          
    569            if ( pRec != NULL )
   \   00001C   EA           MOV     A,R2
   \   00001D   4B           ORL     A,R3
   \   00001E   6020         JZ      ??zcl_registerReadWriteCB_0
    570            {
    571              pRec->pfnReadWriteCB = pfnReadWriteCB;
   \   000020   8A82         MOV     DPL,R2
   \   000022   8B83         MOV     DPH,R3
   \   000024   A3           INC     DPTR
   \   000025   A3           INC     DPTR
   \   000026   A3           INC     DPTR
   \   000027   E5..         MOV     A,?V0 + 0
   \   000029   F0           MOVX    @DPTR,A
   \   00002A   A3           INC     DPTR
   \   00002B   E5..         MOV     A,?V0 + 1
   \   00002D   F0           MOVX    @DPTR,A
    572              pRec->pfnAuthorizeCB = pfnAuthorizeCB;
   \   00002E   8A82         MOV     DPL,R2
   \   000030   8B83         MOV     DPH,R3
   \   000032   A3           INC     DPTR
   \   000033   A3           INC     DPTR
   \   000034   A3           INC     DPTR
   \   000035   A3           INC     DPTR
   \   000036   A3           INC     DPTR
   \   000037   EE           MOV     A,R6
   \   000038   F0           MOVX    @DPTR,A
   \   000039   A3           INC     DPTR
   \   00003A   EF           MOV     A,R7
   \   00003B   F0           MOVX    @DPTR,A
    573          
    574              return ( ZSuccess );
   \   00003C   7900         MOV     R1,#0x0
   \   00003E   8002         SJMP    ??zcl_registerReadWriteCB_1
    575            }
    576          
    577            return ( ZFailure );
   \                     ??zcl_registerReadWriteCB_0:
   \   000040   7901         MOV     R1,#0x1
   \                     ??zcl_registerReadWriteCB_1:
   \   000042   7F06         MOV     R7,#0x6
   \   000044   02....       LJMP    ?BANKED_LEAVE_XDATA
    578          }
    579          
    580          /*********************************************************************
    581           * @fn      zcl_registerForMsg
    582           *
    583           * @brief   The ZCL is setup to send all incoming Foundation Command/Response
    584           *          messages that aren't processed to one task (if a task is
    585           *          registered).
    586           *
    587           * @param   taskId - task Id of the Application where commands will be sent to
    588           *
    589           * @return  TRUE if task registeration successful, FALSE otherwise
    590           *********************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    591          uint8 zcl_registerForMsg( uint8 taskId )
   \                     zcl_registerForMsg:
    592          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   \   000004   E9           MOV     A,R1
   \   000005   F8           MOV     R0,A
    593            // Allow only the first task
    594            if ( zcl_RegisteredMsgTaskID == TASK_NO_TASK )
   \   000006   90....       MOV     DPTR,#zcl_RegisteredMsgTaskID
   \   000009   E0           MOVX    A,@DPTR
   \   00000A   64FF         XRL     A,#0xff
   \   00000C   7009         JNZ     ??zcl_registerForMsg_0
    595            {
    596              zcl_RegisteredMsgTaskID = taskId;
   \   00000E   E8           MOV     A,R0
   \   00000F   90....       MOV     DPTR,#zcl_RegisteredMsgTaskID
   \   000012   F0           MOVX    @DPTR,A
    597          
    598              return ( true );
   \   000013   7901         MOV     R1,#0x1
   \   000015   8002         SJMP    ??zcl_registerForMsg_1
    599            }
    600          
    601            return ( false );
   \                     ??zcl_registerForMsg_0:
   \   000017   7900         MOV     R1,#0x0
   \                     ??zcl_registerForMsg_1:
   \   000019   D083         POP     DPH
   \   00001B   D082         POP     DPL
   \   00001D   02....       LJMP    ?BRET
    602          }
    603          
    604          /*********************************************************************
    605           * @fn      zcl_DeviceOperational
    606           *
    607           * @brief   Used to see whether or not the device can send or respond
    608           *          to application level commands.
    609           *
    610           * @param   srcEP - source endpoint
    611           * @param   clusterID - cluster ID
    612           * @param   frameType - command type
    613           * @param   cmd - command ID
    614           *
    615           * @return  TRUE if device is operational, FALSE otherwise
    616           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    617          static uint8 zcl_DeviceOperational( uint8 srcEP, uint16 clusterID,
   \                     zcl_DeviceOperational:
    618                                              uint8 frameType, uint8 cmd, uint16 profileID )
    619          {
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 9
   \   000005   74F7         MOV     A,#-0x9
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   89..         MOV     ?V0 + 4,R1
   \   00000C   EA           MOV     A,R2
   \   00000D   FE           MOV     R6,A
   \   00000E   EB           MOV     A,R3
   \   00000F   FF           MOV     R7,A
   \   000010   8C..         MOV     ?V0 + 2,R4
   \   000012   8D..         MOV     ?V0 + 3,R5
   \   000014   7419         MOV     A,#0x19
   \   000016   12....       LCALL   ?XSTACK_DISP0_8
   \   000019   E0           MOVX    A,@DPTR
   \   00001A   F5..         MOV     ?V0 + 0,A
   \   00001C   A3           INC     DPTR
   \   00001D   E0           MOVX    A,@DPTR
   \   00001E   F5..         MOV     ?V0 + 1,A
    620            zclAttrRec_t attrRec;
    621            uint8 deviceEnabled = DEVICE_ENABLED; // default value
   \   000020   85..82       MOV     DPL,?XSP + 0
   \   000023   85..83       MOV     DPH,?XSP + 1
   \   000026   7401         MOV     A,#0x1
   \   000028   F0           MOVX    @DPTR,A
    622          
    623            (void)profileID;  // Intentionally unreferenced parameter
    624          
    625            // If the device is Disabled (DeviceEnabled attribute is set to Disabled), it
    626            // cannot send or respond to application level commands, other than commands
    627            // to read or write attributes. Note that the Identify cluster cannot be
    628            // disabled, and remains functional regardless of this setting.
    629            if ( zcl_ProfileCmd( frameType ) && cmd <= ZCL_CMD_WRITE_NO_RSP )
   \   000029   E5..         MOV     A,?V0 + 2
   \   00002B   700B         JNZ     ??zcl_DeviceOperational_0
   \   00002D   E5..         MOV     A,?V0 + 3
   \   00002F   C3           CLR     C
   \   000030   9406         SUBB    A,#0x6
   \   000032   5004         JNC     ??zcl_DeviceOperational_0
    630            {
    631              return ( TRUE );
   \   000034   7901         MOV     R1,#0x1
   \   000036   8069         SJMP    ??zcl_DeviceOperational_1
    632            }
    633          
    634            if ( clusterID == ZCL_CLUSTER_ID_GEN_IDENTIFY )
   \                     ??zcl_DeviceOperational_0:
   \   000038   7403         MOV     A,#0x3
   \   00003A   6E           XRL     A,R6
   \   00003B   7003         JNZ     ??zcl_DeviceOperational_2
   \   00003D   7400         MOV     A,#0x0
   \   00003F   6F           XRL     A,R7
   \                     ??zcl_DeviceOperational_2:
   \   000040   7004         JNZ     ??zcl_DeviceOperational_3
    635            {
    636              return ( TRUE );
   \   000042   7901         MOV     R1,#0x1
   \   000044   805B         SJMP    ??zcl_DeviceOperational_1
    637            }
    638          
    639            // Is device enabled?
    640            if ( zclFindAttrRec( srcEP, ZCL_CLUSTER_ID_GEN_BASIC,
    641                                 ATTRID_BASIC_DEVICE_ENABLED, &attrRec ) )
   \                     ??zcl_DeviceOperational_3:
   \   000046                ; Setup parameters for call to function zclFindAttrRec
   \   000046   7401         MOV     A,#0x1
   \   000048   12....       LCALL   ?XSTACK_DISP0_8
   \   00004B   8582..       MOV     ?V0 + 6,DPL
   \   00004E   8583..       MOV     ?V0 + 7,DPH
   \   000051   78..         MOV     R0,#?V0 + 6
   \   000053   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000056   7C12         MOV     R4,#0x12
   \   000058   7D00         MOV     R5,#0x0
   \   00005A   7A00         MOV     R2,#0x0
   \   00005C   7B00         MOV     R3,#0x0
   \   00005E   A9..         MOV     R1,?V0 + 4
   \   000060   12....       LCALL   ??zclFindAttrRec?relay
   \   000063   7402         MOV     A,#0x2
   \   000065   12....       LCALL   ?DEALLOC_XSTACK8
   \   000068   E9           MOV     A,R1
   \   000069   6025         JZ      ??zcl_DeviceOperational_4
    642            {
    643              zclReadAttrData( &deviceEnabled, &attrRec, NULL );
   \   00006B                ; Setup parameters for call to function zclReadAttrData
   \   00006B   E4           CLR     A
   \   00006C   F5..         MOV     ?V0 + 6,A
   \   00006E   F5..         MOV     ?V0 + 7,A
   \   000070   78..         MOV     R0,#?V0 + 6
   \   000072   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000075   7403         MOV     A,#0x3
   \   000077   12....       LCALL   ?XSTACK_DISP0_8
   \   00007A   AC82         MOV     R4,DPL
   \   00007C   AD83         MOV     R5,DPH
   \   00007E   7402         MOV     A,#0x2
   \   000080   12....       LCALL   ?XSTACK_DISP0_8
   \   000083   AA82         MOV     R2,DPL
   \   000085   AB83         MOV     R3,DPH
   \   000087   12....       LCALL   ??zclReadAttrData?relay
   \   00008A   7402         MOV     A,#0x2
   \   00008C   12....       LCALL   ?DEALLOC_XSTACK8
   \   00008F   E9           MOV     A,R1
    644            }
    645          
    646            return ( deviceEnabled == DEVICE_ENABLED ? TRUE : FALSE );
   \                     ??zcl_DeviceOperational_4:
   \   000090   85..82       MOV     DPL,?XSP + 0
   \   000093   85..83       MOV     DPH,?XSP + 1
   \   000096   E0           MOVX    A,@DPTR
   \   000097   6401         XRL     A,#0x1
   \   000099   7004         JNZ     ??zcl_DeviceOperational_5
   \   00009B   7901         MOV     R1,#0x1
   \   00009D   8002         SJMP    ??zcl_DeviceOperational_1
   \                     ??zcl_DeviceOperational_5:
   \   00009F   7900         MOV     R1,#0x0
   \                     ??zcl_DeviceOperational_1:
   \   0000A1   7409         MOV     A,#0x9
   \   0000A3   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000A6   7F08         MOV     R7,#0x8
   \   0000A8   02....       LJMP    ?BANKED_LEAVE_XDATA
    647          }
    648          
    649          /*********************************************************************
    650           * @fn      zcl_SendCommand
    651           *
    652           * @brief   Used to send Profile and Cluster Specific Command messages.
    653           *
    654           *          NOTE: The calling application is responsible for incrementing
    655           *                the Sequence Number.
    656           *
    657           * @param   srcEp - source endpoint
    658           * @param   destAddr - destination address
    659           * @param   clusterID - cluster ID
    660           * @param   cmd - command ID
    661           * @param   specific - whether the command is Cluster Specific
    662           * @param   direction - client/server direction of the command
    663           * @param   disableDefaultRsp - disable Default Response command
    664           * @param   manuCode - manufacturer code for proprietary extensions to a profile
    665           * @param   seqNumber - identification number for the transaction
    666           * @param   cmdFormatLen - length of the command to be sent
    667           * @param   cmdFormat - command to be sent
    668           *
    669           * @return  ZSuccess if OK
    670           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    671          ZStatus_t zcl_SendCommand( uint8 srcEP, afAddrType_t *destAddr,
   \                     zcl_SendCommand:
    672                                     uint16 clusterID, uint8 cmd, uint8 specific, uint8 direction,
    673                                     uint8 disableDefaultRsp, uint16 manuCode, uint8 seqNum,
    674                                     uint16 cmdFormatLen, uint8 *cmdFormat )
    675          {
   \   000000   74E8         MOV     A,#-0x18
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 24
   \   000005                ; Auto size: 10
   \   000005   74F6         MOV     A,#-0xa
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   7408         MOV     A,#0x8
   \   00000C   12....       LCALL   ?XSTACK_DISP0_8
   \   00000F   EA           MOV     A,R2
   \   000010   F0           MOVX    @DPTR,A
   \   000011   A3           INC     DPTR
   \   000012   EB           MOV     A,R3
   \   000013   F0           MOVX    @DPTR,A
   \   000014   89..         MOV     ?V0 + 3,R1
   \   000016   EC           MOV     A,R4
   \   000017   FE           MOV     R6,A
   \   000018   ED           MOV     A,R5
   \   000019   FF           MOV     R7,A
   \   00001A   7422         MOV     A,#0x22
   \   00001C   12....       LCALL   ?XSTACK_DISP0_8
   \   00001F   E0           MOVX    A,@DPTR
   \   000020   F5..         MOV     ?V0 + 7,A
   \   000022   7424         MOV     A,#0x24
   \   000024   12....       LCALL   ?XSTACK_DISP0_8
   \   000027   E0           MOVX    A,@DPTR
   \   000028   F5..         MOV     ?V0 + 15,A
   \   00002A   7425         MOV     A,#0x25
   \   00002C   12....       LCALL   ?XSTACK_DISP0_8
   \   00002F   E0           MOVX    A,@DPTR
   \   000030   F5..         MOV     ?V0 + 14,A
   \   000032   7428         MOV     A,#0x28
   \   000034   12....       LCALL   ?XSTACK_DISP0_8
   \   000037   E0           MOVX    A,@DPTR
   \   000038   F5..         MOV     ?V0 + 13,A
    676            endPointDesc_t *epDesc;
    677            zclFrameHdr_t hdr;
    678            uint8 *msgBuf;
    679            uint16 msgLen;
    680            uint8 *pBuf;
    681            uint8 options;
    682            ZStatus_t status;
    683          
    684            epDesc = afFindEndPointDesc( srcEP );
   \   00003A                ; Setup parameters for call to function afFindEndPointDesc
   \   00003A   A9..         MOV     R1,?V0 + 3
   \   00003C   12....       LCALL   ??afFindEndPointDesc?relay
   \   00003F   8A..         MOV     ?V0 + 4,R2
   \   000041   8B..         MOV     ?V0 + 5,R3
   \   000043   85....       MOV     ?V0 + 8,?V0 + 4
   \   000046   85....       MOV     ?V0 + 9,?V0 + 5
    685            if ( epDesc == NULL )
   \   000049   E5..         MOV     A,?V0 + 8
   \   00004B   45..         ORL     A,?V0 + 9
   \   00004D   7005         JNZ     ??zcl_SendCommand_0
    686            {
    687              return ( ZInvalidParameter ); // EMBEDDED RETURN
   \   00004F   7902         MOV     R1,#0x2
   \   000051   02....       LJMP    ??zcl_SendCommand_1 & 0xFFFF
    688            }
    689          
    690          #if defined ( INTER_PAN )
    691            if ( StubAPS_InterPan( destAddr->panId, destAddr->endPoint ) )
    692            {
    693              options = AF_TX_OPTIONS_NONE;
    694            }
    695            else
    696          #endif
    697            {
    698              options = zclGetClusterOption( srcEP, clusterID );
   \                     ??zcl_SendCommand_0:
   \   000054                ; Setup parameters for call to function zclGetClusterOption
   \   000054   EE           MOV     A,R6
   \   000055   FA           MOV     R2,A
   \   000056   EF           MOV     A,R7
   \   000057   FB           MOV     R3,A
   \   000058   A9..         MOV     R1,?V0 + 3
   \   00005A   12....       LCALL   ??zclGetClusterOption?relay
   \   00005D   E9           MOV     A,R1
   \   00005E   F5..         MOV     ?V0 + 12,A
    699            }
    700          
    701            osal_memset( &hdr, 0, sizeof( zclFrameHdr_t ) );
   \   000060                ; Setup parameters for call to function osal_memset
   \   000060   7C06         MOV     R4,#0x6
   \   000062   7D00         MOV     R5,#0x0
   \   000064   7900         MOV     R1,#0x0
   \   000066   85..82       MOV     DPL,?XSP + 0
   \   000069   85..83       MOV     DPH,?XSP + 1
   \   00006C   AA82         MOV     R2,DPL
   \   00006E   AB83         MOV     R3,DPH
   \   000070   12....       LCALL   ??osal_memset?relay
    702          
    703            // Not Profile wide command (like READ, WRITE)
    704            if ( specific )
   \   000073   7423         MOV     A,#0x23
   \   000075   12....       LCALL   ?XSTACK_DISP0_8
   \   000078   E0           MOVX    A,@DPTR
   \   000079   6024         JZ      ??zcl_SendCommand_2
    705            {
    706              hdr.fc.type = ZCL_FRAME_TYPE_SPECIFIC_CMD;
   \   00007B   85..82       MOV     DPL,?XSP + 0
   \   00007E   85..83       MOV     DPH,?XSP + 1
   \   000081   E0           MOVX    A,@DPTR
   \   000082   54FC         ANL     A,#0xfc
   \   000084   F8           MOV     R0,A
   \   000085   A3           INC     DPTR
   \   000086   E0           MOVX    A,@DPTR
   \   000087   54FF         ANL     A,#0xff
   \   000089   F9           MOV     R1,A
   \   00008A   E8           MOV     A,R0
   \   00008B   4401         ORL     A,#0x1
   \   00008D   F8           MOV     R0,A
   \   00008E   E9           MOV     A,R1
   \   00008F   4400         ORL     A,#0x0
   \   000091   F9           MOV     R1,A
   \   000092   85..82       MOV     DPL,?XSP + 0
   \   000095   85..83       MOV     DPH,?XSP + 1
   \   000098   E8           MOV     A,R0
   \   000099   F0           MOVX    @DPTR,A
   \   00009A   A3           INC     DPTR
   \   00009B   E9           MOV     A,R1
   \   00009C   F0           MOVX    @DPTR,A
   \   00009D   800F         SJMP    ??zcl_SendCommand_3
    707            }
    708            else
    709            {
    710              hdr.fc.type = ZCL_FRAME_TYPE_PROFILE_CMD;
   \                     ??zcl_SendCommand_2:
   \   00009F   85..82       MOV     DPL,?XSP + 0
   \   0000A2   85..83       MOV     DPH,?XSP + 1
   \   0000A5   E0           MOVX    A,@DPTR
   \   0000A6   54FC         ANL     A,#0xfc
   \   0000A8   F0           MOVX    @DPTR,A
   \   0000A9   A3           INC     DPTR
   \   0000AA   E0           MOVX    A,@DPTR
   \   0000AB   54FF         ANL     A,#0xff
   \   0000AD   F0           MOVX    @DPTR,A
    711            }
    712          
    713            if ( ( epDesc->simpleDesc == NULL ) ||
    714                 ( zcl_DeviceOperational( srcEP, clusterID, hdr.fc.type,
    715                                          cmd, epDesc->simpleDesc->AppProfId ) == FALSE ) )
   \                     ??zcl_SendCommand_3:
   \   0000AE   85..82       MOV     DPL,?V0 + 8
   \   0000B1   85..83       MOV     DPH,?V0 + 9
   \   0000B4   A3           INC     DPTR
   \   0000B5   A3           INC     DPTR
   \   0000B6   A3           INC     DPTR
   \   0000B7   E0           MOVX    A,@DPTR
   \   0000B8   F8           MOV     R0,A
   \   0000B9   A3           INC     DPTR
   \   0000BA   E0           MOVX    A,@DPTR
   \   0000BB   F9           MOV     R1,A
   \   0000BC   E8           MOV     A,R0
   \   0000BD   49           ORL     A,R1
   \   0000BE   6036         JZ      ??zcl_SendCommand_4
   \   0000C0                ; Setup parameters for call to function zcl_DeviceOperational
   \   0000C0   85..82       MOV     DPL,?V0 + 8
   \   0000C3   85..83       MOV     DPH,?V0 + 9
   \   0000C6   A3           INC     DPTR
   \   0000C7   A3           INC     DPTR
   \   0000C8   A3           INC     DPTR
   \   0000C9   E0           MOVX    A,@DPTR
   \   0000CA   F8           MOV     R0,A
   \   0000CB   A3           INC     DPTR
   \   0000CC   E0           MOVX    A,@DPTR
   \   0000CD   F583         MOV     DPH,A
   \   0000CF   8882         MOV     DPL,R0
   \   0000D1   A3           INC     DPTR
   \   0000D2   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   0000D5   AD..         MOV     R5,?V0 + 7
   \   0000D7   7402         MOV     A,#0x2
   \   0000D9   12....       LCALL   ?XSTACK_DISP0_8
   \   0000DC   E0           MOVX    A,@DPTR
   \   0000DD   F8           MOV     R0,A
   \   0000DE   A3           INC     DPTR
   \   0000DF   E0           MOVX    A,@DPTR
   \   0000E0   F9           MOV     R1,A
   \   0000E1   E8           MOV     A,R0
   \   0000E2   5403         ANL     A,#0x3
   \   0000E4   FC           MOV     R4,A
   \   0000E5   EE           MOV     A,R6
   \   0000E6   FA           MOV     R2,A
   \   0000E7   EF           MOV     A,R7
   \   0000E8   FB           MOV     R3,A
   \   0000E9   A9..         MOV     R1,?V0 + 3
   \   0000EB   12....       LCALL   ??zcl_DeviceOperational?relay
   \   0000EE   7402         MOV     A,#0x2
   \   0000F0   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000F3   E9           MOV     A,R1
   \   0000F4   7005         JNZ     ??zcl_SendCommand_5
    716            {
    717              return ( ZFailure ); // EMBEDDED RETURN
   \                     ??zcl_SendCommand_4:
   \   0000F6   7901         MOV     R1,#0x1
   \   0000F8   02....       LJMP    ??zcl_SendCommand_1 & 0xFFFF
    718            }
    719          
    720            // Fill in the Maufacturer Code
    721            if ( manuCode != 0 )
   \                     ??zcl_SendCommand_5:
   \   0000FB   7426         MOV     A,#0x26
   \   0000FD   12....       LCALL   ?XSTACK_DISP0_8
   \   000100   E0           MOVX    A,@DPTR
   \   000101   F8           MOV     R0,A
   \   000102   A3           INC     DPTR
   \   000103   E0           MOVX    A,@DPTR
   \   000104   F9           MOV     R1,A
   \   000105   E8           MOV     A,R0
   \   000106   49           ORL     A,R1
   \   000107   6023         JZ      ??zcl_SendCommand_6
    722            {
    723              hdr.fc.manuSpecific = 1;
   \   000109   85..82       MOV     DPL,?XSP + 0
   \   00010C   85..83       MOV     DPH,?XSP + 1
   \   00010F   E0           MOVX    A,@DPTR
   \   000110   4404         ORL     A,#0x4
   \   000112   F0           MOVX    @DPTR,A
   \   000113   A3           INC     DPTR
   \   000114   E0           MOVX    A,@DPTR
   \   000115   4400         ORL     A,#0x0
   \   000117   F0           MOVX    @DPTR,A
    724              hdr.manuCode = manuCode;
   \   000118   7426         MOV     A,#0x26
   \   00011A   12....       LCALL   ?XSTACK_DISP0_8
   \   00011D   E0           MOVX    A,@DPTR
   \   00011E   F8           MOV     R0,A
   \   00011F   A3           INC     DPTR
   \   000120   E0           MOVX    A,@DPTR
   \   000121   F9           MOV     R1,A
   \   000122   7402         MOV     A,#0x2
   \   000124   12....       LCALL   ?XSTACK_DISP0_8
   \   000127   E8           MOV     A,R0
   \   000128   F0           MOVX    @DPTR,A
   \   000129   A3           INC     DPTR
   \   00012A   E9           MOV     A,R1
   \   00012B   F0           MOVX    @DPTR,A
    725            }
    726          
    727            // Set the Command Direction
    728            if ( direction )
   \                     ??zcl_SendCommand_6:
   \   00012C   E5..         MOV     A,?V0 + 15
   \   00012E   6011         JZ      ??zcl_SendCommand_7
    729            {
    730              hdr.fc.direction = ZCL_FRAME_SERVER_CLIENT_DIR;
   \   000130   85..82       MOV     DPL,?XSP + 0
   \   000133   85..83       MOV     DPH,?XSP + 1
   \   000136   E0           MOVX    A,@DPTR
   \   000137   4408         ORL     A,#0x8
   \   000139   F0           MOVX    @DPTR,A
   \   00013A   A3           INC     DPTR
   \   00013B   E0           MOVX    A,@DPTR
   \   00013C   4400         ORL     A,#0x0
   \   00013E   F0           MOVX    @DPTR,A
   \   00013F   800F         SJMP    ??zcl_SendCommand_8
    731            }
    732            else
    733            {
    734              hdr.fc.direction = ZCL_FRAME_CLIENT_SERVER_DIR;
   \                     ??zcl_SendCommand_7:
   \   000141   85..82       MOV     DPL,?XSP + 0
   \   000144   85..83       MOV     DPH,?XSP + 1
   \   000147   E0           MOVX    A,@DPTR
   \   000148   54F7         ANL     A,#0xf7
   \   00014A   F0           MOVX    @DPTR,A
   \   00014B   A3           INC     DPTR
   \   00014C   E0           MOVX    A,@DPTR
   \   00014D   54FF         ANL     A,#0xff
   \   00014F   F0           MOVX    @DPTR,A
    735            }
    736          
    737            // Set the Disable Default Response field
    738            if ( disableDefaultRsp )
   \                     ??zcl_SendCommand_8:
   \   000150   E5..         MOV     A,?V0 + 14
   \   000152   6011         JZ      ??zcl_SendCommand_9
    739            {
    740              hdr.fc.disableDefaultRsp = 1;
   \   000154   85..82       MOV     DPL,?XSP + 0
   \   000157   85..83       MOV     DPH,?XSP + 1
   \   00015A   E0           MOVX    A,@DPTR
   \   00015B   4410         ORL     A,#0x10
   \   00015D   F0           MOVX    @DPTR,A
   \   00015E   A3           INC     DPTR
   \   00015F   E0           MOVX    A,@DPTR
   \   000160   4400         ORL     A,#0x0
   \   000162   F0           MOVX    @DPTR,A
   \   000163   800F         SJMP    ??zcl_SendCommand_10
    741            }
    742            else
    743            {
    744              hdr.fc.disableDefaultRsp = 0;
   \                     ??zcl_SendCommand_9:
   \   000165   85..82       MOV     DPL,?XSP + 0
   \   000168   85..83       MOV     DPH,?XSP + 1
   \   00016B   E0           MOVX    A,@DPTR
   \   00016C   54EF         ANL     A,#0xef
   \   00016E   F0           MOVX    @DPTR,A
   \   00016F   A3           INC     DPTR
   \   000170   E0           MOVX    A,@DPTR
   \   000171   54FF         ANL     A,#0xff
   \   000173   F0           MOVX    @DPTR,A
    745            }
    746          
    747            // Fill in the Transaction Sequence Number
    748            hdr.transSeqNum = seqNum;
   \                     ??zcl_SendCommand_10:
   \   000174   E5..         MOV     A,?V0 + 13
   \   000176   7404         MOV     A,#0x4
   \   000178   12....       LCALL   ?XSTACK_DISP0_8
   \   00017B   E5..         MOV     A,?V0 + 13
   \   00017D   F0           MOVX    @DPTR,A
    749          
    750            // Fill in the command
    751            hdr.commandID = cmd;
   \   00017E   E5..         MOV     A,?V0 + 7
   \   000180   7405         MOV     A,#0x5
   \   000182   12....       LCALL   ?XSTACK_DISP0_8
   \   000185   E5..         MOV     A,?V0 + 7
   \   000187   F0           MOVX    @DPTR,A
    752          
    753            // calculate the needed buffer size
    754            msgLen = zclCalcHdrSize( &hdr );
   \   000188                ; Setup parameters for call to function zclCalcHdrSize
   \   000188   85..82       MOV     DPL,?XSP + 0
   \   00018B   85..83       MOV     DPH,?XSP + 1
   \   00018E   AA82         MOV     R2,DPL
   \   000190   AB83         MOV     R3,DPH
   \   000192   12....       LCALL   ??zclCalcHdrSize?relay
   \   000195   E9           MOV     A,R1
   \   000196   F8           MOV     R0,A
   \   000197   7900         MOV     R1,#0x0
   \   000199   88..         MOV     ?V0 + 0,R0
   \   00019B   89..         MOV     ?V0 + 1,R1
    755            msgLen += cmdFormatLen;
   \   00019D   7429         MOV     A,#0x29
   \   00019F   12....       LCALL   ?XSTACK_DISP0_8
   \   0001A2   E0           MOVX    A,@DPTR
   \   0001A3   25..         ADD     A,?V0 + 0
   \   0001A5   F5..         MOV     ?V0 + 0,A
   \   0001A7   A3           INC     DPTR
   \   0001A8   E0           MOVX    A,@DPTR
   \   0001A9   35..         ADDC    A,?V0 + 1
   \   0001AB   F5..         MOV     ?V0 + 1,A
    756          
    757            // Allocate the buffer needed
    758            msgBuf = osal_mem_alloc( msgLen );
   \   0001AD                ; Setup parameters for call to function osal_mem_alloc
   \   0001AD   AA..         MOV     R2,?V0 + 0
   \   0001AF   AB..         MOV     R3,?V0 + 1
   \   0001B1   12....       LCALL   ??osal_mem_alloc?relay
   \   0001B4   8A..         MOV     ?V0 + 4,R2
   \   0001B6   8B..         MOV     ?V0 + 5,R3
   \   0001B8   85....       MOV     ?V0 + 10,?V0 + 4
   \   0001BB   85....       MOV     ?V0 + 11,?V0 + 5
    759            if ( msgBuf != NULL )
   \   0001BE   E5..         MOV     A,?V0 + 10
   \   0001C0   45..         ORL     A,?V0 + 11
   \   0001C2   7003         JNZ     $+5
   \   0001C4   02....       LJMP    ??zcl_SendCommand_11 & 0xFFFF
    760            {
    761              // Fill in the ZCL Header
    762              pBuf = zclBuildHdr( &hdr, msgBuf );
   \   0001C7                ; Setup parameters for call to function zclBuildHdr
   \   0001C7   AC..         MOV     R4,?V0 + 10
   \   0001C9   AD..         MOV     R5,?V0 + 11
   \   0001CB   85..82       MOV     DPL,?XSP + 0
   \   0001CE   85..83       MOV     DPH,?XSP + 1
   \   0001D1   AA82         MOV     R2,DPL
   \   0001D3   AB83         MOV     R3,DPH
   \   0001D5   12....       LCALL   ??zclBuildHdr?relay
   \   0001D8   7406         MOV     A,#0x6
   \   0001DA   12....       LCALL   ?XSTACK_DISP0_8
   \   0001DD   EA           MOV     A,R2
   \   0001DE   F0           MOVX    @DPTR,A
   \   0001DF   A3           INC     DPTR
   \   0001E0   EB           MOV     A,R3
   \   0001E1   F0           MOVX    @DPTR,A
    763          
    764              // Fill in the command frame
    765              osal_memcpy( pBuf, cmdFormat, cmdFormatLen );
   \   0001E2                ; Setup parameters for call to function osal_memcpy
   \   0001E2   742B         MOV     A,#0x2b
   \   0001E4   12....       LCALL   ?XSTACK_DISP0_8
   \   0001E7   E0           MOVX    A,@DPTR
   \   0001E8   F5..         MOV     ?V0 + 4,A
   \   0001EA   A3           INC     DPTR
   \   0001EB   E0           MOVX    A,@DPTR
   \   0001EC   F5..         MOV     ?V0 + 5,A
   \   0001EE   75..00       MOV     ?V0 + 6,#0x0
   \   0001F1   78..         MOV     R0,#?V0 + 4
   \   0001F3   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   0001F6   742C         MOV     A,#0x2c
   \   0001F8   12....       LCALL   ?XSTACK_DISP0_8
   \   0001FB   E0           MOVX    A,@DPTR
   \   0001FC   FC           MOV     R4,A
   \   0001FD   A3           INC     DPTR
   \   0001FE   E0           MOVX    A,@DPTR
   \   0001FF   FD           MOV     R5,A
   \   000200   7409         MOV     A,#0x9
   \   000202   12....       LCALL   ?XSTACK_DISP0_8
   \   000205   E0           MOVX    A,@DPTR
   \   000206   FA           MOV     R2,A
   \   000207   A3           INC     DPTR
   \   000208   E0           MOVX    A,@DPTR
   \   000209   FB           MOV     R3,A
   \   00020A   12....       LCALL   ??osal_memcpy?relay
   \   00020D   7403         MOV     A,#0x3
   \   00020F   12....       LCALL   ?DEALLOC_XSTACK8
    766          
    767              status = AF_DataRequest( destAddr, epDesc, clusterID, msgLen, msgBuf,
    768                                       &zcl_TransID, options, AF_DEFAULT_RADIUS );
   \   000212                ; Setup parameters for call to function AF_DataRequest
   \   000212   75..1E       MOV     ?V0 + 4,#0x1e
   \   000215   78..         MOV     R0,#?V0 + 4
   \   000217   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00021A   75....       MOV     ?V0 + 4,#zcl_TransID & 0xff
   \   00021D   75....       MOV     ?V0 + 5,#(zcl_TransID >> 8) & 0xff
   \   000220   78..         MOV     R0,#?V0 + 4
   \   000222   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000225   78..         MOV     R0,#?V0 + 10
   \   000227   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00022A   78..         MOV     R0,#?V0 + 0
   \   00022C   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00022F   8E..         MOV     ?V0 + 4,R6
   \   000231   8F..         MOV     ?V0 + 5,R7
   \   000233   78..         MOV     R0,#?V0 + 4
   \   000235   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000238   A9..         MOV     R1,?V0 + 12
   \   00023A   AC..         MOV     R4,?V0 + 8
   \   00023C   AD..         MOV     R5,?V0 + 9
   \   00023E   7411         MOV     A,#0x11
   \   000240   12....       LCALL   ?XSTACK_DISP0_8
   \   000243   E0           MOVX    A,@DPTR
   \   000244   FA           MOV     R2,A
   \   000245   A3           INC     DPTR
   \   000246   E0           MOVX    A,@DPTR
   \   000247   FB           MOV     R3,A
   \   000248   12....       LCALL   ??AF_DataRequest?relay
   \   00024B   7409         MOV     A,#0x9
   \   00024D   12....       LCALL   ?DEALLOC_XSTACK8
   \   000250   E9           MOV     A,R1
   \   000251   F5..         MOV     ?V0 + 2,A
    769              osal_mem_free ( msgBuf );
   \   000253                ; Setup parameters for call to function osal_mem_free
   \   000253   AA..         MOV     R2,?V0 + 10
   \   000255   AB..         MOV     R3,?V0 + 11
   \   000257   12....       LCALL   ??osal_mem_free?relay
   \   00025A   8003         SJMP    ??zcl_SendCommand_12
    770            }
    771            else
    772            {
    773              status = ZMemError;
   \                     ??zcl_SendCommand_11:
   \   00025C   75..10       MOV     ?V0 + 2,#0x10
    774            }
    775          
    776            return ( status );
   \                     ??zcl_SendCommand_12:
   \   00025F   A9..         MOV     R1,?V0 + 2
   \                     ??zcl_SendCommand_1:
   \   000261   740A         MOV     A,#0xa
   \   000263   12....       LCALL   ?DEALLOC_XSTACK8
   \   000266   7F10         MOV     R7,#0x10
   \   000268   02....       LJMP    ?BANKED_LEAVE_XDATA
    777          }
    778          
    779          #ifdef ZCL_READ
    780          /*********************************************************************
    781           * @fn      zcl_SendRead
    782           *
    783           * @brief   Send a Read command
    784           *
    785           * @param   srcEP - Application's endpoint
    786           * @param   dstAddr - destination address
    787           * @param   clusterID - cluster ID
    788           * @param   readCmd - read command to be sent
    789           * @param   direction - direction of the command
    790           * @param   seqNum - transaction sequence number
    791           *
    792           * @return  ZSuccess if OK
    793           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    794          ZStatus_t zcl_SendRead( uint8 srcEP, afAddrType_t *dstAddr,
   \                     zcl_SendRead:
    795                                  uint16 clusterID, zclReadCmd_t *readCmd,
    796                                  uint8 direction, uint8 disableDefaultRsp, uint8 seqNum)
    797          {
   \   000000   74E8         MOV     A,#-0x18
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 24
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   85..82       MOV     DPL,?XSP + 0
   \   00000D   85..83       MOV     DPH,?XSP + 1
   \   000010   EA           MOV     A,R2
   \   000011   F0           MOVX    @DPTR,A
   \   000012   A3           INC     DPTR
   \   000013   EB           MOV     A,R3
   \   000014   F0           MOVX    @DPTR,A
   \   000015   89..         MOV     ?V0 + 8,R1
   \   000017   8C..         MOV     ?V0 + 14,R4
   \   000019   8D..         MOV     ?V0 + 15,R5
   \   00001B   741A         MOV     A,#0x1a
   \   00001D   12....       LCALL   ?XSTACK_DISP0_8
   \   000020   E0           MOVX    A,@DPTR
   \   000021   F5..         MOV     ?V0 + 6,A
   \   000023   A3           INC     DPTR
   \   000024   E0           MOVX    A,@DPTR
   \   000025   F5..         MOV     ?V0 + 7,A
   \   000027   741C         MOV     A,#0x1c
   \   000029   12....       LCALL   ?XSTACK_DISP0_8
   \   00002C   E0           MOVX    A,@DPTR
   \   00002D   F5..         MOV     ?V0 + 13,A
   \   00002F   741D         MOV     A,#0x1d
   \   000031   12....       LCALL   ?XSTACK_DISP0_8
   \   000034   E0           MOVX    A,@DPTR
   \   000035   F5..         MOV     ?V0 + 12,A
   \   000037   741E         MOV     A,#0x1e
   \   000039   12....       LCALL   ?XSTACK_DISP0_8
   \   00003C   E0           MOVX    A,@DPTR
   \   00003D   F5..         MOV     ?V0 + 9,A
    798            uint16 dataLen;
    799            uint8 *buf;
    800            uint8 *pBuf;
    801            ZStatus_t status;
    802          
    803            dataLen = readCmd->numAttr * 2; // Attribute ID
   \   00003F   85..82       MOV     DPL,?V0 + 6
   \   000042   85..83       MOV     DPH,?V0 + 7
   \   000045   E0           MOVX    A,@DPTR
   \   000046   F8           MOV     R0,A
   \   000047   7900         MOV     R1,#0x0
   \   000049   E8           MOV     A,R0
   \   00004A   75F002       MOV     B,#0x2
   \   00004D   A4           MUL     AB
   \   00004E   C8           XCH     A,R0
   \   00004F   AAF0         MOV     R2,B
   \   000051   75F000       MOV     B,#0x0
   \   000054   A4           MUL     AB
   \   000055   2A           ADD     A,R2
   \   000056   FA           MOV     R2,A
   \   000057   75F002       MOV     B,#0x2
   \   00005A   E9           MOV     A,R1
   \   00005B   A4           MUL     AB
   \   00005C   2A           ADD     A,R2
   \   00005D   F9           MOV     R1,A
   \   00005E   E8           MOV     A,R0
   \   00005F   FE           MOV     R6,A
   \   000060   E9           MOV     A,R1
   \   000061   FF           MOV     R7,A
    804          
    805            buf = osal_mem_alloc( dataLen );
   \   000062                ; Setup parameters for call to function osal_mem_alloc
   \   000062   EE           MOV     A,R6
   \   000063   FA           MOV     R2,A
   \   000064   EF           MOV     A,R7
   \   000065   FB           MOV     R3,A
   \   000066   12....       LCALL   ??osal_mem_alloc?relay
   \   000069   8A..         MOV     ?V0 + 10,R2
   \   00006B   8B..         MOV     ?V0 + 11,R3
   \   00006D   85....       MOV     ?V0 + 4,?V0 + 10
   \   000070   85....       MOV     ?V0 + 5,?V0 + 11
    806            if ( buf != NULL )
   \   000073   E5..         MOV     A,?V0 + 4
   \   000075   45..         ORL     A,?V0 + 5
   \   000077   7003         JNZ     $+5
   \   000079   02....       LJMP    ??zcl_SendRead_0 & 0xFFFF
    807            {
    808              uint8 i;
    809          
    810              // Load the buffer - serially
    811              pBuf = buf;
   \   00007C   85....       MOV     ?V0 + 0,?V0 + 4
   \   00007F   85....       MOV     ?V0 + 1,?V0 + 5
    812              for (i = 0; i < readCmd->numAttr; i++)
   \   000082   75..00       MOV     ?V0 + 3,#0x0
   \                     ??zcl_SendRead_1:
   \   000085   85..82       MOV     DPL,?V0 + 6
   \   000088   85..83       MOV     DPH,?V0 + 7
   \   00008B   E0           MOVX    A,@DPTR
   \   00008C   F8           MOV     R0,A
   \   00008D   E5..         MOV     A,?V0 + 3
   \   00008F   C3           CLR     C
   \   000090   98           SUBB    A,R0
   \   000091   4003         JC      $+5
   \   000093   02....       LJMP    ??zcl_SendRead_2 & 0xFFFF
    813              {
    814                *pBuf++ = LO_UINT16( readCmd->attrID[i] );
   \   000096   E5..         MOV     A,?V0 + 3
   \   000098   A8..         MOV     R0,?V0 + 3
   \   00009A   7900         MOV     R1,#0x0
   \   00009C   E8           MOV     A,R0
   \   00009D   75F002       MOV     B,#0x2
   \   0000A0   A4           MUL     AB
   \   0000A1   C8           XCH     A,R0
   \   0000A2   AAF0         MOV     R2,B
   \   0000A4   75F000       MOV     B,#0x0
   \   0000A7   A4           MUL     AB
   \   0000A8   2A           ADD     A,R2
   \   0000A9   FA           MOV     R2,A
   \   0000AA   75F002       MOV     B,#0x2
   \   0000AD   E9           MOV     A,R1
   \   0000AE   A4           MUL     AB
   \   0000AF   2A           ADD     A,R2
   \   0000B0   F9           MOV     R1,A
   \   0000B1   E5..         MOV     A,?V0 + 6
   \   0000B3   28           ADD     A,R0
   \   0000B4   F582         MOV     DPL,A
   \   0000B6   E5..         MOV     A,?V0 + 7
   \   0000B8   39           ADDC    A,R1
   \   0000B9   F583         MOV     DPH,A
   \   0000BB   A3           INC     DPTR
   \   0000BC   E0           MOVX    A,@DPTR
   \   0000BD   F8           MOV     R0,A
   \   0000BE   A3           INC     DPTR
   \   0000BF   E0           MOVX    A,@DPTR
   \   0000C0   F9           MOV     R1,A
   \   0000C1   E8           MOV     A,R0
   \   0000C2   85..82       MOV     DPL,?V0 + 0
   \   0000C5   85..83       MOV     DPH,?V0 + 1
   \   0000C8   F0           MOVX    @DPTR,A
   \   0000C9   85..82       MOV     DPL,?V0 + 0
   \   0000CC   85..83       MOV     DPH,?V0 + 1
   \   0000CF   A3           INC     DPTR
   \   0000D0   8582..       MOV     ?V0 + 0,DPL
   \   0000D3   8583..       MOV     ?V0 + 1,DPH
    815                *pBuf++ = HI_UINT16( readCmd->attrID[i] );
   \   0000D6   E5..         MOV     A,?V0 + 3
   \   0000D8   A8..         MOV     R0,?V0 + 3
   \   0000DA   7900         MOV     R1,#0x0
   \   0000DC   E8           MOV     A,R0
   \   0000DD   75F002       MOV     B,#0x2
   \   0000E0   A4           MUL     AB
   \   0000E1   C8           XCH     A,R0
   \   0000E2   AAF0         MOV     R2,B
   \   0000E4   75F000       MOV     B,#0x0
   \   0000E7   A4           MUL     AB
   \   0000E8   2A           ADD     A,R2
   \   0000E9   FA           MOV     R2,A
   \   0000EA   75F002       MOV     B,#0x2
   \   0000ED   E9           MOV     A,R1
   \   0000EE   A4           MUL     AB
   \   0000EF   2A           ADD     A,R2
   \   0000F0   F9           MOV     R1,A
   \   0000F1   E5..         MOV     A,?V0 + 6
   \   0000F3   28           ADD     A,R0
   \   0000F4   F582         MOV     DPL,A
   \   0000F6   E5..         MOV     A,?V0 + 7
   \   0000F8   39           ADDC    A,R1
   \   0000F9   F583         MOV     DPH,A
   \   0000FB   A3           INC     DPTR
   \   0000FC   E0           MOVX    A,@DPTR
   \   0000FD   F8           MOV     R0,A
   \   0000FE   A3           INC     DPTR
   \   0000FF   E0           MOVX    A,@DPTR
   \   000100   F9           MOV     R1,A
   \   000101   E4           CLR     A
   \   000102   E9           MOV     A,R1
   \   000103   F8           MOV     R0,A
   \   000104   85..82       MOV     DPL,?V0 + 0
   \   000107   85..83       MOV     DPH,?V0 + 1
   \   00010A   F0           MOVX    @DPTR,A
   \   00010B   85..82       MOV     DPL,?V0 + 0
   \   00010E   85..83       MOV     DPH,?V0 + 1
   \   000111   A3           INC     DPTR
   \   000112   8582..       MOV     ?V0 + 0,DPL
   \   000115   8583..       MOV     ?V0 + 1,DPH
    816              }
   \   000118   05..         INC     ?V0 + 3
   \   00011A   02....       LJMP    ??zcl_SendRead_1 & 0xFFFF
    817          
    818              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_READ, FALSE,
    819                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   \                     ??zcl_SendRead_2:
   \   00011D                ; Setup parameters for call to function zcl_SendCommand
   \   00011D   78..         MOV     R0,#?V0 + 4
   \   00011F   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000122   8E..         MOV     ?V0 + 10,R6
   \   000124   8F..         MOV     ?V0 + 11,R7
   \   000126   78..         MOV     R0,#?V0 + 10
   \   000128   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00012B   E5..         MOV     A,?V0 + 9
   \   00012D   F5..         MOV     ?V0 + 10,A
   \   00012F   78..         MOV     R0,#?V0 + 10
   \   000131   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000134   E4           CLR     A
   \   000135   F5..         MOV     ?V0 + 10,A
   \   000137   F5..         MOV     ?V0 + 11,A
   \   000139   78..         MOV     R0,#?V0 + 10
   \   00013B   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00013E   E5..         MOV     A,?V0 + 12
   \   000140   F5..         MOV     ?V0 + 10,A
   \   000142   78..         MOV     R0,#?V0 + 10
   \   000144   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000147   E5..         MOV     A,?V0 + 13
   \   000149   F5..         MOV     ?V0 + 10,A
   \   00014B   78..         MOV     R0,#?V0 + 10
   \   00014D   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000150   75..00       MOV     ?V0 + 10,#0x0
   \   000153   78..         MOV     R0,#?V0 + 10
   \   000155   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000158   75..00       MOV     ?V0 + 10,#0x0
   \   00015B   78..         MOV     R0,#?V0 + 10
   \   00015D   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000160   AC..         MOV     R4,?V0 + 14
   \   000162   AD..         MOV     R5,?V0 + 15
   \   000164   740B         MOV     A,#0xb
   \   000166   12....       LCALL   ?XSTACK_DISP0_8
   \   000169   E0           MOVX    A,@DPTR
   \   00016A   FA           MOV     R2,A
   \   00016B   A3           INC     DPTR
   \   00016C   E0           MOVX    A,@DPTR
   \   00016D   FB           MOV     R3,A
   \   00016E   A9..         MOV     R1,?V0 + 8
   \   000170   12....       LCALL   ??zcl_SendCommand?relay
   \   000173   740B         MOV     A,#0xb
   \   000175   12....       LCALL   ?DEALLOC_XSTACK8
   \   000178   E9           MOV     A,R1
   \   000179   F5..         MOV     ?V0 + 2,A
    820              osal_mem_free( buf );
   \   00017B                ; Setup parameters for call to function osal_mem_free
   \   00017B   AA..         MOV     R2,?V0 + 4
   \   00017D   AB..         MOV     R3,?V0 + 5
   \   00017F   12....       LCALL   ??osal_mem_free?relay
   \   000182   8003         SJMP    ??zcl_SendRead_3
    821            }
    822            else
    823            {
    824              status = ZMemError;
   \                     ??zcl_SendRead_0:
   \   000184   75..10       MOV     ?V0 + 2,#0x10
    825            }
    826          
    827            return ( status );
   \                     ??zcl_SendRead_3:
   \   000187   A9..         MOV     R1,?V0 + 2
   \   000189   7402         MOV     A,#0x2
   \   00018B   12....       LCALL   ?DEALLOC_XSTACK8
   \   00018E   7F10         MOV     R7,#0x10
   \   000190   02....       LJMP    ?BANKED_LEAVE_XDATA
    828          }
    829          
    830          /*********************************************************************
    831           * @fn      zcl_SendReadRsp
    832           *
    833           * @brief   Send a Read Response command.
    834           *
    835           * @param   srcEP - Application's endpoint
    836           * @param   dstAddr - destination address
    837           * @param   clusterID - cluster ID
    838           * @param   readRspCmd - read response command to be sent
    839           * @param   direction - direction of the command
    840           * @param   seqNum - transaction sequence number
    841           *
    842           * @return  ZSuccess if OK
    843           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    844          ZStatus_t zcl_SendReadRsp( uint8 srcEP, afAddrType_t *dstAddr,
   \                     zcl_SendReadRsp:
    845                                     uint16 clusterID, zclReadRspCmd_t *readRspCmd,
    846                                     uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
    847          {
   \   000000   74E8         MOV     A,#-0x18
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 24
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV     A,#-0x4
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   7402         MOV     A,#0x2
   \   00000C   12....       LCALL   ?XSTACK_DISP0_8
   \   00000F   EA           MOV     A,R2
   \   000010   F0           MOVX    @DPTR,A
   \   000011   A3           INC     DPTR
   \   000012   EB           MOV     A,R3
   \   000013   F0           MOVX    @DPTR,A
   \   000014   89..         MOV     ?V0 + 6,R1
   \   000016   8C..         MOV     ?V0 + 14,R4
   \   000018   8D..         MOV     ?V0 + 15,R5
   \   00001A   741C         MOV     A,#0x1c
   \   00001C   12....       LCALL   ?XSTACK_DISP0_8
   \   00001F   E0           MOVX    A,@DPTR
   \   000020   F5..         MOV     ?V0 + 12,A
   \   000022   A3           INC     DPTR
   \   000023   E0           MOVX    A,@DPTR
   \   000024   F5..         MOV     ?V0 + 13,A
   \   000026   7420         MOV     A,#0x20
   \   000028   12....       LCALL   ?XSTACK_DISP0_8
   \   00002B   E0           MOVX    A,@DPTR
   \   00002C   F5..         MOV     ?V0 + 7,A
    848            uint8 *buf;
    849            uint16 len = 0;
   \   00002E   7E00         MOV     R6,#0x0
   \   000030   7F00         MOV     R7,#0x0
    850            ZStatus_t status;
    851          
    852            // calculate the size of the command
    853            for ( uint8 i = 0; i < readRspCmd->numAttr; i++ )
   \   000032   75..00       MOV     ?V0 + 2,#0x0
   \                     ??zcl_SendReadRsp_0:
   \   000035   85..82       MOV     DPL,?V0 + 12
   \   000038   85..83       MOV     DPH,?V0 + 13
   \   00003B   E0           MOVX    A,@DPTR
   \   00003C   F8           MOV     R0,A
   \   00003D   E5..         MOV     A,?V0 + 2
   \   00003F   C3           CLR     C
   \   000040   98           SUBB    A,R0
   \   000041   4003         JC      $+5
   \   000043   02....       LJMP    ??zcl_SendReadRsp_1 & 0xFFFF
    854            {
    855              zclReadRspStatus_t *statusRec = &(readRspCmd->attrList[i]);
   \   000046   E5..         MOV     A,?V0 + 2
   \   000048   A8..         MOV     R0,?V0 + 2
   \   00004A   7900         MOV     R1,#0x0
   \   00004C   E8           MOV     A,R0
   \   00004D   75F006       MOV     B,#0x6
   \   000050   A4           MUL     AB
   \   000051   C8           XCH     A,R0
   \   000052   AAF0         MOV     R2,B
   \   000054   75F000       MOV     B,#0x0
   \   000057   A4           MUL     AB
   \   000058   2A           ADD     A,R2
   \   000059   FA           MOV     R2,A
   \   00005A   75F006       MOV     B,#0x6
   \   00005D   E9           MOV     A,R1
   \   00005E   A4           MUL     AB
   \   00005F   2A           ADD     A,R2
   \   000060   F9           MOV     R1,A
   \   000061   E5..         MOV     A,?V0 + 12
   \   000063   28           ADD     A,R0
   \   000064   F582         MOV     DPL,A
   \   000066   E5..         MOV     A,?V0 + 13
   \   000068   39           ADDC    A,R1
   \   000069   F583         MOV     DPH,A
   \   00006B   A3           INC     DPTR
   \   00006C   8582..       MOV     ?V0 + 0,DPL
   \   00006F   8583..       MOV     ?V0 + 1,DPH
    856          
    857              len += 2 + 1; // Attribute ID + Status
   \   000072   EE           MOV     A,R6
   \   000073   2403         ADD     A,#0x3
   \   000075   FE           MOV     R6,A
   \   000076   EF           MOV     A,R7
   \   000077   3400         ADDC    A,#0x0
   \   000079   FF           MOV     R7,A
    858          
    859              if ( statusRec->status == ZCL_STATUS_SUCCESS )
   \   00007A   85..82       MOV     DPL,?V0 + 0
   \   00007D   85..83       MOV     DPH,?V0 + 1
   \   000080   A3           INC     DPTR
   \   000081   A3           INC     DPTR
   \   000082   E0           MOVX    A,@DPTR
   \   000083   7066         JNZ     ??zcl_SendReadRsp_2
    860              {
    861                len++; // Attribute Data Type length
   \   000085   EE           MOV     A,R6
   \   000086   2401         ADD     A,#0x1
   \   000088   FE           MOV     R6,A
   \   000089   EF           MOV     A,R7
   \   00008A   3400         ADDC    A,#0x0
   \   00008C   FF           MOV     R7,A
    862          
    863                // Attribute Data length
    864                if ( statusRec->data != NULL )
   \   00008D   85..82       MOV     DPL,?V0 + 0
   \   000090   85..83       MOV     DPH,?V0 + 1
   \   000093   A3           INC     DPTR
   \   000094   A3           INC     DPTR
   \   000095   A3           INC     DPTR
   \   000096   A3           INC     DPTR
   \   000097   E0           MOVX    A,@DPTR
   \   000098   F8           MOV     R0,A
   \   000099   A3           INC     DPTR
   \   00009A   E0           MOVX    A,@DPTR
   \   00009B   F9           MOV     R1,A
   \   00009C   E8           MOV     A,R0
   \   00009D   49           ORL     A,R1
   \   00009E   602B         JZ      ??zcl_SendReadRsp_3
    865                {
    866                  len += zclGetAttrDataLength( statusRec->dataType, statusRec->data );
   \   0000A0                ; Setup parameters for call to function zclGetAttrDataLength
   \   0000A0   85..82       MOV     DPL,?V0 + 0
   \   0000A3   85..83       MOV     DPH,?V0 + 1
   \   0000A6   A3           INC     DPTR
   \   0000A7   A3           INC     DPTR
   \   0000A8   A3           INC     DPTR
   \   0000A9   A3           INC     DPTR
   \   0000AA   E0           MOVX    A,@DPTR
   \   0000AB   FA           MOV     R2,A
   \   0000AC   A3           INC     DPTR
   \   0000AD   E0           MOVX    A,@DPTR
   \   0000AE   FB           MOV     R3,A
   \   0000AF   85..82       MOV     DPL,?V0 + 0
   \   0000B2   85..83       MOV     DPH,?V0 + 1
   \   0000B5   A3           INC     DPTR
   \   0000B6   A3           INC     DPTR
   \   0000B7   A3           INC     DPTR
   \   0000B8   E0           MOVX    A,@DPTR
   \   0000B9   F9           MOV     R1,A
   \   0000BA   12....       LCALL   ??zclGetAttrDataLength?relay
   \   0000BD   8A..         MOV     ?V0 + 10,R2
   \   0000BF   8B..         MOV     ?V0 + 11,R3
   \   0000C1   EE           MOV     A,R6
   \   0000C2   25..         ADD     A,?V0 + 10
   \   0000C4   FE           MOV     R6,A
   \   0000C5   EF           MOV     A,R7
   \   0000C6   35..         ADDC    A,?V0 + 11
   \   0000C8   FF           MOV     R7,A
   \   0000C9   8020         SJMP    ??zcl_SendReadRsp_2
    867                }
    868                else
    869                {
    870                  len += zclGetAttrDataLengthUsingCB( srcEP, clusterID, statusRec->attrID );
   \                     ??zcl_SendReadRsp_3:
   \   0000CB                ; Setup parameters for call to function zclGetAttrDataLengthUsingCB
   \   0000CB   85..82       MOV     DPL,?V0 + 0
   \   0000CE   85..83       MOV     DPH,?V0 + 1
   \   0000D1   E0           MOVX    A,@DPTR
   \   0000D2   FC           MOV     R4,A
   \   0000D3   A3           INC     DPTR
   \   0000D4   E0           MOVX    A,@DPTR
   \   0000D5   FD           MOV     R5,A
   \   0000D6   AA..         MOV     R2,?V0 + 14
   \   0000D8   AB..         MOV     R3,?V0 + 15
   \   0000DA   A9..         MOV     R1,?V0 + 6
   \   0000DC   12....       LCALL   ??zclGetAttrDataLengthUsingCB?relay
   \   0000DF   8A..         MOV     ?V0 + 10,R2
   \   0000E1   8B..         MOV     ?V0 + 11,R3
   \   0000E3   EE           MOV     A,R6
   \   0000E4   25..         ADD     A,?V0 + 10
   \   0000E6   FE           MOV     R6,A
   \   0000E7   EF           MOV     A,R7
   \   0000E8   35..         ADDC    A,?V0 + 11
   \   0000EA   FF           MOV     R7,A
    871                }
    872              }
    873            }
   \                     ??zcl_SendReadRsp_2:
   \   0000EB   05..         INC     ?V0 + 2
   \   0000ED   02....       LJMP    ??zcl_SendReadRsp_0 & 0xFFFF
    874          
    875            buf = osal_mem_alloc( len );
   \                     ??zcl_SendReadRsp_1:
   \   0000F0                ; Setup parameters for call to function osal_mem_alloc
   \   0000F0   EE           MOV     A,R6
   \   0000F1   FA           MOV     R2,A
   \   0000F2   EF           MOV     A,R7
   \   0000F3   FB           MOV     R3,A
   \   0000F4   12....       LCALL   ??osal_mem_alloc?relay
   \   0000F7   8A..         MOV     ?V0 + 0,R2
   \   0000F9   8B..         MOV     ?V0 + 1,R3
   \   0000FB   85....       MOV     ?V0 + 8,?V0 + 0
   \   0000FE   85....       MOV     ?V0 + 9,?V0 + 1
    876            if ( buf != NULL )
   \   000101   E5..         MOV     A,?V0 + 8
   \   000103   45..         ORL     A,?V0 + 9
   \   000105   7003         JNZ     $+5
   \   000107   02....       LJMP    ??zcl_SendReadRsp_4 & 0xFFFF
    877            {
    878              // Load the buffer - serially
    879              uint8 *pBuf = buf;
   \   00010A   85....       MOV     ?V0 + 0,?V0 + 8
   \   00010D   85....       MOV     ?V0 + 1,?V0 + 9
    880              for ( uint8 i = 0; i < readRspCmd->numAttr; i++ )
   \   000110   75..00       MOV     ?V0 + 4,#0x0
   \                     ??zcl_SendReadRsp_5:
   \   000113   85..82       MOV     DPL,?V0 + 12
   \   000116   85..83       MOV     DPH,?V0 + 13
   \   000119   E0           MOVX    A,@DPTR
   \   00011A   F8           MOV     R0,A
   \   00011B   E5..         MOV     A,?V0 + 4
   \   00011D   C3           CLR     C
   \   00011E   98           SUBB    A,R0
   \   00011F   4003         JC      $+5
   \   000121   02....       LJMP    ??zcl_SendReadRsp_6 & 0xFFFF
    881              {
    882                zclReadRspStatus_t *statusRec = &(readRspCmd->attrList[i]);
   \   000124   E5..         MOV     A,?V0 + 4
   \   000126   A8..         MOV     R0,?V0 + 4
   \   000128   7900         MOV     R1,#0x0
   \   00012A   E8           MOV     A,R0
   \   00012B   75F006       MOV     B,#0x6
   \   00012E   A4           MUL     AB
   \   00012F   C8           XCH     A,R0
   \   000130   AAF0         MOV     R2,B
   \   000132   75F000       MOV     B,#0x0
   \   000135   A4           MUL     AB
   \   000136   2A           ADD     A,R2
   \   000137   FA           MOV     R2,A
   \   000138   75F006       MOV     B,#0x6
   \   00013B   E9           MOV     A,R1
   \   00013C   A4           MUL     AB
   \   00013D   2A           ADD     A,R2
   \   00013E   F9           MOV     R1,A
   \   00013F   E5..         MOV     A,?V0 + 12
   \   000141   28           ADD     A,R0
   \   000142   F582         MOV     DPL,A
   \   000144   E5..         MOV     A,?V0 + 13
   \   000146   39           ADDC    A,R1
   \   000147   F583         MOV     DPH,A
   \   000149   A3           INC     DPTR
   \   00014A   8582..       MOV     ?V0 + 2,DPL
   \   00014D   8583..       MOV     ?V0 + 3,DPH
    883          
    884                *pBuf++ = LO_UINT16( statusRec->attrID );
   \   000150   85..82       MOV     DPL,?V0 + 2
   \   000153   85..83       MOV     DPH,?V0 + 3
   \   000156   E0           MOVX    A,@DPTR
   \   000157   F8           MOV     R0,A
   \   000158   A3           INC     DPTR
   \   000159   E0           MOVX    A,@DPTR
   \   00015A   F9           MOV     R1,A
   \   00015B   E8           MOV     A,R0
   \   00015C   85..82       MOV     DPL,?V0 + 0
   \   00015F   85..83       MOV     DPH,?V0 + 1
   \   000162   F0           MOVX    @DPTR,A
   \   000163   85..82       MOV     DPL,?V0 + 0
   \   000166   85..83       MOV     DPH,?V0 + 1
   \   000169   A3           INC     DPTR
   \   00016A   8582..       MOV     ?V0 + 0,DPL
   \   00016D   8583..       MOV     ?V0 + 1,DPH
    885                *pBuf++ = HI_UINT16( statusRec->attrID );
   \   000170   85..82       MOV     DPL,?V0 + 2
   \   000173   85..83       MOV     DPH,?V0 + 3
   \   000176   E0           MOVX    A,@DPTR
   \   000177   F8           MOV     R0,A
   \   000178   A3           INC     DPTR
   \   000179   E0           MOVX    A,@DPTR
   \   00017A   F9           MOV     R1,A
   \   00017B   E4           CLR     A
   \   00017C   E9           MOV     A,R1
   \   00017D   F8           MOV     R0,A
   \   00017E   85..82       MOV     DPL,?V0 + 0
   \   000181   85..83       MOV     DPH,?V0 + 1
   \   000184   F0           MOVX    @DPTR,A
   \   000185   85..82       MOV     DPL,?V0 + 0
   \   000188   85..83       MOV     DPH,?V0 + 1
   \   00018B   A3           INC     DPTR
   \   00018C   8582..       MOV     ?V0 + 0,DPL
   \   00018F   8583..       MOV     ?V0 + 1,DPH
    886                *pBuf++ = statusRec->status;
   \   000192   85..82       MOV     DPL,?V0 + 2
   \   000195   85..83       MOV     DPH,?V0 + 3
   \   000198   A3           INC     DPTR
   \   000199   A3           INC     DPTR
   \   00019A   E0           MOVX    A,@DPTR
   \   00019B   85..82       MOV     DPL,?V0 + 0
   \   00019E   85..83       MOV     DPH,?V0 + 1
   \   0001A1   F0           MOVX    @DPTR,A
   \   0001A2   85..82       MOV     DPL,?V0 + 0
   \   0001A5   85..83       MOV     DPH,?V0 + 1
   \   0001A8   A3           INC     DPTR
   \   0001A9   8582..       MOV     ?V0 + 0,DPL
   \   0001AC   8583..       MOV     ?V0 + 1,DPH
    887          
    888                if ( statusRec->status == ZCL_STATUS_SUCCESS )
   \   0001AF   85..82       MOV     DPL,?V0 + 2
   \   0001B2   85..83       MOV     DPH,?V0 + 3
   \   0001B5   A3           INC     DPTR
   \   0001B6   A3           INC     DPTR
   \   0001B7   E0           MOVX    A,@DPTR
   \   0001B8   6003         JZ      $+5
   \   0001BA   02....       LJMP    ??zcl_SendReadRsp_7 & 0xFFFF
    889                {
    890                  *pBuf++ = statusRec->dataType;
   \   0001BD   85..82       MOV     DPL,?V0 + 2
   \   0001C0   85..83       MOV     DPH,?V0 + 3
   \   0001C3   A3           INC     DPTR
   \   0001C4   A3           INC     DPTR
   \   0001C5   A3           INC     DPTR
   \   0001C6   E0           MOVX    A,@DPTR
   \   0001C7   85..82       MOV     DPL,?V0 + 0
   \   0001CA   85..83       MOV     DPH,?V0 + 1
   \   0001CD   F0           MOVX    @DPTR,A
   \   0001CE   85..82       MOV     DPL,?V0 + 0
   \   0001D1   85..83       MOV     DPH,?V0 + 1
   \   0001D4   A3           INC     DPTR
   \   0001D5   8582..       MOV     ?V0 + 0,DPL
   \   0001D8   8583..       MOV     ?V0 + 1,DPH
    891          
    892                  if ( statusRec->data != NULL )
   \   0001DB   85..82       MOV     DPL,?V0 + 2
   \   0001DE   85..83       MOV     DPH,?V0 + 3
   \   0001E1   A3           INC     DPTR
   \   0001E2   A3           INC     DPTR
   \   0001E3   A3           INC     DPTR
   \   0001E4   A3           INC     DPTR
   \   0001E5   E0           MOVX    A,@DPTR
   \   0001E6   F8           MOV     R0,A
   \   0001E7   A3           INC     DPTR
   \   0001E8   E0           MOVX    A,@DPTR
   \   0001E9   F9           MOV     R1,A
   \   0001EA   E8           MOV     A,R0
   \   0001EB   49           ORL     A,R1
   \   0001EC   602D         JZ      ??zcl_SendReadRsp_8
    893                  {
    894                    // Copy attribute data to the buffer to be sent out
    895                    pBuf = zclSerializeData( statusRec->dataType, statusRec->data, pBuf );
   \   0001EE                ; Setup parameters for call to function zclSerializeData
   \   0001EE   AC..         MOV     R4,?V0 + 0
   \   0001F0   AD..         MOV     R5,?V0 + 1
   \   0001F2   85..82       MOV     DPL,?V0 + 2
   \   0001F5   85..83       MOV     DPH,?V0 + 3
   \   0001F8   A3           INC     DPTR
   \   0001F9   A3           INC     DPTR
   \   0001FA   A3           INC     DPTR
   \   0001FB   A3           INC     DPTR
   \   0001FC   E0           MOVX    A,@DPTR
   \   0001FD   FA           MOV     R2,A
   \   0001FE   A3           INC     DPTR
   \   0001FF   E0           MOVX    A,@DPTR
   \   000200   FB           MOV     R3,A
   \   000201   85..82       MOV     DPL,?V0 + 2
   \   000204   85..83       MOV     DPH,?V0 + 3
   \   000207   A3           INC     DPTR
   \   000208   A3           INC     DPTR
   \   000209   A3           INC     DPTR
   \   00020A   E0           MOVX    A,@DPTR
   \   00020B   F9           MOV     R1,A
   \   00020C   12....       LCALL   ??zclSerializeData?relay
   \   00020F   8A..         MOV     ?V0 + 10,R2
   \   000211   8B..         MOV     ?V0 + 11,R3
   \   000213   85....       MOV     ?V0 + 0,?V0 + 10
   \   000216   85....       MOV     ?V0 + 1,?V0 + 11
   \   000219   8045         SJMP    ??zcl_SendReadRsp_7
    896                  }
    897                  else
    898                  {
    899                    uint16 dataLen;
    900          
    901                    // Read attribute data directly into the buffer to be sent out
    902                    zclReadAttrDataUsingCB( srcEP, clusterID, statusRec->attrID, pBuf, &dataLen );
   \                     ??zcl_SendReadRsp_8:
   \   00021B                ; Setup parameters for call to function zclReadAttrDataUsingCB
   \   00021B   85..82       MOV     DPL,?XSP + 0
   \   00021E   85..83       MOV     DPH,?XSP + 1
   \   000221   8582..       MOV     ?V0 + 10,DPL
   \   000224   8583..       MOV     ?V0 + 11,DPH
   \   000227   78..         MOV     R0,#?V0 + 10
   \   000229   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00022C   78..         MOV     R0,#?V0 + 0
   \   00022E   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000231   85..82       MOV     DPL,?V0 + 2
   \   000234   85..83       MOV     DPH,?V0 + 3
   \   000237   E0           MOVX    A,@DPTR
   \   000238   FC           MOV     R4,A
   \   000239   A3           INC     DPTR
   \   00023A   E0           MOVX    A,@DPTR
   \   00023B   FD           MOV     R5,A
   \   00023C   AA..         MOV     R2,?V0 + 14
   \   00023E   AB..         MOV     R3,?V0 + 15
   \   000240   A9..         MOV     R1,?V0 + 6
   \   000242   12....       LCALL   ??zclReadAttrDataUsingCB?relay
   \   000245   7404         MOV     A,#0x4
   \   000247   12....       LCALL   ?DEALLOC_XSTACK8
   \   00024A   E9           MOV     A,R1
    903                    pBuf += dataLen;
   \   00024B   85..82       MOV     DPL,?XSP + 0
   \   00024E   85..83       MOV     DPH,?XSP + 1
   \   000251   E0           MOVX    A,@DPTR
   \   000252   F8           MOV     R0,A
   \   000253   A3           INC     DPTR
   \   000254   E0           MOVX    A,@DPTR
   \   000255   F9           MOV     R1,A
   \   000256   E5..         MOV     A,?V0 + 0
   \   000258   28           ADD     A,R0
   \   000259   F5..         MOV     ?V0 + 0,A
   \   00025B   E5..         MOV     A,?V0 + 1
   \   00025D   39           ADDC    A,R1
   \   00025E   F5..         MOV     ?V0 + 1,A
    904                  }
    905                }
    906              } // for loop
   \                     ??zcl_SendReadRsp_7:
   \   000260   05..         INC     ?V0 + 4
   \   000262   02....       LJMP    ??zcl_SendReadRsp_5 & 0xFFFF
    907          
    908              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_READ_RSP, FALSE,
    909                                        direction, disableDefaultRsp, 0, seqNum, len, buf );
   \                     ??zcl_SendReadRsp_6:
   \   000265                ; Setup parameters for call to function zcl_SendCommand
   \   000265   78..         MOV     R0,#?V0 + 8
   \   000267   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00026A   8E..         MOV     ?V0 + 2,R6
   \   00026C   8F..         MOV     ?V0 + 3,R7
   \   00026E   78..         MOV     R0,#?V0 + 2
   \   000270   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000273   E5..         MOV     A,?V0 + 7
   \   000275   F5..         MOV     ?V0 + 2,A
   \   000277   78..         MOV     R0,#?V0 + 2
   \   000279   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00027C   E4           CLR     A
   \   00027D   F5..         MOV     ?V0 + 2,A
   \   00027F   F5..         MOV     ?V0 + 3,A
   \   000281   78..         MOV     R0,#?V0 + 2
   \   000283   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000286   7426         MOV     A,#0x26
   \   000288   12....       LCALL   ?XSTACK_DISP0_8
   \   00028B   E0           MOVX    A,@DPTR
   \   00028C   F5..         MOV     ?V0 + 2,A
   \   00028E   78..         MOV     R0,#?V0 + 2
   \   000290   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000293   7426         MOV     A,#0x26
   \   000295   12....       LCALL   ?XSTACK_DISP0_8
   \   000298   E0           MOVX    A,@DPTR
   \   000299   F5..         MOV     ?V0 + 2,A
   \   00029B   78..         MOV     R0,#?V0 + 2
   \   00029D   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0002A0   75..00       MOV     ?V0 + 2,#0x0
   \   0002A3   78..         MOV     R0,#?V0 + 2
   \   0002A5   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0002A8   75..01       MOV     ?V0 + 2,#0x1
   \   0002AB   78..         MOV     R0,#?V0 + 2
   \   0002AD   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0002B0   AC..         MOV     R4,?V0 + 14
   \   0002B2   AD..         MOV     R5,?V0 + 15
   \   0002B4   740D         MOV     A,#0xd
   \   0002B6   12....       LCALL   ?XSTACK_DISP0_8
   \   0002B9   E0           MOVX    A,@DPTR
   \   0002BA   FA           MOV     R2,A
   \   0002BB   A3           INC     DPTR
   \   0002BC   E0           MOVX    A,@DPTR
   \   0002BD   FB           MOV     R3,A
   \   0002BE   A9..         MOV     R1,?V0 + 6
   \   0002C0   12....       LCALL   ??zcl_SendCommand?relay
   \   0002C3   740B         MOV     A,#0xb
   \   0002C5   12....       LCALL   ?DEALLOC_XSTACK8
   \   0002C8   E9           MOV     A,R1
   \   0002C9   F5..         MOV     ?V0 + 5,A
    910              osal_mem_free( buf );
   \   0002CB                ; Setup parameters for call to function osal_mem_free
   \   0002CB   AA..         MOV     R2,?V0 + 8
   \   0002CD   AB..         MOV     R3,?V0 + 9
   \   0002CF   12....       LCALL   ??osal_mem_free?relay
   \   0002D2   8003         SJMP    ??zcl_SendReadRsp_9
    911            }
    912            else
    913            {
    914              status = ZMemError;
   \                     ??zcl_SendReadRsp_4:
   \   0002D4   75..10       MOV     ?V0 + 5,#0x10
    915            }
    916          
    917            return ( status );
   \                     ??zcl_SendReadRsp_9:
   \   0002D7   A9..         MOV     R1,?V0 + 5
   \   0002D9   7404         MOV     A,#0x4
   \   0002DB   12....       LCALL   ?DEALLOC_XSTACK8
   \   0002DE   7F10         MOV     R7,#0x10
   \   0002E0   02....       LJMP    ?BANKED_LEAVE_XDATA
    918          }
    919          #endif // ZCL_READ
    920          
    921          #ifdef ZCL_WRITE
    922          /*********************************************************************
    923           * @fn      sendWriteRequest
    924           *
    925           * @brief   Send a Write command
    926           *
    927           * @param   dstAddr - destination address
    928           * @param   clusterID - cluster ID
    929           * @param   writeCmd - write command to be sent
    930           * @param   cmd - ZCL_CMD_WRITE, ZCL_CMD_WRITE_UNDIVIDED or ZCL_CMD_WRITE_NO_RSP
    931           * @param   direction - direction of the command
    932           * @param   seqNum - transaction sequence number
    933           *
    934           * @return  ZSuccess if OK
    935           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    936          ZStatus_t zcl_SendWriteRequest( uint8 srcEP, afAddrType_t *dstAddr, uint16 clusterID,
   \                     zcl_SendWriteRequest:
    937                                          zclWriteCmd_t *writeCmd, uint8 cmd, uint8 direction,
    938                                          uint8 disableDefaultRsp, uint8 seqNum )
    939          {
   \   000000   74E8         MOV     A,#-0x18
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 24
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV     A,#-0x4
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   7402         MOV     A,#0x2
   \   00000C   12....       LCALL   ?XSTACK_DISP0_8
   \   00000F   EA           MOV     A,R2
   \   000010   F0           MOVX    @DPTR,A
   \   000011   A3           INC     DPTR
   \   000012   EB           MOV     A,R3
   \   000013   F0           MOVX    @DPTR,A
   \   000014   85..82       MOV     DPL,?XSP + 0
   \   000017   85..83       MOV     DPH,?XSP + 1
   \   00001A   EC           MOV     A,R4
   \   00001B   F0           MOVX    @DPTR,A
   \   00001C   A3           INC     DPTR
   \   00001D   ED           MOV     A,R5
   \   00001E   F0           MOVX    @DPTR,A
   \   00001F   89..         MOV     ?V0 + 12,R1
   \   000021   741C         MOV     A,#0x1c
   \   000023   12....       LCALL   ?XSTACK_DISP0_8
   \   000026   E0           MOVX    A,@DPTR
   \   000027   F5..         MOV     ?V0 + 8,A
   \   000029   A3           INC     DPTR
   \   00002A   E0           MOVX    A,@DPTR
   \   00002B   F5..         MOV     ?V0 + 9,A
   \   00002D   741F         MOV     A,#0x1f
   \   00002F   12....       LCALL   ?XSTACK_DISP0_8
   \   000032   E0           MOVX    A,@DPTR
   \   000033   F5..         MOV     ?V0 + 15,A
   \   000035   7420         MOV     A,#0x20
   \   000037   12....       LCALL   ?XSTACK_DISP0_8
   \   00003A   E0           MOVX    A,@DPTR
   \   00003B   F5..         MOV     ?V0 + 14,A
   \   00003D   7421         MOV     A,#0x21
   \   00003F   12....       LCALL   ?XSTACK_DISP0_8
   \   000042   E0           MOVX    A,@DPTR
   \   000043   F5..         MOV     ?V0 + 13,A
    940            uint8 *buf;
    941            uint16 dataLen = 0;
   \   000045   7E00         MOV     R6,#0x0
   \   000047   7F00         MOV     R7,#0x0
    942            ZStatus_t status;
    943          
    944            for ( uint8 i = 0; i < writeCmd->numAttr; i++ )
   \   000049   75..00       MOV     ?V0 + 4,#0x0
   \                     ??zcl_SendWriteRequest_0:
   \   00004C   85..82       MOV     DPL,?V0 + 8
   \   00004F   85..83       MOV     DPH,?V0 + 9
   \   000052   E0           MOVX    A,@DPTR
   \   000053   F8           MOV     R0,A
   \   000054   E5..         MOV     A,?V0 + 4
   \   000056   C3           CLR     C
   \   000057   98           SUBB    A,R0
   \   000058   505F         JNC     ??zcl_SendWriteRequest_1
    945            {
    946              zclWriteRec_t *statusRec = &(writeCmd->attrList[i]);
   \   00005A   E5..         MOV     A,?V0 + 4
   \   00005C   A8..         MOV     R0,?V0 + 4
   \   00005E   7900         MOV     R1,#0x0
   \   000060   E8           MOV     A,R0
   \   000061   75F005       MOV     B,#0x5
   \   000064   A4           MUL     AB
   \   000065   C8           XCH     A,R0
   \   000066   AAF0         MOV     R2,B
   \   000068   75F000       MOV     B,#0x0
   \   00006B   A4           MUL     AB
   \   00006C   2A           ADD     A,R2
   \   00006D   FA           MOV     R2,A
   \   00006E   75F005       MOV     B,#0x5
   \   000071   E9           MOV     A,R1
   \   000072   A4           MUL     AB
   \   000073   2A           ADD     A,R2
   \   000074   F9           MOV     R1,A
   \   000075   E5..         MOV     A,?V0 + 8
   \   000077   28           ADD     A,R0
   \   000078   F582         MOV     DPL,A
   \   00007A   E5..         MOV     A,?V0 + 9
   \   00007C   39           ADDC    A,R1
   \   00007D   F583         MOV     DPH,A
   \   00007F   A3           INC     DPTR
   \   000080   8582..       MOV     ?V0 + 0,DPL
   \   000083   8583..       MOV     ?V0 + 1,DPH
    947          
    948              dataLen += 2 + 1; // Attribute ID + Attribute Type
   \   000086   EE           MOV     A,R6
   \   000087   2403         ADD     A,#0x3
   \   000089   FE           MOV     R6,A
   \   00008A   EF           MOV     A,R7
   \   00008B   3400         ADDC    A,#0x0
   \   00008D   FF           MOV     R7,A
    949          
    950              // Attribute Data
    951              dataLen += zclGetAttrDataLength( statusRec->dataType, statusRec->attrData );
   \   00008E                ; Setup parameters for call to function zclGetAttrDataLength
   \   00008E   85..82       MOV     DPL,?V0 + 0
   \   000091   85..83       MOV     DPH,?V0 + 1
   \   000094   A3           INC     DPTR
   \   000095   A3           INC     DPTR
   \   000096   A3           INC     DPTR
   \   000097   E0           MOVX    A,@DPTR
   \   000098   FA           MOV     R2,A
   \   000099   A3           INC     DPTR
   \   00009A   E0           MOVX    A,@DPTR
   \   00009B   FB           MOV     R3,A
   \   00009C   85..82       MOV     DPL,?V0 + 0
   \   00009F   85..83       MOV     DPH,?V0 + 1
   \   0000A2   A3           INC     DPTR
   \   0000A3   A3           INC     DPTR
   \   0000A4   E0           MOVX    A,@DPTR
   \   0000A5   F9           MOV     R1,A
   \   0000A6   12....       LCALL   ??zclGetAttrDataLength?relay
   \   0000A9   8A..         MOV     ?V0 + 2,R2
   \   0000AB   8B..         MOV     ?V0 + 3,R3
   \   0000AD   EE           MOV     A,R6
   \   0000AE   25..         ADD     A,?V0 + 2
   \   0000B0   FE           MOV     R6,A
   \   0000B1   EF           MOV     A,R7
   \   0000B2   35..         ADDC    A,?V0 + 3
   \   0000B4   FF           MOV     R7,A
    952            }
   \   0000B5   05..         INC     ?V0 + 4
   \   0000B7   8093         SJMP    ??zcl_SendWriteRequest_0
    953          
    954            buf = osal_mem_alloc( dataLen );
   \                     ??zcl_SendWriteRequest_1:
   \   0000B9                ; Setup parameters for call to function osal_mem_alloc
   \   0000B9   EE           MOV     A,R6
   \   0000BA   FA           MOV     R2,A
   \   0000BB   EF           MOV     A,R7
   \   0000BC   FB           MOV     R3,A
   \   0000BD   12....       LCALL   ??osal_mem_alloc?relay
   \   0000C0   8A..         MOV     ?V0 + 0,R2
   \   0000C2   8B..         MOV     ?V0 + 1,R3
   \   0000C4   85....       MOV     ?V0 + 6,?V0 + 0
   \   0000C7   85....       MOV     ?V0 + 7,?V0 + 1
    955            if ( buf != NULL )
   \   0000CA   E5..         MOV     A,?V0 + 6
   \   0000CC   45..         ORL     A,?V0 + 7
   \   0000CE   7003         JNZ     $+5
   \   0000D0   02....       LJMP    ??zcl_SendWriteRequest_2 & 0xFFFF
    956            {
    957              // Load the buffer - serially
    958              uint8 *pBuf = buf;
   \   0000D3   85....       MOV     ?V0 + 0,?V0 + 6
   \   0000D6   85....       MOV     ?V0 + 1,?V0 + 7
    959              for ( uint8 i = 0; i < writeCmd->numAttr; i++ )
   \   0000D9   75..00       MOV     ?V0 + 4,#0x0
   \                     ??zcl_SendWriteRequest_3:
   \   0000DC   85..82       MOV     DPL,?V0 + 8
   \   0000DF   85..83       MOV     DPH,?V0 + 9
   \   0000E2   E0           MOVX    A,@DPTR
   \   0000E3   F8           MOV     R0,A
   \   0000E4   E5..         MOV     A,?V0 + 4
   \   0000E6   C3           CLR     C
   \   0000E7   98           SUBB    A,R0
   \   0000E8   4003         JC      $+5
   \   0000EA   02....       LJMP    ??zcl_SendWriteRequest_4 & 0xFFFF
    960              {
    961                zclWriteRec_t *statusRec = &(writeCmd->attrList[i]);
   \   0000ED   E5..         MOV     A,?V0 + 4
   \   0000EF   A8..         MOV     R0,?V0 + 4
   \   0000F1   7900         MOV     R1,#0x0
   \   0000F3   E8           MOV     A,R0
   \   0000F4   75F005       MOV     B,#0x5
   \   0000F7   A4           MUL     AB
   \   0000F8   C8           XCH     A,R0
   \   0000F9   AAF0         MOV     R2,B
   \   0000FB   75F000       MOV     B,#0x0
   \   0000FE   A4           MUL     AB
   \   0000FF   2A           ADD     A,R2
   \   000100   FA           MOV     R2,A
   \   000101   75F005       MOV     B,#0x5
   \   000104   E9           MOV     A,R1
   \   000105   A4           MUL     AB
   \   000106   2A           ADD     A,R2
   \   000107   F9           MOV     R1,A
   \   000108   E5..         MOV     A,?V0 + 8
   \   00010A   28           ADD     A,R0
   \   00010B   F582         MOV     DPL,A
   \   00010D   E5..         MOV     A,?V0 + 9
   \   00010F   39           ADDC    A,R1
   \   000110   F583         MOV     DPH,A
   \   000112   A3           INC     DPTR
   \   000113   8582..       MOV     ?V0 + 2,DPL
   \   000116   8583..       MOV     ?V0 + 3,DPH
    962          
    963                *pBuf++ = LO_UINT16( statusRec->attrID );
   \   000119   85..82       MOV     DPL,?V0 + 2
   \   00011C   85..83       MOV     DPH,?V0 + 3
   \   00011F   E0           MOVX    A,@DPTR
   \   000120   F8           MOV     R0,A
   \   000121   A3           INC     DPTR
   \   000122   E0           MOVX    A,@DPTR
   \   000123   F9           MOV     R1,A
   \   000124   E8           MOV     A,R0
   \   000125   85..82       MOV     DPL,?V0 + 0
   \   000128   85..83       MOV     DPH,?V0 + 1
   \   00012B   F0           MOVX    @DPTR,A
   \   00012C   85..82       MOV     DPL,?V0 + 0
   \   00012F   85..83       MOV     DPH,?V0 + 1
   \   000132   A3           INC     DPTR
   \   000133   8582..       MOV     ?V0 + 0,DPL
   \   000136   8583..       MOV     ?V0 + 1,DPH
    964                *pBuf++ = HI_UINT16( statusRec->attrID );
   \   000139   85..82       MOV     DPL,?V0 + 2
   \   00013C   85..83       MOV     DPH,?V0 + 3
   \   00013F   E0           MOVX    A,@DPTR
   \   000140   F8           MOV     R0,A
   \   000141   A3           INC     DPTR
   \   000142   E0           MOVX    A,@DPTR
   \   000143   F9           MOV     R1,A
   \   000144   E4           CLR     A
   \   000145   E9           MOV     A,R1
   \   000146   F8           MOV     R0,A
   \   000147   85..82       MOV     DPL,?V0 + 0
   \   00014A   85..83       MOV     DPH,?V0 + 1
   \   00014D   F0           MOVX    @DPTR,A
   \   00014E   85..82       MOV     DPL,?V0 + 0
   \   000151   85..83       MOV     DPH,?V0 + 1
   \   000154   A3           INC     DPTR
   \   000155   8582..       MOV     ?V0 + 0,DPL
   \   000158   8583..       MOV     ?V0 + 1,DPH
    965                *pBuf++ = statusRec->dataType;
   \   00015B   85..82       MOV     DPL,?V0 + 2
   \   00015E   85..83       MOV     DPH,?V0 + 3
   \   000161   A3           INC     DPTR
   \   000162   A3           INC     DPTR
   \   000163   E0           MOVX    A,@DPTR
   \   000164   85..82       MOV     DPL,?V0 + 0
   \   000167   85..83       MOV     DPH,?V0 + 1
   \   00016A   F0           MOVX    @DPTR,A
   \   00016B   85..82       MOV     DPL,?V0 + 0
   \   00016E   85..83       MOV     DPH,?V0 + 1
   \   000171   A3           INC     DPTR
   \   000172   8582..       MOV     ?V0 + 0,DPL
   \   000175   8583..       MOV     ?V0 + 1,DPH
    966          
    967                pBuf = zclSerializeData( statusRec->dataType, statusRec->attrData, pBuf );
   \   000178                ; Setup parameters for call to function zclSerializeData
   \   000178   AC..         MOV     R4,?V0 + 0
   \   00017A   AD..         MOV     R5,?V0 + 1
   \   00017C   85..82       MOV     DPL,?V0 + 2
   \   00017F   85..83       MOV     DPH,?V0 + 3
   \   000182   A3           INC     DPTR
   \   000183   A3           INC     DPTR
   \   000184   A3           INC     DPTR
   \   000185   E0           MOVX    A,@DPTR
   \   000186   FA           MOV     R2,A
   \   000187   A3           INC     DPTR
   \   000188   E0           MOVX    A,@DPTR
   \   000189   FB           MOV     R3,A
   \   00018A   85..82       MOV     DPL,?V0 + 2
   \   00018D   85..83       MOV     DPH,?V0 + 3
   \   000190   A3           INC     DPTR
   \   000191   A3           INC     DPTR
   \   000192   E0           MOVX    A,@DPTR
   \   000193   F9           MOV     R1,A
   \   000194   12....       LCALL   ??zclSerializeData?relay
   \   000197   8A..         MOV     ?V0 + 10,R2
   \   000199   8B..         MOV     ?V0 + 11,R3
   \   00019B   85....       MOV     ?V0 + 0,?V0 + 10
   \   00019E   85....       MOV     ?V0 + 1,?V0 + 11
    968              }
   \   0001A1   05..         INC     ?V0 + 4
   \   0001A3   02....       LJMP    ??zcl_SendWriteRequest_3 & 0xFFFF
    969          
    970              status = zcl_SendCommand( srcEP, dstAddr, clusterID, cmd, FALSE,
    971                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   \                     ??zcl_SendWriteRequest_4:
   \   0001A6                ; Setup parameters for call to function zcl_SendCommand
   \   0001A6   78..         MOV     R0,#?V0 + 6
   \   0001A8   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0001AB   8E..         MOV     ?V0 + 2,R6
   \   0001AD   8F..         MOV     ?V0 + 3,R7
   \   0001AF   78..         MOV     R0,#?V0 + 2
   \   0001B1   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0001B4   E5..         MOV     A,?V0 + 13
   \   0001B6   F5..         MOV     ?V0 + 2,A
   \   0001B8   78..         MOV     R0,#?V0 + 2
   \   0001BA   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0001BD   E4           CLR     A
   \   0001BE   F5..         MOV     ?V0 + 2,A
   \   0001C0   F5..         MOV     ?V0 + 3,A
   \   0001C2   78..         MOV     R0,#?V0 + 2
   \   0001C4   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0001C7   E5..         MOV     A,?V0 + 14
   \   0001C9   F5..         MOV     ?V0 + 2,A
   \   0001CB   78..         MOV     R0,#?V0 + 2
   \   0001CD   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0001D0   E5..         MOV     A,?V0 + 15
   \   0001D2   F5..         MOV     ?V0 + 2,A
   \   0001D4   78..         MOV     R0,#?V0 + 2
   \   0001D6   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0001D9   75..00       MOV     ?V0 + 2,#0x0
   \   0001DC   78..         MOV     R0,#?V0 + 2
   \   0001DE   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0001E1   7428         MOV     A,#0x28
   \   0001E3   12....       LCALL   ?XSTACK_DISP0_8
   \   0001E6   E0           MOVX    A,@DPTR
   \   0001E7   F5..         MOV     ?V0 + 2,A
   \   0001E9   78..         MOV     R0,#?V0 + 2
   \   0001EB   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0001EE   740B         MOV     A,#0xb
   \   0001F0   12....       LCALL   ?XSTACK_DISP0_8
   \   0001F3   E0           MOVX    A,@DPTR
   \   0001F4   FC           MOV     R4,A
   \   0001F5   A3           INC     DPTR
   \   0001F6   E0           MOVX    A,@DPTR
   \   0001F7   FD           MOV     R5,A
   \   0001F8   740D         MOV     A,#0xd
   \   0001FA   12....       LCALL   ?XSTACK_DISP0_8
   \   0001FD   E0           MOVX    A,@DPTR
   \   0001FE   FA           MOV     R2,A
   \   0001FF   A3           INC     DPTR
   \   000200   E0           MOVX    A,@DPTR
   \   000201   FB           MOV     R3,A
   \   000202   A9..         MOV     R1,?V0 + 12
   \   000204   12....       LCALL   ??zcl_SendCommand?relay
   \   000207   740B         MOV     A,#0xb
   \   000209   12....       LCALL   ?DEALLOC_XSTACK8
   \   00020C   E9           MOV     A,R1
   \   00020D   F5..         MOV     ?V0 + 5,A
    972              osal_mem_free( buf );
   \   00020F                ; Setup parameters for call to function osal_mem_free
   \   00020F   AA..         MOV     R2,?V0 + 6
   \   000211   AB..         MOV     R3,?V0 + 7
   \   000213   12....       LCALL   ??osal_mem_free?relay
   \   000216   8003         SJMP    ??zcl_SendWriteRequest_5
    973            }
    974            else
    975            {
    976              status = ZMemError;
   \                     ??zcl_SendWriteRequest_2:
   \   000218   75..10       MOV     ?V0 + 5,#0x10
    977            }
    978          
    979            return ( status);
   \                     ??zcl_SendWriteRequest_5:
   \   00021B   A9..         MOV     R1,?V0 + 5
   \   00021D   7404         MOV     A,#0x4
   \   00021F   12....       LCALL   ?DEALLOC_XSTACK8
   \   000222   7F10         MOV     R7,#0x10
   \   000224   02....       LJMP    ?BANKED_LEAVE_XDATA
    980          }
    981          
    982          /*********************************************************************
    983           * @fn      zcl_SendWriteRsp
    984           *
    985           * @brief   Send a Write Response command
    986           *
    987           * @param   dstAddr - destination address
    988           * @param   clusterID - cluster ID
    989           * @param   wrtieRspCmd - write response command to be sent
    990           * @param   direction - direction of the command
    991           * @param   seqNum - transaction sequence number
    992           *
    993           * @return  ZSuccess if OK
    994           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    995          ZStatus_t zcl_SendWriteRsp( uint8 srcEP, afAddrType_t *dstAddr,
   \                     zcl_SendWriteRsp:
    996                                      uint16 clusterID, zclWriteRspCmd_t *writeRspCmd,
    997                                      uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
    998          {
   \   000000   74E8         MOV     A,#-0x18
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 24
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   85..82       MOV     DPL,?XSP + 0
   \   00000D   85..83       MOV     DPH,?XSP + 1
   \   000010   EA           MOV     A,R2
   \   000011   F0           MOVX    @DPTR,A
   \   000012   A3           INC     DPTR
   \   000013   EB           MOV     A,R3
   \   000014   F0           MOVX    @DPTR,A
   \   000015   89..         MOV     ?V0 + 5,R1
   \   000017   8C..         MOV     ?V0 + 14,R4
   \   000019   8D..         MOV     ?V0 + 15,R5
   \   00001B   741A         MOV     A,#0x1a
   \   00001D   12....       LCALL   ?XSTACK_DISP0_8
   \   000020   E0           MOVX    A,@DPTR
   \   000021   F5..         MOV     ?V0 + 2,A
   \   000023   A3           INC     DPTR
   \   000024   E0           MOVX    A,@DPTR
   \   000025   F5..         MOV     ?V0 + 3,A
   \   000027   741C         MOV     A,#0x1c
   \   000029   12....       LCALL   ?XSTACK_DISP0_8
   \   00002C   E0           MOVX    A,@DPTR
   \   00002D   F5..         MOV     ?V0 + 12,A
   \   00002F   741D         MOV     A,#0x1d
   \   000031   12....       LCALL   ?XSTACK_DISP0_8
   \   000034   E0           MOVX    A,@DPTR
   \   000035   F5..         MOV     ?V0 + 9,A
   \   000037   741E         MOV     A,#0x1e
   \   000039   12....       LCALL   ?XSTACK_DISP0_8
   \   00003C   E0           MOVX    A,@DPTR
   \   00003D   F5..         MOV     ?V0 + 8,A
    999            uint16 dataLen;
   1000            uint8 *buf;
   1001            ZStatus_t status;
   1002          
   1003            dataLen = writeRspCmd->numAttr * ( 1 + 2 ); // status + attribute id
   \   00003F   85..82       MOV     DPL,?V0 + 2
   \   000042   85..83       MOV     DPH,?V0 + 3
   \   000045   E0           MOVX    A,@DPTR
   \   000046   F8           MOV     R0,A
   \   000047   7900         MOV     R1,#0x0
   \   000049   E8           MOV     A,R0
   \   00004A   75F003       MOV     B,#0x3
   \   00004D   A4           MUL     AB
   \   00004E   C8           XCH     A,R0
   \   00004F   AAF0         MOV     R2,B
   \   000051   75F000       MOV     B,#0x0
   \   000054   A4           MUL     AB
   \   000055   2A           ADD     A,R2
   \   000056   FA           MOV     R2,A
   \   000057   75F003       MOV     B,#0x3
   \   00005A   E9           MOV     A,R1
   \   00005B   A4           MUL     AB
   \   00005C   2A           ADD     A,R2
   \   00005D   F9           MOV     R1,A
   \   00005E   E8           MOV     A,R0
   \   00005F   FE           MOV     R6,A
   \   000060   E9           MOV     A,R1
   \   000061   FF           MOV     R7,A
   1004          
   1005            buf = osal_mem_alloc( dataLen );
   \   000062                ; Setup parameters for call to function osal_mem_alloc
   \   000062   EE           MOV     A,R6
   \   000063   FA           MOV     R2,A
   \   000064   EF           MOV     A,R7
   \   000065   FB           MOV     R3,A
   \   000066   12....       LCALL   ??osal_mem_alloc?relay
   \   000069   8A..         MOV     ?V0 + 0,R2
   \   00006B   8B..         MOV     ?V0 + 1,R3
   \   00006D   85....       MOV     ?V0 + 6,?V0 + 0
   \   000070   85....       MOV     ?V0 + 7,?V0 + 1
   1006            if ( buf != NULL )
   \   000073   E5..         MOV     A,?V0 + 6
   \   000075   45..         ORL     A,?V0 + 7
   \   000077   7003         JNZ     $+5
   \   000079   02....       LJMP    ??zcl_SendWriteRsp_0 & 0xFFFF
   1007            {
   1008              // Load the buffer - serially
   1009              uint8 *pBuf = buf;
   \   00007C   85....       MOV     ?V0 + 0,?V0 + 6
   \   00007F   85....       MOV     ?V0 + 1,?V0 + 7
   1010              for ( uint8 i = 0; i < writeRspCmd->numAttr; i++ )
   \   000082   7A00         MOV     R2,#0x0
   \                     ??zcl_SendWriteRsp_1:
   \   000084   85..82       MOV     DPL,?V0 + 2
   \   000087   85..83       MOV     DPH,?V0 + 3
   \   00008A   E0           MOVX    A,@DPTR
   \   00008B   F8           MOV     R0,A
   \   00008C   EA           MOV     A,R2
   \   00008D   C3           CLR     C
   \   00008E   98           SUBB    A,R0
   \   00008F   4003         JC      $+5
   \   000091   02....       LJMP    ??zcl_SendWriteRsp_2 & 0xFFFF
   1011              {
   1012                *pBuf++ = writeRspCmd->attrList[i].status;
   \   000094   EA           MOV     A,R2
   \   000095   F8           MOV     R0,A
   \   000096   7900         MOV     R1,#0x0
   \   000098   E8           MOV     A,R0
   \   000099   75F003       MOV     B,#0x3
   \   00009C   A4           MUL     AB
   \   00009D   C8           XCH     A,R0
   \   00009E   ABF0         MOV     R3,B
   \   0000A0   75F000       MOV     B,#0x0
   \   0000A3   A4           MUL     AB
   \   0000A4   2B           ADD     A,R3
   \   0000A5   FB           MOV     R3,A
   \   0000A6   75F003       MOV     B,#0x3
   \   0000A9   E9           MOV     A,R1
   \   0000AA   A4           MUL     AB
   \   0000AB   2B           ADD     A,R3
   \   0000AC   F9           MOV     R1,A
   \   0000AD   E5..         MOV     A,?V0 + 2
   \   0000AF   28           ADD     A,R0
   \   0000B0   F582         MOV     DPL,A
   \   0000B2   E5..         MOV     A,?V0 + 3
   \   0000B4   39           ADDC    A,R1
   \   0000B5   F583         MOV     DPH,A
   \   0000B7   A3           INC     DPTR
   \   0000B8   E0           MOVX    A,@DPTR
   \   0000B9   85..82       MOV     DPL,?V0 + 0
   \   0000BC   85..83       MOV     DPH,?V0 + 1
   \   0000BF   F0           MOVX    @DPTR,A
   \   0000C0   85..82       MOV     DPL,?V0 + 0
   \   0000C3   85..83       MOV     DPH,?V0 + 1
   \   0000C6   A3           INC     DPTR
   \   0000C7   8582..       MOV     ?V0 + 0,DPL
   \   0000CA   8583..       MOV     ?V0 + 1,DPH
   1013                *pBuf++ = LO_UINT16( writeRspCmd->attrList[i].attrID );
   \   0000CD   EA           MOV     A,R2
   \   0000CE   F8           MOV     R0,A
   \   0000CF   7900         MOV     R1,#0x0
   \   0000D1   E8           MOV     A,R0
   \   0000D2   75F003       MOV     B,#0x3
   \   0000D5   A4           MUL     AB
   \   0000D6   C8           XCH     A,R0
   \   0000D7   ABF0         MOV     R3,B
   \   0000D9   75F000       MOV     B,#0x0
   \   0000DC   A4           MUL     AB
   \   0000DD   2B           ADD     A,R3
   \   0000DE   FB           MOV     R3,A
   \   0000DF   75F003       MOV     B,#0x3
   \   0000E2   E9           MOV     A,R1
   \   0000E3   A4           MUL     AB
   \   0000E4   2B           ADD     A,R3
   \   0000E5   F9           MOV     R1,A
   \   0000E6   E5..         MOV     A,?V0 + 2
   \   0000E8   28           ADD     A,R0
   \   0000E9   F582         MOV     DPL,A
   \   0000EB   E5..         MOV     A,?V0 + 3
   \   0000ED   39           ADDC    A,R1
   \   0000EE   F583         MOV     DPH,A
   \   0000F0   A3           INC     DPTR
   \   0000F1   A3           INC     DPTR
   \   0000F2   E0           MOVX    A,@DPTR
   \   0000F3   F8           MOV     R0,A
   \   0000F4   A3           INC     DPTR
   \   0000F5   E0           MOVX    A,@DPTR
   \   0000F6   F9           MOV     R1,A
   \   0000F7   E8           MOV     A,R0
   \   0000F8   85..82       MOV     DPL,?V0 + 0
   \   0000FB   85..83       MOV     DPH,?V0 + 1
   \   0000FE   F0           MOVX    @DPTR,A
   \   0000FF   85..82       MOV     DPL,?V0 + 0
   \   000102   85..83       MOV     DPH,?V0 + 1
   \   000105   A3           INC     DPTR
   \   000106   8582..       MOV     ?V0 + 0,DPL
   \   000109   8583..       MOV     ?V0 + 1,DPH
   1014                *pBuf++ = HI_UINT16( writeRspCmd->attrList[i].attrID );
   \   00010C   EA           MOV     A,R2
   \   00010D   F8           MOV     R0,A
   \   00010E   7900         MOV     R1,#0x0
   \   000110   E8           MOV     A,R0
   \   000111   75F003       MOV     B,#0x3
   \   000114   A4           MUL     AB
   \   000115   C8           XCH     A,R0
   \   000116   ABF0         MOV     R3,B
   \   000118   75F000       MOV     B,#0x0
   \   00011B   A4           MUL     AB
   \   00011C   2B           ADD     A,R3
   \   00011D   FB           MOV     R3,A
   \   00011E   75F003       MOV     B,#0x3
   \   000121   E9           MOV     A,R1
   \   000122   A4           MUL     AB
   \   000123   2B           ADD     A,R3
   \   000124   F9           MOV     R1,A
   \   000125   E5..         MOV     A,?V0 + 2
   \   000127   28           ADD     A,R0
   \   000128   F582         MOV     DPL,A
   \   00012A   E5..         MOV     A,?V0 + 3
   \   00012C   39           ADDC    A,R1
   \   00012D   F583         MOV     DPH,A
   \   00012F   A3           INC     DPTR
   \   000130   A3           INC     DPTR
   \   000131   E0           MOVX    A,@DPTR
   \   000132   F8           MOV     R0,A
   \   000133   A3           INC     DPTR
   \   000134   E0           MOVX    A,@DPTR
   \   000135   F9           MOV     R1,A
   \   000136   E4           CLR     A
   \   000137   E9           MOV     A,R1
   \   000138   F8           MOV     R0,A
   \   000139   85..82       MOV     DPL,?V0 + 0
   \   00013C   85..83       MOV     DPH,?V0 + 1
   \   00013F   F0           MOVX    @DPTR,A
   \   000140   85..82       MOV     DPL,?V0 + 0
   \   000143   85..83       MOV     DPH,?V0 + 1
   \   000146   A3           INC     DPTR
   \   000147   8582..       MOV     ?V0 + 0,DPL
   \   00014A   8583..       MOV     ?V0 + 1,DPH
   1015              }
   \   00014D   0A           INC     R2
   \   00014E   02....       LJMP    ??zcl_SendWriteRsp_1 & 0xFFFF
   1016          
   1017              // If there's only a single status record and its status field is set to
   1018              // SUCCESS then omit the attribute ID field.
   1019              if ( writeRspCmd->numAttr == 1 && writeRspCmd->attrList[0].status == ZCL_STATUS_SUCCESS )
   \                     ??zcl_SendWriteRsp_2:
   \   000151   85..82       MOV     DPL,?V0 + 2
   \   000154   85..83       MOV     DPH,?V0 + 3
   \   000157   E0           MOVX    A,@DPTR
   \   000158   6401         XRL     A,#0x1
   \   00015A   700E         JNZ     ??zcl_SendWriteRsp_3
   \   00015C   85..82       MOV     DPL,?V0 + 2
   \   00015F   85..83       MOV     DPH,?V0 + 3
   \   000162   A3           INC     DPTR
   \   000163   E0           MOVX    A,@DPTR
   \   000164   7004         JNZ     ??zcl_SendWriteRsp_3
   1020              {
   1021                dataLen = 1;
   \   000166   7E01         MOV     R6,#0x1
   \   000168   7F00         MOV     R7,#0x0
   1022              }
   1023          
   1024              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_WRITE_RSP, FALSE,
   1025                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   \                     ??zcl_SendWriteRsp_3:
   \   00016A                ; Setup parameters for call to function zcl_SendCommand
   \   00016A   78..         MOV     R0,#?V0 + 6
   \   00016C   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00016F   8E..         MOV     ?V0 + 10,R6
   \   000171   8F..         MOV     ?V0 + 11,R7
   \   000173   78..         MOV     R0,#?V0 + 10
   \   000175   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000178   E5..         MOV     A,?V0 + 8
   \   00017A   F5..         MOV     ?V0 + 10,A
   \   00017C   78..         MOV     R0,#?V0 + 10
   \   00017E   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000181   E4           CLR     A
   \   000182   F5..         MOV     ?V0 + 10,A
   \   000184   F5..         MOV     ?V0 + 11,A
   \   000186   78..         MOV     R0,#?V0 + 10
   \   000188   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00018B   E5..         MOV     A,?V0 + 9
   \   00018D   F5..         MOV     ?V0 + 10,A
   \   00018F   78..         MOV     R0,#?V0 + 10
   \   000191   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000194   E5..         MOV     A,?V0 + 12
   \   000196   F5..         MOV     ?V0 + 10,A
   \   000198   78..         MOV     R0,#?V0 + 10
   \   00019A   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00019D   75..00       MOV     ?V0 + 10,#0x0
   \   0001A0   78..         MOV     R0,#?V0 + 10
   \   0001A2   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0001A5   75..04       MOV     ?V0 + 10,#0x4
   \   0001A8   78..         MOV     R0,#?V0 + 10
   \   0001AA   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0001AD   AC..         MOV     R4,?V0 + 14
   \   0001AF   AD..         MOV     R5,?V0 + 15
   \   0001B1   740B         MOV     A,#0xb
   \   0001B3   12....       LCALL   ?XSTACK_DISP0_8
   \   0001B6   E0           MOVX    A,@DPTR
   \   0001B7   FA           MOV     R2,A
   \   0001B8   A3           INC     DPTR
   \   0001B9   E0           MOVX    A,@DPTR
   \   0001BA   FB           MOV     R3,A
   \   0001BB   A9..         MOV     R1,?V0 + 5
   \   0001BD   12....       LCALL   ??zcl_SendCommand?relay
   \   0001C0   740B         MOV     A,#0xb
   \   0001C2   12....       LCALL   ?DEALLOC_XSTACK8
   \   0001C5   E9           MOV     A,R1
   \   0001C6   F5..         MOV     ?V0 + 4,A
   1026              osal_mem_free( buf );
   \   0001C8                ; Setup parameters for call to function osal_mem_free
   \   0001C8   AA..         MOV     R2,?V0 + 6
   \   0001CA   AB..         MOV     R3,?V0 + 7
   \   0001CC   12....       LCALL   ??osal_mem_free?relay
   \   0001CF   8003         SJMP    ??zcl_SendWriteRsp_4
   1027            }
   1028            else
   1029            {
   1030              status = ZMemError;
   \                     ??zcl_SendWriteRsp_0:
   \   0001D1   75..10       MOV     ?V0 + 4,#0x10
   1031            }
   1032          
   1033            return ( status );
   \                     ??zcl_SendWriteRsp_4:
   \   0001D4   A9..         MOV     R1,?V0 + 4
   \   0001D6   7402         MOV     A,#0x2
   \   0001D8   12....       LCALL   ?DEALLOC_XSTACK8
   \   0001DB   7F10         MOV     R7,#0x10
   \   0001DD   02....       LJMP    ?BANKED_LEAVE_XDATA
   1034          }
   1035          #endif // ZCL_WRITE
   1036          
   1037          #ifdef ZCL_REPORT
   1038          /*********************************************************************
   1039           * @fn      zcl_SendConfigReportCmd
   1040           *
   1041           * @brief   Send a Configure Reporting command
   1042           *
   1043           * @param   dstAddr - destination address
   1044           * @param   clusterID - cluster ID
   1045           * @param   cfgReportCmd - configure reporting command to be sent
   1046           * @param   direction - direction of the command
   1047           * @param   seqNum - transaction sequence number
   1048           *
   1049           * @return  ZSuccess if OK
   1050           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1051          ZStatus_t zcl_SendConfigReportCmd( uint8 srcEP, afAddrType_t *dstAddr,
   \                     zcl_SendConfigReportCmd:
   1052                                    uint16 clusterID, zclCfgReportCmd_t *cfgReportCmd,
   1053                                    uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1054          {
   \   000000   74E8         MOV     A,#-0x18
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 24
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV     A,#-0x4
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   7402         MOV     A,#0x2
   \   00000C   12....       LCALL   ?XSTACK_DISP0_8
   \   00000F   EA           MOV     A,R2
   \   000010   F0           MOVX    @DPTR,A
   \   000011   A3           INC     DPTR
   \   000012   EB           MOV     A,R3
   \   000013   F0           MOVX    @DPTR,A
   \   000014   85..82       MOV     DPL,?XSP + 0
   \   000017   85..83       MOV     DPH,?XSP + 1
   \   00001A   EC           MOV     A,R4
   \   00001B   F0           MOVX    @DPTR,A
   \   00001C   A3           INC     DPTR
   \   00001D   ED           MOV     A,R5
   \   00001E   F0           MOVX    @DPTR,A
   \   00001F   89..         MOV     ?V0 + 12,R1
   \   000021   741C         MOV     A,#0x1c
   \   000023   12....       LCALL   ?XSTACK_DISP0_8
   \   000026   E0           MOVX    A,@DPTR
   \   000027   F5..         MOV     ?V0 + 8,A
   \   000029   A3           INC     DPTR
   \   00002A   E0           MOVX    A,@DPTR
   \   00002B   F5..         MOV     ?V0 + 9,A
   \   00002D   741E         MOV     A,#0x1e
   \   00002F   12....       LCALL   ?XSTACK_DISP0_8
   \   000032   E0           MOVX    A,@DPTR
   \   000033   F5..         MOV     ?V0 + 15,A
   \   000035   741F         MOV     A,#0x1f
   \   000037   12....       LCALL   ?XSTACK_DISP0_8
   \   00003A   E0           MOVX    A,@DPTR
   \   00003B   F5..         MOV     ?V0 + 14,A
   \   00003D   7420         MOV     A,#0x20
   \   00003F   12....       LCALL   ?XSTACK_DISP0_8
   \   000042   E0           MOVX    A,@DPTR
   \   000043   F5..         MOV     ?V0 + 13,A
   1055            uint8 *buf;
   1056            uint16 dataLen = 0;
   \   000045   75..00       MOV     ?V0 + 0,#0x0
   \   000048   75..00       MOV     ?V0 + 1,#0x0
   1057            ZStatus_t status;
   1058          
   1059            // Find out the data length
   1060            for ( uint8 i = 0; i < cfgReportCmd->numAttr; i++ )
   \   00004B   75..00       MOV     ?V0 + 2,#0x0
   \                     ??zcl_SendConfigReportCmd_0:
   \   00004E   85..82       MOV     DPL,?V0 + 8
   \   000051   85..83       MOV     DPH,?V0 + 9
   \   000054   E0           MOVX    A,@DPTR
   \   000055   F8           MOV     R0,A
   \   000056   E5..         MOV     A,?V0 + 2
   \   000058   C3           CLR     C
   \   000059   98           SUBB    A,R0
   \   00005A   4003         JC      $+5
   \   00005C   02....       LJMP    ??zcl_SendConfigReportCmd_1 & 0xFFFF
   1061            {
   1062              zclCfgReportRec_t *reportRec = &(cfgReportCmd->attrList[i]);
   \   00005F   E5..         MOV     A,?V0 + 2
   \   000061   A8..         MOV     R0,?V0 + 2
   \   000063   7900         MOV     R1,#0x0
   \   000065   E8           MOV     A,R0
   \   000066   75F00C       MOV     B,#0xc
   \   000069   A4           MUL     AB
   \   00006A   C8           XCH     A,R0
   \   00006B   AAF0         MOV     R2,B
   \   00006D   75F000       MOV     B,#0x0
   \   000070   A4           MUL     AB
   \   000071   2A           ADD     A,R2
   \   000072   FA           MOV     R2,A
   \   000073   75F00C       MOV     B,#0xc
   \   000076   E9           MOV     A,R1
   \   000077   A4           MUL     AB
   \   000078   2A           ADD     A,R2
   \   000079   F9           MOV     R1,A
   \   00007A   E5..         MOV     A,?V0 + 8
   \   00007C   28           ADD     A,R0
   \   00007D   F582         MOV     DPL,A
   \   00007F   E5..         MOV     A,?V0 + 9
   \   000081   39           ADDC    A,R1
   \   000082   F583         MOV     DPH,A
   \   000084   A3           INC     DPTR
   \   000085   AE82         MOV     R6,DPL
   \   000087   AF83         MOV     R7,DPH
   1063          
   1064              dataLen += 1 + 2; // Direction + Attribute ID
   \   000089   E5..         MOV     A,?V0 + 0
   \   00008B   2403         ADD     A,#0x3
   \   00008D   F5..         MOV     ?V0 + 0,A
   \   00008F   E5..         MOV     A,?V0 + 1
   \   000091   3400         ADDC    A,#0x0
   \   000093   F5..         MOV     ?V0 + 1,A
   1065          
   1066              if ( reportRec->direction == ZCL_SEND_ATTR_REPORTS )
   \   000095   8E82         MOV     DPL,R6
   \   000097   8F83         MOV     DPH,R7
   \   000099   E0           MOVX    A,@DPTR
   \   00009A   7037         JNZ     ??zcl_SendConfigReportCmd_2
   1067              {
   1068                dataLen += 1 + 2 + 2; // Data Type + Min + Max Reporting Intervals
   \   00009C   E5..         MOV     A,?V0 + 0
   \   00009E   2405         ADD     A,#0x5
   \   0000A0   F5..         MOV     ?V0 + 0,A
   \   0000A2   E5..         MOV     A,?V0 + 1
   \   0000A4   3400         ADDC    A,#0x0
   \   0000A6   F5..         MOV     ?V0 + 1,A
   1069          
   1070                // Find out the size of the Reportable Change field (for Analog data types)
   1071                if ( zclAnalogDataType( reportRec->dataType ) )
   \   0000A8                ; Setup parameters for call to function zclAnalogDataType
   \   0000A8   8E82         MOV     DPL,R6
   \   0000AA   8F83         MOV     DPH,R7
   \   0000AC   A3           INC     DPTR
   \   0000AD   A3           INC     DPTR
   \   0000AE   A3           INC     DPTR
   \   0000AF   E0           MOVX    A,@DPTR
   \   0000B0   F9           MOV     R1,A
   \   0000B1   12....       LCALL   ??zclAnalogDataType?relay
   \   0000B4   E9           MOV     A,R1
   \   0000B5   6028         JZ      ??zcl_SendConfigReportCmd_3
   1072                {
   1073                  dataLen += zclGetDataTypeLength( reportRec->dataType );
   \   0000B7                ; Setup parameters for call to function zclGetDataTypeLength
   \   0000B7   8E82         MOV     DPL,R6
   \   0000B9   8F83         MOV     DPH,R7
   \   0000BB   A3           INC     DPTR
   \   0000BC   A3           INC     DPTR
   \   0000BD   A3           INC     DPTR
   \   0000BE   E0           MOVX    A,@DPTR
   \   0000BF   F9           MOV     R1,A
   \   0000C0   12....       LCALL   ??zclGetDataTypeLength?relay
   \   0000C3   E9           MOV     A,R1
   \   0000C4   F8           MOV     R0,A
   \   0000C5   7900         MOV     R1,#0x0
   \   0000C7   E5..         MOV     A,?V0 + 0
   \   0000C9   28           ADD     A,R0
   \   0000CA   F5..         MOV     ?V0 + 0,A
   \   0000CC   E5..         MOV     A,?V0 + 1
   \   0000CE   39           ADDC    A,R1
   \   0000CF   F5..         MOV     ?V0 + 1,A
   \   0000D1   800C         SJMP    ??zcl_SendConfigReportCmd_3
   1074                }
   1075              }
   1076              else
   1077              {
   1078                dataLen += 2; // Timeout Period
   \                     ??zcl_SendConfigReportCmd_2:
   \   0000D3   E5..         MOV     A,?V0 + 0
   \   0000D5   2402         ADD     A,#0x2
   \   0000D7   F5..         MOV     ?V0 + 0,A
   \   0000D9   E5..         MOV     A,?V0 + 1
   \   0000DB   3400         ADDC    A,#0x0
   \   0000DD   F5..         MOV     ?V0 + 1,A
   1079              }
   1080            }
   \                     ??zcl_SendConfigReportCmd_3:
   \   0000DF   05..         INC     ?V0 + 2
   \   0000E1   02....       LJMP    ??zcl_SendConfigReportCmd_0 & 0xFFFF
   1081          
   1082            buf = osal_mem_alloc( dataLen );
   \                     ??zcl_SendConfigReportCmd_1:
   \   0000E4                ; Setup parameters for call to function osal_mem_alloc
   \   0000E4   AA..         MOV     R2,?V0 + 0
   \   0000E6   AB..         MOV     R3,?V0 + 1
   \   0000E8   12....       LCALL   ??osal_mem_alloc?relay
   \   0000EB   8A..         MOV     ?V0 + 2,R2
   \   0000ED   8B..         MOV     ?V0 + 3,R3
   \   0000EF   85....       MOV     ?V0 + 6,?V0 + 2
   \   0000F2   85....       MOV     ?V0 + 7,?V0 + 3
   1083            if ( buf != NULL )
   \   0000F5   E5..         MOV     A,?V0 + 6
   \   0000F7   45..         ORL     A,?V0 + 7
   \   0000F9   7003         JNZ     $+5
   \   0000FB   02....       LJMP    ??zcl_SendConfigReportCmd_4 & 0xFFFF
   1084            {
   1085              // Load the buffer - serially
   1086              uint8 *pBuf = buf;
   \   0000FE   AE..         MOV     R6,?V0 + 6
   \   000100   AF..         MOV     R7,?V0 + 7
   1087              for ( uint8 i = 0; i < cfgReportCmd->numAttr; i++ )
   \   000102   75..00       MOV     ?V0 + 4,#0x0
   \                     ??zcl_SendConfigReportCmd_5:
   \   000105   85..82       MOV     DPL,?V0 + 8
   \   000108   85..83       MOV     DPH,?V0 + 9
   \   00010B   E0           MOVX    A,@DPTR
   \   00010C   F8           MOV     R0,A
   \   00010D   E5..         MOV     A,?V0 + 4
   \   00010F   C3           CLR     C
   \   000110   98           SUBB    A,R0
   \   000111   4003         JC      $+5
   \   000113   02....       LJMP    ??zcl_SendConfigReportCmd_6 & 0xFFFF
   1088              {
   1089                zclCfgReportRec_t *reportRec = &(cfgReportCmd->attrList[i]);
   \   000116   E5..         MOV     A,?V0 + 4
   \   000118   A8..         MOV     R0,?V0 + 4
   \   00011A   7900         MOV     R1,#0x0
   \   00011C   E8           MOV     A,R0
   \   00011D   75F00C       MOV     B,#0xc
   \   000120   A4           MUL     AB
   \   000121   C8           XCH     A,R0
   \   000122   AAF0         MOV     R2,B
   \   000124   75F000       MOV     B,#0x0
   \   000127   A4           MUL     AB
   \   000128   2A           ADD     A,R2
   \   000129   FA           MOV     R2,A
   \   00012A   75F00C       MOV     B,#0xc
   \   00012D   E9           MOV     A,R1
   \   00012E   A4           MUL     AB
   \   00012F   2A           ADD     A,R2
   \   000130   F9           MOV     R1,A
   \   000131   E5..         MOV     A,?V0 + 8
   \   000133   28           ADD     A,R0
   \   000134   F582         MOV     DPL,A
   \   000136   E5..         MOV     A,?V0 + 9
   \   000138   39           ADDC    A,R1
   \   000139   F583         MOV     DPH,A
   \   00013B   A3           INC     DPTR
   \   00013C   8582..       MOV     ?V0 + 2,DPL
   \   00013F   8583..       MOV     ?V0 + 3,DPH
   1090          
   1091                *pBuf++ = reportRec->direction;
   \   000142   85..82       MOV     DPL,?V0 + 2
   \   000145   85..83       MOV     DPH,?V0 + 3
   \   000148   E0           MOVX    A,@DPTR
   \   000149   8E82         MOV     DPL,R6
   \   00014B   8F83         MOV     DPH,R7
   \   00014D   F0           MOVX    @DPTR,A
   \   00014E   8E82         MOV     DPL,R6
   \   000150   8F83         MOV     DPH,R7
   \   000152   A3           INC     DPTR
   \   000153   AE82         MOV     R6,DPL
   \   000155   AF83         MOV     R7,DPH
   1092                *pBuf++ = LO_UINT16( reportRec->attrID );
   \   000157   85..82       MOV     DPL,?V0 + 2
   \   00015A   85..83       MOV     DPH,?V0 + 3
   \   00015D   A3           INC     DPTR
   \   00015E   E0           MOVX    A,@DPTR
   \   00015F   F8           MOV     R0,A
   \   000160   A3           INC     DPTR
   \   000161   E0           MOVX    A,@DPTR
   \   000162   F9           MOV     R1,A
   \   000163   E8           MOV     A,R0
   \   000164   8E82         MOV     DPL,R6
   \   000166   8F83         MOV     DPH,R7
   \   000168   F0           MOVX    @DPTR,A
   \   000169   8E82         MOV     DPL,R6
   \   00016B   8F83         MOV     DPH,R7
   \   00016D   A3           INC     DPTR
   \   00016E   AE82         MOV     R6,DPL
   \   000170   AF83         MOV     R7,DPH
   1093                *pBuf++ = HI_UINT16( reportRec->attrID );
   \   000172   85..82       MOV     DPL,?V0 + 2
   \   000175   85..83       MOV     DPH,?V0 + 3
   \   000178   A3           INC     DPTR
   \   000179   E0           MOVX    A,@DPTR
   \   00017A   F8           MOV     R0,A
   \   00017B   A3           INC     DPTR
   \   00017C   E0           MOVX    A,@DPTR
   \   00017D   F9           MOV     R1,A
   \   00017E   E4           CLR     A
   \   00017F   E9           MOV     A,R1
   \   000180   F8           MOV     R0,A
   \   000181   8E82         MOV     DPL,R6
   \   000183   8F83         MOV     DPH,R7
   \   000185   F0           MOVX    @DPTR,A
   \   000186   8E82         MOV     DPL,R6
   \   000188   8F83         MOV     DPH,R7
   \   00018A   A3           INC     DPTR
   \   00018B   AE82         MOV     R6,DPL
   \   00018D   AF83         MOV     R7,DPH
   1094          
   1095                if ( reportRec->direction == ZCL_SEND_ATTR_REPORTS )
   \   00018F   85..82       MOV     DPL,?V0 + 2
   \   000192   85..83       MOV     DPH,?V0 + 3
   \   000195   E0           MOVX    A,@DPTR
   \   000196   6003         JZ      $+5
   \   000198   02....       LJMP    ??zcl_SendConfigReportCmd_7 & 0xFFFF
   1096                {
   1097                  *pBuf++ = reportRec->dataType;
   \   00019B   85..82       MOV     DPL,?V0 + 2
   \   00019E   85..83       MOV     DPH,?V0 + 3
   \   0001A1   A3           INC     DPTR
   \   0001A2   A3           INC     DPTR
   \   0001A3   A3           INC     DPTR
   \   0001A4   E0           MOVX    A,@DPTR
   \   0001A5   8E82         MOV     DPL,R6
   \   0001A7   8F83         MOV     DPH,R7
   \   0001A9   F0           MOVX    @DPTR,A
   \   0001AA   8E82         MOV     DPL,R6
   \   0001AC   8F83         MOV     DPH,R7
   \   0001AE   A3           INC     DPTR
   \   0001AF   AE82         MOV     R6,DPL
   \   0001B1   AF83         MOV     R7,DPH
   1098                  *pBuf++ = LO_UINT16( reportRec->minReportInt );
   \   0001B3   85..82       MOV     DPL,?V0 + 2
   \   0001B6   85..83       MOV     DPH,?V0 + 3
   \   0001B9   A3           INC     DPTR
   \   0001BA   A3           INC     DPTR
   \   0001BB   A3           INC     DPTR
   \   0001BC   A3           INC     DPTR
   \   0001BD   E0           MOVX    A,@DPTR
   \   0001BE   F8           MOV     R0,A
   \   0001BF   A3           INC     DPTR
   \   0001C0   E0           MOVX    A,@DPTR
   \   0001C1   F9           MOV     R1,A
   \   0001C2   E8           MOV     A,R0
   \   0001C3   8E82         MOV     DPL,R6
   \   0001C5   8F83         MOV     DPH,R7
   \   0001C7   F0           MOVX    @DPTR,A
   \   0001C8   8E82         MOV     DPL,R6
   \   0001CA   8F83         MOV     DPH,R7
   \   0001CC   A3           INC     DPTR
   \   0001CD   AE82         MOV     R6,DPL
   \   0001CF   AF83         MOV     R7,DPH
   1099                  *pBuf++ = HI_UINT16( reportRec->minReportInt );
   \   0001D1   85..82       MOV     DPL,?V0 + 2
   \   0001D4   85..83       MOV     DPH,?V0 + 3
   \   0001D7   A3           INC     DPTR
   \   0001D8   A3           INC     DPTR
   \   0001D9   A3           INC     DPTR
   \   0001DA   A3           INC     DPTR
   \   0001DB   E0           MOVX    A,@DPTR
   \   0001DC   F8           MOV     R0,A
   \   0001DD   A3           INC     DPTR
   \   0001DE   E0           MOVX    A,@DPTR
   \   0001DF   F9           MOV     R1,A
   \   0001E0   E4           CLR     A
   \   0001E1   E9           MOV     A,R1
   \   0001E2   F8           MOV     R0,A
   \   0001E3   8E82         MOV     DPL,R6
   \   0001E5   8F83         MOV     DPH,R7
   \   0001E7   F0           MOVX    @DPTR,A
   \   0001E8   8E82         MOV     DPL,R6
   \   0001EA   8F83         MOV     DPH,R7
   \   0001EC   A3           INC     DPTR
   \   0001ED   AE82         MOV     R6,DPL
   \   0001EF   AF83         MOV     R7,DPH
   1100                  *pBuf++ = LO_UINT16( reportRec->maxReportInt );
   \   0001F1   85..82       MOV     DPL,?V0 + 2
   \   0001F4   85..83       MOV     DPH,?V0 + 3
   \   0001F7   A3           INC     DPTR
   \   0001F8   A3           INC     DPTR
   \   0001F9   A3           INC     DPTR
   \   0001FA   A3           INC     DPTR
   \   0001FB   A3           INC     DPTR
   \   0001FC   A3           INC     DPTR
   \   0001FD   E0           MOVX    A,@DPTR
   \   0001FE   F8           MOV     R0,A
   \   0001FF   A3           INC     DPTR
   \   000200   E0           MOVX    A,@DPTR
   \   000201   F9           MOV     R1,A
   \   000202   E8           MOV     A,R0
   \   000203   8E82         MOV     DPL,R6
   \   000205   8F83         MOV     DPH,R7
   \   000207   F0           MOVX    @DPTR,A
   \   000208   8E82         MOV     DPL,R6
   \   00020A   8F83         MOV     DPH,R7
   \   00020C   A3           INC     DPTR
   \   00020D   AE82         MOV     R6,DPL
   \   00020F   AF83         MOV     R7,DPH
   1101                  *pBuf++ = HI_UINT16( reportRec->maxReportInt );
   \   000211   85..82       MOV     DPL,?V0 + 2
   \   000214   85..83       MOV     DPH,?V0 + 3
   \   000217   A3           INC     DPTR
   \   000218   A3           INC     DPTR
   \   000219   A3           INC     DPTR
   \   00021A   A3           INC     DPTR
   \   00021B   A3           INC     DPTR
   \   00021C   A3           INC     DPTR
   \   00021D   E0           MOVX    A,@DPTR
   \   00021E   F8           MOV     R0,A
   \   00021F   A3           INC     DPTR
   \   000220   E0           MOVX    A,@DPTR
   \   000221   F9           MOV     R1,A
   \   000222   E4           CLR     A
   \   000223   E9           MOV     A,R1
   \   000224   F8           MOV     R0,A
   \   000225   8E82         MOV     DPL,R6
   \   000227   8F83         MOV     DPH,R7
   \   000229   F0           MOVX    @DPTR,A
   \   00022A   8E82         MOV     DPL,R6
   \   00022C   8F83         MOV     DPH,R7
   \   00022E   A3           INC     DPTR
   \   00022F   AE82         MOV     R6,DPL
   \   000231   AF83         MOV     R7,DPH
   1102          
   1103                  if ( zclAnalogDataType( reportRec->dataType ) )
   \   000233                ; Setup parameters for call to function zclAnalogDataType
   \   000233   85..82       MOV     DPL,?V0 + 2
   \   000236   85..83       MOV     DPH,?V0 + 3
   \   000239   A3           INC     DPTR
   \   00023A   A3           INC     DPTR
   \   00023B   A3           INC     DPTR
   \   00023C   E0           MOVX    A,@DPTR
   \   00023D   F9           MOV     R1,A
   \   00023E   12....       LCALL   ??zclAnalogDataType?relay
   \   000241   E9           MOV     A,R1
   \   000242   6077         JZ      ??zcl_SendConfigReportCmd_8
   1104                  {
   1105                    pBuf = zclSerializeData( reportRec->dataType, reportRec->reportableChange, pBuf );
   \   000244                ; Setup parameters for call to function zclSerializeData
   \   000244   EE           MOV     A,R6
   \   000245   FC           MOV     R4,A
   \   000246   EF           MOV     A,R7
   \   000247   FD           MOV     R5,A
   \   000248   85..82       MOV     DPL,?V0 + 2
   \   00024B   85..83       MOV     DPH,?V0 + 3
   \   00024E   A3           INC     DPTR
   \   00024F   A3           INC     DPTR
   \   000250   A3           INC     DPTR
   \   000251   A3           INC     DPTR
   \   000252   A3           INC     DPTR
   \   000253   A3           INC     DPTR
   \   000254   A3           INC     DPTR
   \   000255   A3           INC     DPTR
   \   000256   A3           INC     DPTR
   \   000257   A3           INC     DPTR
   \   000258   E0           MOVX    A,@DPTR
   \   000259   FA           MOV     R2,A
   \   00025A   A3           INC     DPTR
   \   00025B   E0           MOVX    A,@DPTR
   \   00025C   FB           MOV     R3,A
   \   00025D   85..82       MOV     DPL,?V0 + 2
   \   000260   85..83       MOV     DPH,?V0 + 3
   \   000263   A3           INC     DPTR
   \   000264   A3           INC     DPTR
   \   000265   A3           INC     DPTR
   \   000266   E0           MOVX    A,@DPTR
   \   000267   F9           MOV     R1,A
   \   000268   12....       LCALL   ??zclSerializeData?relay
   \   00026B   8A..         MOV     ?V0 + 10,R2
   \   00026D   8B..         MOV     ?V0 + 11,R3
   \   00026F   AE..         MOV     R6,?V0 + 10
   \   000271   AF..         MOV     R7,?V0 + 11
   \   000273   8046         SJMP    ??zcl_SendConfigReportCmd_8
   1106                  }
   1107                }
   1108                else
   1109                {
   1110                  *pBuf++ = LO_UINT16( reportRec->timeoutPeriod );
   \                     ??zcl_SendConfigReportCmd_7:
   \   000275   85..82       MOV     DPL,?V0 + 2
   \   000278   85..83       MOV     DPH,?V0 + 3
   \   00027B   A3           INC     DPTR
   \   00027C   A3           INC     DPTR
   \   00027D   A3           INC     DPTR
   \   00027E   A3           INC     DPTR
   \   00027F   A3           INC     DPTR
   \   000280   A3           INC     DPTR
   \   000281   A3           INC     DPTR
   \   000282   A3           INC     DPTR
   \   000283   E0           MOVX    A,@DPTR
   \   000284   F8           MOV     R0,A
   \   000285   A3           INC     DPTR
   \   000286   E0           MOVX    A,@DPTR
   \   000287   F9           MOV     R1,A
   \   000288   E8           MOV     A,R0
   \   000289   8E82         MOV     DPL,R6
   \   00028B   8F83         MOV     DPH,R7
   \   00028D   F0           MOVX    @DPTR,A
   \   00028E   8E82         MOV     DPL,R6
   \   000290   8F83         MOV     DPH,R7
   \   000292   A3           INC     DPTR
   \   000293   AE82         MOV     R6,DPL
   \   000295   AF83         MOV     R7,DPH
   1111                  *pBuf++ = HI_UINT16( reportRec->timeoutPeriod );
   \   000297   85..82       MOV     DPL,?V0 + 2
   \   00029A   85..83       MOV     DPH,?V0 + 3
   \   00029D   A3           INC     DPTR
   \   00029E   A3           INC     DPTR
   \   00029F   A3           INC     DPTR
   \   0002A0   A3           INC     DPTR
   \   0002A1   A3           INC     DPTR
   \   0002A2   A3           INC     DPTR
   \   0002A3   A3           INC     DPTR
   \   0002A4   A3           INC     DPTR
   \   0002A5   E0           MOVX    A,@DPTR
   \   0002A6   F8           MOV     R0,A
   \   0002A7   A3           INC     DPTR
   \   0002A8   E0           MOVX    A,@DPTR
   \   0002A9   F9           MOV     R1,A
   \   0002AA   E4           CLR     A
   \   0002AB   E9           MOV     A,R1
   \   0002AC   F8           MOV     R0,A
   \   0002AD   8E82         MOV     DPL,R6
   \   0002AF   8F83         MOV     DPH,R7
   \   0002B1   F0           MOVX    @DPTR,A
   \   0002B2   8E82         MOV     DPL,R6
   \   0002B4   8F83         MOV     DPH,R7
   \   0002B6   A3           INC     DPTR
   \   0002B7   AE82         MOV     R6,DPL
   \   0002B9   AF83         MOV     R7,DPH
   1112                }
   1113              } // for loop
   \                     ??zcl_SendConfigReportCmd_8:
   \   0002BB   05..         INC     ?V0 + 4
   \   0002BD   02....       LJMP    ??zcl_SendConfigReportCmd_5 & 0xFFFF
   1114          
   1115              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_CONFIG_REPORT, FALSE,
   1116                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   \                     ??zcl_SendConfigReportCmd_6:
   \   0002C0                ; Setup parameters for call to function zcl_SendCommand
   \   0002C0   78..         MOV     R0,#?V0 + 6
   \   0002C2   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0002C5   78..         MOV     R0,#?V0 + 0
   \   0002C7   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0002CA   E5..         MOV     A,?V0 + 13
   \   0002CC   F5..         MOV     ?V0 + 2,A
   \   0002CE   78..         MOV     R0,#?V0 + 2
   \   0002D0   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0002D3   E4           CLR     A
   \   0002D4   F5..         MOV     ?V0 + 2,A
   \   0002D6   F5..         MOV     ?V0 + 3,A
   \   0002D8   78..         MOV     R0,#?V0 + 2
   \   0002DA   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0002DD   E5..         MOV     A,?V0 + 14
   \   0002DF   F5..         MOV     ?V0 + 2,A
   \   0002E1   78..         MOV     R0,#?V0 + 2
   \   0002E3   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0002E6   E5..         MOV     A,?V0 + 15
   \   0002E8   F5..         MOV     ?V0 + 2,A
   \   0002EA   78..         MOV     R0,#?V0 + 2
   \   0002EC   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0002EF   75..00       MOV     ?V0 + 2,#0x0
   \   0002F2   78..         MOV     R0,#?V0 + 2
   \   0002F4   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0002F7   75..06       MOV     ?V0 + 2,#0x6
   \   0002FA   78..         MOV     R0,#?V0 + 2
   \   0002FC   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0002FF   740B         MOV     A,#0xb
   \   000301   12....       LCALL   ?XSTACK_DISP0_8
   \   000304   E0           MOVX    A,@DPTR
   \   000305   FC           MOV     R4,A
   \   000306   A3           INC     DPTR
   \   000307   E0           MOVX    A,@DPTR
   \   000308   FD           MOV     R5,A
   \   000309   740D         MOV     A,#0xd
   \   00030B   12....       LCALL   ?XSTACK_DISP0_8
   \   00030E   E0           MOVX    A,@DPTR
   \   00030F   FA           MOV     R2,A
   \   000310   A3           INC     DPTR
   \   000311   E0           MOVX    A,@DPTR
   \   000312   FB           MOV     R3,A
   \   000313   A9..         MOV     R1,?V0 + 12
   \   000315   12....       LCALL   ??zcl_SendCommand?relay
   \   000318   740B         MOV     A,#0xb
   \   00031A   12....       LCALL   ?DEALLOC_XSTACK8
   \   00031D   E9           MOV     A,R1
   \   00031E   F5..         MOV     ?V0 + 5,A
   1117              osal_mem_free( buf );
   \   000320                ; Setup parameters for call to function osal_mem_free
   \   000320   AA..         MOV     R2,?V0 + 6
   \   000322   AB..         MOV     R3,?V0 + 7
   \   000324   12....       LCALL   ??osal_mem_free?relay
   \   000327   8003         SJMP    ??zcl_SendConfigReportCmd_9
   1118            }
   1119            else
   1120            {
   1121              status = ZMemError;
   \                     ??zcl_SendConfigReportCmd_4:
   \   000329   75..10       MOV     ?V0 + 5,#0x10
   1122            }
   1123          
   1124            return ( status );
   \                     ??zcl_SendConfigReportCmd_9:
   \   00032C   A9..         MOV     R1,?V0 + 5
   \   00032E   7404         MOV     A,#0x4
   \   000330   12....       LCALL   ?DEALLOC_XSTACK8
   \   000333   7F10         MOV     R7,#0x10
   \   000335   02....       LJMP    ?BANKED_LEAVE_XDATA
   1125          }
   1126          
   1127          /*********************************************************************
   1128           * @fn      zcl_SendConfigReportRspCmd
   1129           *
   1130           * @brief   Send a Configure Reporting Response command
   1131           *
   1132           * @param   dstAddr - destination address
   1133           * @param   clusterID - cluster ID
   1134           * @param   cfgReportRspCmd - configure reporting response command to be sent
   1135           * @param   direction - direction of the command
   1136           * @param   seqNum - transaction sequence number
   1137           *
   1138           * @return  ZSuccess if OK
   1139           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1140          ZStatus_t zcl_SendConfigReportRspCmd( uint8 srcEP, afAddrType_t *dstAddr,
   \                     zcl_SendConfigReportRspCmd:
   1141                              uint16 clusterID, zclCfgReportRspCmd_t *cfgReportRspCmd,
   1142                              uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1143          {
   \   000000   74E8         MOV     A,#-0x18
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 24
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   85..82       MOV     DPL,?XSP + 0
   \   00000D   85..83       MOV     DPH,?XSP + 1
   \   000010   EA           MOV     A,R2
   \   000011   F0           MOVX    @DPTR,A
   \   000012   A3           INC     DPTR
   \   000013   EB           MOV     A,R3
   \   000014   F0           MOVX    @DPTR,A
   \   000015   89..         MOV     ?V0 + 5,R1
   \   000017   8C..         MOV     ?V0 + 14,R4
   \   000019   8D..         MOV     ?V0 + 15,R5
   \   00001B   741A         MOV     A,#0x1a
   \   00001D   12....       LCALL   ?XSTACK_DISP0_8
   \   000020   E0           MOVX    A,@DPTR
   \   000021   F5..         MOV     ?V0 + 2,A
   \   000023   A3           INC     DPTR
   \   000024   E0           MOVX    A,@DPTR
   \   000025   F5..         MOV     ?V0 + 3,A
   \   000027   741C         MOV     A,#0x1c
   \   000029   12....       LCALL   ?XSTACK_DISP0_8
   \   00002C   E0           MOVX    A,@DPTR
   \   00002D   F5..         MOV     ?V0 + 12,A
   \   00002F   741D         MOV     A,#0x1d
   \   000031   12....       LCALL   ?XSTACK_DISP0_8
   \   000034   E0           MOVX    A,@DPTR
   \   000035   F5..         MOV     ?V0 + 9,A
   \   000037   741E         MOV     A,#0x1e
   \   000039   12....       LCALL   ?XSTACK_DISP0_8
   \   00003C   E0           MOVX    A,@DPTR
   \   00003D   F5..         MOV     ?V0 + 8,A
   1144            uint16 dataLen;
   1145            uint8 *buf;
   1146            ZStatus_t status;
   1147          
   1148            // Atrribute list (Status, Direction and Attribute ID)
   1149            dataLen = cfgReportRspCmd->numAttr * ( 1 + 1 + 2 );
   \   00003F   85..82       MOV     DPL,?V0 + 2
   \   000042   85..83       MOV     DPH,?V0 + 3
   \   000045   E0           MOVX    A,@DPTR
   \   000046   F8           MOV     R0,A
   \   000047   7900         MOV     R1,#0x0
   \   000049   E8           MOV     A,R0
   \   00004A   75F004       MOV     B,#0x4
   \   00004D   A4           MUL     AB
   \   00004E   C8           XCH     A,R0
   \   00004F   AAF0         MOV     R2,B
   \   000051   75F000       MOV     B,#0x0
   \   000054   A4           MUL     AB
   \   000055   2A           ADD     A,R2
   \   000056   FA           MOV     R2,A
   \   000057   75F004       MOV     B,#0x4
   \   00005A   E9           MOV     A,R1
   \   00005B   A4           MUL     AB
   \   00005C   2A           ADD     A,R2
   \   00005D   F9           MOV     R1,A
   \   00005E   88..         MOV     ?V0 + 0,R0
   \   000060   89..         MOV     ?V0 + 1,R1
   1150          
   1151            buf = osal_mem_alloc( dataLen );
   \   000062                ; Setup parameters for call to function osal_mem_alloc
   \   000062   AA..         MOV     R2,?V0 + 0
   \   000064   AB..         MOV     R3,?V0 + 1
   \   000066   12....       LCALL   ??osal_mem_alloc?relay
   \   000069   8A..         MOV     ?V0 + 10,R2
   \   00006B   8B..         MOV     ?V0 + 11,R3
   \   00006D   85....       MOV     ?V0 + 6,?V0 + 10
   \   000070   85....       MOV     ?V0 + 7,?V0 + 11
   1152            if ( buf != NULL )
   \   000073   E5..         MOV     A,?V0 + 6
   \   000075   45..         ORL     A,?V0 + 7
   \   000077   7003         JNZ     $+5
   \   000079   02....       LJMP    ??zcl_SendConfigReportRspCmd_0 & 0xFFFF
   1153            {
   1154              // Load the buffer - serially
   1155              uint8 *pBuf = buf;
   \   00007C   AE..         MOV     R6,?V0 + 6
   \   00007E   AF..         MOV     R7,?V0 + 7
   1156              for ( uint8 i = 0; i < cfgReportRspCmd->numAttr; i++ )
   \   000080   7A00         MOV     R2,#0x0
   \                     ??zcl_SendConfigReportRspCmd_1:
   \   000082   85..82       MOV     DPL,?V0 + 2
   \   000085   85..83       MOV     DPH,?V0 + 3
   \   000088   E0           MOVX    A,@DPTR
   \   000089   F8           MOV     R0,A
   \   00008A   EA           MOV     A,R2
   \   00008B   C3           CLR     C
   \   00008C   98           SUBB    A,R0
   \   00008D   4003         JC      $+5
   \   00008F   02....       LJMP    ??zcl_SendConfigReportRspCmd_2 & 0xFFFF
   1157              {
   1158                *pBuf++ = cfgReportRspCmd->attrList[i].status;
   \   000092   EA           MOV     A,R2
   \   000093   F8           MOV     R0,A
   \   000094   7900         MOV     R1,#0x0
   \   000096   E8           MOV     A,R0
   \   000097   75F004       MOV     B,#0x4
   \   00009A   A4           MUL     AB
   \   00009B   C8           XCH     A,R0
   \   00009C   ABF0         MOV     R3,B
   \   00009E   75F000       MOV     B,#0x0
   \   0000A1   A4           MUL     AB
   \   0000A2   2B           ADD     A,R3
   \   0000A3   FB           MOV     R3,A
   \   0000A4   75F004       MOV     B,#0x4
   \   0000A7   E9           MOV     A,R1
   \   0000A8   A4           MUL     AB
   \   0000A9   2B           ADD     A,R3
   \   0000AA   F9           MOV     R1,A
   \   0000AB   E5..         MOV     A,?V0 + 2
   \   0000AD   28           ADD     A,R0
   \   0000AE   F582         MOV     DPL,A
   \   0000B0   E5..         MOV     A,?V0 + 3
   \   0000B2   39           ADDC    A,R1
   \   0000B3   F583         MOV     DPH,A
   \   0000B5   A3           INC     DPTR
   \   0000B6   E0           MOVX    A,@DPTR
   \   0000B7   8E82         MOV     DPL,R6
   \   0000B9   8F83         MOV     DPH,R7
   \   0000BB   F0           MOVX    @DPTR,A
   \   0000BC   8E82         MOV     DPL,R6
   \   0000BE   8F83         MOV     DPH,R7
   \   0000C0   A3           INC     DPTR
   \   0000C1   AE82         MOV     R6,DPL
   \   0000C3   AF83         MOV     R7,DPH
   1159                *pBuf++ = cfgReportRspCmd->attrList[i].direction;
   \   0000C5   EA           MOV     A,R2
   \   0000C6   F8           MOV     R0,A
   \   0000C7   7900         MOV     R1,#0x0
   \   0000C9   E8           MOV     A,R0
   \   0000CA   75F004       MOV     B,#0x4
   \   0000CD   A4           MUL     AB
   \   0000CE   C8           XCH     A,R0
   \   0000CF   ABF0         MOV     R3,B
   \   0000D1   75F000       MOV     B,#0x0
   \   0000D4   A4           MUL     AB
   \   0000D5   2B           ADD     A,R3
   \   0000D6   FB           MOV     R3,A
   \   0000D7   75F004       MOV     B,#0x4
   \   0000DA   E9           MOV     A,R1
   \   0000DB   A4           MUL     AB
   \   0000DC   2B           ADD     A,R3
   \   0000DD   F9           MOV     R1,A
   \   0000DE   E5..         MOV     A,?V0 + 2
   \   0000E0   28           ADD     A,R0
   \   0000E1   F582         MOV     DPL,A
   \   0000E3   E5..         MOV     A,?V0 + 3
   \   0000E5   39           ADDC    A,R1
   \   0000E6   F583         MOV     DPH,A
   \   0000E8   A3           INC     DPTR
   \   0000E9   A3           INC     DPTR
   \   0000EA   E0           MOVX    A,@DPTR
   \   0000EB   8E82         MOV     DPL,R6
   \   0000ED   8F83         MOV     DPH,R7
   \   0000EF   F0           MOVX    @DPTR,A
   \   0000F0   8E82         MOV     DPL,R6
   \   0000F2   8F83         MOV     DPH,R7
   \   0000F4   A3           INC     DPTR
   \   0000F5   AE82         MOV     R6,DPL
   \   0000F7   AF83         MOV     R7,DPH
   1160                *pBuf++ = LO_UINT16( cfgReportRspCmd->attrList[i].attrID );
   \   0000F9   EA           MOV     A,R2
   \   0000FA   F8           MOV     R0,A
   \   0000FB   7900         MOV     R1,#0x0
   \   0000FD   E8           MOV     A,R0
   \   0000FE   75F004       MOV     B,#0x4
   \   000101   A4           MUL     AB
   \   000102   C8           XCH     A,R0
   \   000103   ABF0         MOV     R3,B
   \   000105   75F000       MOV     B,#0x0
   \   000108   A4           MUL     AB
   \   000109   2B           ADD     A,R3
   \   00010A   FB           MOV     R3,A
   \   00010B   75F004       MOV     B,#0x4
   \   00010E   E9           MOV     A,R1
   \   00010F   A4           MUL     AB
   \   000110   2B           ADD     A,R3
   \   000111   F9           MOV     R1,A
   \   000112   E5..         MOV     A,?V0 + 2
   \   000114   28           ADD     A,R0
   \   000115   F582         MOV     DPL,A
   \   000117   E5..         MOV     A,?V0 + 3
   \   000119   39           ADDC    A,R1
   \   00011A   F583         MOV     DPH,A
   \   00011C   A3           INC     DPTR
   \   00011D   A3           INC     DPTR
   \   00011E   A3           INC     DPTR
   \   00011F   E0           MOVX    A,@DPTR
   \   000120   F8           MOV     R0,A
   \   000121   A3           INC     DPTR
   \   000122   E0           MOVX    A,@DPTR
   \   000123   F9           MOV     R1,A
   \   000124   E8           MOV     A,R0
   \   000125   8E82         MOV     DPL,R6
   \   000127   8F83         MOV     DPH,R7
   \   000129   F0           MOVX    @DPTR,A
   \   00012A   8E82         MOV     DPL,R6
   \   00012C   8F83         MOV     DPH,R7
   \   00012E   A3           INC     DPTR
   \   00012F   AE82         MOV     R6,DPL
   \   000131   AF83         MOV     R7,DPH
   1161                *pBuf++ = HI_UINT16( cfgReportRspCmd->attrList[i].attrID );
   \   000133   EA           MOV     A,R2
   \   000134   F8           MOV     R0,A
   \   000135   7900         MOV     R1,#0x0
   \   000137   E8           MOV     A,R0
   \   000138   75F004       MOV     B,#0x4
   \   00013B   A4           MUL     AB
   \   00013C   C8           XCH     A,R0
   \   00013D   ABF0         MOV     R3,B
   \   00013F   75F000       MOV     B,#0x0
   \   000142   A4           MUL     AB
   \   000143   2B           ADD     A,R3
   \   000144   FB           MOV     R3,A
   \   000145   75F004       MOV     B,#0x4
   \   000148   E9           MOV     A,R1
   \   000149   A4           MUL     AB
   \   00014A   2B           ADD     A,R3
   \   00014B   F9           MOV     R1,A
   \   00014C   E5..         MOV     A,?V0 + 2
   \   00014E   28           ADD     A,R0
   \   00014F   F582         MOV     DPL,A
   \   000151   E5..         MOV     A,?V0 + 3
   \   000153   39           ADDC    A,R1
   \   000154   F583         MOV     DPH,A
   \   000156   A3           INC     DPTR
   \   000157   A3           INC     DPTR
   \   000158   A3           INC     DPTR
   \   000159   E0           MOVX    A,@DPTR
   \   00015A   F8           MOV     R0,A
   \   00015B   A3           INC     DPTR
   \   00015C   E0           MOVX    A,@DPTR
   \   00015D   F9           MOV     R1,A
   \   00015E   E4           CLR     A
   \   00015F   E9           MOV     A,R1
   \   000160   F8           MOV     R0,A
   \   000161   8E82         MOV     DPL,R6
   \   000163   8F83         MOV     DPH,R7
   \   000165   F0           MOVX    @DPTR,A
   \   000166   8E82         MOV     DPL,R6
   \   000168   8F83         MOV     DPH,R7
   \   00016A   A3           INC     DPTR
   \   00016B   AE82         MOV     R6,DPL
   \   00016D   AF83         MOV     R7,DPH
   1162              }
   \   00016F   0A           INC     R2
   \   000170   02....       LJMP    ??zcl_SendConfigReportRspCmd_1 & 0xFFFF
   1163          
   1164              // If there's only a single status record and its status field is set to
   1165              // SUCCESS then omit the attribute ID field.
   1166              if ( cfgReportRspCmd->numAttr == 1 && cfgReportRspCmd->attrList[0].status == ZCL_STATUS_SUCCESS )
   \                     ??zcl_SendConfigReportRspCmd_2:
   \   000173   85..82       MOV     DPL,?V0 + 2
   \   000176   85..83       MOV     DPH,?V0 + 3
   \   000179   E0           MOVX    A,@DPTR
   \   00017A   6401         XRL     A,#0x1
   \   00017C   7010         JNZ     ??zcl_SendConfigReportRspCmd_3
   \   00017E   85..82       MOV     DPL,?V0 + 2
   \   000181   85..83       MOV     DPH,?V0 + 3
   \   000184   A3           INC     DPTR
   \   000185   E0           MOVX    A,@DPTR
   \   000186   7006         JNZ     ??zcl_SendConfigReportRspCmd_3
   1167              {
   1168                dataLen = 1;
   \   000188   75..01       MOV     ?V0 + 0,#0x1
   \   00018B   75..00       MOV     ?V0 + 1,#0x0
   1169              }
   1170          
   1171              status = zcl_SendCommand( srcEP, dstAddr, clusterID,
   1172                                        ZCL_CMD_CONFIG_REPORT_RSP, FALSE, direction,
   1173                                        disableDefaultRsp, 0, seqNum, dataLen, buf );
   \                     ??zcl_SendConfigReportRspCmd_3:
   \   00018E                ; Setup parameters for call to function zcl_SendCommand
   \   00018E   78..         MOV     R0,#?V0 + 6
   \   000190   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000193   78..         MOV     R0,#?V0 + 0
   \   000195   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000198   E5..         MOV     A,?V0 + 8
   \   00019A   F5..         MOV     ?V0 + 10,A
   \   00019C   78..         MOV     R0,#?V0 + 10
   \   00019E   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0001A1   E4           CLR     A
   \   0001A2   F5..         MOV     ?V0 + 10,A
   \   0001A4   F5..         MOV     ?V0 + 11,A
   \   0001A6   78..         MOV     R0,#?V0 + 10
   \   0001A8   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0001AB   E5..         MOV     A,?V0 + 9
   \   0001AD   F5..         MOV     ?V0 + 10,A
   \   0001AF   78..         MOV     R0,#?V0 + 10
   \   0001B1   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0001B4   E5..         MOV     A,?V0 + 12
   \   0001B6   F5..         MOV     ?V0 + 10,A
   \   0001B8   78..         MOV     R0,#?V0 + 10
   \   0001BA   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0001BD   75..00       MOV     ?V0 + 10,#0x0
   \   0001C0   78..         MOV     R0,#?V0 + 10
   \   0001C2   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0001C5   75..07       MOV     ?V0 + 10,#0x7
   \   0001C8   78..         MOV     R0,#?V0 + 10
   \   0001CA   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0001CD   AC..         MOV     R4,?V0 + 14
   \   0001CF   AD..         MOV     R5,?V0 + 15
   \   0001D1   740B         MOV     A,#0xb
   \   0001D3   12....       LCALL   ?XSTACK_DISP0_8
   \   0001D6   E0           MOVX    A,@DPTR
   \   0001D7   FA           MOV     R2,A
   \   0001D8   A3           INC     DPTR
   \   0001D9   E0           MOVX    A,@DPTR
   \   0001DA   FB           MOV     R3,A
   \   0001DB   A9..         MOV     R1,?V0 + 5
   \   0001DD   12....       LCALL   ??zcl_SendCommand?relay
   \   0001E0   740B         MOV     A,#0xb
   \   0001E2   12....       LCALL   ?DEALLOC_XSTACK8
   \   0001E5   E9           MOV     A,R1
   \   0001E6   F5..         MOV     ?V0 + 4,A
   1174              osal_mem_free( buf );
   \   0001E8                ; Setup parameters for call to function osal_mem_free
   \   0001E8   AA..         MOV     R2,?V0 + 6
   \   0001EA   AB..         MOV     R3,?V0 + 7
   \   0001EC   12....       LCALL   ??osal_mem_free?relay
   \   0001EF   8003         SJMP    ??zcl_SendConfigReportRspCmd_4
   1175            }
   1176            else
   1177            {
   1178              status = ZMemError;
   \                     ??zcl_SendConfigReportRspCmd_0:
   \   0001F1   75..10       MOV     ?V0 + 4,#0x10
   1179            }
   1180          
   1181            return ( status );
   \                     ??zcl_SendConfigReportRspCmd_4:
   \   0001F4   A9..         MOV     R1,?V0 + 4
   \   0001F6   7402         MOV     A,#0x2
   \   0001F8   12....       LCALL   ?DEALLOC_XSTACK8
   \   0001FB   7F10         MOV     R7,#0x10
   \   0001FD   02....       LJMP    ?BANKED_LEAVE_XDATA
   1182          }
   1183          
   1184          /*********************************************************************
   1185           * @fn      zcl_SendReadReportCfgCmd
   1186           *
   1187           * @brief   Send a Read Reporting Configuration command
   1188           *
   1189           * @param   dstAddr - destination address
   1190           * @param   clusterID - cluster ID
   1191           * @param   readReportCfgCmd - read reporting configuration command to be sent
   1192           * @param   direction - direction of the command
   1193           * @param   seqNum - transaction sequence number
   1194           *
   1195           * @return  ZSuccess if OK
   1196           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1197          ZStatus_t zcl_SendReadReportCfgCmd( uint8 srcEP, afAddrType_t *dstAddr,
   \                     zcl_SendReadReportCfgCmd:
   1198                            uint16 clusterID, zclReadReportCfgCmd_t *readReportCfgCmd,
   1199                            uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1200          {
   \   000000   74E8         MOV     A,#-0x18
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 24
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   85..82       MOV     DPL,?XSP + 0
   \   00000D   85..83       MOV     DPH,?XSP + 1
   \   000010   EA           MOV     A,R2
   \   000011   F0           MOVX    @DPTR,A
   \   000012   A3           INC     DPTR
   \   000013   EB           MOV     A,R3
   \   000014   F0           MOVX    @DPTR,A
   \   000015   89..         MOV     ?V0 + 5,R1
   \   000017   8C..         MOV     ?V0 + 14,R4
   \   000019   8D..         MOV     ?V0 + 15,R5
   \   00001B   741A         MOV     A,#0x1a
   \   00001D   12....       LCALL   ?XSTACK_DISP0_8
   \   000020   E0           MOVX    A,@DPTR
   \   000021   F5..         MOV     ?V0 + 2,A
   \   000023   A3           INC     DPTR
   \   000024   E0           MOVX    A,@DPTR
   \   000025   F5..         MOV     ?V0 + 3,A
   \   000027   741C         MOV     A,#0x1c
   \   000029   12....       LCALL   ?XSTACK_DISP0_8
   \   00002C   E0           MOVX    A,@DPTR
   \   00002D   F5..         MOV     ?V0 + 12,A
   \   00002F   741D         MOV     A,#0x1d
   \   000031   12....       LCALL   ?XSTACK_DISP0_8
   \   000034   E0           MOVX    A,@DPTR
   \   000035   F5..         MOV     ?V0 + 9,A
   \   000037   741E         MOV     A,#0x1e
   \   000039   12....       LCALL   ?XSTACK_DISP0_8
   \   00003C   E0           MOVX    A,@DPTR
   \   00003D   F5..         MOV     ?V0 + 8,A
   1201            uint16 dataLen;
   1202            uint8 *buf;
   1203            ZStatus_t status;
   1204          
   1205            dataLen = readReportCfgCmd->numAttr * ( 1 + 2 ); // Direction + Atrribute ID
   \   00003F   85..82       MOV     DPL,?V0 + 2
   \   000042   85..83       MOV     DPH,?V0 + 3
   \   000045   E0           MOVX    A,@DPTR
   \   000046   F8           MOV     R0,A
   \   000047   7900         MOV     R1,#0x0
   \   000049   E8           MOV     A,R0
   \   00004A   75F003       MOV     B,#0x3
   \   00004D   A4           MUL     AB
   \   00004E   C8           XCH     A,R0
   \   00004F   AAF0         MOV     R2,B
   \   000051   75F000       MOV     B,#0x0
   \   000054   A4           MUL     AB
   \   000055   2A           ADD     A,R2
   \   000056   FA           MOV     R2,A
   \   000057   75F003       MOV     B,#0x3
   \   00005A   E9           MOV     A,R1
   \   00005B   A4           MUL     AB
   \   00005C   2A           ADD     A,R2
   \   00005D   F9           MOV     R1,A
   \   00005E   88..         MOV     ?V0 + 0,R0
   \   000060   89..         MOV     ?V0 + 1,R1
   1206          
   1207            buf = osal_mem_alloc( dataLen );
   \   000062                ; Setup parameters for call to function osal_mem_alloc
   \   000062   AA..         MOV     R2,?V0 + 0
   \   000064   AB..         MOV     R3,?V0 + 1
   \   000066   12....       LCALL   ??osal_mem_alloc?relay
   \   000069   8A..         MOV     ?V0 + 10,R2
   \   00006B   8B..         MOV     ?V0 + 11,R3
   \   00006D   85....       MOV     ?V0 + 6,?V0 + 10
   \   000070   85....       MOV     ?V0 + 7,?V0 + 11
   1208            if ( buf != NULL )
   \   000073   E5..         MOV     A,?V0 + 6
   \   000075   45..         ORL     A,?V0 + 7
   \   000077   7003         JNZ     $+5
   \   000079   02....       LJMP    ??zcl_SendReadReportCfgCmd_0 & 0xFFFF
   1209            {
   1210              // Load the buffer - serially
   1211              uint8 *pBuf = buf;
   \   00007C   AE..         MOV     R6,?V0 + 6
   \   00007E   AF..         MOV     R7,?V0 + 7
   1212              for ( uint8 i = 0; i < readReportCfgCmd->numAttr; i++ )
   \   000080   7A00         MOV     R2,#0x0
   \                     ??zcl_SendReadReportCfgCmd_1:
   \   000082   85..82       MOV     DPL,?V0 + 2
   \   000085   85..83       MOV     DPH,?V0 + 3
   \   000088   E0           MOVX    A,@DPTR
   \   000089   F8           MOV     R0,A
   \   00008A   EA           MOV     A,R2
   \   00008B   C3           CLR     C
   \   00008C   98           SUBB    A,R0
   \   00008D   4003         JC      $+5
   \   00008F   02....       LJMP    ??zcl_SendReadReportCfgCmd_2 & 0xFFFF
   1213              {
   1214                *pBuf++ = readReportCfgCmd->attrList[i].direction;
   \   000092   EA           MOV     A,R2
   \   000093   F8           MOV     R0,A
   \   000094   7900         MOV     R1,#0x0
   \   000096   E8           MOV     A,R0
   \   000097   75F003       MOV     B,#0x3
   \   00009A   A4           MUL     AB
   \   00009B   C8           XCH     A,R0
   \   00009C   ABF0         MOV     R3,B
   \   00009E   75F000       MOV     B,#0x0
   \   0000A1   A4           MUL     AB
   \   0000A2   2B           ADD     A,R3
   \   0000A3   FB           MOV     R3,A
   \   0000A4   75F003       MOV     B,#0x3
   \   0000A7   E9           MOV     A,R1
   \   0000A8   A4           MUL     AB
   \   0000A9   2B           ADD     A,R3
   \   0000AA   F9           MOV     R1,A
   \   0000AB   E5..         MOV     A,?V0 + 2
   \   0000AD   28           ADD     A,R0
   \   0000AE   F582         MOV     DPL,A
   \   0000B0   E5..         MOV     A,?V0 + 3
   \   0000B2   39           ADDC    A,R1
   \   0000B3   F583         MOV     DPH,A
   \   0000B5   A3           INC     DPTR
   \   0000B6   E0           MOVX    A,@DPTR
   \   0000B7   8E82         MOV     DPL,R6
   \   0000B9   8F83         MOV     DPH,R7
   \   0000BB   F0           MOVX    @DPTR,A
   \   0000BC   8E82         MOV     DPL,R6
   \   0000BE   8F83         MOV     DPH,R7
   \   0000C0   A3           INC     DPTR
   \   0000C1   AE82         MOV     R6,DPL
   \   0000C3   AF83         MOV     R7,DPH
   1215                *pBuf++ = LO_UINT16( readReportCfgCmd->attrList[i].attrID );
   \   0000C5   EA           MOV     A,R2
   \   0000C6   F8           MOV     R0,A
   \   0000C7   7900         MOV     R1,#0x0
   \   0000C9   E8           MOV     A,R0
   \   0000CA   75F003       MOV     B,#0x3
   \   0000CD   A4           MUL     AB
   \   0000CE   C8           XCH     A,R0
   \   0000CF   ABF0         MOV     R3,B
   \   0000D1   75F000       MOV     B,#0x0
   \   0000D4   A4           MUL     AB
   \   0000D5   2B           ADD     A,R3
   \   0000D6   FB           MOV     R3,A
   \   0000D7   75F003       MOV     B,#0x3
   \   0000DA   E9           MOV     A,R1
   \   0000DB   A4           MUL     AB
   \   0000DC   2B           ADD     A,R3
   \   0000DD   F9           MOV     R1,A
   \   0000DE   E5..         MOV     A,?V0 + 2
   \   0000E0   28           ADD     A,R0
   \   0000E1   F582         MOV     DPL,A
   \   0000E3   E5..         MOV     A,?V0 + 3
   \   0000E5   39           ADDC    A,R1
   \   0000E6   F583         MOV     DPH,A
   \   0000E8   A3           INC     DPTR
   \   0000E9   A3           INC     DPTR
   \   0000EA   E0           MOVX    A,@DPTR
   \   0000EB   F8           MOV     R0,A
   \   0000EC   A3           INC     DPTR
   \   0000ED   E0           MOVX    A,@DPTR
   \   0000EE   F9           MOV     R1,A
   \   0000EF   E8           MOV     A,R0
   \   0000F0   8E82         MOV     DPL,R6
   \   0000F2   8F83         MOV     DPH,R7
   \   0000F4   F0           MOVX    @DPTR,A
   \   0000F5   8E82         MOV     DPL,R6
   \   0000F7   8F83         MOV     DPH,R7
   \   0000F9   A3           INC     DPTR
   \   0000FA   AE82         MOV     R6,DPL
   \   0000FC   AF83         MOV     R7,DPH
   1216                *pBuf++ = HI_UINT16( readReportCfgCmd->attrList[i].attrID );
   \   0000FE   EA           MOV     A,R2
   \   0000FF   F8           MOV     R0,A
   \   000100   7900         MOV     R1,#0x0
   \   000102   E8           MOV     A,R0
   \   000103   75F003       MOV     B,#0x3
   \   000106   A4           MUL     AB
   \   000107   C8           XCH     A,R0
   \   000108   ABF0         MOV     R3,B
   \   00010A   75F000       MOV     B,#0x0
   \   00010D   A4           MUL     AB
   \   00010E   2B           ADD     A,R3
   \   00010F   FB           MOV     R3,A
   \   000110   75F003       MOV     B,#0x3
   \   000113   E9           MOV     A,R1
   \   000114   A4           MUL     AB
   \   000115   2B           ADD     A,R3
   \   000116   F9           MOV     R1,A
   \   000117   E5..         MOV     A,?V0 + 2
   \   000119   28           ADD     A,R0
   \   00011A   F582         MOV     DPL,A
   \   00011C   E5..         MOV     A,?V0 + 3
   \   00011E   39           ADDC    A,R1
   \   00011F   F583         MOV     DPH,A
   \   000121   A3           INC     DPTR
   \   000122   A3           INC     DPTR
   \   000123   E0           MOVX    A,@DPTR
   \   000124   F8           MOV     R0,A
   \   000125   A3           INC     DPTR
   \   000126   E0           MOVX    A,@DPTR
   \   000127   F9           MOV     R1,A
   \   000128   E4           CLR     A
   \   000129   E9           MOV     A,R1
   \   00012A   F8           MOV     R0,A
   \   00012B   8E82         MOV     DPL,R6
   \   00012D   8F83         MOV     DPH,R7
   \   00012F   F0           MOVX    @DPTR,A
   \   000130   8E82         MOV     DPL,R6
   \   000132   8F83         MOV     DPH,R7
   \   000134   A3           INC     DPTR
   \   000135   AE82         MOV     R6,DPL
   \   000137   AF83         MOV     R7,DPH
   1217              }
   \   000139   0A           INC     R2
   \   00013A   02....       LJMP    ??zcl_SendReadReportCfgCmd_1 & 0xFFFF
   1218          
   1219              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_READ_REPORT_CFG, FALSE,
   1220                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   \                     ??zcl_SendReadReportCfgCmd_2:
   \   00013D                ; Setup parameters for call to function zcl_SendCommand
   \   00013D   78..         MOV     R0,#?V0 + 6
   \   00013F   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000142   78..         MOV     R0,#?V0 + 0
   \   000144   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000147   E5..         MOV     A,?V0 + 8
   \   000149   F5..         MOV     ?V0 + 10,A
   \   00014B   78..         MOV     R0,#?V0 + 10
   \   00014D   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000150   E4           CLR     A
   \   000151   F5..         MOV     ?V0 + 10,A
   \   000153   F5..         MOV     ?V0 + 11,A
   \   000155   78..         MOV     R0,#?V0 + 10
   \   000157   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00015A   E5..         MOV     A,?V0 + 9
   \   00015C   F5..         MOV     ?V0 + 10,A
   \   00015E   78..         MOV     R0,#?V0 + 10
   \   000160   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000163   E5..         MOV     A,?V0 + 12
   \   000165   F5..         MOV     ?V0 + 10,A
   \   000167   78..         MOV     R0,#?V0 + 10
   \   000169   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00016C   75..00       MOV     ?V0 + 10,#0x0
   \   00016F   78..         MOV     R0,#?V0 + 10
   \   000171   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000174   75..08       MOV     ?V0 + 10,#0x8
   \   000177   78..         MOV     R0,#?V0 + 10
   \   000179   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00017C   AC..         MOV     R4,?V0 + 14
   \   00017E   AD..         MOV     R5,?V0 + 15
   \   000180   740B         MOV     A,#0xb
   \   000182   12....       LCALL   ?XSTACK_DISP0_8
   \   000185   E0           MOVX    A,@DPTR
   \   000186   FA           MOV     R2,A
   \   000187   A3           INC     DPTR
   \   000188   E0           MOVX    A,@DPTR
   \   000189   FB           MOV     R3,A
   \   00018A   A9..         MOV     R1,?V0 + 5
   \   00018C   12....       LCALL   ??zcl_SendCommand?relay
   \   00018F   740B         MOV     A,#0xb
   \   000191   12....       LCALL   ?DEALLOC_XSTACK8
   \   000194   E9           MOV     A,R1
   \   000195   F5..         MOV     ?V0 + 4,A
   1221              osal_mem_free( buf );
   \   000197                ; Setup parameters for call to function osal_mem_free
   \   000197   AA..         MOV     R2,?V0 + 6
   \   000199   AB..         MOV     R3,?V0 + 7
   \   00019B   12....       LCALL   ??osal_mem_free?relay
   \   00019E   8003         SJMP    ??zcl_SendReadReportCfgCmd_3
   1222            }
   1223            else
   1224            {
   1225              status = ZMemError;
   \                     ??zcl_SendReadReportCfgCmd_0:
   \   0001A0   75..10       MOV     ?V0 + 4,#0x10
   1226            }
   1227          
   1228            return ( status );
   \                     ??zcl_SendReadReportCfgCmd_3:
   \   0001A3   A9..         MOV     R1,?V0 + 4
   \   0001A5   7402         MOV     A,#0x2
   \   0001A7   12....       LCALL   ?DEALLOC_XSTACK8
   \   0001AA   7F10         MOV     R7,#0x10
   \   0001AC   02....       LJMP    ?BANKED_LEAVE_XDATA
   1229          }
   1230          
   1231          /*********************************************************************
   1232           * @fn      zcl_SendReadReportCfgRspCmd
   1233           *
   1234           * @brief   Send a Read Reporting Configuration Response command
   1235           *
   1236           * @param   dstAddr - destination address
   1237           * @param   clusterID - cluster ID
   1238           * @param   readReportCfgRspCmd - read reporting configuration response command to be sent
   1239           * @param   direction - direction of the command
   1240           * @param   seqNum - transaction sequence number
   1241           *
   1242           * @return  ZSuccess if OK
   1243           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1244          ZStatus_t zcl_SendReadReportCfgRspCmd( uint8 srcEP, afAddrType_t *dstAddr,
   \                     zcl_SendReadReportCfgRspCmd:
   1245                       uint16 clusterID, zclReadReportCfgRspCmd_t *readReportCfgRspCmd,
   1246                       uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1247          {
   \   000000   74E8         MOV     A,#-0x18
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 24
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV     A,#-0x4
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   7402         MOV     A,#0x2
   \   00000C   12....       LCALL   ?XSTACK_DISP0_8
   \   00000F   EA           MOV     A,R2
   \   000010   F0           MOVX    @DPTR,A
   \   000011   A3           INC     DPTR
   \   000012   EB           MOV     A,R3
   \   000013   F0           MOVX    @DPTR,A
   \   000014   85..82       MOV     DPL,?XSP + 0
   \   000017   85..83       MOV     DPH,?XSP + 1
   \   00001A   EC           MOV     A,R4
   \   00001B   F0           MOVX    @DPTR,A
   \   00001C   A3           INC     DPTR
   \   00001D   ED           MOV     A,R5
   \   00001E   F0           MOVX    @DPTR,A
   \   00001F   89..         MOV     ?V0 + 12,R1
   \   000021   741C         MOV     A,#0x1c
   \   000023   12....       LCALL   ?XSTACK_DISP0_8
   \   000026   E0           MOVX    A,@DPTR
   \   000027   F5..         MOV     ?V0 + 8,A
   \   000029   A3           INC     DPTR
   \   00002A   E0           MOVX    A,@DPTR
   \   00002B   F5..         MOV     ?V0 + 9,A
   \   00002D   741E         MOV     A,#0x1e
   \   00002F   12....       LCALL   ?XSTACK_DISP0_8
   \   000032   E0           MOVX    A,@DPTR
   \   000033   F5..         MOV     ?V0 + 15,A
   \   000035   741F         MOV     A,#0x1f
   \   000037   12....       LCALL   ?XSTACK_DISP0_8
   \   00003A   E0           MOVX    A,@DPTR
   \   00003B   F5..         MOV     ?V0 + 14,A
   \   00003D   7420         MOV     A,#0x20
   \   00003F   12....       LCALL   ?XSTACK_DISP0_8
   \   000042   E0           MOVX    A,@DPTR
   \   000043   F5..         MOV     ?V0 + 13,A
   1248            uint8 *buf;
   1249            uint16 dataLen = 0;
   \   000045   75..00       MOV     ?V0 + 2,#0x0
   \   000048   75..00       MOV     ?V0 + 3,#0x0
   1250            ZStatus_t status;
   1251          
   1252            // Find out the data length
   1253            for ( uint8 i = 0; i < readReportCfgRspCmd->numAttr; i++ )
   \   00004B   75..00       MOV     ?V0 + 0,#0x0
   \                     ??zcl_SendReadReportCfgRspCmd_0:
   \   00004E   85..82       MOV     DPL,?V0 + 8
   \   000051   85..83       MOV     DPH,?V0 + 9
   \   000054   E0           MOVX    A,@DPTR
   \   000055   F8           MOV     R0,A
   \   000056   E5..         MOV     A,?V0 + 0
   \   000058   C3           CLR     C
   \   000059   98           SUBB    A,R0
   \   00005A   4003         JC      $+5
   \   00005C   02....       LJMP    ??zcl_SendReadReportCfgRspCmd_1 & 0xFFFF
   1254            {
   1255              zclReportCfgRspRec_t *reportRspRec = &(readReportCfgRspCmd->attrList[i]);
   \   00005F   E5..         MOV     A,?V0 + 0
   \   000061   A8..         MOV     R0,?V0 + 0
   \   000063   7900         MOV     R1,#0x0
   \   000065   E8           MOV     A,R0
   \   000066   75F00D       MOV     B,#0xd
   \   000069   A4           MUL     AB
   \   00006A   C8           XCH     A,R0
   \   00006B   AAF0         MOV     R2,B
   \   00006D   75F000       MOV     B,#0x0
   \   000070   A4           MUL     AB
   \   000071   2A           ADD     A,R2
   \   000072   FA           MOV     R2,A
   \   000073   75F00D       MOV     B,#0xd
   \   000076   E9           MOV     A,R1
   \   000077   A4           MUL     AB
   \   000078   2A           ADD     A,R2
   \   000079   F9           MOV     R1,A
   \   00007A   E5..         MOV     A,?V0 + 8
   \   00007C   28           ADD     A,R0
   \   00007D   F582         MOV     DPL,A
   \   00007F   E5..         MOV     A,?V0 + 9
   \   000081   39           ADDC    A,R1
   \   000082   F583         MOV     DPH,A
   \   000084   A3           INC     DPTR
   \   000085   AE82         MOV     R6,DPL
   \   000087   AF83         MOV     R7,DPH
   1256          
   1257              dataLen += 1 + 1 + 2 ; // Status, Direction and Atrribute ID
   \   000089   E5..         MOV     A,?V0 + 2
   \   00008B   2404         ADD     A,#0x4
   \   00008D   F5..         MOV     ?V0 + 2,A
   \   00008F   E5..         MOV     A,?V0 + 3
   \   000091   3400         ADDC    A,#0x0
   \   000093   F5..         MOV     ?V0 + 3,A
   1258          
   1259              if ( reportRspRec->status == ZCL_STATUS_SUCCESS )
   \   000095   8E82         MOV     DPL,R6
   \   000097   8F83         MOV     DPH,R7
   \   000099   E0           MOVX    A,@DPTR
   \   00009A   704D         JNZ     ??zcl_SendReadReportCfgRspCmd_2
   1260              {
   1261                if ( reportRspRec->direction == ZCL_SEND_ATTR_REPORTS )
   \   00009C   8E82         MOV     DPL,R6
   \   00009E   8F83         MOV     DPH,R7
   \   0000A0   A3           INC     DPTR
   \   0000A1   E0           MOVX    A,@DPTR
   \   0000A2   7039         JNZ     ??zcl_SendReadReportCfgRspCmd_3
   1262                {
   1263                  dataLen += 1 + 2 + 2; // Data Type + Min + Max Reporting Intervals
   \   0000A4   E5..         MOV     A,?V0 + 2
   \   0000A6   2405         ADD     A,#0x5
   \   0000A8   F5..         MOV     ?V0 + 2,A
   \   0000AA   E5..         MOV     A,?V0 + 3
   \   0000AC   3400         ADDC    A,#0x0
   \   0000AE   F5..         MOV     ?V0 + 3,A
   1264          
   1265                  // Find out the size of the Reportable Change field (for Analog data types)
   1266                  if ( zclAnalogDataType( reportRspRec->dataType ) )
   \   0000B0                ; Setup parameters for call to function zclAnalogDataType
   \   0000B0   8E82         MOV     DPL,R6
   \   0000B2   8F83         MOV     DPH,R7
   \   0000B4   A3           INC     DPTR
   \   0000B5   A3           INC     DPTR
   \   0000B6   A3           INC     DPTR
   \   0000B7   A3           INC     DPTR
   \   0000B8   E0           MOVX    A,@DPTR
   \   0000B9   F9           MOV     R1,A
   \   0000BA   12....       LCALL   ??zclAnalogDataType?relay
   \   0000BD   E9           MOV     A,R1
   \   0000BE   6029         JZ      ??zcl_SendReadReportCfgRspCmd_2
   1267                  {
   1268                    dataLen += zclGetDataTypeLength( reportRspRec->dataType );
   \   0000C0                ; Setup parameters for call to function zclGetDataTypeLength
   \   0000C0   8E82         MOV     DPL,R6
   \   0000C2   8F83         MOV     DPH,R7
   \   0000C4   A3           INC     DPTR
   \   0000C5   A3           INC     DPTR
   \   0000C6   A3           INC     DPTR
   \   0000C7   A3           INC     DPTR
   \   0000C8   E0           MOVX    A,@DPTR
   \   0000C9   F9           MOV     R1,A
   \   0000CA   12....       LCALL   ??zclGetDataTypeLength?relay
   \   0000CD   E9           MOV     A,R1
   \   0000CE   F8           MOV     R0,A
   \   0000CF   7900         MOV     R1,#0x0
   \   0000D1   E5..         MOV     A,?V0 + 2
   \   0000D3   28           ADD     A,R0
   \   0000D4   F5..         MOV     ?V0 + 2,A
   \   0000D6   E5..         MOV     A,?V0 + 3
   \   0000D8   39           ADDC    A,R1
   \   0000D9   F5..         MOV     ?V0 + 3,A
   \   0000DB   800C         SJMP    ??zcl_SendReadReportCfgRspCmd_2
   1269                  }
   1270                }
   1271                else
   1272                {
   1273                  dataLen += 2; // Timeout Period
   \                     ??zcl_SendReadReportCfgRspCmd_3:
   \   0000DD   E5..         MOV     A,?V0 + 2
   \   0000DF   2402         ADD     A,#0x2
   \   0000E1   F5..         MOV     ?V0 + 2,A
   \   0000E3   E5..         MOV     A,?V0 + 3
   \   0000E5   3400         ADDC    A,#0x0
   \   0000E7   F5..         MOV     ?V0 + 3,A
   1274                }
   1275              }
   1276            }
   \                     ??zcl_SendReadReportCfgRspCmd_2:
   \   0000E9   05..         INC     ?V0 + 0
   \   0000EB   02....       LJMP    ??zcl_SendReadReportCfgRspCmd_0 & 0xFFFF
   1277          
   1278            buf = osal_mem_alloc( dataLen );
   \                     ??zcl_SendReadReportCfgRspCmd_1:
   \   0000EE                ; Setup parameters for call to function osal_mem_alloc
   \   0000EE   AA..         MOV     R2,?V0 + 2
   \   0000F0   AB..         MOV     R3,?V0 + 3
   \   0000F2   12....       LCALL   ??osal_mem_alloc?relay
   \   0000F5   8A..         MOV     ?V0 + 0,R2
   \   0000F7   8B..         MOV     ?V0 + 1,R3
   \   0000F9   85....       MOV     ?V0 + 4,?V0 + 0
   \   0000FC   85....       MOV     ?V0 + 5,?V0 + 1
   1279            if ( buf != NULL )
   \   0000FF   E5..         MOV     A,?V0 + 4
   \   000101   45..         ORL     A,?V0 + 5
   \   000103   7003         JNZ     $+5
   \   000105   02....       LJMP    ??zcl_SendReadReportCfgRspCmd_4 & 0xFFFF
   1280            {
   1281              // Load the buffer - serially
   1282              uint8 *pBuf = buf;
   \   000108   AE..         MOV     R6,?V0 + 4
   \   00010A   AF..         MOV     R7,?V0 + 5
   1283              for ( uint8 i = 0; i < readReportCfgRspCmd->numAttr; i++ )
   \   00010C   75..00       MOV     ?V0 + 6,#0x0
   \                     ??zcl_SendReadReportCfgRspCmd_5:
   \   00010F   85..82       MOV     DPL,?V0 + 8
   \   000112   85..83       MOV     DPH,?V0 + 9
   \   000115   E0           MOVX    A,@DPTR
   \   000116   F8           MOV     R0,A
   \   000117   E5..         MOV     A,?V0 + 6
   \   000119   C3           CLR     C
   \   00011A   98           SUBB    A,R0
   \   00011B   4003         JC      $+5
   \   00011D   02....       LJMP    ??zcl_SendReadReportCfgRspCmd_6 & 0xFFFF
   1284              {
   1285                zclReportCfgRspRec_t *reportRspRec = &(readReportCfgRspCmd->attrList[i]);
   \   000120   E5..         MOV     A,?V0 + 6
   \   000122   A8..         MOV     R0,?V0 + 6
   \   000124   7900         MOV     R1,#0x0
   \   000126   E8           MOV     A,R0
   \   000127   75F00D       MOV     B,#0xd
   \   00012A   A4           MUL     AB
   \   00012B   C8           XCH     A,R0
   \   00012C   AAF0         MOV     R2,B
   \   00012E   75F000       MOV     B,#0x0
   \   000131   A4           MUL     AB
   \   000132   2A           ADD     A,R2
   \   000133   FA           MOV     R2,A
   \   000134   75F00D       MOV     B,#0xd
   \   000137   E9           MOV     A,R1
   \   000138   A4           MUL     AB
   \   000139   2A           ADD     A,R2
   \   00013A   F9           MOV     R1,A
   \   00013B   E5..         MOV     A,?V0 + 8
   \   00013D   28           ADD     A,R0
   \   00013E   F582         MOV     DPL,A
   \   000140   E5..         MOV     A,?V0 + 9
   \   000142   39           ADDC    A,R1
   \   000143   F583         MOV     DPH,A
   \   000145   A3           INC     DPTR
   \   000146   8582..       MOV     ?V0 + 0,DPL
   \   000149   8583..       MOV     ?V0 + 1,DPH
   1286          
   1287                *pBuf++ = reportRspRec->status;
   \   00014C   85..82       MOV     DPL,?V0 + 0
   \   00014F   85..83       MOV     DPH,?V0 + 1
   \   000152   E0           MOVX    A,@DPTR
   \   000153   8E82         MOV     DPL,R6
   \   000155   8F83         MOV     DPH,R7
   \   000157   F0           MOVX    @DPTR,A
   \   000158   8E82         MOV     DPL,R6
   \   00015A   8F83         MOV     DPH,R7
   \   00015C   A3           INC     DPTR
   \   00015D   AE82         MOV     R6,DPL
   \   00015F   AF83         MOV     R7,DPH
   1288                *pBuf++ = reportRspRec->direction;
   \   000161   85..82       MOV     DPL,?V0 + 0
   \   000164   85..83       MOV     DPH,?V0 + 1
   \   000167   A3           INC     DPTR
   \   000168   E0           MOVX    A,@DPTR
   \   000169   8E82         MOV     DPL,R6
   \   00016B   8F83         MOV     DPH,R7
   \   00016D   F0           MOVX    @DPTR,A
   \   00016E   8E82         MOV     DPL,R6
   \   000170   8F83         MOV     DPH,R7
   \   000172   A3           INC     DPTR
   \   000173   AE82         MOV     R6,DPL
   \   000175   AF83         MOV     R7,DPH
   1289                *pBuf++ = LO_UINT16( reportRspRec->attrID );
   \   000177   85..82       MOV     DPL,?V0 + 0
   \   00017A   85..83       MOV     DPH,?V0 + 1
   \   00017D   A3           INC     DPTR
   \   00017E   A3           INC     DPTR
   \   00017F   E0           MOVX    A,@DPTR
   \   000180   F8           MOV     R0,A
   \   000181   A3           INC     DPTR
   \   000182   E0           MOVX    A,@DPTR
   \   000183   F9           MOV     R1,A
   \   000184   E8           MOV     A,R0
   \   000185   8E82         MOV     DPL,R6
   \   000187   8F83         MOV     DPH,R7
   \   000189   F0           MOVX    @DPTR,A
   \   00018A   8E82         MOV     DPL,R6
   \   00018C   8F83         MOV     DPH,R7
   \   00018E   A3           INC     DPTR
   \   00018F   AE82         MOV     R6,DPL
   \   000191   AF83         MOV     R7,DPH
   1290                *pBuf++ = HI_UINT16( reportRspRec->attrID );
   \   000193   85..82       MOV     DPL,?V0 + 0
   \   000196   85..83       MOV     DPH,?V0 + 1
   \   000199   A3           INC     DPTR
   \   00019A   A3           INC     DPTR
   \   00019B   E0           MOVX    A,@DPTR
   \   00019C   F8           MOV     R0,A
   \   00019D   A3           INC     DPTR
   \   00019E   E0           MOVX    A,@DPTR
   \   00019F   F9           MOV     R1,A
   \   0001A0   E4           CLR     A
   \   0001A1   E9           MOV     A,R1
   \   0001A2   F8           MOV     R0,A
   \   0001A3   8E82         MOV     DPL,R6
   \   0001A5   8F83         MOV     DPH,R7
   \   0001A7   F0           MOVX    @DPTR,A
   \   0001A8   8E82         MOV     DPL,R6
   \   0001AA   8F83         MOV     DPH,R7
   \   0001AC   A3           INC     DPTR
   \   0001AD   AE82         MOV     R6,DPL
   \   0001AF   AF83         MOV     R7,DPH
   1291          
   1292                if ( reportRspRec->status == ZCL_STATUS_SUCCESS )
   \   0001B1   85..82       MOV     DPL,?V0 + 0
   \   0001B4   85..83       MOV     DPH,?V0 + 1
   \   0001B7   E0           MOVX    A,@DPTR
   \   0001B8   6003         JZ      $+5
   \   0001BA   02....       LJMP    ??zcl_SendReadReportCfgRspCmd_7 & 0xFFFF
   1293                {
   1294                  if ( reportRspRec->direction == ZCL_SEND_ATTR_REPORTS )
   \   0001BD   85..82       MOV     DPL,?V0 + 0
   \   0001C0   85..83       MOV     DPH,?V0 + 1
   \   0001C3   A3           INC     DPTR
   \   0001C4   E0           MOVX    A,@DPTR
   \   0001C5   6003         JZ      $+5
   \   0001C7   02....       LJMP    ??zcl_SendReadReportCfgRspCmd_8 & 0xFFFF
   1295                  {
   1296                    *pBuf++ = reportRspRec->dataType;
   \   0001CA   85..82       MOV     DPL,?V0 + 0
   \   0001CD   85..83       MOV     DPH,?V0 + 1
   \   0001D0   A3           INC     DPTR
   \   0001D1   A3           INC     DPTR
   \   0001D2   A3           INC     DPTR
   \   0001D3   A3           INC     DPTR
   \   0001D4   E0           MOVX    A,@DPTR
   \   0001D5   8E82         MOV     DPL,R6
   \   0001D7   8F83         MOV     DPH,R7
   \   0001D9   F0           MOVX    @DPTR,A
   \   0001DA   8E82         MOV     DPL,R6
   \   0001DC   8F83         MOV     DPH,R7
   \   0001DE   A3           INC     DPTR
   \   0001DF   AE82         MOV     R6,DPL
   \   0001E1   AF83         MOV     R7,DPH
   1297                    *pBuf++ = LO_UINT16( reportRspRec->minReportInt );
   \   0001E3   85..82       MOV     DPL,?V0 + 0
   \   0001E6   85..83       MOV     DPH,?V0 + 1
   \   0001E9   A3           INC     DPTR
   \   0001EA   A3           INC     DPTR
   \   0001EB   A3           INC     DPTR
   \   0001EC   A3           INC     DPTR
   \   0001ED   A3           INC     DPTR
   \   0001EE   E0           MOVX    A,@DPTR
   \   0001EF   F8           MOV     R0,A
   \   0001F0   A3           INC     DPTR
   \   0001F1   E0           MOVX    A,@DPTR
   \   0001F2   F9           MOV     R1,A
   \   0001F3   E8           MOV     A,R0
   \   0001F4   8E82         MOV     DPL,R6
   \   0001F6   8F83         MOV     DPH,R7
   \   0001F8   F0           MOVX    @DPTR,A
   \   0001F9   8E82         MOV     DPL,R6
   \   0001FB   8F83         MOV     DPH,R7
   \   0001FD   A3           INC     DPTR
   \   0001FE   AE82         MOV     R6,DPL
   \   000200   AF83         MOV     R7,DPH
   1298                    *pBuf++ = HI_UINT16( reportRspRec->minReportInt );
   \   000202   85..82       MOV     DPL,?V0 + 0
   \   000205   85..83       MOV     DPH,?V0 + 1
   \   000208   A3           INC     DPTR
   \   000209   A3           INC     DPTR
   \   00020A   A3           INC     DPTR
   \   00020B   A3           INC     DPTR
   \   00020C   A3           INC     DPTR
   \   00020D   E0           MOVX    A,@DPTR
   \   00020E   F8           MOV     R0,A
   \   00020F   A3           INC     DPTR
   \   000210   E0           MOVX    A,@DPTR
   \   000211   F9           MOV     R1,A
   \   000212   E4           CLR     A
   \   000213   E9           MOV     A,R1
   \   000214   F8           MOV     R0,A
   \   000215   8E82         MOV     DPL,R6
   \   000217   8F83         MOV     DPH,R7
   \   000219   F0           MOVX    @DPTR,A
   \   00021A   8E82         MOV     DPL,R6
   \   00021C   8F83         MOV     DPH,R7
   \   00021E   A3           INC     DPTR
   \   00021F   AE82         MOV     R6,DPL
   \   000221   AF83         MOV     R7,DPH
   1299                    *pBuf++ = LO_UINT16( reportRspRec->maxReportInt );
   \   000223   85..82       MOV     DPL,?V0 + 0
   \   000226   85..83       MOV     DPH,?V0 + 1
   \   000229   A3           INC     DPTR
   \   00022A   A3           INC     DPTR
   \   00022B   A3           INC     DPTR
   \   00022C   A3           INC     DPTR
   \   00022D   A3           INC     DPTR
   \   00022E   A3           INC     DPTR
   \   00022F   A3           INC     DPTR
   \   000230   E0           MOVX    A,@DPTR
   \   000231   F8           MOV     R0,A
   \   000232   A3           INC     DPTR
   \   000233   E0           MOVX    A,@DPTR
   \   000234   F9           MOV     R1,A
   \   000235   E8           MOV     A,R0
   \   000236   8E82         MOV     DPL,R6
   \   000238   8F83         MOV     DPH,R7
   \   00023A   F0           MOVX    @DPTR,A
   \   00023B   8E82         MOV     DPL,R6
   \   00023D   8F83         MOV     DPH,R7
   \   00023F   A3           INC     DPTR
   \   000240   AE82         MOV     R6,DPL
   \   000242   AF83         MOV     R7,DPH
   1300                    *pBuf++ = HI_UINT16( reportRspRec->maxReportInt );
   \   000244   85..82       MOV     DPL,?V0 + 0
   \   000247   85..83       MOV     DPH,?V0 + 1
   \   00024A   A3           INC     DPTR
   \   00024B   A3           INC     DPTR
   \   00024C   A3           INC     DPTR
   \   00024D   A3           INC     DPTR
   \   00024E   A3           INC     DPTR
   \   00024F   A3           INC     DPTR
   \   000250   A3           INC     DPTR
   \   000251   E0           MOVX    A,@DPTR
   \   000252   F8           MOV     R0,A
   \   000253   A3           INC     DPTR
   \   000254   E0           MOVX    A,@DPTR
   \   000255   F9           MOV     R1,A
   \   000256   E4           CLR     A
   \   000257   E9           MOV     A,R1
   \   000258   F8           MOV     R0,A
   \   000259   8E82         MOV     DPL,R6
   \   00025B   8F83         MOV     DPH,R7
   \   00025D   F0           MOVX    @DPTR,A
   \   00025E   8E82         MOV     DPL,R6
   \   000260   8F83         MOV     DPH,R7
   \   000262   A3           INC     DPTR
   \   000263   AE82         MOV     R6,DPL
   \   000265   AF83         MOV     R7,DPH
   1301          
   1302                    if ( zclAnalogDataType( reportRspRec->dataType ) )
   \   000267                ; Setup parameters for call to function zclAnalogDataType
   \   000267   85..82       MOV     DPL,?V0 + 0
   \   00026A   85..83       MOV     DPH,?V0 + 1
   \   00026D   A3           INC     DPTR
   \   00026E   A3           INC     DPTR
   \   00026F   A3           INC     DPTR
   \   000270   A3           INC     DPTR
   \   000271   E0           MOVX    A,@DPTR
   \   000272   F9           MOV     R1,A
   \   000273   12....       LCALL   ??zclAnalogDataType?relay
   \   000276   E9           MOV     A,R1
   \   000277   6076         JZ      ??zcl_SendReadReportCfgRspCmd_7
   1303                    {
   1304                      pBuf = zclSerializeData( reportRspRec->dataType,
   1305                                               reportRspRec->reportableChange, pBuf );
   \   000279                ; Setup parameters for call to function zclSerializeData
   \   000279   EE           MOV     A,R6
   \   00027A   FC           MOV     R4,A
   \   00027B   EF           MOV     A,R7
   \   00027C   FD           MOV     R5,A
   \   00027D   E5..         MOV     A,?V0 + 0
   \   00027F   240B         ADD     A,#0xb
   \   000281   F582         MOV     DPL,A
   \   000283   E5..         MOV     A,?V0 + 1
   \   000285   3400         ADDC    A,#0x0
   \   000287   F583         MOV     DPH,A
   \   000289   E0           MOVX    A,@DPTR
   \   00028A   FA           MOV     R2,A
   \   00028B   A3           INC     DPTR
   \   00028C   E0           MOVX    A,@DPTR
   \   00028D   FB           MOV     R3,A
   \   00028E   85..82       MOV     DPL,?V0 + 0
   \   000291   85..83       MOV     DPH,?V0 + 1
   \   000294   A3           INC     DPTR
   \   000295   A3           INC     DPTR
   \   000296   A3           INC     DPTR
   \   000297   A3           INC     DPTR
   \   000298   E0           MOVX    A,@DPTR
   \   000299   F9           MOV     R1,A
   \   00029A   12....       LCALL   ??zclSerializeData?relay
   \   00029D   8A..         MOV     ?V0 + 10,R2
   \   00029F   8B..         MOV     ?V0 + 11,R3
   \   0002A1   AE..         MOV     R6,?V0 + 10
   \   0002A3   AF..         MOV     R7,?V0 + 11
   \   0002A5   8048         SJMP    ??zcl_SendReadReportCfgRspCmd_7
   1306                    }
   1307                  }
   1308                  else
   1309                  {
   1310                    *pBuf++ = LO_UINT16( reportRspRec->timeoutPeriod );
   \                     ??zcl_SendReadReportCfgRspCmd_8:
   \   0002A7   85..82       MOV     DPL,?V0 + 0
   \   0002AA   85..83       MOV     DPH,?V0 + 1
   \   0002AD   A3           INC     DPTR
   \   0002AE   A3           INC     DPTR
   \   0002AF   A3           INC     DPTR
   \   0002B0   A3           INC     DPTR
   \   0002B1   A3           INC     DPTR
   \   0002B2   A3           INC     DPTR
   \   0002B3   A3           INC     DPTR
   \   0002B4   A3           INC     DPTR
   \   0002B5   A3           INC     DPTR
   \   0002B6   E0           MOVX    A,@DPTR
   \   0002B7   F8           MOV     R0,A
   \   0002B8   A3           INC     DPTR
   \   0002B9   E0           MOVX    A,@DPTR
   \   0002BA   F9           MOV     R1,A
   \   0002BB   E8           MOV     A,R0
   \   0002BC   8E82         MOV     DPL,R6
   \   0002BE   8F83         MOV     DPH,R7
   \   0002C0   F0           MOVX    @DPTR,A
   \   0002C1   8E82         MOV     DPL,R6
   \   0002C3   8F83         MOV     DPH,R7
   \   0002C5   A3           INC     DPTR
   \   0002C6   AE82         MOV     R6,DPL
   \   0002C8   AF83         MOV     R7,DPH
   1311                    *pBuf++ = HI_UINT16( reportRspRec->timeoutPeriod );
   \   0002CA   85..82       MOV     DPL,?V0 + 0
   \   0002CD   85..83       MOV     DPH,?V0 + 1
   \   0002D0   A3           INC     DPTR
   \   0002D1   A3           INC     DPTR
   \   0002D2   A3           INC     DPTR
   \   0002D3   A3           INC     DPTR
   \   0002D4   A3           INC     DPTR
   \   0002D5   A3           INC     DPTR
   \   0002D6   A3           INC     DPTR
   \   0002D7   A3           INC     DPTR
   \   0002D8   A3           INC     DPTR
   \   0002D9   E0           MOVX    A,@DPTR
   \   0002DA   F8           MOV     R0,A
   \   0002DB   A3           INC     DPTR
   \   0002DC   E0           MOVX    A,@DPTR
   \   0002DD   F9           MOV     R1,A
   \   0002DE   E4           CLR     A
   \   0002DF   E9           MOV     A,R1
   \   0002E0   F8           MOV     R0,A
   \   0002E1   8E82         MOV     DPL,R6
   \   0002E3   8F83         MOV     DPH,R7
   \   0002E5   F0           MOVX    @DPTR,A
   \   0002E6   8E82         MOV     DPL,R6
   \   0002E8   8F83         MOV     DPH,R7
   \   0002EA   A3           INC     DPTR
   \   0002EB   AE82         MOV     R6,DPL
   \   0002ED   AF83         MOV     R7,DPH
   1312                  }
   1313                }
   1314              }
   \                     ??zcl_SendReadReportCfgRspCmd_7:
   \   0002EF   05..         INC     ?V0 + 6
   \   0002F1   02....       LJMP    ??zcl_SendReadReportCfgRspCmd_5 & 0xFFFF
   1315          
   1316              status = zcl_SendCommand( srcEP, dstAddr, clusterID,
   1317                                        ZCL_CMD_READ_REPORT_CFG_RSP, FALSE,
   1318                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   \                     ??zcl_SendReadReportCfgRspCmd_6:
   \   0002F4                ; Setup parameters for call to function zcl_SendCommand
   \   0002F4   78..         MOV     R0,#?V0 + 4
   \   0002F6   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0002F9   78..         MOV     R0,#?V0 + 2
   \   0002FB   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0002FE   E5..         MOV     A,?V0 + 13
   \   000300   F5..         MOV     ?V0 + 0,A
   \   000302   78..         MOV     R0,#?V0 + 0
   \   000304   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000307   E4           CLR     A
   \   000308   F5..         MOV     ?V0 + 0,A
   \   00030A   F5..         MOV     ?V0 + 1,A
   \   00030C   78..         MOV     R0,#?V0 + 0
   \   00030E   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000311   E5..         MOV     A,?V0 + 14
   \   000313   F5..         MOV     ?V0 + 0,A
   \   000315   78..         MOV     R0,#?V0 + 0
   \   000317   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00031A   E5..         MOV     A,?V0 + 15
   \   00031C   F5..         MOV     ?V0 + 0,A
   \   00031E   78..         MOV     R0,#?V0 + 0
   \   000320   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000323   75..00       MOV     ?V0 + 0,#0x0
   \   000326   78..         MOV     R0,#?V0 + 0
   \   000328   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00032B   75..09       MOV     ?V0 + 0,#0x9
   \   00032E   78..         MOV     R0,#?V0 + 0
   \   000330   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000333   740B         MOV     A,#0xb
   \   000335   12....       LCALL   ?XSTACK_DISP0_8
   \   000338   E0           MOVX    A,@DPTR
   \   000339   FC           MOV     R4,A
   \   00033A   A3           INC     DPTR
   \   00033B   E0           MOVX    A,@DPTR
   \   00033C   FD           MOV     R5,A
   \   00033D   740D         MOV     A,#0xd
   \   00033F   12....       LCALL   ?XSTACK_DISP0_8
   \   000342   E0           MOVX    A,@DPTR
   \   000343   FA           MOV     R2,A
   \   000344   A3           INC     DPTR
   \   000345   E0           MOVX    A,@DPTR
   \   000346   FB           MOV     R3,A
   \   000347   A9..         MOV     R1,?V0 + 12
   \   000349   12....       LCALL   ??zcl_SendCommand?relay
   \   00034C   740B         MOV     A,#0xb
   \   00034E   12....       LCALL   ?DEALLOC_XSTACK8
   \   000351   E9           MOV     A,R1
   \   000352   F5..         MOV     ?V0 + 7,A
   1319              osal_mem_free( buf );
   \   000354                ; Setup parameters for call to function osal_mem_free
   \   000354   AA..         MOV     R2,?V0 + 4
   \   000356   AB..         MOV     R3,?V0 + 5
   \   000358   12....       LCALL   ??osal_mem_free?relay
   \   00035B   8003         SJMP    ??zcl_SendReadReportCfgRspCmd_9
   1320            }
   1321            else
   1322            {
   1323              status = ZMemError;
   \                     ??zcl_SendReadReportCfgRspCmd_4:
   \   00035D   75..10       MOV     ?V0 + 7,#0x10
   1324            }
   1325          
   1326            return ( status );
   \                     ??zcl_SendReadReportCfgRspCmd_9:
   \   000360   A9..         MOV     R1,?V0 + 7
   \   000362   7404         MOV     A,#0x4
   \   000364   12....       LCALL   ?DEALLOC_XSTACK8
   \   000367   7F10         MOV     R7,#0x10
   \   000369   02....       LJMP    ?BANKED_LEAVE_XDATA
   1327          }
   1328          
   1329          /*********************************************************************
   1330           * @fn      zcl_SendReportCmd
   1331           *
   1332           * @brief   Send a Report command
   1333           *
   1334           * @param   dstAddr - destination address
   1335           * @param   clusterID - cluster ID
   1336           * @param   reportCmd - report command to be sent
   1337           * @param   direction - direction of the command
   1338           * @param   seqNum - transaction sequence number
   1339           *
   1340           * @return  ZSuccess if OK
   1341           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1342          ZStatus_t zcl_SendReportCmd( uint8 srcEP, afAddrType_t *dstAddr,
   \                     zcl_SendReportCmd:
   1343                                       uint16 clusterID, zclReportCmd_t *reportCmd,
   1344                                       uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1345          {
   \   000000   74E8         MOV     A,#-0x18
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 24
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV     A,#-0x4
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   7402         MOV     A,#0x2
   \   00000C   12....       LCALL   ?XSTACK_DISP0_8
   \   00000F   EA           MOV     A,R2
   \   000010   F0           MOVX    @DPTR,A
   \   000011   A3           INC     DPTR
   \   000012   EB           MOV     A,R3
   \   000013   F0           MOVX    @DPTR,A
   \   000014   85..82       MOV     DPL,?XSP + 0
   \   000017   85..83       MOV     DPH,?XSP + 1
   \   00001A   EC           MOV     A,R4
   \   00001B   F0           MOVX    @DPTR,A
   \   00001C   A3           INC     DPTR
   \   00001D   ED           MOV     A,R5
   \   00001E   F0           MOVX    @DPTR,A
   \   00001F   89..         MOV     ?V0 + 12,R1
   \   000021   741C         MOV     A,#0x1c
   \   000023   12....       LCALL   ?XSTACK_DISP0_8
   \   000026   E0           MOVX    A,@DPTR
   \   000027   F5..         MOV     ?V0 + 8,A
   \   000029   A3           INC     DPTR
   \   00002A   E0           MOVX    A,@DPTR
   \   00002B   F5..         MOV     ?V0 + 9,A
   \   00002D   741E         MOV     A,#0x1e
   \   00002F   12....       LCALL   ?XSTACK_DISP0_8
   \   000032   E0           MOVX    A,@DPTR
   \   000033   F5..         MOV     ?V0 + 15,A
   \   000035   741F         MOV     A,#0x1f
   \   000037   12....       LCALL   ?XSTACK_DISP0_8
   \   00003A   E0           MOVX    A,@DPTR
   \   00003B   F5..         MOV     ?V0 + 14,A
   \   00003D   7420         MOV     A,#0x20
   \   00003F   12....       LCALL   ?XSTACK_DISP0_8
   \   000042   E0           MOVX    A,@DPTR
   \   000043   F5..         MOV     ?V0 + 13,A
   1346            uint16 dataLen = 0;
   \   000045   7E00         MOV     R6,#0x0
   \   000047   7F00         MOV     R7,#0x0
   1347            uint8 *buf;
   1348            ZStatus_t status;
   1349          
   1350            // calculate the size of the command
   1351            for ( uint8 i = 0; i < reportCmd->numAttr; i++ )
   \   000049   75..00       MOV     ?V0 + 4,#0x0
   \                     ??zcl_SendReportCmd_0:
   \   00004C   85..82       MOV     DPL,?V0 + 8
   \   00004F   85..83       MOV     DPH,?V0 + 9
   \   000052   E0           MOVX    A,@DPTR
   \   000053   F8           MOV     R0,A
   \   000054   E5..         MOV     A,?V0 + 4
   \   000056   C3           CLR     C
   \   000057   98           SUBB    A,R0
   \   000058   505F         JNC     ??zcl_SendReportCmd_1
   1352            {
   1353              zclReport_t *reportRec = &(reportCmd->attrList[i]);
   \   00005A   E5..         MOV     A,?V0 + 4
   \   00005C   A8..         MOV     R0,?V0 + 4
   \   00005E   7900         MOV     R1,#0x0
   \   000060   E8           MOV     A,R0
   \   000061   75F005       MOV     B,#0x5
   \   000064   A4           MUL     AB
   \   000065   C8           XCH     A,R0
   \   000066   AAF0         MOV     R2,B
   \   000068   75F000       MOV     B,#0x0
   \   00006B   A4           MUL     AB
   \   00006C   2A           ADD     A,R2
   \   00006D   FA           MOV     R2,A
   \   00006E   75F005       MOV     B,#0x5
   \   000071   E9           MOV     A,R1
   \   000072   A4           MUL     AB
   \   000073   2A           ADD     A,R2
   \   000074   F9           MOV     R1,A
   \   000075   E5..         MOV     A,?V0 + 8
   \   000077   28           ADD     A,R0
   \   000078   F582         MOV     DPL,A
   \   00007A   E5..         MOV     A,?V0 + 9
   \   00007C   39           ADDC    A,R1
   \   00007D   F583         MOV     DPH,A
   \   00007F   A3           INC     DPTR
   \   000080   8582..       MOV     ?V0 + 0,DPL
   \   000083   8583..       MOV     ?V0 + 1,DPH
   1354          
   1355              dataLen += 2 + 1; // Attribute ID + data type
   \   000086   EE           MOV     A,R6
   \   000087   2403         ADD     A,#0x3
   \   000089   FE           MOV     R6,A
   \   00008A   EF           MOV     A,R7
   \   00008B   3400         ADDC    A,#0x0
   \   00008D   FF           MOV     R7,A
   1356          
   1357              // Attribute Data
   1358              dataLen += zclGetAttrDataLength( reportRec->dataType, reportRec->attrData );
   \   00008E                ; Setup parameters for call to function zclGetAttrDataLength
   \   00008E   85..82       MOV     DPL,?V0 + 0
   \   000091   85..83       MOV     DPH,?V0 + 1
   \   000094   A3           INC     DPTR
   \   000095   A3           INC     DPTR
   \   000096   A3           INC     DPTR
   \   000097   E0           MOVX    A,@DPTR
   \   000098   FA           MOV     R2,A
   \   000099   A3           INC     DPTR
   \   00009A   E0           MOVX    A,@DPTR
   \   00009B   FB           MOV     R3,A
   \   00009C   85..82       MOV     DPL,?V0 + 0
   \   00009F   85..83       MOV     DPH,?V0 + 1
   \   0000A2   A3           INC     DPTR
   \   0000A3   A3           INC     DPTR
   \   0000A4   E0           MOVX    A,@DPTR
   \   0000A5   F9           MOV     R1,A
   \   0000A6   12....       LCALL   ??zclGetAttrDataLength?relay
   \   0000A9   8A..         MOV     ?V0 + 2,R2
   \   0000AB   8B..         MOV     ?V0 + 3,R3
   \   0000AD   EE           MOV     A,R6
   \   0000AE   25..         ADD     A,?V0 + 2
   \   0000B0   FE           MOV     R6,A
   \   0000B1   EF           MOV     A,R7
   \   0000B2   35..         ADDC    A,?V0 + 3
   \   0000B4   FF           MOV     R7,A
   1359            }
   \   0000B5   05..         INC     ?V0 + 4
   \   0000B7   8093         SJMP    ??zcl_SendReportCmd_0
   1360          
   1361            buf = osal_mem_alloc( dataLen );
   \                     ??zcl_SendReportCmd_1:
   \   0000B9                ; Setup parameters for call to function osal_mem_alloc
   \   0000B9   EE           MOV     A,R6
   \   0000BA   FA           MOV     R2,A
   \   0000BB   EF           MOV     A,R7
   \   0000BC   FB           MOV     R3,A
   \   0000BD   12....       LCALL   ??osal_mem_alloc?relay
   \   0000C0   8A..         MOV     ?V0 + 0,R2
   \   0000C2   8B..         MOV     ?V0 + 1,R3
   \   0000C4   85....       MOV     ?V0 + 6,?V0 + 0
   \   0000C7   85....       MOV     ?V0 + 7,?V0 + 1
   1362            if ( buf != NULL )
   \   0000CA   E5..         MOV     A,?V0 + 6
   \   0000CC   45..         ORL     A,?V0 + 7
   \   0000CE   7003         JNZ     $+5
   \   0000D0   02....       LJMP    ??zcl_SendReportCmd_2 & 0xFFFF
   1363            {
   1364              // Load the buffer - serially
   1365              uint8 *pBuf = buf;
   \   0000D3   85....       MOV     ?V0 + 0,?V0 + 6
   \   0000D6   85....       MOV     ?V0 + 1,?V0 + 7
   1366              for ( uint8 i = 0; i < reportCmd->numAttr; i++ )
   \   0000D9   75..00       MOV     ?V0 + 4,#0x0
   \                     ??zcl_SendReportCmd_3:
   \   0000DC   85..82       MOV     DPL,?V0 + 8
   \   0000DF   85..83       MOV     DPH,?V0 + 9
   \   0000E2   E0           MOVX    A,@DPTR
   \   0000E3   F8           MOV     R0,A
   \   0000E4   E5..         MOV     A,?V0 + 4
   \   0000E6   C3           CLR     C
   \   0000E7   98           SUBB    A,R0
   \   0000E8   4003         JC      $+5
   \   0000EA   02....       LJMP    ??zcl_SendReportCmd_4 & 0xFFFF
   1367              {
   1368                zclReport_t *reportRec = &(reportCmd->attrList[i]);
   \   0000ED   E5..         MOV     A,?V0 + 4
   \   0000EF   A8..         MOV     R0,?V0 + 4
   \   0000F1   7900         MOV     R1,#0x0
   \   0000F3   E8           MOV     A,R0
   \   0000F4   75F005       MOV     B,#0x5
   \   0000F7   A4           MUL     AB
   \   0000F8   C8           XCH     A,R0
   \   0000F9   AAF0         MOV     R2,B
   \   0000FB   75F000       MOV     B,#0x0
   \   0000FE   A4           MUL     AB
   \   0000FF   2A           ADD     A,R2
   \   000100   FA           MOV     R2,A
   \   000101   75F005       MOV     B,#0x5
   \   000104   E9           MOV     A,R1
   \   000105   A4           MUL     AB
   \   000106   2A           ADD     A,R2
   \   000107   F9           MOV     R1,A
   \   000108   E5..         MOV     A,?V0 + 8
   \   00010A   28           ADD     A,R0
   \   00010B   F582         MOV     DPL,A
   \   00010D   E5..         MOV     A,?V0 + 9
   \   00010F   39           ADDC    A,R1
   \   000110   F583         MOV     DPH,A
   \   000112   A3           INC     DPTR
   \   000113   8582..       MOV     ?V0 + 2,DPL
   \   000116   8583..       MOV     ?V0 + 3,DPH
   1369          
   1370                *pBuf++ = LO_UINT16( reportRec->attrID );
   \   000119   85..82       MOV     DPL,?V0 + 2
   \   00011C   85..83       MOV     DPH,?V0 + 3
   \   00011F   E0           MOVX    A,@DPTR
   \   000120   F8           MOV     R0,A
   \   000121   A3           INC     DPTR
   \   000122   E0           MOVX    A,@DPTR
   \   000123   F9           MOV     R1,A
   \   000124   E8           MOV     A,R0
   \   000125   85..82       MOV     DPL,?V0 + 0
   \   000128   85..83       MOV     DPH,?V0 + 1
   \   00012B   F0           MOVX    @DPTR,A
   \   00012C   85..82       MOV     DPL,?V0 + 0
   \   00012F   85..83       MOV     DPH,?V0 + 1
   \   000132   A3           INC     DPTR
   \   000133   8582..       MOV     ?V0 + 0,DPL
   \   000136   8583..       MOV     ?V0 + 1,DPH
   1371                *pBuf++ = HI_UINT16( reportRec->attrID );
   \   000139   85..82       MOV     DPL,?V0 + 2
   \   00013C   85..83       MOV     DPH,?V0 + 3
   \   00013F   E0           MOVX    A,@DPTR
   \   000140   F8           MOV     R0,A
   \   000141   A3           INC     DPTR
   \   000142   E0           MOVX    A,@DPTR
   \   000143   F9           MOV     R1,A
   \   000144   E4           CLR     A
   \   000145   E9           MOV     A,R1
   \   000146   F8           MOV     R0,A
   \   000147   85..82       MOV     DPL,?V0 + 0
   \   00014A   85..83       MOV     DPH,?V0 + 1
   \   00014D   F0           MOVX    @DPTR,A
   \   00014E   85..82       MOV     DPL,?V0 + 0
   \   000151   85..83       MOV     DPH,?V0 + 1
   \   000154   A3           INC     DPTR
   \   000155   8582..       MOV     ?V0 + 0,DPL
   \   000158   8583..       MOV     ?V0 + 1,DPH
   1372                *pBuf++ = reportRec->dataType;
   \   00015B   85..82       MOV     DPL,?V0 + 2
   \   00015E   85..83       MOV     DPH,?V0 + 3
   \   000161   A3           INC     DPTR
   \   000162   A3           INC     DPTR
   \   000163   E0           MOVX    A,@DPTR
   \   000164   85..82       MOV     DPL,?V0 + 0
   \   000167   85..83       MOV     DPH,?V0 + 1
   \   00016A   F0           MOVX    @DPTR,A
   \   00016B   85..82       MOV     DPL,?V0 + 0
   \   00016E   85..83       MOV     DPH,?V0 + 1
   \   000171   A3           INC     DPTR
   \   000172   8582..       MOV     ?V0 + 0,DPL
   \   000175   8583..       MOV     ?V0 + 1,DPH
   1373          
   1374                pBuf = zclSerializeData( reportRec->dataType, reportRec->attrData, pBuf );
   \   000178                ; Setup parameters for call to function zclSerializeData
   \   000178   AC..         MOV     R4,?V0 + 0
   \   00017A   AD..         MOV     R5,?V0 + 1
   \   00017C   85..82       MOV     DPL,?V0 + 2
   \   00017F   85..83       MOV     DPH,?V0 + 3
   \   000182   A3           INC     DPTR
   \   000183   A3           INC     DPTR
   \   000184   A3           INC     DPTR
   \   000185   E0           MOVX    A,@DPTR
   \   000186   FA           MOV     R2,A
   \   000187   A3           INC     DPTR
   \   000188   E0           MOVX    A,@DPTR
   \   000189   FB           MOV     R3,A
   \   00018A   85..82       MOV     DPL,?V0 + 2
   \   00018D   85..83       MOV     DPH,?V0 + 3
   \   000190   A3           INC     DPTR
   \   000191   A3           INC     DPTR
   \   000192   E0           MOVX    A,@DPTR
   \   000193   F9           MOV     R1,A
   \   000194   12....       LCALL   ??zclSerializeData?relay
   \   000197   8A..         MOV     ?V0 + 10,R2
   \   000199   8B..         MOV     ?V0 + 11,R3
   \   00019B   85....       MOV     ?V0 + 0,?V0 + 10
   \   00019E   85....       MOV     ?V0 + 1,?V0 + 11
   1375              }
   \   0001A1   05..         INC     ?V0 + 4
   \   0001A3   02....       LJMP    ??zcl_SendReportCmd_3 & 0xFFFF
   1376          
   1377              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_REPORT, FALSE,
   1378                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   \                     ??zcl_SendReportCmd_4:
   \   0001A6                ; Setup parameters for call to function zcl_SendCommand
   \   0001A6   78..         MOV     R0,#?V0 + 6
   \   0001A8   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0001AB   8E..         MOV     ?V0 + 2,R6
   \   0001AD   8F..         MOV     ?V0 + 3,R7
   \   0001AF   78..         MOV     R0,#?V0 + 2
   \   0001B1   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0001B4   E5..         MOV     A,?V0 + 13
   \   0001B6   F5..         MOV     ?V0 + 2,A
   \   0001B8   78..         MOV     R0,#?V0 + 2
   \   0001BA   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0001BD   E4           CLR     A
   \   0001BE   F5..         MOV     ?V0 + 2,A
   \   0001C0   F5..         MOV     ?V0 + 3,A
   \   0001C2   78..         MOV     R0,#?V0 + 2
   \   0001C4   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0001C7   E5..         MOV     A,?V0 + 14
   \   0001C9   F5..         MOV     ?V0 + 2,A
   \   0001CB   78..         MOV     R0,#?V0 + 2
   \   0001CD   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0001D0   E5..         MOV     A,?V0 + 15
   \   0001D2   F5..         MOV     ?V0 + 2,A
   \   0001D4   78..         MOV     R0,#?V0 + 2
   \   0001D6   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0001D9   75..00       MOV     ?V0 + 2,#0x0
   \   0001DC   78..         MOV     R0,#?V0 + 2
   \   0001DE   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0001E1   75..0A       MOV     ?V0 + 2,#0xa
   \   0001E4   78..         MOV     R0,#?V0 + 2
   \   0001E6   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0001E9   740B         MOV     A,#0xb
   \   0001EB   12....       LCALL   ?XSTACK_DISP0_8
   \   0001EE   E0           MOVX    A,@DPTR
   \   0001EF   FC           MOV     R4,A
   \   0001F0   A3           INC     DPTR
   \   0001F1   E0           MOVX    A,@DPTR
   \   0001F2   FD           MOV     R5,A
   \   0001F3   740D         MOV     A,#0xd
   \   0001F5   12....       LCALL   ?XSTACK_DISP0_8
   \   0001F8   E0           MOVX    A,@DPTR
   \   0001F9   FA           MOV     R2,A
   \   0001FA   A3           INC     DPTR
   \   0001FB   E0           MOVX    A,@DPTR
   \   0001FC   FB           MOV     R3,A
   \   0001FD   A9..         MOV     R1,?V0 + 12
   \   0001FF   12....       LCALL   ??zcl_SendCommand?relay
   \   000202   740B         MOV     A,#0xb
   \   000204   12....       LCALL   ?DEALLOC_XSTACK8
   \   000207   E9           MOV     A,R1
   \   000208   F5..         MOV     ?V0 + 5,A
   1379              osal_mem_free( buf );
   \   00020A                ; Setup parameters for call to function osal_mem_free
   \   00020A   AA..         MOV     R2,?V0 + 6
   \   00020C   AB..         MOV     R3,?V0 + 7
   \   00020E   12....       LCALL   ??osal_mem_free?relay
   \   000211   8003         SJMP    ??zcl_SendReportCmd_5
   1380            }
   1381            else
   1382            {
   1383              status = ZMemError;
   \                     ??zcl_SendReportCmd_2:
   \   000213   75..10       MOV     ?V0 + 5,#0x10
   1384            }
   1385          
   1386            return ( status );
   \                     ??zcl_SendReportCmd_5:
   \   000216   A9..         MOV     R1,?V0 + 5
   \   000218   7404         MOV     A,#0x4
   \   00021A   12....       LCALL   ?DEALLOC_XSTACK8
   \   00021D   7F10         MOV     R7,#0x10
   \   00021F   02....       LJMP    ?BANKED_LEAVE_XDATA
   1387          }
   1388          #endif // ZCL_REPORT
   1389          
   1390          /*********************************************************************
   1391           * @fn      zcl_SendDefaultRspCmd
   1392           *
   1393           * @brief   Send a Default Response command
   1394           *
   1395           *          Note: The manufacturer code field should be set if this
   1396           *          command is being sent in response to a manufacturer specific
   1397           *          command.
   1398           *
   1399           * @param   dstAddr - destination address
   1400           * @param   clusterID - cluster ID
   1401           * @param   defaultRspCmd - default response command to be sent
   1402           * @param   direction - direction of the command
   1403           * @param   manuCode - manufacturer code for proprietary extensions to a profile
   1404           * @param   seqNum - transaction sequence number
   1405           *
   1406           * @return  ZSuccess if OK
   1407           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1408          ZStatus_t zcl_SendDefaultRspCmd( uint8 srcEP, afAddrType_t *dstAddr, uint16 clusterID,
   \                     zcl_SendDefaultRspCmd:
   1409                                           zclDefaultRspCmd_t *defaultRspCmd, uint8 direction,
   1410                                           uint8 disableDefaultRsp, uint16 manuCode, uint8 seqNum )
   1411          {
   \   000000   74EC         MOV     A,#-0x14
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 20
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   89..         MOV     ?V0 + 5,R1
   \   00000C   8A..         MOV     ?V0 + 10,R2
   \   00000E   8B..         MOV     ?V0 + 11,R3
   \   000010   8C..         MOV     ?V0 + 6,R4
   \   000012   8D..         MOV     ?V0 + 7,R5
   \   000014   7416         MOV     A,#0x16
   \   000016   12....       LCALL   ?XSTACK_DISP0_8
   \   000019   E0           MOVX    A,@DPTR
   \   00001A   F5..         MOV     ?V0 + 0,A
   \   00001C   A3           INC     DPTR
   \   00001D   E0           MOVX    A,@DPTR
   \   00001E   F5..         MOV     ?V0 + 1,A
   \   000020   7418         MOV     A,#0x18
   \   000022   12....       LCALL   ?XSTACK_DISP0_8
   \   000025   E0           MOVX    A,@DPTR
   \   000026   F5..         MOV     ?V0 + 2,A
   \   000028   7419         MOV     A,#0x19
   \   00002A   12....       LCALL   ?XSTACK_DISP0_8
   \   00002D   E0           MOVX    A,@DPTR
   \   00002E   F5..         MOV     ?V0 + 3,A
   \   000030   741A         MOV     A,#0x1a
   \   000032   12....       LCALL   ?XSTACK_DISP0_8
   \   000035   E0           MOVX    A,@DPTR
   \   000036   FE           MOV     R6,A
   \   000037   A3           INC     DPTR
   \   000038   E0           MOVX    A,@DPTR
   \   000039   FF           MOV     R7,A
   \   00003A   741C         MOV     A,#0x1c
   \   00003C   12....       LCALL   ?XSTACK_DISP0_8
   \   00003F   E0           MOVX    A,@DPTR
   \   000040   F5..         MOV     ?V0 + 4,A
   1412            uint8 buf[2]; // Command ID and Status;
   1413          
   1414            // Load the buffer - serially
   1415            buf[0] = defaultRspCmd->commandID;
   \   000042   85..82       MOV     DPL,?V0 + 0
   \   000045   85..83       MOV     DPH,?V0 + 1
   \   000048   E0           MOVX    A,@DPTR
   \   000049   85..82       MOV     DPL,?XSP + 0
   \   00004C   85..83       MOV     DPH,?XSP + 1
   \   00004F   F0           MOVX    @DPTR,A
   1416            buf[1] = defaultRspCmd->statusCode;
   \   000050   85..82       MOV     DPL,?V0 + 0
   \   000053   85..83       MOV     DPH,?V0 + 1
   \   000056   A3           INC     DPTR
   \   000057   E0           MOVX    A,@DPTR
   \   000058   C0E0         PUSH    A
   \   00005A   7401         MOV     A,#0x1
   \   00005C   12....       LCALL   ?XSTACK_DISP0_8
   \   00005F   D0E0         POP     A
   \   000061   F0           MOVX    @DPTR,A
   1417          
   1418            return ( zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_DEFAULT_RSP, FALSE,
   1419                                      direction, disableDefaultRsp, manuCode, seqNum, 2, buf ) );
   \   000062                ; Setup parameters for call to function zcl_SendCommand
   \   000062   85..82       MOV     DPL,?XSP + 0
   \   000065   85..83       MOV     DPH,?XSP + 1
   \   000068   8582..       MOV     ?V0 + 8,DPL
   \   00006B   8583..       MOV     ?V0 + 9,DPH
   \   00006E   78..         MOV     R0,#?V0 + 8
   \   000070   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000073   75..02       MOV     ?V0 + 8,#0x2
   \   000076   75..00       MOV     ?V0 + 9,#0x0
   \   000079   78..         MOV     R0,#?V0 + 8
   \   00007B   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00007E   E5..         MOV     A,?V0 + 4
   \   000080   F5..         MOV     ?V0 + 8,A
   \   000082   78..         MOV     R0,#?V0 + 8
   \   000084   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000087   8E..         MOV     ?V0 + 8,R6
   \   000089   8F..         MOV     ?V0 + 9,R7
   \   00008B   78..         MOV     R0,#?V0 + 8
   \   00008D   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000090   E5..         MOV     A,?V0 + 3
   \   000092   F5..         MOV     ?V0 + 8,A
   \   000094   78..         MOV     R0,#?V0 + 8
   \   000096   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000099   E5..         MOV     A,?V0 + 2
   \   00009B   F5..         MOV     ?V0 + 8,A
   \   00009D   78..         MOV     R0,#?V0 + 8
   \   00009F   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000A2   75..00       MOV     ?V0 + 8,#0x0
   \   0000A5   78..         MOV     R0,#?V0 + 8
   \   0000A7   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000AA   75..0B       MOV     ?V0 + 8,#0xb
   \   0000AD   78..         MOV     R0,#?V0 + 8
   \   0000AF   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000B2   AC..         MOV     R4,?V0 + 6
   \   0000B4   AD..         MOV     R5,?V0 + 7
   \   0000B6   AA..         MOV     R2,?V0 + 10
   \   0000B8   AB..         MOV     R3,?V0 + 11
   \   0000BA   A9..         MOV     R1,?V0 + 5
   \   0000BC   12....       LCALL   ??zcl_SendCommand?relay
   \   0000BF   740B         MOV     A,#0xb
   \   0000C1   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000C4   7402         MOV     A,#0x2
   \   0000C6   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000C9   7F0C         MOV     R7,#0xc
   \   0000CB   02....       LJMP    ?BANKED_LEAVE_XDATA
   1420          }
   1421          
   1422          #ifdef ZCL_DISCOVER
   1423          /*********************************************************************
   1424           * @fn      zcl_SendDiscoverCmd
   1425           *
   1426           * @brief   Send a Discover command
   1427           *
   1428           * @param   dstAddr - destination address
   1429           * @param   clusterID - cluster ID
   1430           * @param   discoverCmd - discover command to be sent
   1431           * @param   direction - direction of the command
   1432           * @param   seqNum - transaction sequence number
   1433           *
   1434           * @return  ZSuccess if OK
   1435           */
   1436          ZStatus_t zcl_SendDiscoverCmd( uint8 srcEP, afAddrType_t *dstAddr,
   1437                                      uint16 clusterID, zclDiscoverCmd_t *discoverCmd,
   1438                                      uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1439          {
   1440            uint16 dataLen = 2 + 1; // Start Attribute ID and Max Attribute IDs
   1441            uint8 *buf;
   1442            ZStatus_t status;
   1443          
   1444            buf = osal_mem_alloc( dataLen );
   1445            if ( buf != NULL )
   1446            {
   1447              // Load the buffer - serially
   1448              uint8 *pBuf = buf;
   1449              *pBuf++ = LO_UINT16(discoverCmd->startAttr);
   1450              *pBuf++ = HI_UINT16(discoverCmd->startAttr);
   1451              *pBuf++ = discoverCmd->maxAttrIDs;
   1452          
   1453              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_DISCOVER, FALSE,
   1454                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   1455              osal_mem_free( buf );
   1456            }
   1457            else
   1458            {
   1459              status = ZMemError;
   1460            }
   1461          
   1462            return ( status );
   1463          }
   1464          
   1465          /*********************************************************************
   1466           * @fn      zcl_SendDiscoverRspCmd
   1467           *
   1468           * @brief   Send a Discover Response command
   1469           *
   1470           * @param   dstAddr - destination address
   1471           * @param   clusterID - cluster ID
   1472           * @param   reportRspCmd - report response command to be sent
   1473           * @param   direction - direction of the command
   1474           * @param   seqNum - transaction sequence number
   1475           *
   1476           * @return  ZSuccess if OK
   1477           */
   1478          ZStatus_t zcl_SendDiscoverRspCmd( uint8 srcEP, afAddrType_t *dstAddr,
   1479                                uint16 clusterID, zclDiscoverRspCmd_t *discoverRspCmd,
   1480                                uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1481          {
   1482            uint16 dataLen = 1; // Discovery complete
   1483            uint8 *buf;
   1484            ZStatus_t status;
   1485          
   1486            // calculate the size of the command
   1487            dataLen += discoverRspCmd->numAttr * (2 + 1); // Attribute ID and Data Type
   1488          
   1489            buf = osal_mem_alloc( dataLen );
   1490            if ( buf != NULL )
   1491            {
   1492              // Load the buffer - serially
   1493              uint8 *pBuf = buf;
   1494              *pBuf++ = discoverRspCmd->discComplete;
   1495              for ( uint8 i = 0; i < discoverRspCmd->numAttr; i++ )
   1496              {
   1497                *pBuf++ = LO_UINT16(discoverRspCmd->attrList[i].attrID);
   1498                *pBuf++ = HI_UINT16(discoverRspCmd->attrList[i].attrID);
   1499                *pBuf++ = discoverRspCmd->attrList[i].dataType;
   1500              }
   1501          
   1502              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_DISCOVER_RSP, FALSE,
   1503                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   1504              osal_mem_free( buf );
   1505            }
   1506            else
   1507            {
   1508              status = ZMemError;
   1509            }
   1510          
   1511            return ( status );
   1512          }
   1513          #endif // ZCL_DISCOVER
   1514          
   1515          /*********************************************************************
   1516           * PRIVATE FUNCTIONS
   1517           *********************************************************************/
   1518          
   1519          /*********************************************************************
   1520           * @fn      zclProcessMessageMSG
   1521           *
   1522           * @brief   Data message processor callback.  This function processes
   1523           *          any incoming data - probably from other devices.  So, based
   1524           *          on cluster ID, perform the intended action.
   1525           *
   1526           * @param   pkt - incoming message
   1527           *
   1528           * @return  none
   1529           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1530          void zclProcessMessageMSG( afIncomingMSGPacket_t *pkt )
   \                     zclProcessMessageMSG:
   1531          {
   \   000000   74EE         MOV     A,#-0x12
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 18
   \   000005                ; Auto size: 21
   \   000005   74EB         MOV     A,#-0x15
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V0 + 0,R2
   \   00000C   8B..         MOV     ?V0 + 1,R3
   1532            endPointDesc_t *epDesc;
   1533            zclIncoming_t inMsg;
   1534            zclLibPlugin_t *pInPlugin;
   1535            zclDefaultRspCmd_t defautlRspCmd;
   1536            uint8 options;
   1537            uint8 securityEnable;
   1538            uint8 interPanMsg;
   1539            ZStatus_t status = ZFailure;
   \   00000E   7E01         MOV     R6,#0x1
   1540          
   1541            if ( pkt->cmd.DataLength == 0 )
   \   000010   E5..         MOV     A,?V0 + 0
   \   000012   2420         ADD     A,#0x20
   \   000014   F582         MOV     DPL,A
   \   000016   E5..         MOV     A,?V0 + 1
   \   000018   3400         ADDC    A,#0x0
   \   00001A   F583         MOV     DPH,A
   \   00001C   E0           MOVX    A,@DPTR
   \   00001D   F8           MOV     R0,A
   \   00001E   A3           INC     DPTR
   \   00001F   E0           MOVX    A,@DPTR
   \   000020   F9           MOV     R1,A
   \   000021   E8           MOV     A,R0
   \   000022   49           ORL     A,R1
   \   000023   7003         JNZ     $+5
   \   000025   02....       LJMP    ??zclProcessMessageMSG_0 & 0xFFFF
   1542            {
   1543              return;   // Error, ignore the message
   1544            }
   1545          
   1546            // Initialize
   1547            inMsg.msg = pkt;
   \   000028   85..82       MOV     DPL,?XSP + 0
   \   00002B   85..83       MOV     DPH,?XSP + 1
   \   00002E   E5..         MOV     A,?V0 + 0
   \   000030   F0           MOVX    @DPTR,A
   \   000031   A3           INC     DPTR
   \   000032   E5..         MOV     A,?V0 + 1
   \   000034   F0           MOVX    @DPTR,A
   1548            inMsg.attrCmd = NULL;
   \   000035   740C         MOV     A,#0xc
   \   000037   12....       LCALL   ?XSTACK_DISP0_8
   \   00003A   7400         MOV     A,#0x0
   \   00003C   F0           MOVX    @DPTR,A
   \   00003D   A3           INC     DPTR
   \   00003E   7400         MOV     A,#0x0
   \   000040   F0           MOVX    @DPTR,A
   1549            inMsg.pData = NULL;
   \   000041   7408         MOV     A,#0x8
   \   000043   12....       LCALL   ?XSTACK_DISP0_8
   \   000046   7400         MOV     A,#0x0
   \   000048   F0           MOVX    @DPTR,A
   \   000049   A3           INC     DPTR
   \   00004A   7400         MOV     A,#0x0
   \   00004C   F0           MOVX    @DPTR,A
   1550            inMsg.pDataLen = 0;
   \   00004D   740A         MOV     A,#0xa
   \   00004F   12....       LCALL   ?XSTACK_DISP0_8
   \   000052   7400         MOV     A,#0x0
   \   000054   F0           MOVX    @DPTR,A
   \   000055   A3           INC     DPTR
   \   000056   7400         MOV     A,#0x0
   \   000058   F0           MOVX    @DPTR,A
   1551          
   1552            inMsg.pData = zclParseHdr( &(inMsg.hdr), pkt->cmd.Data );
   \   000059                ; Setup parameters for call to function zclParseHdr
   \   000059   E5..         MOV     A,?V0 + 0
   \   00005B   2422         ADD     A,#0x22
   \   00005D   F582         MOV     DPL,A
   \   00005F   E5..         MOV     A,?V0 + 1
   \   000061   3400         ADDC    A,#0x0
   \   000063   F583         MOV     DPH,A
   \   000065   E0           MOVX    A,@DPTR
   \   000066   FC           MOV     R4,A
   \   000067   A3           INC     DPTR
   \   000068   E0           MOVX    A,@DPTR
   \   000069   FD           MOV     R5,A
   \   00006A   7402         MOV     A,#0x2
   \   00006C   12....       LCALL   ?XSTACK_DISP0_8
   \   00006F   AA82         MOV     R2,DPL
   \   000071   AB83         MOV     R3,DPH
   \   000073   12....       LCALL   ??zclParseHdr?relay
   \   000076   7408         MOV     A,#0x8
   \   000078   12....       LCALL   ?XSTACK_DISP0_8
   \   00007B   EA           MOV     A,R2
   \   00007C   F0           MOVX    @DPTR,A
   \   00007D   A3           INC     DPTR
   \   00007E   EB           MOV     A,R3
   \   00007F   F0           MOVX    @DPTR,A
   1553            inMsg.pDataLen = pkt->cmd.DataLength;
   \   000080   E5..         MOV     A,?V0 + 0
   \   000082   2420         ADD     A,#0x20
   \   000084   F582         MOV     DPL,A
   \   000086   E5..         MOV     A,?V0 + 1
   \   000088   3400         ADDC    A,#0x0
   \   00008A   F583         MOV     DPH,A
   \   00008C   E0           MOVX    A,@DPTR
   \   00008D   F8           MOV     R0,A
   \   00008E   A3           INC     DPTR
   \   00008F   E0           MOVX    A,@DPTR
   \   000090   F9           MOV     R1,A
   \   000091   740A         MOV     A,#0xa
   \   000093   12....       LCALL   ?XSTACK_DISP0_8
   \   000096   E8           MOV     A,R0
   \   000097   F0           MOVX    @DPTR,A
   \   000098   A3           INC     DPTR
   \   000099   E9           MOV     A,R1
   \   00009A   F0           MOVX    @DPTR,A
   1554            inMsg.pDataLen -= (uint16)(inMsg.pData - pkt->cmd.Data);
   \   00009B   740A         MOV     A,#0xa
   \   00009D   12....       LCALL   ?XSTACK_DISP0_8
   \   0000A0   C082         PUSH    DPL
   \   0000A2   C083         PUSH    DPH
   \   0000A4   7408         MOV     A,#0x8
   \   0000A6   12....       LCALL   ?XSTACK_DISP0_8
   \   0000A9   E0           MOVX    A,@DPTR
   \   0000AA   F8           MOV     R0,A
   \   0000AB   A3           INC     DPTR
   \   0000AC   E0           MOVX    A,@DPTR
   \   0000AD   F9           MOV     R1,A
   \   0000AE   D083         POP     DPH
   \   0000B0   D082         POP     DPL
   \   0000B2   E0           MOVX    A,@DPTR
   \   0000B3   C3           CLR     C
   \   0000B4   98           SUBB    A,R0
   \   0000B5   F8           MOV     R0,A
   \   0000B6   A3           INC     DPTR
   \   0000B7   E0           MOVX    A,@DPTR
   \   0000B8   99           SUBB    A,R1
   \   0000B9   F9           MOV     R1,A
   \   0000BA   E5..         MOV     A,?V0 + 0
   \   0000BC   2422         ADD     A,#0x22
   \   0000BE   F582         MOV     DPL,A
   \   0000C0   E5..         MOV     A,?V0 + 1
   \   0000C2   3400         ADDC    A,#0x0
   \   0000C4   F583         MOV     DPH,A
   \   0000C6   E0           MOVX    A,@DPTR
   \   0000C7   28           ADD     A,R0
   \   0000C8   F8           MOV     R0,A
   \   0000C9   A3           INC     DPTR
   \   0000CA   E0           MOVX    A,@DPTR
   \   0000CB   39           ADDC    A,R1
   \   0000CC   F9           MOV     R1,A
   \   0000CD   740A         MOV     A,#0xa
   \   0000CF   12....       LCALL   ?XSTACK_DISP0_8
   \   0000D2   E8           MOV     A,R0
   \   0000D3   F0           MOVX    @DPTR,A
   \   0000D4   A3           INC     DPTR
   \   0000D5   E9           MOV     A,R1
   \   0000D6   F0           MOVX    @DPTR,A
   1555          
   1556            // Find the wanted endpoint
   1557            epDesc = afFindEndPointDesc( pkt->endPoint );
   \   0000D7                ; Setup parameters for call to function afFindEndPointDesc
   \   0000D7   E5..         MOV     A,?V0 + 0
   \   0000D9   2414         ADD     A,#0x14
   \   0000DB   F582         MOV     DPL,A
   \   0000DD   E5..         MOV     A,?V0 + 1
   \   0000DF   3400         ADDC    A,#0x0
   \   0000E1   F583         MOV     DPH,A
   \   0000E3   E0           MOVX    A,@DPTR
   \   0000E4   F9           MOV     R1,A
   \   0000E5   12....       LCALL   ??afFindEndPointDesc?relay
   \   0000E8   8A..         MOV     ?V0 + 8,R2
   \   0000EA   8B..         MOV     ?V0 + 9,R3
   \   0000EC   85....       MOV     ?V0 + 6,?V0 + 8
   \   0000EF   85....       MOV     ?V0 + 7,?V0 + 9
   1558            if ( epDesc == NULL )
   \   0000F2   E5..         MOV     A,?V0 + 6
   \   0000F4   45..         ORL     A,?V0 + 7
   \   0000F6   7003         JNZ     $+5
   \   0000F8   02....       LJMP    ??zclProcessMessageMSG_0 & 0xFFFF
   1559            {
   1560              return;   // Error, ignore the message
   1561            }
   1562          
   1563            if ( ( epDesc->simpleDesc == NULL ) ||
   1564                 ( zcl_DeviceOperational( pkt->endPoint, pkt->clusterId, inMsg.hdr.fc.type,
   1565                                          inMsg.hdr.commandID, epDesc->simpleDesc->AppProfId ) == FALSE ) )
   \   0000FB   85..82       MOV     DPL,?V0 + 6
   \   0000FE   85..83       MOV     DPH,?V0 + 7
   \   000101   A3           INC     DPTR
   \   000102   A3           INC     DPTR
   \   000103   A3           INC     DPTR
   \   000104   E0           MOVX    A,@DPTR
   \   000105   F8           MOV     R0,A
   \   000106   A3           INC     DPTR
   \   000107   E0           MOVX    A,@DPTR
   \   000108   F9           MOV     R1,A
   \   000109   E8           MOV     A,R0
   \   00010A   49           ORL     A,R1
   \   00010B   6052         JZ      ??zclProcessMessageMSG_1
   \   00010D                ; Setup parameters for call to function zcl_DeviceOperational
   \   00010D   85..82       MOV     DPL,?V0 + 6
   \   000110   85..83       MOV     DPH,?V0 + 7
   \   000113   A3           INC     DPTR
   \   000114   A3           INC     DPTR
   \   000115   A3           INC     DPTR
   \   000116   E0           MOVX    A,@DPTR
   \   000117   F8           MOV     R0,A
   \   000118   A3           INC     DPTR
   \   000119   E0           MOVX    A,@DPTR
   \   00011A   F583         MOV     DPH,A
   \   00011C   8882         MOV     DPL,R0
   \   00011E   A3           INC     DPTR
   \   00011F   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   000122   7409         MOV     A,#0x9
   \   000124   12....       LCALL   ?XSTACK_DISP0_8
   \   000127   E0           MOVX    A,@DPTR
   \   000128   FD           MOV     R5,A
   \   000129   7404         MOV     A,#0x4
   \   00012B   12....       LCALL   ?XSTACK_DISP0_8
   \   00012E   E0           MOVX    A,@DPTR
   \   00012F   F8           MOV     R0,A
   \   000130   A3           INC     DPTR
   \   000131   E0           MOVX    A,@DPTR
   \   000132   F9           MOV     R1,A
   \   000133   E8           MOV     A,R0
   \   000134   5403         ANL     A,#0x3
   \   000136   FC           MOV     R4,A
   \   000137   85..82       MOV     DPL,?V0 + 0
   \   00013A   85..83       MOV     DPH,?V0 + 1
   \   00013D   A3           INC     DPTR
   \   00013E   A3           INC     DPTR
   \   00013F   A3           INC     DPTR
   \   000140   A3           INC     DPTR
   \   000141   E0           MOVX    A,@DPTR
   \   000142   FA           MOV     R2,A
   \   000143   A3           INC     DPTR
   \   000144   E0           MOVX    A,@DPTR
   \   000145   FB           MOV     R3,A
   \   000146   E5..         MOV     A,?V0 + 0
   \   000148   2414         ADD     A,#0x14
   \   00014A   F582         MOV     DPL,A
   \   00014C   E5..         MOV     A,?V0 + 1
   \   00014E   3400         ADDC    A,#0x0
   \   000150   F583         MOV     DPH,A
   \   000152   E0           MOVX    A,@DPTR
   \   000153   F9           MOV     R1,A
   \   000154   12....       LCALL   ??zcl_DeviceOperational?relay
   \   000157   7402         MOV     A,#0x2
   \   000159   12....       LCALL   ?DEALLOC_XSTACK8
   \   00015C   E9           MOV     A,R1
   \   00015D   7003         JNZ     ??zclProcessMessageMSG_2
   1566            {
   1567              return; // Error, ignore the message
   \                     ??zclProcessMessageMSG_1:
   \   00015F   02....       LJMP    ??zclProcessMessageMSG_0 & 0xFFFF
   1568            }
   1569          
   1570          #if defined ( INTER_PAN )
   1571            if ( StubAPS_InterPan( pkt->srcAddr.panId, pkt->srcAddr.endPoint ) )
   1572            {
   1573              // No foundation command is supported thru Inter-PAN communication.
   1574              // But the Smart Light cluster uses a different Frame Control format
   1575              // for it's Inter-PAN messages, where the messages could be confused
   1576              // with the foundation commands.
   1577              if ( !ZCL_CLUSTER_ID_SL( pkt->clusterId ) && zcl_ProfileCmd( inMsg.hdr.fc.type ) )
   1578              {
   1579                return;
   1580              }
   1581          
   1582              interPanMsg = TRUE;
   1583              options = AF_TX_OPTIONS_NONE;
   1584            }
   1585            else
   1586          #endif
   1587            {
   1588              interPanMsg = FALSE;
   \                     ??zclProcessMessageMSG_2:
   \   000162   75..00       MOV     ?V0 + 2,#0x0
   1589              options = zclGetClusterOption( pkt->endPoint, pkt->clusterId );
   \   000165                ; Setup parameters for call to function zclGetClusterOption
   \   000165   85..82       MOV     DPL,?V0 + 0
   \   000168   85..83       MOV     DPH,?V0 + 1
   \   00016B   A3           INC     DPTR
   \   00016C   A3           INC     DPTR
   \   00016D   A3           INC     DPTR
   \   00016E   A3           INC     DPTR
   \   00016F   E0           MOVX    A,@DPTR
   \   000170   FA           MOV     R2,A
   \   000171   A3           INC     DPTR
   \   000172   E0           MOVX    A,@DPTR
   \   000173   FB           MOV     R3,A
   \   000174   E5..         MOV     A,?V0 + 0
   \   000176   2414         ADD     A,#0x14
   \   000178   F582         MOV     DPL,A
   \   00017A   E5..         MOV     A,?V0 + 1
   \   00017C   3400         ADDC    A,#0x0
   \   00017E   F583         MOV     DPH,A
   \   000180   E0           MOVX    A,@DPTR
   \   000181   F9           MOV     R1,A
   \   000182   12....       LCALL   ??zclGetClusterOption?relay
   \   000185   E9           MOV     A,R1
   \   000186   F5..         MOV     ?V0 + 3,A
   1590            }
   1591          
   1592            // Find the appropriate plugin
   1593            pInPlugin = zclFindPlugin( pkt->clusterId, epDesc->simpleDesc->AppProfId );
   \   000188                ; Setup parameters for call to function zclFindPlugin
   \   000188   85..82       MOV     DPL,?V0 + 6
   \   00018B   85..83       MOV     DPH,?V0 + 7
   \   00018E   A3           INC     DPTR
   \   00018F   A3           INC     DPTR
   \   000190   A3           INC     DPTR
   \   000191   E0           MOVX    A,@DPTR
   \   000192   F8           MOV     R0,A
   \   000193   A3           INC     DPTR
   \   000194   E0           MOVX    A,@DPTR
   \   000195   F583         MOV     DPH,A
   \   000197   8882         MOV     DPL,R0
   \   000199   A3           INC     DPTR
   \   00019A   E0           MOVX    A,@DPTR
   \   00019B   FC           MOV     R4,A
   \   00019C   A3           INC     DPTR
   \   00019D   E0           MOVX    A,@DPTR
   \   00019E   FD           MOV     R5,A
   \   00019F   85..82       MOV     DPL,?V0 + 0
   \   0001A2   85..83       MOV     DPH,?V0 + 1
   \   0001A5   A3           INC     DPTR
   \   0001A6   A3           INC     DPTR
   \   0001A7   A3           INC     DPTR
   \   0001A8   A3           INC     DPTR
   \   0001A9   E0           MOVX    A,@DPTR
   \   0001AA   FA           MOV     R2,A
   \   0001AB   A3           INC     DPTR
   \   0001AC   E0           MOVX    A,@DPTR
   \   0001AD   FB           MOV     R3,A
   \   0001AE   12....       LCALL   ??zclFindPlugin?relay
   \   0001B1   8A..         MOV     ?V0 + 8,R2
   \   0001B3   8B..         MOV     ?V0 + 9,R3
   \   0001B5   85....       MOV     ?V0 + 4,?V0 + 8
   \   0001B8   85....       MOV     ?V0 + 5,?V0 + 9
   1594          
   1595            // Local and remote Security options must match except for Default Response command
   1596            if ( ( pInPlugin != NULL ) && !zcl_DefaultRspCmd( inMsg.hdr ) )
   \   0001BB   E5..         MOV     A,?V0 + 4
   \   0001BD   45..         ORL     A,?V0 + 5
   \   0001BF   7003         JNZ     $+5
   \   0001C1   02....       LJMP    ??zclProcessMessageMSG_3 & 0xFFFF
   \   0001C4   7402         MOV     A,#0x2
   \   0001C6   12....       LCALL   ?XSTACK_DISP0_8
   \   0001C9   E0           MOVX    A,@DPTR
   \   0001CA   5407         ANL     A,#0x7
   \   0001CC   F8           MOV     R0,A
   \   0001CD   A3           INC     DPTR
   \   0001CE   E0           MOVX    A,@DPTR
   \   0001CF   5400         ANL     A,#0x0
   \   0001D1   F9           MOV     R1,A
   \   0001D2   E8           MOV     A,R0
   \   0001D3   49           ORL     A,R1
   \   0001D4   700D         JNZ     ??zclProcessMessageMSG_4
   \   0001D6   7407         MOV     A,#0x7
   \   0001D8   12....       LCALL   ?XSTACK_DISP0_8
   \   0001DB   E0           MOVX    A,@DPTR
   \   0001DC   640B         XRL     A,#0xb
   \   0001DE   7003         JNZ     $+5
   \   0001E0   02....       LJMP    ??zclProcessMessageMSG_3 & 0xFFFF
   1597            {
   1598              securityEnable = ( options & AF_EN_SECURITY ) ? TRUE : FALSE;
   \                     ??zclProcessMessageMSG_4:
   \   0001E3   E5..         MOV     A,?V0 + 3
   \   0001E5   A2E6         MOV     C,0xE0 /* A   */.6
   \   0001E7   5004         JNC     ??zclProcessMessageMSG_5
   \   0001E9   D2F0         SETB    B.0
   \   0001EB   8002         SJMP    ??zclProcessMessageMSG_6
   \                     ??zclProcessMessageMSG_5:
   \   0001ED   C2F0         CLR     B.0
   \                     ??zclProcessMessageMSG_6:
   \   0001EF   A2F0         MOV     C,B.0
   \   0001F1   E4           CLR     A
   \   0001F2   33           RLC     A
   \   0001F3   FF           MOV     R7,A
   1599              if ( pkt->SecurityUse != securityEnable )
   \   0001F4   E5..         MOV     A,?V0 + 0
   \   0001F6   2419         ADD     A,#0x19
   \   0001F8   F582         MOV     DPL,A
   \   0001FA   E5..         MOV     A,?V0 + 1
   \   0001FC   3400         ADDC    A,#0x0
   \   0001FE   F583         MOV     DPH,A
   \   000200   E0           MOVX    A,@DPTR
   \   000201   6F           XRL     A,R7
   \   000202   7003         JNZ     $+5
   \   000204   02....       LJMP    ??zclProcessMessageMSG_3 & 0xFFFF
   1600              {
   1601                if ( UNICAST_MSG( inMsg.msg ) )
   \   000207   85..82       MOV     DPL,?XSP + 0
   \   00020A   85..83       MOV     DPH,?XSP + 1
   \   00020D   E0           MOVX    A,@DPTR
   \   00020E   F8           MOV     R0,A
   \   00020F   A3           INC     DPTR
   \   000210   E0           MOVX    A,@DPTR
   \   000211   C8           XCH     A,R0
   \   000212   2415         ADD     A,#0x15
   \   000214   F582         MOV     DPL,A
   \   000216   E8           MOV     A,R0
   \   000217   3400         ADDC    A,#0x0
   \   000219   F583         MOV     DPH,A
   \   00021B   E0           MOVX    A,@DPTR
   \   00021C   6003         JZ      $+5
   \   00021E   02....       LJMP    ??zclProcessMessageMSG_0 & 0xFFFF
   \   000221   85..82       MOV     DPL,?XSP + 0
   \   000224   85..83       MOV     DPH,?XSP + 1
   \   000227   E0           MOVX    A,@DPTR
   \   000228   F8           MOV     R0,A
   \   000229   A3           INC     DPTR
   \   00022A   E0           MOVX    A,@DPTR
   \   00022B   F583         MOV     DPH,A
   \   00022D   8882         MOV     DPL,R0
   \   00022F   A3           INC     DPTR
   \   000230   A3           INC     DPTR
   \   000231   E0           MOVX    A,@DPTR
   \   000232   F8           MOV     R0,A
   \   000233   A3           INC     DPTR
   \   000234   E0           MOVX    A,@DPTR
   \   000235   F9           MOV     R1,A
   \   000236   E8           MOV     A,R0
   \   000237   49           ORL     A,R1
   \   000238   6003         JZ      $+5
   \   00023A   02....       LJMP    ??zclProcessMessageMSG_0 & 0xFFFF
   1602                {
   1603                  // Send a Default Response command back with no Application Link Key security
   1604                  if ( securityEnable )
   \   00023D   EF           MOV     A,R7
   \   00023E   6022         JZ      ??zclProcessMessageMSG_7
   1605                  {
   1606                    zclSetSecurityOption( pkt->endPoint, pkt->clusterId, FALSE );
   \   000240                ; Setup parameters for call to function zclSetSecurityOption
   \   000240   7C00         MOV     R4,#0x0
   \   000242   85..82       MOV     DPL,?V0 + 0
   \   000245   85..83       MOV     DPH,?V0 + 1
   \   000248   A3           INC     DPTR
   \   000249   A3           INC     DPTR
   \   00024A   A3           INC     DPTR
   \   00024B   A3           INC     DPTR
   \   00024C   E0           MOVX    A,@DPTR
   \   00024D   FA           MOV     R2,A
   \   00024E   A3           INC     DPTR
   \   00024F   E0           MOVX    A,@DPTR
   \   000250   FB           MOV     R3,A
   \   000251   E5..         MOV     A,?V0 + 0
   \   000253   2414         ADD     A,#0x14
   \   000255   F582         MOV     DPL,A
   \   000257   E5..         MOV     A,?V0 + 1
   \   000259   3400         ADDC    A,#0x0
   \   00025B   F583         MOV     DPH,A
   \   00025D   E0           MOVX    A,@DPTR
   \   00025E   F9           MOV     R1,A
   \   00025F   12....       LCALL   ??zclSetSecurityOption?relay
   1607                  }
   1608          
   1609                  defautlRspCmd.statusCode = status;
   \                     ??zclProcessMessageMSG_7:
   \   000262   EE           MOV     A,R6
   \   000263   C0E0         PUSH    A
   \   000265   740F         MOV     A,#0xf
   \   000267   12....       LCALL   ?XSTACK_DISP0_8
   \   00026A   D0E0         POP     A
   \   00026C   F0           MOVX    @DPTR,A
   1610                  defautlRspCmd.commandID = inMsg.hdr.commandID;
   \   00026D   7407         MOV     A,#0x7
   \   00026F   12....       LCALL   ?XSTACK_DISP0_8
   \   000272   E0           MOVX    A,@DPTR
   \   000273   C0E0         PUSH    A
   \   000275   740E         MOV     A,#0xe
   \   000277   12....       LCALL   ?XSTACK_DISP0_8
   \   00027A   D0E0         POP     A
   \   00027C   F0           MOVX    @DPTR,A
   1611                  zcl_SendDefaultRspCmd( inMsg.msg->endPoint, &(inMsg.msg->srcAddr),
   1612                                         inMsg.msg->clusterId, &defautlRspCmd,
   1613                                         ZCL_FRAME_SERVER_CLIENT_DIR, true,
   1614                                         inMsg.hdr.manuCode, inMsg.hdr.transSeqNum );
   \   00027D                ; Setup parameters for call to function zcl_SendDefaultRspCmd
   \   00027D   7406         MOV     A,#0x6
   \   00027F   12....       LCALL   ?XSTACK_DISP0_8
   \   000282   E0           MOVX    A,@DPTR
   \   000283   F5..         MOV     ?V0 + 8,A
   \   000285   78..         MOV     R0,#?V0 + 8
   \   000287   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00028A   7405         MOV     A,#0x5
   \   00028C   12....       LCALL   ?XSTACK_DISP0_8
   \   00028F   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   000292   75..01       MOV     ?V0 + 8,#0x1
   \   000295   78..         MOV     R0,#?V0 + 8
   \   000297   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00029A   75..01       MOV     ?V0 + 8,#0x1
   \   00029D   78..         MOV     R0,#?V0 + 8
   \   00029F   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0002A2   7413         MOV     A,#0x13
   \   0002A4   12....       LCALL   ?XSTACK_DISP0_8
   \   0002A7   8582..       MOV     ?V0 + 8,DPL
   \   0002AA   8583..       MOV     ?V0 + 9,DPH
   \   0002AD   78..         MOV     R0,#?V0 + 8
   \   0002AF   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0002B2   7407         MOV     A,#0x7
   \   0002B4   12....       LCALL   ?XSTACK_DISP0_8
   \   0002B7   E0           MOVX    A,@DPTR
   \   0002B8   F8           MOV     R0,A
   \   0002B9   A3           INC     DPTR
   \   0002BA   E0           MOVX    A,@DPTR
   \   0002BB   F583         MOV     DPH,A
   \   0002BD   8882         MOV     DPL,R0
   \   0002BF   A3           INC     DPTR
   \   0002C0   A3           INC     DPTR
   \   0002C1   A3           INC     DPTR
   \   0002C2   A3           INC     DPTR
   \   0002C3   E0           MOVX    A,@DPTR
   \   0002C4   FC           MOV     R4,A
   \   0002C5   A3           INC     DPTR
   \   0002C6   E0           MOVX    A,@DPTR
   \   0002C7   FD           MOV     R5,A
   \   0002C8   7407         MOV     A,#0x7
   \   0002CA   12....       LCALL   ?XSTACK_DISP0_8
   \   0002CD   E0           MOVX    A,@DPTR
   \   0002CE   2406         ADD     A,#0x6
   \   0002D0   FA           MOV     R2,A
   \   0002D1   A3           INC     DPTR
   \   0002D2   E0           MOVX    A,@DPTR
   \   0002D3   3400         ADDC    A,#0x0
   \   0002D5   FB           MOV     R3,A
   \   0002D6   7407         MOV     A,#0x7
   \   0002D8   12....       LCALL   ?XSTACK_DISP0_8
   \   0002DB   E0           MOVX    A,@DPTR
   \   0002DC   F8           MOV     R0,A
   \   0002DD   A3           INC     DPTR
   \   0002DE   E0           MOVX    A,@DPTR
   \   0002DF   C8           XCH     A,R0
   \   0002E0   2414         ADD     A,#0x14
   \   0002E2   F582         MOV     DPL,A
   \   0002E4   E8           MOV     A,R0
   \   0002E5   3400         ADDC    A,#0x0
   \   0002E7   F583         MOV     DPH,A
   \   0002E9   E0           MOVX    A,@DPTR
   \   0002EA   F9           MOV     R1,A
   \   0002EB   12....       LCALL   ??zcl_SendDefaultRspCmd?relay
   \   0002EE   7407         MOV     A,#0x7
   \   0002F0   12....       LCALL   ?DEALLOC_XSTACK8
   \   0002F3   E9           MOV     A,R1
   1615                  if ( securityEnable )
   \   0002F4   EF           MOV     A,R7
   \   0002F5   6022         JZ      ??zclProcessMessageMSG_8
   1616                  {
   1617                    zclSetSecurityOption( pkt->endPoint, pkt->clusterId, TRUE );
   \   0002F7                ; Setup parameters for call to function zclSetSecurityOption
   \   0002F7   7C01         MOV     R4,#0x1
   \   0002F9   85..82       MOV     DPL,?V0 + 0
   \   0002FC   85..83       MOV     DPH,?V0 + 1
   \   0002FF   A3           INC     DPTR
   \   000300   A3           INC     DPTR
   \   000301   A3           INC     DPTR
   \   000302   A3           INC     DPTR
   \   000303   E0           MOVX    A,@DPTR
   \   000304   FA           MOV     R2,A
   \   000305   A3           INC     DPTR
   \   000306   E0           MOVX    A,@DPTR
   \   000307   FB           MOV     R3,A
   \   000308   E5..         MOV     A,?V0 + 0
   \   00030A   2414         ADD     A,#0x14
   \   00030C   F582         MOV     DPL,A
   \   00030E   E5..         MOV     A,?V0 + 1
   \   000310   3400         ADDC    A,#0x0
   \   000312   F583         MOV     DPH,A
   \   000314   E0           MOVX    A,@DPTR
   \   000315   F9           MOV     R1,A
   \   000316   12....       LCALL   ??zclSetSecurityOption?relay
   1618                  }
   1619                }
   1620          
   1621                return;   // Error, ignore the message
   \                     ??zclProcessMessageMSG_8:
   \   000319   02....       LJMP    ??zclProcessMessageMSG_0 & 0xFFFF
   1622              }
   1623            }
   1624          
   1625            // Is this a foundation type message
   1626            if ( !interPanMsg && zcl_ProfileCmd( inMsg.hdr.fc.type ) )
   \                     ??zclProcessMessageMSG_3:
   \   00031C   E5..         MOV     A,?V0 + 2
   \   00031E   6003         JZ      $+5
   \   000320   02....       LJMP    ??zclProcessMessageMSG_9 & 0xFFFF
   \   000323   7402         MOV     A,#0x2
   \   000325   12....       LCALL   ?XSTACK_DISP0_8
   \   000328   E0           MOVX    A,@DPTR
   \   000329   5403         ANL     A,#0x3
   \   00032B   F8           MOV     R0,A
   \   00032C   A3           INC     DPTR
   \   00032D   E0           MOVX    A,@DPTR
   \   00032E   5400         ANL     A,#0x0
   \   000330   F9           MOV     R1,A
   \   000331   E8           MOV     A,R0
   \   000332   6003         JZ      $+5
   \   000334   02....       LJMP    ??zclProcessMessageMSG_9 & 0xFFFF
   1627            {
   1628              if ( inMsg.hdr.fc.manuSpecific )
   \   000337   7402         MOV     A,#0x2
   \   000339   12....       LCALL   ?XSTACK_DISP0_8
   \   00033C   E0           MOVX    A,@DPTR
   \   00033D   F8           MOV     R0,A
   \   00033E   A3           INC     DPTR
   \   00033F   E0           MOVX    A,@DPTR
   \   000340   F9           MOV     R1,A
   \   000341   E8           MOV     A,R0
   \   000342   13           RRC     A
   \   000343   13           RRC     A
   \   000344   543F         ANL     A,#0x3f
   \   000346   F8           MOV     R0,A
   \   000347   7900         MOV     R1,#0x0
   \   000349   5401         ANL     A,#0x1
   \   00034B   F8           MOV     R0,A
   \   00034C   E9           MOV     A,R1
   \   00034D   5400         ANL     A,#0x0
   \   00034F   F9           MOV     R1,A
   \   000350   E8           MOV     A,R0
   \   000351   A2E0         MOV     C,0xE0 /* A   */.0
   \   000353   5005         JNC     ??zclProcessMessageMSG_10
   1629              {
   1630                // We don't support any manufacturer specific command
   1631                status = ZCL_STATUS_UNSUP_MANU_GENERAL_COMMAND;
   \   000355   7E84         MOV     R6,#-0x7c
   \   000357   02....       LJMP    ??zclProcessMessageMSG_11 & 0xFFFF
   1632              }
   1633              else if ( ( inMsg.hdr.commandID <= ZCL_CMD_MAX ) &&
   1634                        ( zclCmdTable[inMsg.hdr.commandID].pfnParseInProfile != NULL ) )
   \                     ??zclProcessMessageMSG_10:
   \   00035A   7407         MOV     A,#0x7
   \   00035C   12....       LCALL   ?XSTACK_DISP0_8
   \   00035F   E0           MOVX    A,@DPTR
   \   000360   C3           CLR     C
   \   000361   940E         SUBB    A,#0xe
   \   000363   4003         JC      $+5
   \   000365   02....       LJMP    ??zclProcessMessageMSG_12 & 0xFFFF
   \   000368   7407         MOV     A,#0x7
   \   00036A   12....       LCALL   ?XSTACK_DISP0_8
   \   00036D   E0           MOVX    A,@DPTR
   \   00036E   F8           MOV     R0,A
   \   00036F   7900         MOV     R1,#0x0
   \   000371   E8           MOV     A,R0
   \   000372   75F004       MOV     B,#0x4
   \   000375   A4           MUL     AB
   \   000376   C8           XCH     A,R0
   \   000377   AAF0         MOV     R2,B
   \   000379   75F000       MOV     B,#0x0
   \   00037C   A4           MUL     AB
   \   00037D   2A           ADD     A,R2
   \   00037E   FA           MOV     R2,A
   \   00037F   75F004       MOV     B,#0x4
   \   000382   E9           MOV     A,R1
   \   000383   A4           MUL     AB
   \   000384   2A           ADD     A,R2
   \   000385   F9           MOV     R1,A
   \   000386   74..         MOV     A,#zclCmdTable & 0xff
   \   000388   28           ADD     A,R0
   \   000389   F582         MOV     DPL,A
   \   00038B   74..         MOV     A,#(zclCmdTable >> 8) & 0xff
   \   00038D   39           ADDC    A,R1
   \   00038E   F583         MOV     DPH,A
   \   000390   E4           CLR     A
   \   000391   93           MOVC    A,@A+DPTR
   \   000392   F8           MOV     R0,A
   \   000393   7401         MOV     A,#0x1
   \   000395   93           MOVC    A,@A+DPTR
   \   000396   F9           MOV     R1,A
   \   000397   E8           MOV     A,R0
   \   000398   49           ORL     A,R1
   \   000399   7003         JNZ     $+5
   \   00039B   02....       LJMP    ??zclProcessMessageMSG_12 & 0xFFFF
   1635              {
   1636                zclParseCmd_t parseCmd;
   1637          
   1638                parseCmd.endpoint = pkt->endPoint;
   \   00039E   E5..         MOV     A,?V0 + 0
   \   0003A0   2414         ADD     A,#0x14
   \   0003A2   F582         MOV     DPL,A
   \   0003A4   E5..         MOV     A,?V0 + 1
   \   0003A6   3400         ADDC    A,#0x0
   \   0003A8   F583         MOV     DPH,A
   \   0003AA   E0           MOVX    A,@DPTR
   \   0003AB   C0E0         PUSH    A
   \   0003AD   7410         MOV     A,#0x10
   \   0003AF   12....       LCALL   ?XSTACK_DISP0_8
   \   0003B2   D0E0         POP     A
   \   0003B4   F0           MOVX    @DPTR,A
   1639                parseCmd.dataLen = inMsg.pDataLen;
   \   0003B5   740A         MOV     A,#0xa
   \   0003B7   12....       LCALL   ?XSTACK_DISP0_8
   \   0003BA   E0           MOVX    A,@DPTR
   \   0003BB   F8           MOV     R0,A
   \   0003BC   A3           INC     DPTR
   \   0003BD   E0           MOVX    A,@DPTR
   \   0003BE   F9           MOV     R1,A
   \   0003BF   7411         MOV     A,#0x11
   \   0003C1   12....       LCALL   ?XSTACK_DISP0_8
   \   0003C4   E8           MOV     A,R0
   \   0003C5   F0           MOVX    @DPTR,A
   \   0003C6   A3           INC     DPTR
   \   0003C7   E9           MOV     A,R1
   \   0003C8   F0           MOVX    @DPTR,A
   1640                parseCmd.pData = inMsg.pData;
   \   0003C9   7408         MOV     A,#0x8
   \   0003CB   12....       LCALL   ?XSTACK_DISP0_8
   \   0003CE   E0           MOVX    A,@DPTR
   \   0003CF   F8           MOV     R0,A
   \   0003D0   A3           INC     DPTR
   \   0003D1   E0           MOVX    A,@DPTR
   \   0003D2   F9           MOV     R1,A
   \   0003D3   7413         MOV     A,#0x13
   \   0003D5   12....       LCALL   ?XSTACK_DISP0_8
   \   0003D8   E8           MOV     A,R0
   \   0003D9   F0           MOVX    @DPTR,A
   \   0003DA   A3           INC     DPTR
   \   0003DB   E9           MOV     A,R1
   \   0003DC   F0           MOVX    @DPTR,A
   1641          
   1642                // Parse the command, remember that the return value is a pointer to allocated memory
   1643                inMsg.attrCmd = zclParseCmd( inMsg.hdr.commandID, &parseCmd );
   \   0003DD                ; Setup parameters for indirect call
   \   0003DD   7410         MOV     A,#0x10
   \   0003DF   12....       LCALL   ?XSTACK_DISP0_8
   \   0003E2   AA82         MOV     R2,DPL
   \   0003E4   AB83         MOV     R3,DPH
   \   0003E6   7407         MOV     A,#0x7
   \   0003E8   12....       LCALL   ?XSTACK_DISP0_8
   \   0003EB   E0           MOVX    A,@DPTR
   \   0003EC   F8           MOV     R0,A
   \   0003ED   7900         MOV     R1,#0x0
   \   0003EF   E8           MOV     A,R0
   \   0003F0   75F004       MOV     B,#0x4
   \   0003F3   A4           MUL     AB
   \   0003F4   C8           XCH     A,R0
   \   0003F5   ACF0         MOV     R4,B
   \   0003F7   75F000       MOV     B,#0x0
   \   0003FA   A4           MUL     AB
   \   0003FB   2C           ADD     A,R4
   \   0003FC   FC           MOV     R4,A
   \   0003FD   75F004       MOV     B,#0x4
   \   000400   E9           MOV     A,R1
   \   000401   A4           MUL     AB
   \   000402   2C           ADD     A,R4
   \   000403   F9           MOV     R1,A
   \   000404   74..         MOV     A,#zclCmdTable & 0xff
   \   000406   28           ADD     A,R0
   \   000407   F582         MOV     DPL,A
   \   000409   74..         MOV     A,#(zclCmdTable >> 8) & 0xff
   \   00040B   39           ADDC    A,R1
   \   00040C   F583         MOV     DPH,A
   \   00040E   E4           CLR     A
   \   00040F   93           MOVC    A,@A+DPTR
   \   000410   C0E0         PUSH    A
   \   000412   7401         MOV     A,#0x1
   \   000414   93           MOVC    A,@A+DPTR
   \   000415   F583         MOV     DPH,A
   \   000417   D082         POP     DPL
   \   000419   12....       LCALL   ?CALL_IND
   \   00041C   740C         MOV     A,#0xc
   \   00041E   12....       LCALL   ?XSTACK_DISP0_8
   \   000421   EA           MOV     A,R2
   \   000422   F0           MOVX    @DPTR,A
   \   000423   A3           INC     DPTR
   \   000424   EB           MOV     A,R3
   \   000425   F0           MOVX    @DPTR,A
   1644                if ( (inMsg.attrCmd != NULL) && (zclCmdTable[inMsg.hdr.commandID].pfnProcessInProfile != NULL) )
   \   000426   740C         MOV     A,#0xc
   \   000428   12....       LCALL   ?XSTACK_DISP0_8
   \   00042B   E0           MOVX    A,@DPTR
   \   00042C   F8           MOV     R0,A
   \   00042D   A3           INC     DPTR
   \   00042E   E0           MOVX    A,@DPTR
   \   00042F   F9           MOV     R1,A
   \   000430   E8           MOV     A,R0
   \   000431   49           ORL     A,R1
   \   000432   6074         JZ      ??zclProcessMessageMSG_13
   \   000434   7407         MOV     A,#0x7
   \   000436   12....       LCALL   ?XSTACK_DISP0_8
   \   000439   E0           MOVX    A,@DPTR
   \   00043A   F8           MOV     R0,A
   \   00043B   7900         MOV     R1,#0x0
   \   00043D   E8           MOV     A,R0
   \   00043E   75F004       MOV     B,#0x4
   \   000441   A4           MUL     AB
   \   000442   C8           XCH     A,R0
   \   000443   AAF0         MOV     R2,B
   \   000445   75F000       MOV     B,#0x0
   \   000448   A4           MUL     AB
   \   000449   2A           ADD     A,R2
   \   00044A   FA           MOV     R2,A
   \   00044B   75F004       MOV     B,#0x4
   \   00044E   E9           MOV     A,R1
   \   00044F   A4           MUL     AB
   \   000450   2A           ADD     A,R2
   \   000451   F9           MOV     R1,A
   \   000452   74..         MOV     A,#(zclCmdTable + 2) & 0xff
   \   000454   28           ADD     A,R0
   \   000455   F582         MOV     DPL,A
   \   000457   74..         MOV     A,#((zclCmdTable + 2) >> 8) & 0xff
   \   000459   39           ADDC    A,R1
   \   00045A   F583         MOV     DPH,A
   \   00045C   E4           CLR     A
   \   00045D   93           MOVC    A,@A+DPTR
   \   00045E   F8           MOV     R0,A
   \   00045F   7401         MOV     A,#0x1
   \   000461   93           MOVC    A,@A+DPTR
   \   000462   F9           MOV     R1,A
   \   000463   E8           MOV     A,R0
   \   000464   49           ORL     A,R1
   \   000465   6041         JZ      ??zclProcessMessageMSG_13
   1645                {
   1646                  // Process the command
   1647                  if ( zclProcessCmd( inMsg.hdr.commandID, &inMsg ) == FALSE )
   \   000467                ; Setup parameters for indirect call
   \   000467   85..82       MOV     DPL,?XSP + 0
   \   00046A   85..83       MOV     DPH,?XSP + 1
   \   00046D   AA82         MOV     R2,DPL
   \   00046F   AB83         MOV     R3,DPH
   \   000471   7407         MOV     A,#0x7
   \   000473   12....       LCALL   ?XSTACK_DISP0_8
   \   000476   E0           MOVX    A,@DPTR
   \   000477   F8           MOV     R0,A
   \   000478   7900         MOV     R1,#0x0
   \   00047A   E8           MOV     A,R0
   \   00047B   75F004       MOV     B,#0x4
   \   00047E   A4           MUL     AB
   \   00047F   C8           XCH     A,R0
   \   000480   ACF0         MOV     R4,B
   \   000482   75F000       MOV     B,#0x0
   \   000485   A4           MUL     AB
   \   000486   2C           ADD     A,R4
   \   000487   FC           MOV     R4,A
   \   000488   75F004       MOV     B,#0x4
   \   00048B   E9           MOV     A,R1
   \   00048C   A4           MUL     AB
   \   00048D   2C           ADD     A,R4
   \   00048E   F9           MOV     R1,A
   \   00048F   74..         MOV     A,#(zclCmdTable + 2) & 0xff
   \   000491   28           ADD     A,R0
   \   000492   F582         MOV     DPL,A
   \   000494   74..         MOV     A,#((zclCmdTable + 2) >> 8) & 0xff
   \   000496   39           ADDC    A,R1
   \   000497   F583         MOV     DPH,A
   \   000499   E4           CLR     A
   \   00049A   93           MOVC    A,@A+DPTR
   \   00049B   C0E0         PUSH    A
   \   00049D   7401         MOV     A,#0x1
   \   00049F   93           MOVC    A,@A+DPTR
   \   0004A0   F583         MOV     DPH,A
   \   0004A2   D082         POP     DPL
   \   0004A4   12....       LCALL   ?CALL_IND
   \   0004A7   E9           MOV     A,R1
   1648                  {
   1649                    // Couldn't find attribute in the table.
   1650                  }
   1651                }
   1652          
   1653                // Free the buffer
   1654                if ( inMsg.attrCmd )
   \                     ??zclProcessMessageMSG_13:
   \   0004A8   740C         MOV     A,#0xc
   \   0004AA   12....       LCALL   ?XSTACK_DISP0_8
   \   0004AD   E0           MOVX    A,@DPTR
   \   0004AE   F8           MOV     R0,A
   \   0004AF   A3           INC     DPTR
   \   0004B0   E0           MOVX    A,@DPTR
   \   0004B1   F9           MOV     R1,A
   \   0004B2   E8           MOV     A,R0
   \   0004B3   49           ORL     A,R1
   \   0004B4   600D         JZ      ??zclProcessMessageMSG_14
   1655                {
   1656                  osal_mem_free( inMsg.attrCmd );
   \   0004B6                ; Setup parameters for call to function osal_mem_free
   \   0004B6   740C         MOV     A,#0xc
   \   0004B8   12....       LCALL   ?XSTACK_DISP0_8
   \   0004BB   E0           MOVX    A,@DPTR
   \   0004BC   FA           MOV     R2,A
   \   0004BD   A3           INC     DPTR
   \   0004BE   E0           MOVX    A,@DPTR
   \   0004BF   FB           MOV     R3,A
   \   0004C0   12....       LCALL   ??osal_mem_free?relay
   1657                }
   1658          
   1659                if ( CMD_HAS_RSP( inMsg.hdr.commandID ) )
   \                     ??zclProcessMessageMSG_14:
   \   0004C3   7407         MOV     A,#0x7
   \   0004C5   12....       LCALL   ?XSTACK_DISP0_8
   \   0004C8   E0           MOVX    A,@DPTR
   \   0004C9   603C         JZ      ??zclProcessMessageMSG_15
   \   0004CB   7407         MOV     A,#0x7
   \   0004CD   12....       LCALL   ?XSTACK_DISP0_8
   \   0004D0   E0           MOVX    A,@DPTR
   \   0004D1   6402         XRL     A,#0x2
   \   0004D3   6032         JZ      ??zclProcessMessageMSG_15
   \   0004D5   7407         MOV     A,#0x7
   \   0004D7   12....       LCALL   ?XSTACK_DISP0_8
   \   0004DA   E0           MOVX    A,@DPTR
   \   0004DB   6403         XRL     A,#0x3
   \   0004DD   6028         JZ      ??zclProcessMessageMSG_15
   \   0004DF   7407         MOV     A,#0x7
   \   0004E1   12....       LCALL   ?XSTACK_DISP0_8
   \   0004E4   E0           MOVX    A,@DPTR
   \   0004E5   6406         XRL     A,#0x6
   \   0004E7   601E         JZ      ??zclProcessMessageMSG_15
   \   0004E9   7407         MOV     A,#0x7
   \   0004EB   12....       LCALL   ?XSTACK_DISP0_8
   \   0004EE   E0           MOVX    A,@DPTR
   \   0004EF   6408         XRL     A,#0x8
   \   0004F1   6014         JZ      ??zclProcessMessageMSG_15
   \   0004F3   7407         MOV     A,#0x7
   \   0004F5   12....       LCALL   ?XSTACK_DISP0_8
   \   0004F8   E0           MOVX    A,@DPTR
   \   0004F9   640C         XRL     A,#0xc
   \   0004FB   600A         JZ      ??zclProcessMessageMSG_15
   \   0004FD   7407         MOV     A,#0x7
   \   0004FF   12....       LCALL   ?XSTACK_DISP0_8
   \   000502   E0           MOVX    A,@DPTR
   \   000503   640B         XRL     A,#0xb
   \   000505   7003         JNZ     ??zclProcessMessageMSG_16
   1660                {
   1661                  return; // We're done
   \                     ??zclProcessMessageMSG_15:
   \   000507   02....       LJMP    ??zclProcessMessageMSG_0 & 0xFFFF
   1662                }
   1663          
   1664                status = ZSuccess;
   \                     ??zclProcessMessageMSG_16:
   \   00050A   7E00         MOV     R6,#0x0
   \   00050C   807A         SJMP    ??zclProcessMessageMSG_11
   1665              }
   1666              else
   1667              {
   1668                // Unsupported message
   1669                status = ZCL_STATUS_UNSUP_GENERAL_COMMAND;
   \                     ??zclProcessMessageMSG_12:
   \   00050E   7E82         MOV     R6,#-0x7e
   \   000510   8076         SJMP    ??zclProcessMessageMSG_11
   1670              }
   1671            }
   1672            else  // Not a foundation type message, so it must be specific to the cluster ID.
   1673            {
   1674              if ( pInPlugin && pInPlugin->pfnIncomingHdlr )
   \                     ??zclProcessMessageMSG_9:
   \   000512   E5..         MOV     A,?V0 + 4
   \   000514   45..         ORL     A,?V0 + 5
   \   000516   6047         JZ      ??zclProcessMessageMSG_17
   \   000518   85..82       MOV     DPL,?V0 + 4
   \   00051B   85..83       MOV     DPH,?V0 + 5
   \   00051E   A3           INC     DPTR
   \   00051F   A3           INC     DPTR
   \   000520   A3           INC     DPTR
   \   000521   A3           INC     DPTR
   \   000522   A3           INC     DPTR
   \   000523   A3           INC     DPTR
   \   000524   E0           MOVX    A,@DPTR
   \   000525   F8           MOV     R0,A
   \   000526   A3           INC     DPTR
   \   000527   E0           MOVX    A,@DPTR
   \   000528   F9           MOV     R1,A
   \   000529   E8           MOV     A,R0
   \   00052A   49           ORL     A,R1
   \   00052B   6032         JZ      ??zclProcessMessageMSG_17
   1675              {
   1676                // The return value of the plugin function will be
   1677                //  ZSuccess - Supported and need default response
   1678                //  ZFailure - Unsupported
   1679                //  ZCL_STATUS_CMD_HAS_RSP - Supported and do not need default rsp
   1680                //  ZCL_STATUS_INVALID_FIELD - Supported, but the incoming msg is wrong formatted
   1681                //  ZCL_STATUS_INVALID_VALUE - Supported, but the request not achievable by the h/w
   1682                //  ZCL_STATUS_SOFTWARE_FAILURE - Supported but ZStack memory allocation fails
   1683                status = pInPlugin->pfnIncomingHdlr( &inMsg );
   \   00052D                ; Setup parameters for indirect call
   \   00052D   85..82       MOV     DPL,?XSP + 0
   \   000530   85..83       MOV     DPH,?XSP + 1
   \   000533   AA82         MOV     R2,DPL
   \   000535   AB83         MOV     R3,DPH
   \   000537   85..82       MOV     DPL,?V0 + 4
   \   00053A   85..83       MOV     DPH,?V0 + 5
   \   00053D   A3           INC     DPTR
   \   00053E   A3           INC     DPTR
   \   00053F   A3           INC     DPTR
   \   000540   A3           INC     DPTR
   \   000541   A3           INC     DPTR
   \   000542   A3           INC     DPTR
   \   000543   E0           MOVX    A,@DPTR
   \   000544   F8           MOV     R0,A
   \   000545   A3           INC     DPTR
   \   000546   E0           MOVX    A,@DPTR
   \   000547   F583         MOV     DPH,A
   \   000549   8882         MOV     DPL,R0
   \   00054B   12....       LCALL   ?CALL_IND
   \   00054E   E9           MOV     A,R1
   \   00054F   FE           MOV     R6,A
   1684                if ( status == ZCL_STATUS_CMD_HAS_RSP || ( interPanMsg && status == ZSuccess ) )
   \   000550   74FF         MOV     A,#-0x1
   \   000552   6E           XRL     A,R6
   \   000553   6007         JZ      ??zclProcessMessageMSG_18
   \   000555   E5..         MOV     A,?V0 + 2
   \   000557   6006         JZ      ??zclProcessMessageMSG_17
   \   000559   EE           MOV     A,R6
   \   00055A   7003         JNZ     ??zclProcessMessageMSG_17
   1685                {
   1686                  return; // We're done
   \                     ??zclProcessMessageMSG_18:
   \   00055C   02....       LJMP    ??zclProcessMessageMSG_0 & 0xFFFF
   1687                }
   1688              }
   1689          
   1690              if ( status == ZFailure )
   \                     ??zclProcessMessageMSG_17:
   \   00055F   7401         MOV     A,#0x1
   \   000561   6E           XRL     A,R6
   \   000562   7024         JNZ     ??zclProcessMessageMSG_11
   1691              {
   1692                // Unsupported message
   1693                if ( inMsg.hdr.fc.manuSpecific )
   \   000564   7402         MOV     A,#0x2
   \   000566   12....       LCALL   ?XSTACK_DISP0_8
   \   000569   E0           MOVX    A,@DPTR
   \   00056A   F8           MOV     R0,A
   \   00056B   A3           INC     DPTR
   \   00056C   E0           MOVX    A,@DPTR
   \   00056D   F9           MOV     R1,A
   \   00056E   E8           MOV     A,R0
   \   00056F   13           RRC     A
   \   000570   13           RRC     A
   \   000571   543F         ANL     A,#0x3f
   \   000573   F8           MOV     R0,A
   \   000574   7900         MOV     R1,#0x0
   \   000576   5401         ANL     A,#0x1
   \   000578   F8           MOV     R0,A
   \   000579   E9           MOV     A,R1
   \   00057A   5400         ANL     A,#0x0
   \   00057C   F9           MOV     R1,A
   \   00057D   E8           MOV     A,R0
   \   00057E   A2E0         MOV     C,0xE0 /* A   */.0
   \   000580   5004         JNC     ??zclProcessMessageMSG_19
   1694                {
   1695                  status = ZCL_STATUS_UNSUP_MANU_CLUSTER_COMMAND;
   \   000582   7E83         MOV     R6,#-0x7d
   \   000584   8002         SJMP    ??zclProcessMessageMSG_11
   1696                }
   1697                else
   1698                {
   1699                  status = ZCL_STATUS_UNSUP_CLUSTER_COMMAND;
   \                     ??zclProcessMessageMSG_19:
   \   000586   7E81         MOV     R6,#-0x7f
   1700                }
   1701              }
   1702            }
   1703          
   1704            if ( UNICAST_MSG( inMsg.msg ) && inMsg.hdr.fc.disableDefaultRsp == 0 )
   \                     ??zclProcessMessageMSG_11:
   \   000588   85..82       MOV     DPL,?XSP + 0
   \   00058B   85..83       MOV     DPH,?XSP + 1
   \   00058E   E0           MOVX    A,@DPTR
   \   00058F   F8           MOV     R0,A
   \   000590   A3           INC     DPTR
   \   000591   E0           MOVX    A,@DPTR
   \   000592   C8           XCH     A,R0
   \   000593   2415         ADD     A,#0x15
   \   000595   F582         MOV     DPL,A
   \   000597   E8           MOV     A,R0
   \   000598   3400         ADDC    A,#0x0
   \   00059A   F583         MOV     DPH,A
   \   00059C   E0           MOVX    A,@DPTR
   \   00059D   6003         JZ      $+5
   \   00059F   02....       LJMP    ??zclProcessMessageMSG_0 & 0xFFFF
   \   0005A2   85..82       MOV     DPL,?XSP + 0
   \   0005A5   85..83       MOV     DPH,?XSP + 1
   \   0005A8   E0           MOVX    A,@DPTR
   \   0005A9   F8           MOV     R0,A
   \   0005AA   A3           INC     DPTR
   \   0005AB   E0           MOVX    A,@DPTR
   \   0005AC   F583         MOV     DPH,A
   \   0005AE   8882         MOV     DPL,R0
   \   0005B0   A3           INC     DPTR
   \   0005B1   A3           INC     DPTR
   \   0005B2   E0           MOVX    A,@DPTR
   \   0005B3   F8           MOV     R0,A
   \   0005B4   A3           INC     DPTR
   \   0005B5   E0           MOVX    A,@DPTR
   \   0005B6   F9           MOV     R1,A
   \   0005B7   E8           MOV     A,R0
   \   0005B8   49           ORL     A,R1
   \   0005B9   6003         JZ      $+5
   \   0005BB   02....       LJMP    ??zclProcessMessageMSG_0 & 0xFFFF
   \   0005BE   7402         MOV     A,#0x2
   \   0005C0   12....       LCALL   ?XSTACK_DISP0_8
   \   0005C3   E0           MOVX    A,@DPTR
   \   0005C4   F8           MOV     R0,A
   \   0005C5   A3           INC     DPTR
   \   0005C6   E0           MOVX    A,@DPTR
   \   0005C7   F9           MOV     R1,A
   \   0005C8   E8           MOV     A,R0
   \   0005C9   C4           SWAP    A
   \   0005CA   540F         ANL     A,#0xf
   \   0005CC   F8           MOV     R0,A
   \   0005CD   7900         MOV     R1,#0x0
   \   0005CF   5401         ANL     A,#0x1
   \   0005D1   F8           MOV     R0,A
   \   0005D2   E9           MOV     A,R1
   \   0005D3   5400         ANL     A,#0x0
   \   0005D5   F9           MOV     R1,A
   \   0005D6   E8           MOV     A,R0
   \   0005D7   A2E0         MOV     C,0xE0 /* A   */.0
   \   0005D9   5003         JNC     $+5
   \   0005DB   02....       LJMP    ??zclProcessMessageMSG_0 & 0xFFFF
   1705            {
   1706              // Send a Default Response command back
   1707              defautlRspCmd.statusCode = status;
   \   0005DE   EE           MOV     A,R6
   \   0005DF   C0E0         PUSH    A
   \   0005E1   740F         MOV     A,#0xf
   \   0005E3   12....       LCALL   ?XSTACK_DISP0_8
   \   0005E6   D0E0         POP     A
   \   0005E8   F0           MOVX    @DPTR,A
   1708              defautlRspCmd.commandID = inMsg.hdr.commandID;
   \   0005E9   7407         MOV     A,#0x7
   \   0005EB   12....       LCALL   ?XSTACK_DISP0_8
   \   0005EE   E0           MOVX    A,@DPTR
   \   0005EF   C0E0         PUSH    A
   \   0005F1   740E         MOV     A,#0xe
   \   0005F3   12....       LCALL   ?XSTACK_DISP0_8
   \   0005F6   D0E0         POP     A
   \   0005F8   F0           MOVX    @DPTR,A
   1709              zcl_SendDefaultRspCmd( inMsg.msg->endPoint, &(inMsg.msg->srcAddr),
   1710                                     inMsg.msg->clusterId, &defautlRspCmd,
   1711                                     ZCL_FRAME_SERVER_CLIENT_DIR, true,
   1712                                     inMsg.hdr.manuCode, inMsg.hdr.transSeqNum );
   \   0005F9                ; Setup parameters for call to function zcl_SendDefaultRspCmd
   \   0005F9   7406         MOV     A,#0x6
   \   0005FB   12....       LCALL   ?XSTACK_DISP0_8
   \   0005FE   E0           MOVX    A,@DPTR
   \   0005FF   F5..         MOV     ?V0 + 8,A
   \   000601   78..         MOV     R0,#?V0 + 8
   \   000603   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000606   7405         MOV     A,#0x5
   \   000608   12....       LCALL   ?XSTACK_DISP0_8
   \   00060B   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   00060E   75..01       MOV     ?V0 + 8,#0x1
   \   000611   78..         MOV     R0,#?V0 + 8
   \   000613   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000616   75..01       MOV     ?V0 + 8,#0x1
   \   000619   78..         MOV     R0,#?V0 + 8
   \   00061B   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00061E   7413         MOV     A,#0x13
   \   000620   12....       LCALL   ?XSTACK_DISP0_8
   \   000623   8582..       MOV     ?V0 + 8,DPL
   \   000626   8583..       MOV     ?V0 + 9,DPH
   \   000629   78..         MOV     R0,#?V0 + 8
   \   00062B   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00062E   7407         MOV     A,#0x7
   \   000630   12....       LCALL   ?XSTACK_DISP0_8
   \   000633   E0           MOVX    A,@DPTR
   \   000634   F8           MOV     R0,A
   \   000635   A3           INC     DPTR
   \   000636   E0           MOVX    A,@DPTR
   \   000637   F583         MOV     DPH,A
   \   000639   8882         MOV     DPL,R0
   \   00063B   A3           INC     DPTR
   \   00063C   A3           INC     DPTR
   \   00063D   A3           INC     DPTR
   \   00063E   A3           INC     DPTR
   \   00063F   E0           MOVX    A,@DPTR
   \   000640   FC           MOV     R4,A
   \   000641   A3           INC     DPTR
   \   000642   E0           MOVX    A,@DPTR
   \   000643   FD           MOV     R5,A
   \   000644   7407         MOV     A,#0x7
   \   000646   12....       LCALL   ?XSTACK_DISP0_8
   \   000649   E0           MOVX    A,@DPTR
   \   00064A   2406         ADD     A,#0x6
   \   00064C   FA           MOV     R2,A
   \   00064D   A3           INC     DPTR
   \   00064E   E0           MOVX    A,@DPTR
   \   00064F   3400         ADDC    A,#0x0
   \   000651   FB           MOV     R3,A
   \   000652   7407         MOV     A,#0x7
   \   000654   12....       LCALL   ?XSTACK_DISP0_8
   \   000657   E0           MOVX    A,@DPTR
   \   000658   F8           MOV     R0,A
   \   000659   A3           INC     DPTR
   \   00065A   E0           MOVX    A,@DPTR
   \   00065B   C8           XCH     A,R0
   \   00065C   2414         ADD     A,#0x14
   \   00065E   F582         MOV     DPL,A
   \   000660   E8           MOV     A,R0
   \   000661   3400         ADDC    A,#0x0
   \   000663   F583         MOV     DPH,A
   \   000665   E0           MOVX    A,@DPTR
   \   000666   F9           MOV     R1,A
   \   000667   12....       LCALL   ??zcl_SendDefaultRspCmd?relay
   \   00066A   7407         MOV     A,#0x7
   \   00066C   12....       LCALL   ?DEALLOC_XSTACK8
   \   00066F   E9           MOV     A,R1
   1713            }
   1714          }
   \                     ??zclProcessMessageMSG_0:
   \   000670   7415         MOV     A,#0x15
   \   000672   12....       LCALL   ?DEALLOC_XSTACK8
   \   000675   7F0A         MOV     R7,#0xa
   \   000677   02....       LJMP    ?BANKED_LEAVE_XDATA
   1715          
   1716          /*********************************************************************
   1717           * @fn      zclParseHdr
   1718           *
   1719           * @brief   Parse header of the ZCL format
   1720           *
   1721           * @param   hdr - place to put the frame control information
   1722           * @param   pData - incoming buffer to parse
   1723           *
   1724           * @return  pointer past the header
   1725           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1726          uint8 *zclParseHdr( zclFrameHdr_t *hdr, uint8 *pData )
   \                     zclParseHdr:
   1727          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV     ?V0 + 0,R2
   \   000007   8B..         MOV     ?V0 + 1,R3
   \   000009   EC           MOV     A,R4
   \   00000A   FE           MOV     R6,A
   \   00000B   ED           MOV     A,R5
   \   00000C   FF           MOV     R7,A
   1728            // Clear the header
   1729            osal_memset( (uint8 *)hdr, 0, sizeof ( zclFrameHdr_t ) );
   \   00000D                ; Setup parameters for call to function osal_memset
   \   00000D   7C06         MOV     R4,#0x6
   \   00000F   7D00         MOV     R5,#0x0
   \   000011   7900         MOV     R1,#0x0
   \   000013   AA..         MOV     R2,?V0 + 0
   \   000015   AB..         MOV     R3,?V0 + 1
   \   000017   12....       LCALL   ??osal_memset?relay
   1730          
   1731            // Parse the Frame Control
   1732            hdr->fc.type = zcl_FCType( *pData );
   \   00001A   8E82         MOV     DPL,R6
   \   00001C   8F83         MOV     DPH,R7
   \   00001E   E0           MOVX    A,@DPTR
   \   00001F   F8           MOV     R0,A
   \   000020   7900         MOV     R1,#0x0
   \   000022   5403         ANL     A,#0x3
   \   000024   F8           MOV     R0,A
   \   000025   E9           MOV     A,R1
   \   000026   5400         ANL     A,#0x0
   \   000028   F9           MOV     R1,A
   \   000029   85..82       MOV     DPL,?V0 + 0
   \   00002C   85..83       MOV     DPH,?V0 + 1
   \   00002F   E0           MOVX    A,@DPTR
   \   000030   54FC         ANL     A,#0xfc
   \   000032   FA           MOV     R2,A
   \   000033   A3           INC     DPTR
   \   000034   E0           MOVX    A,@DPTR
   \   000035   54FF         ANL     A,#0xff
   \   000037   FB           MOV     R3,A
   \   000038   E8           MOV     A,R0
   \   000039   5403         ANL     A,#0x3
   \   00003B   F8           MOV     R0,A
   \   00003C   E9           MOV     A,R1
   \   00003D   5400         ANL     A,#0x0
   \   00003F   F9           MOV     R1,A
   \   000040   EA           MOV     A,R2
   \   000041   48           ORL     A,R0
   \   000042   F8           MOV     R0,A
   \   000043   EB           MOV     A,R3
   \   000044   49           ORL     A,R1
   \   000045   F9           MOV     R1,A
   \   000046   85..82       MOV     DPL,?V0 + 0
   \   000049   85..83       MOV     DPH,?V0 + 1
   \   00004C   E8           MOV     A,R0
   \   00004D   F0           MOVX    @DPTR,A
   \   00004E   A3           INC     DPTR
   \   00004F   E9           MOV     A,R1
   \   000050   F0           MOVX    @DPTR,A
   1733            hdr->fc.manuSpecific = zcl_FCManuSpecific( *pData ) ? 1 : 0;
   \   000051   8E82         MOV     DPL,R6
   \   000053   8F83         MOV     DPH,R7
   \   000055   E0           MOVX    A,@DPTR
   \   000056   A2E2         MOV     C,0xE0 /* A   */.2
   \   000058   5004         JNC     ??zclParseHdr_0
   \   00005A   D2F0         SETB    B.0
   \   00005C   8002         SJMP    ??zclParseHdr_1
   \                     ??zclParseHdr_0:
   \   00005E   C2F0         CLR     B.0
   \                     ??zclParseHdr_1:
   \   000060   85..82       MOV     DPL,?V0 + 0
   \   000063   85..83       MOV     DPH,?V0 + 1
   \   000066   E0           MOVX    A,@DPTR
   \   000067   54FB         ANL     A,#0xfb
   \   000069   FA           MOV     R2,A
   \   00006A   A3           INC     DPTR
   \   00006B   E0           MOVX    A,@DPTR
   \   00006C   54FF         ANL     A,#0xff
   \   00006E   FB           MOV     R3,A
   \   00006F   A2F0         MOV     C,B.0
   \   000071   E4           CLR     A
   \   000072   33           RLC     A
   \   000073   F5..         MOV     ?V0 + 2,A
   \   000075   75..00       MOV     ?V0 + 3,#0x0
   \   000078   7402         MOV     A,#0x2
   \   00007A   78..         MOV     R0,#?V0 + 2
   \   00007C   12....       LCALL   ?S_SHL
   \   00007F   EA           MOV     A,R2
   \   000080   45..         ORL     A,?V0 + 2
   \   000082   F8           MOV     R0,A
   \   000083   EB           MOV     A,R3
   \   000084   45..         ORL     A,?V0 + 3
   \   000086   F9           MOV     R1,A
   \   000087   85..82       MOV     DPL,?V0 + 0
   \   00008A   85..83       MOV     DPH,?V0 + 1
   \   00008D   E8           MOV     A,R0
   \   00008E   F0           MOVX    @DPTR,A
   \   00008F   A3           INC     DPTR
   \   000090   E9           MOV     A,R1
   \   000091   F0           MOVX    @DPTR,A
   1734            if ( zcl_FCDirection( *pData ) )
   \   000092   8E82         MOV     DPL,R6
   \   000094   8F83         MOV     DPH,R7
   \   000096   E0           MOVX    A,@DPTR
   \   000097   A2E3         MOV     C,0xE0 /* A   */.3
   \   000099   5011         JNC     ??zclParseHdr_2
   1735            {
   1736              hdr->fc.direction = ZCL_FRAME_SERVER_CLIENT_DIR;
   \   00009B   85..82       MOV     DPL,?V0 + 0
   \   00009E   85..83       MOV     DPH,?V0 + 1
   \   0000A1   E0           MOVX    A,@DPTR
   \   0000A2   4408         ORL     A,#0x8
   \   0000A4   F0           MOVX    @DPTR,A
   \   0000A5   A3           INC     DPTR
   \   0000A6   E0           MOVX    A,@DPTR
   \   0000A7   4400         ORL     A,#0x0
   \   0000A9   F0           MOVX    @DPTR,A
   \   0000AA   800F         SJMP    ??zclParseHdr_3
   1737            }
   1738            else
   1739            {
   1740              hdr->fc.direction = ZCL_FRAME_CLIENT_SERVER_DIR;
   \                     ??zclParseHdr_2:
   \   0000AC   85..82       MOV     DPL,?V0 + 0
   \   0000AF   85..83       MOV     DPH,?V0 + 1
   \   0000B2   E0           MOVX    A,@DPTR
   \   0000B3   54F7         ANL     A,#0xf7
   \   0000B5   F0           MOVX    @DPTR,A
   \   0000B6   A3           INC     DPTR
   \   0000B7   E0           MOVX    A,@DPTR
   \   0000B8   54FF         ANL     A,#0xff
   \   0000BA   F0           MOVX    @DPTR,A
   1741            }
   1742          
   1743            hdr->fc.disableDefaultRsp = zcl_FCDisableDefaultRsp( *pData ) ? 1 : 0;
   \                     ??zclParseHdr_3:
   \   0000BB   8E82         MOV     DPL,R6
   \   0000BD   8F83         MOV     DPH,R7
   \   0000BF   E0           MOVX    A,@DPTR
   \   0000C0   A2E4         MOV     C,0xE0 /* A   */.4
   \   0000C2   5004         JNC     ??zclParseHdr_4
   \   0000C4   D2F0         SETB    B.0
   \   0000C6   8002         SJMP    ??zclParseHdr_5
   \                     ??zclParseHdr_4:
   \   0000C8   C2F0         CLR     B.0
   \                     ??zclParseHdr_5:
   \   0000CA   85..82       MOV     DPL,?V0 + 0
   \   0000CD   85..83       MOV     DPH,?V0 + 1
   \   0000D0   E0           MOVX    A,@DPTR
   \   0000D1   54EF         ANL     A,#0xef
   \   0000D3   FA           MOV     R2,A
   \   0000D4   A3           INC     DPTR
   \   0000D5   E0           MOVX    A,@DPTR
   \   0000D6   54FF         ANL     A,#0xff
   \   0000D8   FB           MOV     R3,A
   \   0000D9   A2F0         MOV     C,B.0
   \   0000DB   E4           CLR     A
   \   0000DC   33           RLC     A
   \   0000DD   F5..         MOV     ?V0 + 2,A
   \   0000DF   75..00       MOV     ?V0 + 3,#0x0
   \   0000E2   7404         MOV     A,#0x4
   \   0000E4   78..         MOV     R0,#?V0 + 2
   \   0000E6   12....       LCALL   ?S_SHL
   \   0000E9   EA           MOV     A,R2
   \   0000EA   45..         ORL     A,?V0 + 2
   \   0000EC   F8           MOV     R0,A
   \   0000ED   EB           MOV     A,R3
   \   0000EE   45..         ORL     A,?V0 + 3
   \   0000F0   F9           MOV     R1,A
   \   0000F1   85..82       MOV     DPL,?V0 + 0
   \   0000F4   85..83       MOV     DPH,?V0 + 1
   \   0000F7   E8           MOV     A,R0
   \   0000F8   F0           MOVX    @DPTR,A
   \   0000F9   A3           INC     DPTR
   \   0000FA   E9           MOV     A,R1
   \   0000FB   F0           MOVX    @DPTR,A
   1744            pData++;  // move past the frame control field
   \   0000FC   8E82         MOV     DPL,R6
   \   0000FE   8F83         MOV     DPH,R7
   \   000100   A3           INC     DPTR
   \   000101   AE82         MOV     R6,DPL
   \   000103   AF83         MOV     R7,DPH
   1745          
   1746            // parse the manfacturer code
   1747            if ( hdr->fc.manuSpecific )
   \   000105   85..82       MOV     DPL,?V0 + 0
   \   000108   85..83       MOV     DPH,?V0 + 1
   \   00010B   E0           MOVX    A,@DPTR
   \   00010C   F8           MOV     R0,A
   \   00010D   A3           INC     DPTR
   \   00010E   E0           MOVX    A,@DPTR
   \   00010F   F9           MOV     R1,A
   \   000110   E8           MOV     A,R0
   \   000111   13           RRC     A
   \   000112   13           RRC     A
   \   000113   543F         ANL     A,#0x3f
   \   000115   F8           MOV     R0,A
   \   000116   7900         MOV     R1,#0x0
   \   000118   5401         ANL     A,#0x1
   \   00011A   F8           MOV     R0,A
   \   00011B   E9           MOV     A,R1
   \   00011C   5400         ANL     A,#0x0
   \   00011E   F9           MOV     R1,A
   \   00011F   E8           MOV     A,R0
   \   000120   A2E0         MOV     C,0xE0 /* A   */.0
   \   000122   502F         JNC     ??zclParseHdr_6
   1748            {
   1749              hdr->manuCode = BUILD_UINT16( pData[0], pData[1] );
   \   000124   8E82         MOV     DPL,R6
   \   000126   8F83         MOV     DPH,R7
   \   000128   E0           MOVX    A,@DPTR
   \   000129   FA           MOV     R2,A
   \   00012A   7B00         MOV     R3,#0x0
   \   00012C   8E82         MOV     DPL,R6
   \   00012E   8F83         MOV     DPH,R7
   \   000130   A3           INC     DPTR
   \   000131   E0           MOVX    A,@DPTR
   \   000132   F8           MOV     R0,A
   \   000133   7900         MOV     R1,#0x0
   \   000135   E4           CLR     A
   \   000136   C8           XCH     A,R0
   \   000137   F9           MOV     R1,A
   \   000138   EA           MOV     A,R2
   \   000139   28           ADD     A,R0
   \   00013A   F8           MOV     R0,A
   \   00013B   EB           MOV     A,R3
   \   00013C   39           ADDC    A,R1
   \   00013D   F9           MOV     R1,A
   \   00013E   85..82       MOV     DPL,?V0 + 0
   \   000141   85..83       MOV     DPH,?V0 + 1
   \   000144   A3           INC     DPTR
   \   000145   A3           INC     DPTR
   \   000146   E8           MOV     A,R0
   \   000147   F0           MOVX    @DPTR,A
   \   000148   A3           INC     DPTR
   \   000149   E9           MOV     A,R1
   \   00014A   F0           MOVX    @DPTR,A
   1750              pData += 2;
   \   00014B   EE           MOV     A,R6
   \   00014C   2402         ADD     A,#0x2
   \   00014E   FE           MOV     R6,A
   \   00014F   EF           MOV     A,R7
   \   000150   3400         ADDC    A,#0x0
   \   000152   FF           MOV     R7,A
   1751            }
   1752          
   1753            // parse the Transaction Sequence Number
   1754            hdr->transSeqNum = *pData++;
   \                     ??zclParseHdr_6:
   \   000153   8E82         MOV     DPL,R6
   \   000155   8F83         MOV     DPH,R7
   \   000157   E0           MOVX    A,@DPTR
   \   000158   85..82       MOV     DPL,?V0 + 0
   \   00015B   85..83       MOV     DPH,?V0 + 1
   \   00015E   A3           INC     DPTR
   \   00015F   A3           INC     DPTR
   \   000160   A3           INC     DPTR
   \   000161   A3           INC     DPTR
   \   000162   F0           MOVX    @DPTR,A
   \   000163   8E82         MOV     DPL,R6
   \   000165   8F83         MOV     DPH,R7
   \   000167   A3           INC     DPTR
   \   000168   AE82         MOV     R6,DPL
   \   00016A   AF83         MOV     R7,DPH
   1755          
   1756            // parse the Cluster's command ID
   1757            hdr->commandID = *pData++;
   \   00016C   8E82         MOV     DPL,R6
   \   00016E   8F83         MOV     DPH,R7
   \   000170   E0           MOVX    A,@DPTR
   \   000171   85..82       MOV     DPL,?V0 + 0
   \   000174   85..83       MOV     DPH,?V0 + 1
   \   000177   A3           INC     DPTR
   \   000178   A3           INC     DPTR
   \   000179   A3           INC     DPTR
   \   00017A   A3           INC     DPTR
   \   00017B   A3           INC     DPTR
   \   00017C   F0           MOVX    @DPTR,A
   \   00017D   8E82         MOV     DPL,R6
   \   00017F   8F83         MOV     DPH,R7
   \   000181   A3           INC     DPTR
   \   000182   AE82         MOV     R6,DPL
   \   000184   AF83         MOV     R7,DPH
   1758          
   1759            // Should point to the frame payload
   1760            return ( pData );
   \   000186   E582         MOV     A,DPL
   \   000188   AA82         MOV     R2,DPL
   \   00018A   E583         MOV     A,DPH
   \   00018C   AB83         MOV     R3,DPH
   \   00018E   7F04         MOV     R7,#0x4
   \   000190   02....       LJMP    ?BANKED_LEAVE_XDATA
   1761          }
   1762          
   1763          /*********************************************************************
   1764           * @fn      zclBuildHdr
   1765           *
   1766           * @brief   Build header of the ZCL format
   1767           *
   1768           * @param   hdr - outgoing header information
   1769           * @param   pData - outgoing header space
   1770           *
   1771           * @return  pointer past the header
   1772           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1773          static uint8 *zclBuildHdr( zclFrameHdr_t *hdr, uint8 *pData )
   \                     zclBuildHdr:
   1774          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   \   000004   EA           MOV     A,R2
   \   000005   F8           MOV     R0,A
   \   000006   EB           MOV     A,R3
   \   000007   F9           MOV     R1,A
   \   000008   EC           MOV     A,R4
   \   000009   FA           MOV     R2,A
   \   00000A   ED           MOV     A,R5
   \   00000B   FB           MOV     R3,A
   1775            // Build the Frame Control byte
   1776            *pData = hdr->fc.type;
   \   00000C   8882         MOV     DPL,R0
   \   00000E   8983         MOV     DPH,R1
   \   000010   E0           MOVX    A,@DPTR
   \   000011   FC           MOV     R4,A
   \   000012   A3           INC     DPTR
   \   000013   E0           MOVX    A,@DPTR
   \   000014   FD           MOV     R5,A
   \   000015   EC           MOV     A,R4
   \   000016   5403         ANL     A,#0x3
   \   000018   8A82         MOV     DPL,R2
   \   00001A   8B83         MOV     DPH,R3
   \   00001C   F0           MOVX    @DPTR,A
   1777            *pData |= hdr->fc.manuSpecific << 2;
   \   00001D   8882         MOV     DPL,R0
   \   00001F   8983         MOV     DPH,R1
   \   000021   E0           MOVX    A,@DPTR
   \   000022   FC           MOV     R4,A
   \   000023   A3           INC     DPTR
   \   000024   E0           MOVX    A,@DPTR
   \   000025   FD           MOV     R5,A
   \   000026   EC           MOV     A,R4
   \   000027   13           RRC     A
   \   000028   13           RRC     A
   \   000029   543F         ANL     A,#0x3f
   \   00002B   FC           MOV     R4,A
   \   00002C   7D00         MOV     R5,#0x0
   \   00002E   5401         ANL     A,#0x1
   \   000030   FC           MOV     R4,A
   \   000031   ED           MOV     A,R5
   \   000032   5400         ANL     A,#0x0
   \   000034   FD           MOV     R5,A
   \   000035   EC           MOV     A,R4
   \   000036   33           RLC     A
   \   000037   33           RLC     A
   \   000038   54FC         ANL     A,#0xfc
   \   00003A   FC           MOV     R4,A
   \   00003B   8A82         MOV     DPL,R2
   \   00003D   8B83         MOV     DPH,R3
   \   00003F   E0           MOVX    A,@DPTR
   \   000040   4C           ORL     A,R4
   \   000041   F0           MOVX    @DPTR,A
   1778            *pData |= hdr->fc.direction << 3;
   \   000042   8882         MOV     DPL,R0
   \   000044   8983         MOV     DPH,R1
   \   000046   E0           MOVX    A,@DPTR
   \   000047   FC           MOV     R4,A
   \   000048   A3           INC     DPTR
   \   000049   E0           MOVX    A,@DPTR
   \   00004A   FD           MOV     R5,A
   \   00004B   EC           MOV     A,R4
   \   00004C   13           RRC     A
   \   00004D   13           RRC     A
   \   00004E   13           RRC     A
   \   00004F   541F         ANL     A,#0x1f
   \   000051   FC           MOV     R4,A
   \   000052   7D00         MOV     R5,#0x0
   \   000054   5401         ANL     A,#0x1
   \   000056   FC           MOV     R4,A
   \   000057   ED           MOV     A,R5
   \   000058   5400         ANL     A,#0x0
   \   00005A   FD           MOV     R5,A
   \   00005B   EC           MOV     A,R4
   \   00005C   33           RLC     A
   \   00005D   33           RLC     A
   \   00005E   33           RLC     A
   \   00005F   54F8         ANL     A,#0xf8
   \   000061   FC           MOV     R4,A
   \   000062   8A82         MOV     DPL,R2
   \   000064   8B83         MOV     DPH,R3
   \   000066   E0           MOVX    A,@DPTR
   \   000067   4C           ORL     A,R4
   \   000068   F0           MOVX    @DPTR,A
   1779            *pData |= hdr->fc.disableDefaultRsp << 4;
   \   000069   8882         MOV     DPL,R0
   \   00006B   8983         MOV     DPH,R1
   \   00006D   E0           MOVX    A,@DPTR
   \   00006E   FC           MOV     R4,A
   \   00006F   A3           INC     DPTR
   \   000070   E0           MOVX    A,@DPTR
   \   000071   FD           MOV     R5,A
   \   000072   EC           MOV     A,R4
   \   000073   C4           SWAP    A
   \   000074   540F         ANL     A,#0xf
   \   000076   FC           MOV     R4,A
   \   000077   7D00         MOV     R5,#0x0
   \   000079   5401         ANL     A,#0x1
   \   00007B   FC           MOV     R4,A
   \   00007C   ED           MOV     A,R5
   \   00007D   5400         ANL     A,#0x0
   \   00007F   FD           MOV     R5,A
   \   000080   EC           MOV     A,R4
   \   000081   C4           SWAP    A
   \   000082   54F0         ANL     A,#0xf0
   \   000084   FC           MOV     R4,A
   \   000085   8A82         MOV     DPL,R2
   \   000087   8B83         MOV     DPH,R3
   \   000089   E0           MOVX    A,@DPTR
   \   00008A   4C           ORL     A,R4
   \   00008B   F0           MOVX    @DPTR,A
   1780            pData++;  // move past the frame control field
   \   00008C   8A82         MOV     DPL,R2
   \   00008E   8B83         MOV     DPH,R3
   \   000090   A3           INC     DPTR
   \   000091   AA82         MOV     R2,DPL
   \   000093   AB83         MOV     R3,DPH
   1781          
   1782            // Add the manfacturer code
   1783            if ( hdr->fc.manuSpecific )
   \   000095   8882         MOV     DPL,R0
   \   000097   8983         MOV     DPH,R1
   \   000099   E0           MOVX    A,@DPTR
   \   00009A   FC           MOV     R4,A
   \   00009B   A3           INC     DPTR
   \   00009C   E0           MOVX    A,@DPTR
   \   00009D   FD           MOV     R5,A
   \   00009E   EC           MOV     A,R4
   \   00009F   13           RRC     A
   \   0000A0   13           RRC     A
   \   0000A1   543F         ANL     A,#0x3f
   \   0000A3   FC           MOV     R4,A
   \   0000A4   7D00         MOV     R5,#0x0
   \   0000A6   5401         ANL     A,#0x1
   \   0000A8   FC           MOV     R4,A
   \   0000A9   ED           MOV     A,R5
   \   0000AA   5400         ANL     A,#0x0
   \   0000AC   FD           MOV     R5,A
   \   0000AD   EC           MOV     A,R4
   \   0000AE   A2E0         MOV     C,0xE0 /* A   */.0
   \   0000B0   5036         JNC     ??zclBuildHdr_0
   1784            {
   1785              *pData++ = LO_UINT16( hdr->manuCode );
   \   0000B2   8882         MOV     DPL,R0
   \   0000B4   8983         MOV     DPH,R1
   \   0000B6   A3           INC     DPTR
   \   0000B7   A3           INC     DPTR
   \   0000B8   E0           MOVX    A,@DPTR
   \   0000B9   FC           MOV     R4,A
   \   0000BA   A3           INC     DPTR
   \   0000BB   E0           MOVX    A,@DPTR
   \   0000BC   FD           MOV     R5,A
   \   0000BD   EC           MOV     A,R4
   \   0000BE   8A82         MOV     DPL,R2
   \   0000C0   8B83         MOV     DPH,R3
   \   0000C2   F0           MOVX    @DPTR,A
   \   0000C3   8A82         MOV     DPL,R2
   \   0000C5   8B83         MOV     DPH,R3
   \   0000C7   A3           INC     DPTR
   \   0000C8   AA82         MOV     R2,DPL
   \   0000CA   AB83         MOV     R3,DPH
   1786              *pData++ = HI_UINT16( hdr->manuCode );
   \   0000CC   8882         MOV     DPL,R0
   \   0000CE   8983         MOV     DPH,R1
   \   0000D0   A3           INC     DPTR
   \   0000D1   A3           INC     DPTR
   \   0000D2   E0           MOVX    A,@DPTR
   \   0000D3   FC           MOV     R4,A
   \   0000D4   A3           INC     DPTR
   \   0000D5   E0           MOVX    A,@DPTR
   \   0000D6   FD           MOV     R5,A
   \   0000D7   E4           CLR     A
   \   0000D8   ED           MOV     A,R5
   \   0000D9   FC           MOV     R4,A
   \   0000DA   8A82         MOV     DPL,R2
   \   0000DC   8B83         MOV     DPH,R3
   \   0000DE   F0           MOVX    @DPTR,A
   \   0000DF   8A82         MOV     DPL,R2
   \   0000E1   8B83         MOV     DPH,R3
   \   0000E3   A3           INC     DPTR
   \   0000E4   AA82         MOV     R2,DPL
   \   0000E6   AB83         MOV     R3,DPH
   1787            }
   1788          
   1789            // Add the Transaction Sequence Number
   1790            *pData++ = hdr->transSeqNum;
   \                     ??zclBuildHdr_0:
   \   0000E8   8882         MOV     DPL,R0
   \   0000EA   8983         MOV     DPH,R1
   \   0000EC   A3           INC     DPTR
   \   0000ED   A3           INC     DPTR
   \   0000EE   A3           INC     DPTR
   \   0000EF   A3           INC     DPTR
   \   0000F0   E0           MOVX    A,@DPTR
   \   0000F1   8A82         MOV     DPL,R2
   \   0000F3   8B83         MOV     DPH,R3
   \   0000F5   F0           MOVX    @DPTR,A
   \   0000F6   8A82         MOV     DPL,R2
   \   0000F8   8B83         MOV     DPH,R3
   \   0000FA   A3           INC     DPTR
   \   0000FB   AA82         MOV     R2,DPL
   \   0000FD   AB83         MOV     R3,DPH
   1791          
   1792            // Add the Cluster's command ID
   1793            *pData++ = hdr->commandID;
   \   0000FF   8882         MOV     DPL,R0
   \   000101   8983         MOV     DPH,R1
   \   000103   A3           INC     DPTR
   \   000104   A3           INC     DPTR
   \   000105   A3           INC     DPTR
   \   000106   A3           INC     DPTR
   \   000107   A3           INC     DPTR
   \   000108   E0           MOVX    A,@DPTR
   \   000109   8A82         MOV     DPL,R2
   \   00010B   8B83         MOV     DPH,R3
   \   00010D   F0           MOVX    @DPTR,A
   \   00010E   8A82         MOV     DPL,R2
   \   000110   8B83         MOV     DPH,R3
   \   000112   A3           INC     DPTR
   \   000113   AA82         MOV     R2,DPL
   \   000115   AB83         MOV     R3,DPH
   1794          
   1795            // Should point to the frame payload
   1796            return ( pData );
   \   000117   D083         POP     DPH
   \   000119   D082         POP     DPL
   \   00011B   02....       LJMP    ?BRET
   1797          }
   1798          
   1799          /*********************************************************************
   1800           * @fn      zclCalcHdrSize
   1801           *
   1802           * @brief   Calculate the number of bytes needed for an outgoing
   1803           *          ZCL header.
   1804           *
   1805           * @param   hdr - outgoing header information
   1806           *
   1807           * @return  returns the number of bytes needed
   1808           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1809          static uint8 zclCalcHdrSize( zclFrameHdr_t *hdr )
   \                     zclCalcHdrSize:
   1810          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1811            uint8 needed = (1 + 1 + 1); // frame control + transaction seq num + cmd ID
   \   000004   7903         MOV     R1,#0x3
   1812          
   1813            // Add the manfacturer code
   1814            if ( hdr->fc.manuSpecific )
   \   000006   8A82         MOV     DPL,R2
   \   000008   8B83         MOV     DPH,R3
   \   00000A   E0           MOVX    A,@DPTR
   \   00000B   FC           MOV     R4,A
   \   00000C   A3           INC     DPTR
   \   00000D   E0           MOVX    A,@DPTR
   \   00000E   FD           MOV     R5,A
   \   00000F   EC           MOV     A,R4
   \   000010   13           RRC     A
   \   000011   13           RRC     A
   \   000012   543F         ANL     A,#0x3f
   \   000014   FC           MOV     R4,A
   \   000015   7D00         MOV     R5,#0x0
   \   000017   5401         ANL     A,#0x1
   \   000019   FC           MOV     R4,A
   \   00001A   ED           MOV     A,R5
   \   00001B   5400         ANL     A,#0x0
   \   00001D   FD           MOV     R5,A
   \   00001E   EC           MOV     A,R4
   \   00001F   A2E0         MOV     C,0xE0 /* A   */.0
   \   000021   5004         JNC     ??zclCalcHdrSize_0
   1815            {
   1816              needed += 2;
   \   000023   7402         MOV     A,#0x2
   \   000025   29           ADD     A,R1
   \   000026   F9           MOV     R1,A
   1817            }
   1818          
   1819            return ( needed );
   \                     ??zclCalcHdrSize_0:
   \   000027   D083         POP     DPH
   \   000029   D082         POP     DPL
   \   00002B   02....       LJMP    ?BRET
   1820          }
   1821          
   1822          /*********************************************************************
   1823           * @fn      zclFindPlugin
   1824           *
   1825           * @brief   Find the right plugin for a cluster ID
   1826           *
   1827           * @param   clusterID - cluster ID to look for
   1828           * @param   profileID - profile ID
   1829           *
   1830           * @return  pointer to plugin, NULL if not found
   1831           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1832          static zclLibPlugin_t *zclFindPlugin( uint16 clusterID, uint16 profileID )
   \                     zclFindPlugin:
   1833          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   1834            (void)profileID;  // Intentionally unreferenced parameter
   1835          
   1836            zclLibPlugin_t *pLoop = plugins;
   \   000009   90....       MOV     DPTR,#plugins
   \   00000C   E0           MOVX    A,@DPTR
   \   00000D   F8           MOV     R0,A
   \   00000E   A3           INC     DPTR
   \   00000F   E0           MOVX    A,@DPTR
   \   000010   F9           MOV     R1,A
   1837          
   1838            while ( pLoop != NULL )
   \                     ??zclFindPlugin_0:
   \   000011   E8           MOV     A,R0
   \   000012   49           ORL     A,R1
   \   000013   6033         JZ      ??zclFindPlugin_1
   1839            {
   1840              if ( ( clusterID >= pLoop->startClusterID ) && ( clusterID <= pLoop->endClusterID ) )
   \   000015   8882         MOV     DPL,R0
   \   000017   8983         MOV     DPH,R1
   \   000019   A3           INC     DPTR
   \   00001A   A3           INC     DPTR
   \   00001B   E0           MOVX    A,@DPTR
   \   00001C   FA           MOV     R2,A
   \   00001D   A3           INC     DPTR
   \   00001E   E0           MOVX    A,@DPTR
   \   00001F   FB           MOV     R3,A
   \   000020   C3           CLR     C
   \   000021   EE           MOV     A,R6
   \   000022   9A           SUBB    A,R2
   \   000023   EF           MOV     A,R7
   \   000024   9B           SUBB    A,R3
   \   000025   4016         JC      ??zclFindPlugin_2
   \   000027   8882         MOV     DPL,R0
   \   000029   8983         MOV     DPH,R1
   \   00002B   A3           INC     DPTR
   \   00002C   A3           INC     DPTR
   \   00002D   A3           INC     DPTR
   \   00002E   A3           INC     DPTR
   \   00002F   C3           CLR     C
   \   000030   E0           MOVX    A,@DPTR
   \   000031   9E           SUBB    A,R6
   \   000032   A3           INC     DPTR
   \   000033   E0           MOVX    A,@DPTR
   \   000034   9F           SUBB    A,R7
   \   000035   4006         JC      ??zclFindPlugin_2
   1841              {
   1842                return ( pLoop );
   \   000037   E8           MOV     A,R0
   \   000038   FA           MOV     R2,A
   \   000039   E9           MOV     A,R1
   \   00003A   FB           MOV     R3,A
   \   00003B   800F         SJMP    ??zclFindPlugin_3
   1843              }
   1844          
   1845              pLoop = pLoop->next;
   \                     ??zclFindPlugin_2:
   \   00003D   8882         MOV     DPL,R0
   \   00003F   8983         MOV     DPH,R1
   \   000041   E0           MOVX    A,@DPTR
   \   000042   F8           MOV     R0,A
   \   000043   A3           INC     DPTR
   \   000044   E0           MOVX    A,@DPTR
   \   000045   F9           MOV     R1,A
   \   000046   80C9         SJMP    ??zclFindPlugin_0
   1846            }
   1847          
   1848            return ( (zclLibPlugin_t *)NULL );
   \                     ??zclFindPlugin_1:
   \   000048   7A00         MOV     R2,#0x0
   \   00004A   7B00         MOV     R3,#0x0
   \                     ??zclFindPlugin_3:
   \   00004C   7F01         MOV     R7,#0x1
   \   00004E   02....       LJMP    ?BANKED_LEAVE_XDATA
   1849          }
   1850          
   1851          /*********************************************************************
   1852           * @fn      zclFindAttrRecsList
   1853           *
   1854           * @brief   Find the right attribute record list for an endpoint
   1855           *
   1856           * @param   clusterID - endpointto look for
   1857           *
   1858           * @return  pointer to record list, NULL if not found
   1859           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1860          static zclAttrRecsList *zclFindAttrRecsList( uint8 endpoint )
   \                     zclFindAttrRecsList:
   1861          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1862            zclAttrRecsList *pLoop = attrList;
   \   000004   90....       MOV     DPTR,#attrList
   \   000007   E0           MOVX    A,@DPTR
   \   000008   FC           MOV     R4,A
   \   000009   A3           INC     DPTR
   \   00000A   E0           MOVX    A,@DPTR
   \   00000B   FD           MOV     R5,A
   1863          
   1864            while ( pLoop != NULL )
   \                     ??zclFindAttrRecsList_0:
   \   00000C   EC           MOV     A,R4
   \   00000D   4D           ORL     A,R5
   \   00000E   601B         JZ      ??zclFindAttrRecsList_1
   1865            {
   1866              if ( pLoop->endpoint == endpoint )
   \   000010   8C82         MOV     DPL,R4
   \   000012   8D83         MOV     DPH,R5
   \   000014   A3           INC     DPTR
   \   000015   A3           INC     DPTR
   \   000016   E0           MOVX    A,@DPTR
   \   000017   69           XRL     A,R1
   \   000018   7006         JNZ     ??zclFindAttrRecsList_2
   1867              {
   1868                return ( pLoop );
   \   00001A   EC           MOV     A,R4
   \   00001B   FA           MOV     R2,A
   \   00001C   ED           MOV     A,R5
   \   00001D   FB           MOV     R3,A
   \   00001E   800F         SJMP    ??zclFindAttrRecsList_3
   1869              }
   1870          
   1871              pLoop = pLoop->next;
   \                     ??zclFindAttrRecsList_2:
   \   000020   8C82         MOV     DPL,R4
   \   000022   8D83         MOV     DPH,R5
   \   000024   E0           MOVX    A,@DPTR
   \   000025   FC           MOV     R4,A
   \   000026   A3           INC     DPTR
   \   000027   E0           MOVX    A,@DPTR
   \   000028   FD           MOV     R5,A
   \   000029   80E1         SJMP    ??zclFindAttrRecsList_0
   1872            }
   1873          
   1874            return ( NULL );
   \                     ??zclFindAttrRecsList_1:
   \   00002B   7A00         MOV     R2,#0x0
   \   00002D   7B00         MOV     R3,#0x0
   \                     ??zclFindAttrRecsList_3:
   \   00002F   D083         POP     DPH
   \   000031   D082         POP     DPL
   \   000033   02....       LJMP    ?BRET
   1875          }
   1876          
   1877          /*********************************************************************
   1878           * @fn      zclFindAttrRec
   1879           *
   1880           * @brief   Find the attribute record that matchs the parameters
   1881           *
   1882           * @param   endpoint - Application's endpoint
   1883           * @param   clusterID - cluster ID
   1884           * @param   attrId - attribute looking for
   1885           * @param   pAttr - attribute record to be returned
   1886           *
   1887           * @return  TRUE if record found. FALSE, otherwise.
   1888           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1889          uint8 zclFindAttrRec( uint8 endpoint, uint16 clusterID, uint16 attrId, zclAttrRec_t *pAttr )
   \                     zclFindAttrRec:
   1890          {
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V0 + 4,R1
   \   000007   8A..         MOV     ?V0 + 0,R2
   \   000009   8B..         MOV     ?V0 + 1,R3
   \   00000B   8C..         MOV     ?V0 + 2,R4
   \   00000D   8D..         MOV     ?V0 + 3,R5
   \   00000F   7410         MOV     A,#0x10
   \   000011   12....       LCALL   ?XSTACK_DISP0_8
   \   000014   E0           MOVX    A,@DPTR
   \   000015   FE           MOV     R6,A
   \   000016   A3           INC     DPTR
   \   000017   E0           MOVX    A,@DPTR
   \   000018   FF           MOV     R7,A
   1891            uint8 x;
   1892            zclAttrRecsList *pRec = zclFindAttrRecsList( endpoint );
   \   000019                ; Setup parameters for call to function zclFindAttrRecsList
   \   000019   A9..         MOV     R1,?V0 + 4
   \   00001B   12....       LCALL   ??zclFindAttrRecsList?relay
   \   00001E   8A..         MOV     ?V0 + 6,R2
   \   000020   8B..         MOV     ?V0 + 7,R3
   \   000022   AA..         MOV     R2,?V0 + 6
   \   000024   AB..         MOV     R3,?V0 + 7
   1893          
   1894            if ( pRec != NULL )
   \   000026   EA           MOV     A,R2
   \   000027   4B           ORL     A,R3
   \   000028   7003         JNZ     $+5
   \   00002A   02....       LJMP    ??zclFindAttrRec_0 & 0xFFFF
   1895            {
   1896              for ( x = 0; x < pRec->numAttributes; x++ )
   \   00002D   75..00       MOV     ?V0 + 5,#0x0
   \                     ??zclFindAttrRec_1:
   \   000030   8A82         MOV     DPL,R2
   \   000032   8B83         MOV     DPH,R3
   \   000034   A3           INC     DPTR
   \   000035   A3           INC     DPTR
   \   000036   A3           INC     DPTR
   \   000037   A3           INC     DPTR
   \   000038   A3           INC     DPTR
   \   000039   A3           INC     DPTR
   \   00003A   A3           INC     DPTR
   \   00003B   E0           MOVX    A,@DPTR
   \   00003C   F8           MOV     R0,A
   \   00003D   E5..         MOV     A,?V0 + 5
   \   00003F   C3           CLR     C
   \   000040   98           SUBB    A,R0
   \   000041   4003         JC      $+5
   \   000043   02....       LJMP    ??zclFindAttrRec_0 & 0xFFFF
   1897              {
   1898                if ( pRec->attrs[x].clusterID == clusterID && pRec->attrs[x].attr.attrId == attrId )
   \   000046   E5..         MOV     A,?V0 + 5
   \   000048   A8..         MOV     R0,?V0 + 5
   \   00004A   7900         MOV     R1,#0x0
   \   00004C   E8           MOV     A,R0
   \   00004D   75F008       MOV     B,#0x8
   \   000050   A4           MUL     AB
   \   000051   C8           XCH     A,R0
   \   000052   ACF0         MOV     R4,B
   \   000054   75F000       MOV     B,#0x0
   \   000057   A4           MUL     AB
   \   000058   2C           ADD     A,R4
   \   000059   FC           MOV     R4,A
   \   00005A   75F008       MOV     B,#0x8
   \   00005D   E9           MOV     A,R1
   \   00005E   A4           MUL     AB
   \   00005F   2C           ADD     A,R4
   \   000060   F9           MOV     R1,A
   \   000061   8A82         MOV     DPL,R2
   \   000063   8B83         MOV     DPH,R3
   \   000065   A3           INC     DPTR
   \   000066   A3           INC     DPTR
   \   000067   A3           INC     DPTR
   \   000068   A3           INC     DPTR
   \   000069   A3           INC     DPTR
   \   00006A   A3           INC     DPTR
   \   00006B   A3           INC     DPTR
   \   00006C   A3           INC     DPTR
   \   00006D   E0           MOVX    A,@DPTR
   \   00006E   28           ADD     A,R0
   \   00006F   FC           MOV     R4,A
   \   000070   A3           INC     DPTR
   \   000071   E0           MOVX    A,@DPTR
   \   000072   39           ADDC    A,R1
   \   000073   8C82         MOV     DPL,R4
   \   000075   F583         MOV     DPH,A
   \   000077   E4           CLR     A
   \   000078   93           MOVC    A,@A+DPTR
   \   000079   F8           MOV     R0,A
   \   00007A   7401         MOV     A,#0x1
   \   00007C   93           MOVC    A,@A+DPTR
   \   00007D   F9           MOV     R1,A
   \   00007E   E5..         MOV     A,?V0 + 0
   \   000080   68           XRL     A,R0
   \   000081   7003         JNZ     ??zclFindAttrRec_2
   \   000083   E5..         MOV     A,?V0 + 1
   \   000085   69           XRL     A,R1
   \                     ??zclFindAttrRec_2:
   \   000086   6003         JZ      $+5
   \   000088   02....       LJMP    ??zclFindAttrRec_3 & 0xFFFF
   \   00008B   E5..         MOV     A,?V0 + 5
   \   00008D   A8..         MOV     R0,?V0 + 5
   \   00008F   7900         MOV     R1,#0x0
   \   000091   E8           MOV     A,R0
   \   000092   75F008       MOV     B,#0x8
   \   000095   A4           MUL     AB
   \   000096   C8           XCH     A,R0
   \   000097   ACF0         MOV     R4,B
   \   000099   75F000       MOV     B,#0x0
   \   00009C   A4           MUL     AB
   \   00009D   2C           ADD     A,R4
   \   00009E   FC           MOV     R4,A
   \   00009F   75F008       MOV     B,#0x8
   \   0000A2   E9           MOV     A,R1
   \   0000A3   A4           MUL     AB
   \   0000A4   2C           ADD     A,R4
   \   0000A5   F9           MOV     R1,A
   \   0000A6   8A82         MOV     DPL,R2
   \   0000A8   8B83         MOV     DPH,R3
   \   0000AA   A3           INC     DPTR
   \   0000AB   A3           INC     DPTR
   \   0000AC   A3           INC     DPTR
   \   0000AD   A3           INC     DPTR
   \   0000AE   A3           INC     DPTR
   \   0000AF   A3           INC     DPTR
   \   0000B0   A3           INC     DPTR
   \   0000B1   A3           INC     DPTR
   \   0000B2   E0           MOVX    A,@DPTR
   \   0000B3   28           ADD     A,R0
   \   0000B4   FC           MOV     R4,A
   \   0000B5   A3           INC     DPTR
   \   0000B6   E0           MOVX    A,@DPTR
   \   0000B7   39           ADDC    A,R1
   \   0000B8   8C82         MOV     DPL,R4
   \   0000BA   F583         MOV     DPH,A
   \   0000BC   A3           INC     DPTR
   \   0000BD   A3           INC     DPTR
   \   0000BE   E4           CLR     A
   \   0000BF   93           MOVC    A,@A+DPTR
   \   0000C0   F8           MOV     R0,A
   \   0000C1   7401         MOV     A,#0x1
   \   0000C3   93           MOVC    A,@A+DPTR
   \   0000C4   F9           MOV     R1,A
   \   0000C5   E5..         MOV     A,?V0 + 2
   \   0000C7   68           XRL     A,R0
   \   0000C8   7003         JNZ     ??zclFindAttrRec_4
   \   0000CA   E5..         MOV     A,?V0 + 3
   \   0000CC   69           XRL     A,R1
   \                     ??zclFindAttrRec_4:
   \   0000CD   703E         JNZ     ??zclFindAttrRec_3
   1899                {
   1900                  *pAttr = pRec->attrs[x];
   \   0000CF   E5..         MOV     A,?V0 + 5
   \   0000D1   A8..         MOV     R0,?V0 + 5
   \   0000D3   7900         MOV     R1,#0x0
   \   0000D5   E8           MOV     A,R0
   \   0000D6   75F008       MOV     B,#0x8
   \   0000D9   A4           MUL     AB
   \   0000DA   C8           XCH     A,R0
   \   0000DB   ACF0         MOV     R4,B
   \   0000DD   75F000       MOV     B,#0x0
   \   0000E0   A4           MUL     AB
   \   0000E1   2C           ADD     A,R4
   \   0000E2   FC           MOV     R4,A
   \   0000E3   75F008       MOV     B,#0x8
   \   0000E6   E9           MOV     A,R1
   \   0000E7   A4           MUL     AB
   \   0000E8   2C           ADD     A,R4
   \   0000E9   F9           MOV     R1,A
   \   0000EA   8A82         MOV     DPL,R2
   \   0000EC   8B83         MOV     DPH,R3
   \   0000EE   A3           INC     DPTR
   \   0000EF   A3           INC     DPTR
   \   0000F0   A3           INC     DPTR
   \   0000F1   A3           INC     DPTR
   \   0000F2   A3           INC     DPTR
   \   0000F3   A3           INC     DPTR
   \   0000F4   A3           INC     DPTR
   \   0000F5   A3           INC     DPTR
   \   0000F6   E0           MOVX    A,@DPTR
   \   0000F7   28           ADD     A,R0
   \   0000F8   FC           MOV     R4,A
   \   0000F9   A3           INC     DPTR
   \   0000FA   E0           MOVX    A,@DPTR
   \   0000FB   39           ADDC    A,R1
   \   0000FC   8C82         MOV     DPL,R4
   \   0000FE   F583         MOV     DPH,A
   \   000100   EE           MOV     A,R6
   \   000101   FC           MOV     R4,A
   \   000102   EF           MOV     A,R7
   \   000103   FD           MOV     R5,A
   \   000104   7408         MOV     A,#0x8
   \   000106   12....       LCALL   ?MOVE_LONG8_XDATA_CODE
   1901          
   1902                  return ( TRUE ); // EMBEDDED RETURN
   \   000109   7901         MOV     R1,#0x1
   \   00010B   8007         SJMP    ??zclFindAttrRec_5
   1903                }
   1904              }
   \                     ??zclFindAttrRec_3:
   \   00010D   05..         INC     ?V0 + 5
   \   00010F   02....       LJMP    ??zclFindAttrRec_1 & 0xFFFF
   1905            }
   1906          
   1907            return ( FALSE );
   \                     ??zclFindAttrRec_0:
   \   000112   7900         MOV     R1,#0x0
   \                     ??zclFindAttrRec_5:
   \   000114   7F08         MOV     R7,#0x8
   \   000116   02....       LJMP    ?BANKED_LEAVE_XDATA
   1908          }
   1909          
   1910          #if defined ( ZCL_READ ) || defined ( ZCL_WRITE )
   1911          /*********************************************************************
   1912           * @fn      zclGetReadWriteCB
   1913           *
   1914           * @brief   Get the Read/Write callback function pointer for a given endpoint.
   1915           *
   1916           * @param   endpoint - Application's endpoint
   1917           *
   1918           * @return  Read/Write CB, NULL if not found
   1919           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1920          static zclReadWriteCB_t zclGetReadWriteCB( uint8 endpoint )
   \                     zclGetReadWriteCB:
   1921          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   E9           MOV     A,R1
   \   000006   FE           MOV     R6,A
   1922            zclAttrRecsList *pRec = zclFindAttrRecsList( endpoint );
   \   000007                ; Setup parameters for call to function zclFindAttrRecsList
   \   000007   F9           MOV     R1,A
   \   000008   12....       LCALL   ??zclFindAttrRecsList?relay
   \   00000B   8A..         MOV     ?V0 + 0,R2
   \   00000D   8B..         MOV     ?V0 + 1,R3
   \   00000F   85..82       MOV     DPL,?V0 + 0
   \   000012   85..83       MOV     DPH,?V0 + 1
   1923          
   1924            if ( pRec != NULL )
   \   000015   E582         MOV     A,DPL
   \   000017   4583         ORL     A,DPH
   \   000019   600A         JZ      ??zclGetReadWriteCB_0
   1925            {
   1926              return ( pRec->pfnReadWriteCB );
   \   00001B   A3           INC     DPTR
   \   00001C   A3           INC     DPTR
   \   00001D   A3           INC     DPTR
   \   00001E   E0           MOVX    A,@DPTR
   \   00001F   FA           MOV     R2,A
   \   000020   A3           INC     DPTR
   \   000021   E0           MOVX    A,@DPTR
   \   000022   FB           MOV     R3,A
   \   000023   8004         SJMP    ??zclGetReadWriteCB_1
   1927            }
   1928          
   1929            return ( NULL );
   \                     ??zclGetReadWriteCB_0:
   \   000025   7A00         MOV     R2,#0x0
   \   000027   7B00         MOV     R3,#0x0
   \                     ??zclGetReadWriteCB_1:
   \   000029   7F02         MOV     R7,#0x2
   \   00002B   02....       LJMP    ?BANKED_LEAVE_XDATA
   1930          }
   1931          
   1932          /*********************************************************************
   1933           * @fn      zclGetAuthorizeCB
   1934           *
   1935           * @brief   Get the Read/Write Authorization callback function pointer
   1936           *          for a given endpoint.
   1937           *
   1938           * @param   endpoint - Application's endpoint
   1939           *
   1940           * @return  Authorization CB, NULL if not found
   1941           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1942          static zclAuthorizeCB_t zclGetAuthorizeCB( uint8 endpoint )
   \                     zclGetAuthorizeCB:
   1943          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   E9           MOV     A,R1
   \   000006   FE           MOV     R6,A
   1944            zclAttrRecsList *pRec = zclFindAttrRecsList( endpoint );
   \   000007                ; Setup parameters for call to function zclFindAttrRecsList
   \   000007   F9           MOV     R1,A
   \   000008   12....       LCALL   ??zclFindAttrRecsList?relay
   \   00000B   8A..         MOV     ?V0 + 0,R2
   \   00000D   8B..         MOV     ?V0 + 1,R3
   \   00000F   85..82       MOV     DPL,?V0 + 0
   \   000012   85..83       MOV     DPH,?V0 + 1
   1945          
   1946            if ( pRec != NULL )
   \   000015   E582         MOV     A,DPL
   \   000017   4583         ORL     A,DPH
   \   000019   600C         JZ      ??zclGetAuthorizeCB_0
   1947            {
   1948              return ( pRec->pfnAuthorizeCB );
   \   00001B   A3           INC     DPTR
   \   00001C   A3           INC     DPTR
   \   00001D   A3           INC     DPTR
   \   00001E   A3           INC     DPTR
   \   00001F   A3           INC     DPTR
   \   000020   E0           MOVX    A,@DPTR
   \   000021   FA           MOV     R2,A
   \   000022   A3           INC     DPTR
   \   000023   E0           MOVX    A,@DPTR
   \   000024   FB           MOV     R3,A
   \   000025   8004         SJMP    ??zclGetAuthorizeCB_1
   1949            }
   1950          
   1951            return ( NULL );
   \                     ??zclGetAuthorizeCB_0:
   \   000027   7A00         MOV     R2,#0x0
   \   000029   7B00         MOV     R3,#0x0
   \                     ??zclGetAuthorizeCB_1:
   \   00002B   7F02         MOV     R7,#0x2
   \   00002D   02....       LJMP    ?BANKED_LEAVE_XDATA
   1952          }
   1953          #endif // ZCL_READ || ZCL_WRITE
   1954          
   1955          /*********************************************************************
   1956           * @fn      zclFindClusterOption
   1957           *
   1958           * @brief   Find the option record that matchs the cluster id
   1959           *
   1960           * @param   endpoint - Application's endpoint
   1961           * @param   clusterID - cluster ID looking for
   1962           *
   1963           * @return  pointer to clutser option, NULL if not found
   1964           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1965          static zclOptionRec_t *zclFindClusterOption( uint8 endpoint, uint16 clusterID )
   \                     zclFindClusterOption:
   1966          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   E9           MOV     A,R1
   \   000006   FC           MOV     R4,A
   \   000007   EA           MOV     A,R2
   \   000008   FE           MOV     R6,A
   \   000009   EB           MOV     A,R3
   \   00000A   FF           MOV     R7,A
   1967            zclClusterOptionList *pLoop;
   1968          
   1969            pLoop = clusterOptionList;
   \   00000B   90....       MOV     DPTR,#clusterOptionList
   \   00000E   E0           MOVX    A,@DPTR
   \   00000F   FA           MOV     R2,A
   \   000010   A3           INC     DPTR
   \   000011   E0           MOVX    A,@DPTR
   \   000012   FB           MOV     R3,A
   \   000013   EA           MOV     A,R2
   \   000014   F8           MOV     R0,A
   \   000015   EB           MOV     A,R3
   \   000016   F9           MOV     R1,A
   1970            while ( pLoop != NULL )
   \                     ??zclFindClusterOption_0:
   \   000017   E8           MOV     A,R0
   \   000018   49           ORL     A,R1
   \   000019   7003         JNZ     $+5
   \   00001B   02....       LJMP    ??zclFindClusterOption_1 & 0xFFFF
   1971            {
   1972              if ( pLoop->endpoint == endpoint )
   \   00001E   8882         MOV     DPL,R0
   \   000020   8983         MOV     DPH,R1
   \   000022   A3           INC     DPTR
   \   000023   A3           INC     DPTR
   \   000024   E0           MOVX    A,@DPTR
   \   000025   6C           XRL     A,R4
   \   000026   7078         JNZ     ??zclFindClusterOption_2
   1973              {
   1974                for ( uint8 x = 0; x < pLoop->numOptions; x++ )
   \   000028   75..00       MOV     ?V0 + 0,#0x0
   \                     ??zclFindClusterOption_3:
   \   00002B   8882         MOV     DPL,R0
   \   00002D   8983         MOV     DPH,R1
   \   00002F   A3           INC     DPTR
   \   000030   A3           INC     DPTR
   \   000031   A3           INC     DPTR
   \   000032   E0           MOVX    A,@DPTR
   \   000033   FA           MOV     R2,A
   \   000034   E5..         MOV     A,?V0 + 0
   \   000036   C3           CLR     C
   \   000037   9A           SUBB    A,R2
   \   000038   5066         JNC     ??zclFindClusterOption_2
   1975                {
   1976                  if ( pLoop->options[x].clusterID == clusterID )
   \   00003A   E5..         MOV     A,?V0 + 0
   \   00003C   AA..         MOV     R2,?V0 + 0
   \   00003E   7B00         MOV     R3,#0x0
   \   000040   EA           MOV     A,R2
   \   000041   75F003       MOV     B,#0x3
   \   000044   A4           MUL     AB
   \   000045   CA           XCH     A,R2
   \   000046   ADF0         MOV     R5,B
   \   000048   75F000       MOV     B,#0x0
   \   00004B   A4           MUL     AB
   \   00004C   2D           ADD     A,R5
   \   00004D   FD           MOV     R5,A
   \   00004E   75F003       MOV     B,#0x3
   \   000051   EB           MOV     A,R3
   \   000052   A4           MUL     AB
   \   000053   2D           ADD     A,R5
   \   000054   FB           MOV     R3,A
   \   000055   8882         MOV     DPL,R0
   \   000057   8983         MOV     DPH,R1
   \   000059   A3           INC     DPTR
   \   00005A   A3           INC     DPTR
   \   00005B   A3           INC     DPTR
   \   00005C   A3           INC     DPTR
   \   00005D   E0           MOVX    A,@DPTR
   \   00005E   2A           ADD     A,R2
   \   00005F   FD           MOV     R5,A
   \   000060   A3           INC     DPTR
   \   000061   E0           MOVX    A,@DPTR
   \   000062   3B           ADDC    A,R3
   \   000063   8D82         MOV     DPL,R5
   \   000065   F583         MOV     DPH,A
   \   000067   E0           MOVX    A,@DPTR
   \   000068   6E           XRL     A,R6
   \   000069   7003         JNZ     ??zclFindClusterOption_4
   \   00006B   A3           INC     DPTR
   \   00006C   E0           MOVX    A,@DPTR
   \   00006D   6F           XRL     A,R7
   \                     ??zclFindClusterOption_4:
   \   00006E   702C         JNZ     ??zclFindClusterOption_5
   1977                  {
   1978                    return ( &(pLoop->options[x]) ); // EMBEDDED RETURN
   \   000070   E5..         MOV     A,?V0 + 0
   \   000072   AA..         MOV     R2,?V0 + 0
   \   000074   7B00         MOV     R3,#0x0
   \   000076   EA           MOV     A,R2
   \   000077   75F003       MOV     B,#0x3
   \   00007A   A4           MUL     AB
   \   00007B   CA           XCH     A,R2
   \   00007C   ADF0         MOV     R5,B
   \   00007E   75F000       MOV     B,#0x0
   \   000081   A4           MUL     AB
   \   000082   2D           ADD     A,R5
   \   000083   FD           MOV     R5,A
   \   000084   75F003       MOV     B,#0x3
   \   000087   EB           MOV     A,R3
   \   000088   A4           MUL     AB
   \   000089   2D           ADD     A,R5
   \   00008A   FB           MOV     R3,A
   \   00008B   8882         MOV     DPL,R0
   \   00008D   8983         MOV     DPH,R1
   \   00008F   A3           INC     DPTR
   \   000090   A3           INC     DPTR
   \   000091   A3           INC     DPTR
   \   000092   A3           INC     DPTR
   \   000093   E0           MOVX    A,@DPTR
   \   000094   2A           ADD     A,R2
   \   000095   FA           MOV     R2,A
   \   000096   A3           INC     DPTR
   \   000097   E0           MOVX    A,@DPTR
   \   000098   3B           ADDC    A,R3
   \   000099   FB           MOV     R3,A
   \   00009A   8014         SJMP    ??zclFindClusterOption_6
   1979                  }
   1980                }
   \                     ??zclFindClusterOption_5:
   \   00009C   05..         INC     ?V0 + 0
   \   00009E   808B         SJMP    ??zclFindClusterOption_3
   1981              }
   1982          
   1983              pLoop = pLoop->next;
   \                     ??zclFindClusterOption_2:
   \   0000A0   8882         MOV     DPL,R0
   \   0000A2   8983         MOV     DPH,R1
   \   0000A4   E0           MOVX    A,@DPTR
   \   0000A5   F8           MOV     R0,A
   \   0000A6   A3           INC     DPTR
   \   0000A7   E0           MOVX    A,@DPTR
   \   0000A8   F9           MOV     R1,A
   \   0000A9   02....       LJMP    ??zclFindClusterOption_0 & 0xFFFF
   1984            }
   1985          
   1986            return ( NULL );
   \                     ??zclFindClusterOption_1:
   \   0000AC   7A00         MOV     R2,#0x0
   \   0000AE   7B00         MOV     R3,#0x0
   \                     ??zclFindClusterOption_6:
   \   0000B0   7F01         MOV     R7,#0x1
   \   0000B2   02....       LJMP    ?BANKED_LEAVE_XDATA
   1987          }
   1988          
   1989          /*********************************************************************
   1990           * @fn      zclGetClusterOption
   1991           *
   1992           * @brief   Get the option record that matchs the cluster id
   1993           *
   1994           * @param   endpoint - Application's endpoint
   1995           * @param   clusterID - cluster ID looking for
   1996           *
   1997           * @return  clutser option, AF_TX_OPTIONS_NONE if not found
   1998           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1999          static uint8 zclGetClusterOption( uint8 endpoint, uint16 clusterID )
   \                     zclGetClusterOption:
   2000          {
   \   000000   74F2         MOV     A,#-0xe
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V0 + 3,R1
   \   000007   EA           MOV     A,R2
   \   000008   FE           MOV     R6,A
   \   000009   EB           MOV     A,R3
   \   00000A   FF           MOV     R7,A
   2001            uint8 option;
   2002            zclOptionRec_t *pOption;
   2003          
   2004            pOption = zclFindClusterOption( endpoint, clusterID );
   \   00000B                ; Setup parameters for call to function zclFindClusterOption
   \   00000B   EE           MOV     A,R6
   \   00000C   FA           MOV     R2,A
   \   00000D   EF           MOV     A,R7
   \   00000E   FB           MOV     R3,A
   \   00000F   A9..         MOV     R1,?V0 + 3
   \   000011   12....       LCALL   ??zclFindClusterOption?relay
   \   000014   8A..         MOV     ?V0 + 4,R2
   \   000016   8B..         MOV     ?V0 + 5,R3
   \   000018   85....       MOV     ?V0 + 0,?V0 + 4
   \   00001B   85....       MOV     ?V0 + 1,?V0 + 5
   2005            if ( pOption != NULL )
   \   00001E   E5..         MOV     A,?V0 + 0
   \   000020   45..         ORL     A,?V0 + 1
   \   000022   6016         JZ      ??zclGetClusterOption_0
   2006            {
   2007              option = pOption->option;
   \   000024   85..82       MOV     DPL,?V0 + 0
   \   000027   85..83       MOV     DPH,?V0 + 1
   \   00002A   A3           INC     DPTR
   \   00002B   A3           INC     DPTR
   \   00002C   E0           MOVX    A,@DPTR
   \   00002D   F5..         MOV     ?V0 + 2,A
   2008              if ( !ZG_SECURE_ENABLED )
   2009              {
   2010                option &= (AF_EN_SECURITY ^ 0xFF); // make sure Application Link Key security is off
   \   00002F   C3           CLR     C
   \   000030   E5..         MOV     A,?V0 + 2
   \   000032   92E6         MOV     0xE0 /* A   */.6,C
   \   000034   F5..         MOV     ?V0 + 2,A
   2011              }
   2012          
   2013              return ( option ); // EMBEDDED RETURN
   \   000036   A9..         MOV     R1,?V0 + 2
   \   000038   8002         SJMP    ??zclGetClusterOption_1
   2014            }
   2015          
   2016            return ( AF_TX_OPTIONS_NONE );
   \                     ??zclGetClusterOption_0:
   \   00003A   7900         MOV     R1,#0x0
   \                     ??zclGetClusterOption_1:
   \   00003C   7F06         MOV     R7,#0x6
   \   00003E   02....       LJMP    ?BANKED_LEAVE_XDATA
   2017          }
   2018          
   2019          /*********************************************************************
   2020           * @fn      zclSetSecurityOption
   2021           *
   2022           * @brief   Set the security option for the cluster id
   2023           *
   2024           * @param   endpoint - Application's endpoint
   2025           * @param   clusterID - cluster ID looking for
   2026           * @param   enable - whether to enable (TRUE) or disable (FALSE) security option
   2027           *
   2028           * @return  none
   2029           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2030          static void zclSetSecurityOption( uint8 endpoint, uint16 clusterID, uint8 enable )
   \                     zclSetSecurityOption:
   2031          {
   \   000000   74F2         MOV     A,#-0xe
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V0 + 2,R1
   \   000007   EA           MOV     A,R2
   \   000008   FE           MOV     R6,A
   \   000009   EB           MOV     A,R3
   \   00000A   FF           MOV     R7,A
   \   00000B   8C..         MOV     ?V0 + 3,R4
   2032            zclOptionRec_t *pOption;
   2033          
   2034            pOption = zclFindClusterOption( endpoint, clusterID );
   \   00000D                ; Setup parameters for call to function zclFindClusterOption
   \   00000D   EE           MOV     A,R6
   \   00000E   FA           MOV     R2,A
   \   00000F   EF           MOV     A,R7
   \   000010   FB           MOV     R3,A
   \   000011   A9..         MOV     R1,?V0 + 2
   \   000013   12....       LCALL   ??zclFindClusterOption?relay
   \   000016   8A..         MOV     ?V0 + 4,R2
   \   000018   8B..         MOV     ?V0 + 5,R3
   \   00001A   85....       MOV     ?V0 + 0,?V0 + 4
   \   00001D   85....       MOV     ?V0 + 1,?V0 + 5
   2035            if ( pOption != NULL )
   \   000020   E5..         MOV     A,?V0 + 0
   \   000022   45..         ORL     A,?V0 + 1
   \   000024   601E         JZ      ??zclSetSecurityOption_0
   2036            {
   2037              if ( enable )
   \   000026   E5..         MOV     A,?V0 + 3
   \   000028   600E         JZ      ??zclSetSecurityOption_1
   2038              {
   2039                pOption->option |= AF_EN_SECURITY;
   \   00002A   85..82       MOV     DPL,?V0 + 0
   \   00002D   85..83       MOV     DPH,?V0 + 1
   \   000030   A3           INC     DPTR
   \   000031   A3           INC     DPTR
   \   000032   E0           MOVX    A,@DPTR
   \   000033   D2E6         SETB    0xE0 /* A   */.6
   \   000035   F0           MOVX    @DPTR,A
   \   000036   800C         SJMP    ??zclSetSecurityOption_0
   2040              }
   2041              else
   2042              {
   2043                pOption->option &= (AF_EN_SECURITY ^ 0xFF);
   \                     ??zclSetSecurityOption_1:
   \   000038   85..82       MOV     DPL,?V0 + 0
   \   00003B   85..83       MOV     DPH,?V0 + 1
   \   00003E   A3           INC     DPTR
   \   00003F   A3           INC     DPTR
   \   000040   E0           MOVX    A,@DPTR
   \   000041   C2E6         CLR     0xE0 /* A   */.6
   \   000043   F0           MOVX    @DPTR,A
   2044              }
   2045            }
   2046          }
   \                     ??zclSetSecurityOption_0:
   \   000044   7F06         MOV     R7,#0x6
   \   000046   02....       LJMP    ?BANKED_LEAVE_XDATA
   2047          
   2048          #ifdef ZCL_DISCOVER
   2049          /*********************************************************************
   2050           * @fn      zclFindNextAttrRec
   2051           *
   2052           * @brief   Find the attribute (or next) record that matchs the parameters
   2053           *
   2054           * @param   endpoint - Application's endpoint
   2055           * @param   clusterID - cluster ID
   2056           * @param   attr - attribute looking for
   2057           *
   2058           * @return  pointer to attribute record, NULL if not found
   2059           */
   2060          static uint8 zclFindNextAttrRec( uint8 endpoint, uint16 clusterID,
   2061                                           uint16 *attrId, zclAttrRec_t *pAttr )
   2062          {
   2063            zclAttrRecsList *pRec = zclFindAttrRecsList( endpoint );
   2064          
   2065            if ( pRec != NULL )
   2066            {
   2067              for ( uint16 x = 0; x < pRec->numAttributes; x++ )
   2068              {
   2069                if ( ( pRec->attrs[x].clusterID == clusterID ) &&
   2070                     ( pRec->attrs[x].attr.attrId >= *attrId ) )
   2071                {
   2072                  *pAttr = pRec->attrs[x];
   2073          
   2074                  // Update attribute ID
   2075                  *attrId = pAttr->attr.attrId;
   2076          
   2077                  return ( TRUE ); // EMBEDDED RETURN
   2078                }
   2079              }
   2080            }
   2081          
   2082            return ( FALSE );
   2083          }
   2084          #endif // ZCL_DISCOVER
   2085          
   2086          /*********************************************************************
   2087           * @fn      zclSerializeData
   2088           *
   2089           * @brief   Builds a buffer from the attribute data to sent out over
   2090           *          the air.
   2091           *
   2092           * @param   dataType - data types defined in zcl.h
   2093           * @param   attrData - pointer to the attribute data
   2094           * @param   buf - where to put the serialized data
   2095           *
   2096           * @return  pointer to end of destination buffer
   2097           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2098          uint8 *zclSerializeData( uint8 dataType, void *attrData, uint8 *buf )
   \                     zclSerializeData:
   2099          {
   \   000000   74ED         MOV     A,#-0x13
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 19
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V0 + 10,R1
   \   000007   8A..         MOV     ?V0 + 0,R2
   \   000009   8B..         MOV     ?V0 + 1,R3
   \   00000B   EC           MOV     A,R4
   \   00000C   FE           MOV     R6,A
   \   00000D   ED           MOV     A,R5
   \   00000E   FF           MOV     R7,A
   2100            uint8 *pStr;
   2101            uint16 len;
   2102          
   2103            switch ( dataType )
   \   00000F   E5..         MOV     A,?V0 + 10
   \   000011   12....       LCALL   ?UC_SWITCH_SPARSE
   \                     `?<Jumptable for zclSerializeData>_0`:
   \   000014   04           DB        4
   \   000015   41           DB        65
   \   000016   42           DB        66
   \   000017   ....         DW        ??zclSerializeData_0
   \   000019   43           DB        67
   \   00001A   44           DB        68
   \   00001B   ....         DW        ??zclSerializeData_1
   \   00001D   E0           DB        224
   \   00001E   E2           DB        226
   \   00001F   ....         DW        ??zclSerializeData_2
   \   000021   E8           DB        232
   \   000022   E9           DB        233
   \   000023   ....         DW        ??zclSerializeData_3
   \   000025   1A           DB        26
   \   000026   08           DB        8
   \   000027   ....         DW        ??zclSerializeData_4
   \   000029   09           DB        9
   \   00002A   ....         DW        ??zclSerializeData_3
   \   00002C   0A           DB        10
   \   00002D   ....         DW        ??zclSerializeData_5
   \   00002F   0B           DB        11
   \   000030   ....         DW        ??zclSerializeData_2
   \   000032   10           DB        16
   \   000033   ....         DW        ??zclSerializeData_4
   \   000035   18           DB        24
   \   000036   ....         DW        ??zclSerializeData_4
   \   000038   19           DB        25
   \   000039   ....         DW        ??zclSerializeData_3
   \   00003B   1A           DB        26
   \   00003C   ....         DW        ??zclSerializeData_5
   \   00003E   1B           DB        27
   \   00003F   ....         DW        ??zclSerializeData_2
   \   000041   20           DB        32
   \   000042   ....         DW        ??zclSerializeData_4
   \   000044   21           DB        33
   \   000045   ....         DW        ??zclSerializeData_3
   \   000047   22           DB        34
   \   000048   ....         DW        ??zclSerializeData_5
   \   00004A   23           DB        35
   \   00004B   ....         DW        ??zclSerializeData_2
   \   00004D   24           DB        36
   \   00004E   ....         DW        ??zclSerializeData_6
   \   000050   25           DB        37
   \   000051   ....         DW        ??zclSerializeData_7
   \   000053   28           DB        40
   \   000054   ....         DW        ??zclSerializeData_4
   \   000056   29           DB        41
   \   000057   ....         DW        ??zclSerializeData_3
   \   000059   2A           DB        42
   \   00005A   ....         DW        ??zclSerializeData_5
   \   00005C   2B           DB        43
   \   00005D   ....         DW        ??zclSerializeData_2
   \   00005F   30           DB        48
   \   000060   ....         DW        ??zclSerializeData_4
   \   000062   31           DB        49
   \   000063   ....         DW        ??zclSerializeData_3
   \   000065   38           DB        56
   \   000066   ....         DW        ??zclSerializeData_3
   \   000068   39           DB        57
   \   000069   ....         DW        ??zclSerializeData_2
   \   00006B   EA           DB        234
   \   00006C   ....         DW        ??zclSerializeData_2
   \   00006E   F0           DB        240
   \   00006F   ....         DW        ??zclSerializeData_8
   \   000071   F1           DB        241
   \   000072   ....         DW        ??zclSerializeData_9
   \   000074   ....         DW        ??zclSerializeData_10
   2104            {
   2105              case ZCL_DATATYPE_DATA8:
   2106              case ZCL_DATATYPE_BOOLEAN:
   2107              case ZCL_DATATYPE_BITMAP8:
   2108              case ZCL_DATATYPE_INT8:
   2109              case ZCL_DATATYPE_UINT8:
   2110              case ZCL_DATATYPE_ENUM8:
   2111                *buf++ = *((uint8 *)attrData);
   \                     ??zclSerializeData_4:
   \   000076   85..82       MOV     DPL,?V0 + 0
   \   000079   85..83       MOV     DPH,?V0 + 1
   \   00007C   E0           MOVX    A,@DPTR
   \   00007D   8E82         MOV     DPL,R6
   \   00007F   8F83         MOV     DPH,R7
   \   000081   F0           MOVX    @DPTR,A
   \   000082   8E82         MOV     DPL,R6
   \   000084   8F83         MOV     DPH,R7
   \   000086   A3           INC     DPTR
   \   000087   AE82         MOV     R6,DPL
   \   000089   AF83         MOV     R7,DPH
   2112                 break;
   \   00008B   02....       LJMP    ??zclSerializeData_10 & 0xFFFF
   2113          
   2114              case ZCL_DATATYPE_DATA16:
   2115              case ZCL_DATATYPE_BITMAP16:
   2116              case ZCL_DATATYPE_UINT16:
   2117              case ZCL_DATATYPE_INT16:
   2118              case ZCL_DATATYPE_ENUM16:
   2119              case ZCL_DATATYPE_SEMI_PREC:
   2120              case ZCL_DATATYPE_CLUSTER_ID:
   2121              case ZCL_DATATYPE_ATTR_ID:
   2122                *buf++ = LO_UINT16( *((uint16*)attrData) );
   \                     ??zclSerializeData_3:
   \   00008E   85..82       MOV     DPL,?V0 + 0
   \   000091   85..83       MOV     DPH,?V0 + 1
   \   000094   E0           MOVX    A,@DPTR
   \   000095   F8           MOV     R0,A
   \   000096   A3           INC     DPTR
   \   000097   E0           MOVX    A,@DPTR
   \   000098   F9           MOV     R1,A
   \   000099   E8           MOV     A,R0
   \   00009A   8E82         MOV     DPL,R6
   \   00009C   8F83         MOV     DPH,R7
   \   00009E   F0           MOVX    @DPTR,A
   \   00009F   8E82         MOV     DPL,R6
   \   0000A1   8F83         MOV     DPH,R7
   \   0000A3   A3           INC     DPTR
   \   0000A4   AE82         MOV     R6,DPL
   \   0000A6   AF83         MOV     R7,DPH
   2123                *buf++ = HI_UINT16( *((uint16*)attrData) );
   \   0000A8   85..82       MOV     DPL,?V0 + 0
   \   0000AB   85..83       MOV     DPH,?V0 + 1
   \   0000AE   E0           MOVX    A,@DPTR
   \   0000AF   F8           MOV     R0,A
   \   0000B0   A3           INC     DPTR
   \   0000B1   E0           MOVX    A,@DPTR
   \   0000B2   F9           MOV     R1,A
   \   0000B3   E4           CLR     A
   \   0000B4   E9           MOV     A,R1
   \   0000B5   F8           MOV     R0,A
   \   0000B6   8E82         MOV     DPL,R6
   \   0000B8   8F83         MOV     DPH,R7
   \   0000BA   F0           MOVX    @DPTR,A
   \   0000BB   8E82         MOV     DPL,R6
   \   0000BD   8F83         MOV     DPH,R7
   \   0000BF   A3           INC     DPTR
   \   0000C0   AE82         MOV     R6,DPL
   \   0000C2   AF83         MOV     R7,DPH
   2124                break;
   \   0000C4   02....       LJMP    ??zclSerializeData_10 & 0xFFFF
   2125          
   2126              case ZCL_DATATYPE_DATA24:
   2127              case ZCL_DATATYPE_BITMAP24:
   2128              case ZCL_DATATYPE_UINT24:
   2129              case ZCL_DATATYPE_INT24:
   2130                *buf++ = BREAK_UINT32( *((uint32*)attrData), 0 );
   \                     ??zclSerializeData_5:
   \   0000C7   85..82       MOV     DPL,?V0 + 0
   \   0000CA   85..83       MOV     DPH,?V0 + 1
   \   0000CD   78..         MOV     R0,#?V0 + 4
   \   0000CF   12....       LCALL   ?L_MOV_X
   \   0000D2   E5..         MOV     A,?V0 + 4
   \   0000D4   8E82         MOV     DPL,R6
   \   0000D6   8F83         MOV     DPH,R7
   \   0000D8   E5..         MOV     A,?V0 + 4
   \   0000DA   F0           MOVX    @DPTR,A
   \   0000DB   8E82         MOV     DPL,R6
   \   0000DD   8F83         MOV     DPH,R7
   \   0000DF   A3           INC     DPTR
   \   0000E0   AE82         MOV     R6,DPL
   \   0000E2   AF83         MOV     R7,DPH
   2131                *buf++ = BREAK_UINT32( *((uint32*)attrData), 1 );
   \   0000E4   85..82       MOV     DPL,?V0 + 0
   \   0000E7   85..83       MOV     DPH,?V0 + 1
   \   0000EA   78..         MOV     R0,#?V0 + 4
   \   0000EC   12....       LCALL   ?L_MOV_X
   \   0000EF   E4           CLR     A
   \   0000F0   E5..         MOV     A,?V0 + 5
   \   0000F2   F5..         MOV     ?V0 + 4,A
   \   0000F4   E5..         MOV     A,?V0 + 4
   \   0000F6   8E82         MOV     DPL,R6
   \   0000F8   8F83         MOV     DPH,R7
   \   0000FA   E5..         MOV     A,?V0 + 4
   \   0000FC   F0           MOVX    @DPTR,A
   \   0000FD   8E82         MOV     DPL,R6
   \   0000FF   8F83         MOV     DPH,R7
   \   000101   A3           INC     DPTR
   \   000102   AE82         MOV     R6,DPL
   \   000104   AF83         MOV     R7,DPH
   2132                *buf++ = BREAK_UINT32( *((uint32*)attrData), 2 );
   \   000106   85..82       MOV     DPL,?V0 + 0
   \   000109   85..83       MOV     DPH,?V0 + 1
   \   00010C   78..         MOV     R0,#?V0 + 4
   \   00010E   12....       LCALL   ?L_MOV_X
   \   000111   7410         MOV     A,#0x10
   \   000113   78..         MOV     R0,#?V0 + 4
   \   000115   12....       LCALL   ?UL_SHR
   \   000118   E5..         MOV     A,?V0 + 4
   \   00011A   8E82         MOV     DPL,R6
   \   00011C   8F83         MOV     DPH,R7
   \   00011E   E5..         MOV     A,?V0 + 4
   \   000120   F0           MOVX    @DPTR,A
   \   000121   8E82         MOV     DPL,R6
   \   000123   8F83         MOV     DPH,R7
   \   000125   A3           INC     DPTR
   \   000126   AE82         MOV     R6,DPL
   \   000128   AF83         MOV     R7,DPH
   2133                break;
   \   00012A   02....       LJMP    ??zclSerializeData_10 & 0xFFFF
   2134          
   2135              case ZCL_DATATYPE_DATA32:
   2136              case ZCL_DATATYPE_BITMAP32:
   2137              case ZCL_DATATYPE_UINT32:
   2138              case ZCL_DATATYPE_INT32:
   2139              case ZCL_DATATYPE_SINGLE_PREC:
   2140              case ZCL_DATATYPE_TOD:
   2141              case ZCL_DATATYPE_DATE:
   2142              case ZCL_DATATYPE_UTC:
   2143              case ZCL_DATATYPE_BAC_OID:
   2144                buf = osal_buffer_uint32( buf, *((uint32*)attrData) );
   \                     ??zclSerializeData_2:
   \   00012D                ; Setup parameters for call to function osal_buffer_uint32
   \   00012D   85..82       MOV     DPL,?V0 + 0
   \   000130   85..83       MOV     DPH,?V0 + 1
   \   000133   12....       LCALL   ?PUSH_XSTACK8_X_FOUR
   \   000136   EE           MOV     A,R6
   \   000137   FA           MOV     R2,A
   \   000138   EF           MOV     A,R7
   \   000139   FB           MOV     R3,A
   \   00013A   12....       LCALL   ??osal_buffer_uint32?relay
   \   00013D   7404         MOV     A,#0x4
   \   00013F   12....       LCALL   ?DEALLOC_XSTACK8
   \   000142   8A..         MOV     ?V0 + 4,R2
   \   000144   8B..         MOV     ?V0 + 5,R3
   \   000146   AE..         MOV     R6,?V0 + 4
   \   000148   AF..         MOV     R7,?V0 + 5
   2145                break;
   \   00014A   02....       LJMP    ??zclSerializeData_10 & 0xFFFF
   2146          
   2147              case ZCL_DATATYPE_UINT40:
   2148                pStr = (uint8*)attrData;
   \                     ??zclSerializeData_6:
   \   00014D   85....       MOV     ?V0 + 2,?V0 + 0
   \   000150   85....       MOV     ?V0 + 3,?V0 + 1
   2149                buf = osal_memcpy( buf, pStr, 5 );
   \   000153                ; Setup parameters for call to function osal_memcpy
   \   000153   85....       MOV     ?V0 + 4,?V0 + 2
   \   000156   85....       MOV     ?V0 + 5,?V0 + 3
   \   000159   75..00       MOV     ?V0 + 6,#0x0
   \   00015C   78..         MOV     R0,#?V0 + 4
   \   00015E   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   000161   7C05         MOV     R4,#0x5
   \   000163   7D00         MOV     R5,#0x0
   \   000165   EE           MOV     A,R6
   \   000166   FA           MOV     R2,A
   \   000167   EF           MOV     A,R7
   \   000168   FB           MOV     R3,A
   \   000169   12....       LCALL   ??osal_memcpy?relay
   \   00016C   7403         MOV     A,#0x3
   \   00016E   12....       LCALL   ?DEALLOC_XSTACK8
   \   000171   8A..         MOV     ?V0 + 4,R2
   \   000173   8B..         MOV     ?V0 + 5,R3
   \   000175   AE..         MOV     R6,?V0 + 4
   \   000177   AF..         MOV     R7,?V0 + 5
   2150                break;
   \   000179   02....       LJMP    ??zclSerializeData_10 & 0xFFFF
   2151          
   2152              case ZCL_DATATYPE_UINT48:
   2153                pStr = (uint8*)attrData;
   \                     ??zclSerializeData_7:
   \   00017C   85....       MOV     ?V0 + 2,?V0 + 0
   \   00017F   85....       MOV     ?V0 + 3,?V0 + 1
   2154                buf = osal_memcpy( buf, pStr, 6 );
   \   000182                ; Setup parameters for call to function osal_memcpy
   \   000182   85....       MOV     ?V0 + 4,?V0 + 2
   \   000185   85....       MOV     ?V0 + 5,?V0 + 3
   \   000188   75..00       MOV     ?V0 + 6,#0x0
   \   00018B   78..         MOV     R0,#?V0 + 4
   \   00018D   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   000190   7C06         MOV     R4,#0x6
   \   000192   7D00         MOV     R5,#0x0
   \   000194   EE           MOV     A,R6
   \   000195   FA           MOV     R2,A
   \   000196   EF           MOV     A,R7
   \   000197   FB           MOV     R3,A
   \   000198   12....       LCALL   ??osal_memcpy?relay
   \   00019B   7403         MOV     A,#0x3
   \   00019D   12....       LCALL   ?DEALLOC_XSTACK8
   \   0001A0   8A..         MOV     ?V0 + 4,R2
   \   0001A2   8B..         MOV     ?V0 + 5,R3
   \   0001A4   AE..         MOV     R6,?V0 + 4
   \   0001A6   AF..         MOV     R7,?V0 + 5
   2155                break;
   \   0001A8   02....       LJMP    ??zclSerializeData_10 & 0xFFFF
   2156          
   2157              case ZCL_DATATYPE_IEEE_ADDR:
   2158                pStr = (uint8*)attrData;
   \                     ??zclSerializeData_8:
   \   0001AB   85....       MOV     ?V0 + 2,?V0 + 0
   \   0001AE   85....       MOV     ?V0 + 3,?V0 + 1
   2159                buf = osal_memcpy( buf, pStr, 8 );
   \   0001B1                ; Setup parameters for call to function osal_memcpy
   \   0001B1   85....       MOV     ?V0 + 4,?V0 + 2
   \   0001B4   85....       MOV     ?V0 + 5,?V0 + 3
   \   0001B7   75..00       MOV     ?V0 + 6,#0x0
   \   0001BA   78..         MOV     R0,#?V0 + 4
   \   0001BC   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   0001BF   7C08         MOV     R4,#0x8
   \   0001C1   7D00         MOV     R5,#0x0
   \   0001C3   EE           MOV     A,R6
   \   0001C4   FA           MOV     R2,A
   \   0001C5   EF           MOV     A,R7
   \   0001C6   FB           MOV     R3,A
   \   0001C7   12....       LCALL   ??osal_memcpy?relay
   \   0001CA   7403         MOV     A,#0x3
   \   0001CC   12....       LCALL   ?DEALLOC_XSTACK8
   \   0001CF   8A..         MOV     ?V0 + 4,R2
   \   0001D1   8B..         MOV     ?V0 + 5,R3
   \   0001D3   AE..         MOV     R6,?V0 + 4
   \   0001D5   AF..         MOV     R7,?V0 + 5
   2160                break;
   \   0001D7   02....       LJMP    ??zclSerializeData_10 & 0xFFFF
   2161          
   2162              case ZCL_DATATYPE_CHAR_STR:
   2163              case ZCL_DATATYPE_OCTET_STR:
   2164                pStr = (uint8*)attrData;
   \                     ??zclSerializeData_0:
   \   0001DA   85....       MOV     ?V0 + 2,?V0 + 0
   \   0001DD   85....       MOV     ?V0 + 3,?V0 + 1
   2165                len = *pStr;
   \   0001E0   85..82       MOV     DPL,?V0 + 2
   \   0001E3   85..83       MOV     DPH,?V0 + 3
   \   0001E6   E0           MOVX    A,@DPTR
   \   0001E7   F8           MOV     R0,A
   \   0001E8   7900         MOV     R1,#0x0
   \   0001EA   88..         MOV     ?V0 + 8,R0
   \   0001EC   89..         MOV     ?V0 + 9,R1
   2166                buf = osal_memcpy( buf, pStr, len+1 ); // Including length field
   \   0001EE                ; Setup parameters for call to function osal_memcpy
   \   0001EE   85....       MOV     ?V0 + 4,?V0 + 2
   \   0001F1   85....       MOV     ?V0 + 5,?V0 + 3
   \   0001F4   75..00       MOV     ?V0 + 6,#0x0
   \   0001F7   78..         MOV     R0,#?V0 + 4
   \   0001F9   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   0001FC   E5..         MOV     A,?V0 + 8
   \   0001FE   2401         ADD     A,#0x1
   \   000200   FC           MOV     R4,A
   \   000201   E5..         MOV     A,?V0 + 9
   \   000203   3400         ADDC    A,#0x0
   \   000205   FD           MOV     R5,A
   \   000206   EE           MOV     A,R6
   \   000207   FA           MOV     R2,A
   \   000208   EF           MOV     A,R7
   \   000209   FB           MOV     R3,A
   \   00020A   12....       LCALL   ??osal_memcpy?relay
   \   00020D   7403         MOV     A,#0x3
   \   00020F   12....       LCALL   ?DEALLOC_XSTACK8
   \   000212   8A..         MOV     ?V0 + 4,R2
   \   000214   8B..         MOV     ?V0 + 5,R3
   \   000216   AE..         MOV     R6,?V0 + 4
   \   000218   AF..         MOV     R7,?V0 + 5
   2167                break;
   \   00021A   02....       LJMP    ??zclSerializeData_10 & 0xFFFF
   2168          
   2169              case ZCL_DATATYPE_LONG_CHAR_STR:
   2170              case ZCL_DATATYPE_LONG_OCTET_STR:
   2171                pStr = (uint8*)attrData;
   \                     ??zclSerializeData_1:
   \   00021D   85....       MOV     ?V0 + 2,?V0 + 0
   \   000220   85....       MOV     ?V0 + 3,?V0 + 1
   2172                len = BUILD_UINT16( pStr[0], pStr[1] );
   \   000223   85..82       MOV     DPL,?V0 + 2
   \   000226   85..83       MOV     DPH,?V0 + 3
   \   000229   E0           MOVX    A,@DPTR
   \   00022A   FA           MOV     R2,A
   \   00022B   7B00         MOV     R3,#0x0
   \   00022D   85..82       MOV     DPL,?V0 + 2
   \   000230   85..83       MOV     DPH,?V0 + 3
   \   000233   A3           INC     DPTR
   \   000234   E0           MOVX    A,@DPTR
   \   000235   F8           MOV     R0,A
   \   000236   7900         MOV     R1,#0x0
   \   000238   E4           CLR     A
   \   000239   C8           XCH     A,R0
   \   00023A   F9           MOV     R1,A
   \   00023B   EA           MOV     A,R2
   \   00023C   28           ADD     A,R0
   \   00023D   F8           MOV     R0,A
   \   00023E   EB           MOV     A,R3
   \   00023F   39           ADDC    A,R1
   \   000240   F9           MOV     R1,A
   \   000241   88..         MOV     ?V0 + 8,R0
   \   000243   89..         MOV     ?V0 + 9,R1
   2173                buf = osal_memcpy( buf, pStr, len+2 ); // Including length field
   \   000245                ; Setup parameters for call to function osal_memcpy
   \   000245   85....       MOV     ?V0 + 4,?V0 + 2
   \   000248   85....       MOV     ?V0 + 5,?V0 + 3
   \   00024B   75..00       MOV     ?V0 + 6,#0x0
   \   00024E   78..         MOV     R0,#?V0 + 4
   \   000250   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   000253   E5..         MOV     A,?V0 + 8
   \   000255   2402         ADD     A,#0x2
   \   000257   FC           MOV     R4,A
   \   000258   E5..         MOV     A,?V0 + 9
   \   00025A   3400         ADDC    A,#0x0
   \   00025C   FD           MOV     R5,A
   \   00025D   EE           MOV     A,R6
   \   00025E   FA           MOV     R2,A
   \   00025F   EF           MOV     A,R7
   \   000260   FB           MOV     R3,A
   \   000261   12....       LCALL   ??osal_memcpy?relay
   \   000264   7403         MOV     A,#0x3
   \   000266   12....       LCALL   ?DEALLOC_XSTACK8
   \   000269   8A..         MOV     ?V0 + 4,R2
   \   00026B   8B..         MOV     ?V0 + 5,R3
   \   00026D   AE..         MOV     R6,?V0 + 4
   \   00026F   AF..         MOV     R7,?V0 + 5
   2174                break;
   \   000271   802C         SJMP    ??zclSerializeData_10
   2175          
   2176              case ZCL_DATATYPE_128_BIT_SEC_KEY:
   2177                pStr = (uint8*)attrData;
   \                     ??zclSerializeData_9:
   \   000273   85....       MOV     ?V0 + 2,?V0 + 0
   \   000276   85....       MOV     ?V0 + 3,?V0 + 1
   2178                buf = osal_memcpy( buf, pStr, SEC_KEY_LEN );
   \   000279                ; Setup parameters for call to function osal_memcpy
   \   000279   85....       MOV     ?V0 + 4,?V0 + 2
   \   00027C   85....       MOV     ?V0 + 5,?V0 + 3
   \   00027F   75..00       MOV     ?V0 + 6,#0x0
   \   000282   78..         MOV     R0,#?V0 + 4
   \   000284   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   000287   7C10         MOV     R4,#0x10
   \   000289   7D00         MOV     R5,#0x0
   \   00028B   EE           MOV     A,R6
   \   00028C   FA           MOV     R2,A
   \   00028D   EF           MOV     A,R7
   \   00028E   FB           MOV     R3,A
   \   00028F   12....       LCALL   ??osal_memcpy?relay
   \   000292   7403         MOV     A,#0x3
   \   000294   12....       LCALL   ?DEALLOC_XSTACK8
   \   000297   8A..         MOV     ?V0 + 4,R2
   \   000299   8B..         MOV     ?V0 + 5,R3
   \   00029B   AE..         MOV     R6,?V0 + 4
   \   00029D   AF..         MOV     R7,?V0 + 5
   2179                break;
   2180          
   2181              case ZCL_DATATYPE_NO_DATA:
   2182              case ZCL_DATATYPE_UNKNOWN:
   2183                // Fall through
   2184          
   2185              default:
   2186                break;
   2187            }
   2188          
   2189            return ( buf );
   \                     ??zclSerializeData_10:
   \   00029F   EE           MOV     A,R6
   \   0002A0   FA           MOV     R2,A
   \   0002A1   EF           MOV     A,R7
   \   0002A2   FB           MOV     R3,A
   \   0002A3   7F0B         MOV     R7,#0xb
   \   0002A5   02....       LJMP    ?BANKED_LEAVE_XDATA
   2190          }
   2191          
   2192          #ifdef ZCL_REPORT
   2193          /*********************************************************************
   2194           * @fn      zclAnalogDataType
   2195           *
   2196           * @brief   Checks to see if Data Type is Analog
   2197           *
   2198           * @param   dataType - data type
   2199           *
   2200           * @return  TRUE if data type is analog
   2201           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2202          uint8 zclAnalogDataType( uint8 dataType )
   \                     zclAnalogDataType:
   2203          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   \   000004   E9           MOV     A,R1
   \   000005   F8           MOV     R0,A
   2204            uint8 analog;
   2205          
   2206            switch ( dataType )
   \   000006   12....       LCALL   ?UC_SWITCH_SPARSE
   \                     `?<Jumptable for zclAnalogDataType>_0`:
   \   000009   03           DB        3
   \   00000A   20           DB        32
   \   00000B   2F           DB        47
   \   00000C   ....         DW        ??zclAnalogDataType_0
   \   00000E   38           DB        56
   \   00000F   3A           DB        58
   \   000010   ....         DW        ??zclAnalogDataType_0
   \   000012   E0           DB        224
   \   000013   E2           DB        226
   \   000014   ....         DW        ??zclAnalogDataType_0
   \   000016   00           DB        0
   \   000017   ....         DW        ??zclAnalogDataType_1
   2207            {
   2208              case ZCL_DATATYPE_UINT8:
   2209              case ZCL_DATATYPE_UINT16:
   2210              case ZCL_DATATYPE_UINT24:
   2211              case ZCL_DATATYPE_UINT32:
   2212              case ZCL_DATATYPE_UINT40:
   2213              case ZCL_DATATYPE_UINT48:
   2214              case ZCL_DATATYPE_UINT56:
   2215              case ZCL_DATATYPE_UINT64:
   2216              case ZCL_DATATYPE_INT8:
   2217              case ZCL_DATATYPE_INT16:
   2218              case ZCL_DATATYPE_INT24:
   2219              case ZCL_DATATYPE_INT32:
   2220              case ZCL_DATATYPE_INT40:
   2221              case ZCL_DATATYPE_INT48:
   2222              case ZCL_DATATYPE_INT56:
   2223              case ZCL_DATATYPE_INT64:
   2224              case ZCL_DATATYPE_SEMI_PREC:
   2225              case ZCL_DATATYPE_SINGLE_PREC:
   2226              case ZCL_DATATYPE_DOUBLE_PREC:
   2227              case ZCL_DATATYPE_TOD:
   2228              case ZCL_DATATYPE_DATE:
   2229              case ZCL_DATATYPE_UTC:
   2230                analog = TRUE;
   \                     ??zclAnalogDataType_0:
   \   000019   7901         MOV     R1,#0x1
   2231                break;
   \   00001B   8002         SJMP    ??zclAnalogDataType_2
   2232          
   2233              default:
   2234                analog = FALSE;
   \                     ??zclAnalogDataType_1:
   \   00001D   7900         MOV     R1,#0x0
   2235                break;
   2236            }
   2237          
   2238            return ( analog );
   \                     ??zclAnalogDataType_2:
   \   00001F   D083         POP     DPH
   \   000021   D082         POP     DPL
   \   000023   02....       LJMP    ?BRET
   2239          }
   2240          
   2241          /*********************************************************************
   2242           * @fn      zcl_BuildAnalogData
   2243           *
   2244           * @brief   Build an analog arribute out of sequential bytes.
   2245           *
   2246           * @param   dataType - type of data
   2247           * @param   pData - pointer to data
   2248           * @param   pBuf - where to put the data
   2249           *
   2250           * @return  none
   2251           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2252          static void zcl_BuildAnalogData( uint8 dataType, uint8 *pData, uint8 *pBuf)
   \                     zcl_BuildAnalogData:
   2253          {
   \   000000   74F5         MOV     A,#-0xb
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 11
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V0 + 2,R1
   \   000007   8A..         MOV     ?V0 + 0,R2
   \   000009   8B..         MOV     ?V0 + 1,R3
   \   00000B   EC           MOV     A,R4
   \   00000C   FE           MOV     R6,A
   \   00000D   ED           MOV     A,R5
   \   00000E   FF           MOV     R7,A
   2254            switch ( dataType )
   \   00000F   E5..         MOV     A,?V0 + 2
   \   000011   12....       LCALL   ?UC_SWITCH_SPARSE
   \                     `?<Jumptable for zcl_BuildAnalogData>_0`:
   \   000014   03           DB        3
   \   000015   24           DB        36
   \   000016   27           DB        39
   \   000017   ....         DW        ??zcl_BuildAnalogData_0
   \   000019   2C           DB        44
   \   00001A   2F           DB        47
   \   00001B   ....         DW        ??zcl_BuildAnalogData_0
   \   00001D   E0           DB        224
   \   00001E   E2           DB        226
   \   00001F   ....         DW        ??zcl_BuildAnalogData_1
   \   000021   0B           DB        11
   \   000022   20           DB        32
   \   000023   ....         DW        ??zcl_BuildAnalogData_2
   \   000025   21           DB        33
   \   000026   ....         DW        ??zcl_BuildAnalogData_3
   \   000028   22           DB        34
   \   000029   ....         DW        ??zcl_BuildAnalogData_4
   \   00002B   23           DB        35
   \   00002C   ....         DW        ??zcl_BuildAnalogData_1
   \   00002E   28           DB        40
   \   00002F   ....         DW        ??zcl_BuildAnalogData_2
   \   000031   29           DB        41
   \   000032   ....         DW        ??zcl_BuildAnalogData_3
   \   000034   2A           DB        42
   \   000035   ....         DW        ??zcl_BuildAnalogData_4
   \   000037   2B           DB        43
   \   000038   ....         DW        ??zcl_BuildAnalogData_1
   \   00003A   38           DB        56
   \   00003B   ....         DW        ??zcl_BuildAnalogData_3
   \   00003D   39           DB        57
   \   00003E   ....         DW        ??zcl_BuildAnalogData_1
   \   000040   3A           DB        58
   \   000041   ....         DW        ??zcl_BuildAnalogData_0
   \   000043   ....         DW        ??zcl_BuildAnalogData_5
   2255            {
   2256              case ZCL_DATATYPE_UINT8:
   2257              case ZCL_DATATYPE_INT8:
   2258                *pData = *pBuf;
   \                     ??zcl_BuildAnalogData_2:
   \   000045   8E82         MOV     DPL,R6
   \   000047   8F83         MOV     DPH,R7
   \   000049   E0           MOVX    A,@DPTR
   \   00004A   85..82       MOV     DPL,?V0 + 0
   \   00004D   85..83       MOV     DPH,?V0 + 1
   \   000050   F0           MOVX    @DPTR,A
   2259                break;
   \   000051   8063         SJMP    ??zcl_BuildAnalogData_6
   2260          
   2261              case ZCL_DATATYPE_UINT16:
   2262              case ZCL_DATATYPE_INT16:
   2263              case ZCL_DATATYPE_SEMI_PREC:
   2264                *((uint16*)pData) = BUILD_UINT16( pBuf[0], pBuf[1] );
   \                     ??zcl_BuildAnalogData_3:
   \   000053   8E82         MOV     DPL,R6
   \   000055   8F83         MOV     DPH,R7
   \   000057   E0           MOVX    A,@DPTR
   \   000058   FA           MOV     R2,A
   \   000059   7B00         MOV     R3,#0x0
   \   00005B   8E82         MOV     DPL,R6
   \   00005D   8F83         MOV     DPH,R7
   \   00005F   A3           INC     DPTR
   \   000060   E0           MOVX    A,@DPTR
   \   000061   F8           MOV     R0,A
   \   000062   7900         MOV     R1,#0x0
   \   000064   E4           CLR     A
   \   000065   C8           XCH     A,R0
   \   000066   F9           MOV     R1,A
   \   000067   EA           MOV     A,R2
   \   000068   28           ADD     A,R0
   \   000069   F8           MOV     R0,A
   \   00006A   EB           MOV     A,R3
   \   00006B   39           ADDC    A,R1
   \   00006C   F9           MOV     R1,A
   \   00006D   85..82       MOV     DPL,?V0 + 0
   \   000070   85..83       MOV     DPH,?V0 + 1
   \   000073   E8           MOV     A,R0
   \   000074   F0           MOVX    @DPTR,A
   \   000075   A3           INC     DPTR
   \   000076   E9           MOV     A,R1
   \   000077   F0           MOVX    @DPTR,A
   2265                break;
   \   000078   803C         SJMP    ??zcl_BuildAnalogData_6
   2266          
   2267              case ZCL_DATATYPE_UINT24:
   2268              case ZCL_DATATYPE_INT24:
   2269                *((uint32*)pData) = osal_build_uint32( pBuf, 3 );
   \                     ??zcl_BuildAnalogData_4:
   \   00007A                ; Setup parameters for call to function osal_build_uint32
   \   00007A   7903         MOV     R1,#0x3
   \   00007C   EE           MOV     A,R6
   \   00007D   FA           MOV     R2,A
   \   00007E   EF           MOV     A,R7
   \   00007F   FB           MOV     R3,A
   \   000080   12....       LCALL   ??osal_build_uint32?relay
   \   000083   85..82       MOV     DPL,?V0 + 0
   \   000086   85..83       MOV     DPH,?V0 + 1
   \   000089   12....       LCALL   ?XSTORE_R2345
   2270                break;
   \   00008C   8028         SJMP    ??zcl_BuildAnalogData_6
   2271          
   2272              case ZCL_DATATYPE_UINT32:
   2273              case ZCL_DATATYPE_INT32:
   2274              case ZCL_DATATYPE_SINGLE_PREC:
   2275              case ZCL_DATATYPE_TOD:
   2276              case ZCL_DATATYPE_DATE:
   2277              case ZCL_DATATYPE_UTC:
   2278                *((uint32*)pData) = osal_build_uint32( pBuf, 4 );
   \                     ??zcl_BuildAnalogData_1:
   \   00008E                ; Setup parameters for call to function osal_build_uint32
   \   00008E   7904         MOV     R1,#0x4
   \   000090   EE           MOV     A,R6
   \   000091   FA           MOV     R2,A
   \   000092   EF           MOV     A,R7
   \   000093   FB           MOV     R3,A
   \   000094   12....       LCALL   ??osal_build_uint32?relay
   \   000097   85..82       MOV     DPL,?V0 + 0
   \   00009A   85..83       MOV     DPH,?V0 + 1
   \   00009D   12....       LCALL   ?XSTORE_R2345
   2279                break;
   \   0000A0   8014         SJMP    ??zcl_BuildAnalogData_6
   2280          
   2281              case ZCL_DATATYPE_UINT40:
   2282              case ZCL_DATATYPE_UINT48:
   2283              case ZCL_DATATYPE_UINT56:
   2284              case ZCL_DATATYPE_UINT64:
   2285              case ZCL_DATATYPE_INT40:
   2286              case ZCL_DATATYPE_INT48:
   2287              case ZCL_DATATYPE_INT56:
   2288              case ZCL_DATATYPE_INT64:
   2289              case ZCL_DATATYPE_DOUBLE_PREC:
   2290                *pData = 0;
   \                     ??zcl_BuildAnalogData_0:
   \   0000A2   85..82       MOV     DPL,?V0 + 0
   \   0000A5   85..83       MOV     DPH,?V0 + 1
   \   0000A8   7400         MOV     A,#0x0
   \   0000AA   F0           MOVX    @DPTR,A
   2291                break;
   \   0000AB   8009         SJMP    ??zcl_BuildAnalogData_6
   2292          
   2293              default:
   2294                *pData = 0;
   \                     ??zcl_BuildAnalogData_5:
   \   0000AD   85..82       MOV     DPL,?V0 + 0
   \   0000B0   85..83       MOV     DPH,?V0 + 1
   \   0000B3   7400         MOV     A,#0x0
   \   0000B5   F0           MOVX    @DPTR,A
   2295                break;
   2296            }
   2297          }
   \                     ??zcl_BuildAnalogData_6:
   \   0000B6   7F03         MOV     R7,#0x3
   \   0000B8   02....       LJMP    ?BANKED_LEAVE_XDATA
   2298          #endif // ZCL_REPORT
   2299          
   2300          /*********************************************************************
   2301           * @fn      zclGetDataTypeLength
   2302           *
   2303           * @brief   Return the length of the datatype in octet.
   2304           *
   2305           *          NOTE: Should not be called for ZCL_DATATYPE_OCTECT_STR or
   2306           *                ZCL_DATATYPE_CHAR_STR data types.
   2307           *
   2308           * @param   dataType - data type
   2309           *
   2310           * @return  length of data
   2311           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2312          uint8 zclGetDataTypeLength( uint8 dataType )
   \                     zclGetDataTypeLength:
   2313          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   \   000000   E9           MOV     A,R1
   \   000001   F8           MOV     R0,A
   2314            uint8 len;
   2315          
   2316            switch ( dataType )
   \   000002   24F8         ADD     A,#-0x8
   \   000004   6078         JZ      ??zclGetDataTypeLength_0
   \   000006   14           DEC     A
   \   000007   6079         JZ      ??zclGetDataTypeLength_1
   \   000009   14           DEC     A
   \   00000A   607A         JZ      ??zclGetDataTypeLength_2
   \   00000C   14           DEC     A
   \   00000D   607B         JZ      ??zclGetDataTypeLength_3
   \   00000F   24FB         ADD     A,#-0x5
   \   000011   606B         JZ      ??zclGetDataTypeLength_0
   \   000013   24F8         ADD     A,#-0x8
   \   000015   6067         JZ      ??zclGetDataTypeLength_0
   \   000017   14           DEC     A
   \   000018   6068         JZ      ??zclGetDataTypeLength_1
   \   00001A   14           DEC     A
   \   00001B   6069         JZ      ??zclGetDataTypeLength_2
   \   00001D   14           DEC     A
   \   00001E   606A         JZ      ??zclGetDataTypeLength_3
   \   000020   24FB         ADD     A,#-0x5
   \   000022   605A         JZ      ??zclGetDataTypeLength_0
   \   000024   14           DEC     A
   \   000025   605B         JZ      ??zclGetDataTypeLength_1
   \   000027   14           DEC     A
   \   000028   605C         JZ      ??zclGetDataTypeLength_2
   \   00002A   14           DEC     A
   \   00002B   605D         JZ      ??zclGetDataTypeLength_3
   \   00002D   14           DEC     A
   \   00002E   605E         JZ      ??zclGetDataTypeLength_4
   \   000030   14           DEC     A
   \   000031   605F         JZ      ??zclGetDataTypeLength_5
   \   000033   14           DEC     A
   \   000034   6060         JZ      ??zclGetDataTypeLength_6
   \   000036   14           DEC     A
   \   000037   6061         JZ      ??zclGetDataTypeLength_7
   \   000039   14           DEC     A
   \   00003A   6042         JZ      ??zclGetDataTypeLength_0
   \   00003C   14           DEC     A
   \   00003D   6043         JZ      ??zclGetDataTypeLength_1
   \   00003F   14           DEC     A
   \   000040   6044         JZ      ??zclGetDataTypeLength_2
   \   000042   14           DEC     A
   \   000043   6045         JZ      ??zclGetDataTypeLength_3
   \   000045   14           DEC     A
   \   000046   6046         JZ      ??zclGetDataTypeLength_4
   \   000048   14           DEC     A
   \   000049   6047         JZ      ??zclGetDataTypeLength_5
   \   00004B   14           DEC     A
   \   00004C   6048         JZ      ??zclGetDataTypeLength_6
   \   00004E   14           DEC     A
   \   00004F   6049         JZ      ??zclGetDataTypeLength_7
   \   000051   14           DEC     A
   \   000052   602A         JZ      ??zclGetDataTypeLength_0
   \   000054   14           DEC     A
   \   000055   602B         JZ      ??zclGetDataTypeLength_1
   \   000057   24F9         ADD     A,#-0x7
   \   000059   6027         JZ      ??zclGetDataTypeLength_1
   \   00005B   14           DEC     A
   \   00005C   602C         JZ      ??zclGetDataTypeLength_3
   \   00005E   14           DEC     A
   \   00005F   6039         JZ      ??zclGetDataTypeLength_7
   \   000061   245A         ADD     A,#0x5a
   \   000063   6025         JZ      ??zclGetDataTypeLength_3
   \   000065   14           DEC     A
   \   000066   6022         JZ      ??zclGetDataTypeLength_3
   \   000068   14           DEC     A
   \   000069   601F         JZ      ??zclGetDataTypeLength_3
   \   00006B   24FA         ADD     A,#-0x6
   \   00006D   6013         JZ      ??zclGetDataTypeLength_1
   \   00006F   14           DEC     A
   \   000070   6010         JZ      ??zclGetDataTypeLength_1
   \   000072   14           DEC     A
   \   000073   6015         JZ      ??zclGetDataTypeLength_3
   \   000075   24FA         ADD     A,#-0x6
   \   000077   6021         JZ      ??zclGetDataTypeLength_7
   \   000079   14           DEC     A
   \   00007A   6022         JZ      ??zclGetDataTypeLength_8
   \   00007C   8024         SJMP    ??zclGetDataTypeLength_9
   2317            {
   2318              case ZCL_DATATYPE_DATA8:
   2319              case ZCL_DATATYPE_BOOLEAN:
   2320              case ZCL_DATATYPE_BITMAP8:
   2321              case ZCL_DATATYPE_INT8:
   2322              case ZCL_DATATYPE_UINT8:
   2323              case ZCL_DATATYPE_ENUM8:
   2324                len = 1;
   \                     ??zclGetDataTypeLength_0:
   \   00007E   7901         MOV     R1,#0x1
   2325                break;
   \   000080   8022         SJMP    ??zclGetDataTypeLength_10
   2326          
   2327              case ZCL_DATATYPE_DATA16:
   2328              case ZCL_DATATYPE_BITMAP16:
   2329              case ZCL_DATATYPE_UINT16:
   2330              case ZCL_DATATYPE_INT16:
   2331              case ZCL_DATATYPE_ENUM16:
   2332              case ZCL_DATATYPE_SEMI_PREC:
   2333              case ZCL_DATATYPE_CLUSTER_ID:
   2334              case ZCL_DATATYPE_ATTR_ID:
   2335                len = 2;
   \                     ??zclGetDataTypeLength_1:
   \   000082   7902         MOV     R1,#0x2
   2336                break;
   \   000084   801E         SJMP    ??zclGetDataTypeLength_10
   2337          
   2338              case ZCL_DATATYPE_DATA24:
   2339              case ZCL_DATATYPE_BITMAP24:
   2340              case ZCL_DATATYPE_UINT24:
   2341              case ZCL_DATATYPE_INT24:
   2342                len = 3;
   \                     ??zclGetDataTypeLength_2:
   \   000086   7903         MOV     R1,#0x3
   2343                break;
   \   000088   801A         SJMP    ??zclGetDataTypeLength_10
   2344          
   2345              case ZCL_DATATYPE_DATA32:
   2346              case ZCL_DATATYPE_BITMAP32:
   2347              case ZCL_DATATYPE_UINT32:
   2348              case ZCL_DATATYPE_INT32:
   2349              case ZCL_DATATYPE_SINGLE_PREC:
   2350              case ZCL_DATATYPE_TOD:
   2351              case ZCL_DATATYPE_DATE:
   2352              case ZCL_DATATYPE_UTC:
   2353              case ZCL_DATATYPE_BAC_OID:
   2354                len = 4;
   \                     ??zclGetDataTypeLength_3:
   \   00008A   7904         MOV     R1,#0x4
   2355                break;
   \   00008C   8016         SJMP    ??zclGetDataTypeLength_10
   2356          
   2357             case ZCL_DATATYPE_UINT40:
   2358             case ZCL_DATATYPE_INT40:
   2359                 len = 5;
   \                     ??zclGetDataTypeLength_4:
   \   00008E   7905         MOV     R1,#0x5
   2360                 break;
   \   000090   8012         SJMP    ??zclGetDataTypeLength_10
   2361          
   2362             case ZCL_DATATYPE_UINT48:
   2363             case ZCL_DATATYPE_INT48:
   2364                 len = 6;
   \                     ??zclGetDataTypeLength_5:
   \   000092   7906         MOV     R1,#0x6
   2365                 break;
   \   000094   800E         SJMP    ??zclGetDataTypeLength_10
   2366          
   2367             case ZCL_DATATYPE_UINT56:
   2368             case ZCL_DATATYPE_INT56:
   2369                 len = 7;
   \                     ??zclGetDataTypeLength_6:
   \   000096   7907         MOV     R1,#0x7
   2370                 break;
   \   000098   800A         SJMP    ??zclGetDataTypeLength_10
   2371          
   2372             case ZCL_DATATYPE_DOUBLE_PREC:
   2373             case ZCL_DATATYPE_IEEE_ADDR:
   2374             case ZCL_DATATYPE_UINT64:
   2375             case ZCL_DATATYPE_INT64:
   2376               len = 8;
   \                     ??zclGetDataTypeLength_7:
   \   00009A   7908         MOV     R1,#0x8
   2377               break;
   \   00009C   8006         SJMP    ??zclGetDataTypeLength_10
   2378          
   2379              case ZCL_DATATYPE_128_BIT_SEC_KEY:
   2380               len = SEC_KEY_LEN;
   \                     ??zclGetDataTypeLength_8:
   \   00009E   7910         MOV     R1,#0x10
   2381               break;
   \   0000A0   8002         SJMP    ??zclGetDataTypeLength_10
   2382          
   2383              case ZCL_DATATYPE_NO_DATA:
   2384              case ZCL_DATATYPE_UNKNOWN:
   2385                // Fall through
   2386          
   2387              default:
   2388                len = 0;
   \                     ??zclGetDataTypeLength_9:
   \   0000A2   7900         MOV     R1,#0x0
   2389                break;
   2390            }
   2391          
   2392            return ( len );
   \                     ??zclGetDataTypeLength_10:
   \   0000A4   02....       LJMP    ?BRET
   2393          }
   2394          
   2395          /*********************************************************************
   2396           * @fn      zclGetAttrDataLength
   2397           *
   2398           * @brief   Return the length of the attribute.
   2399           *
   2400           * @param   dataType - data type
   2401           * @param   pData - pointer to data
   2402           *
   2403           * @return  returns atrribute length
   2404           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2405          uint16 zclGetAttrDataLength( uint8 dataType, uint8 *pData )
   \                     zclGetAttrDataLength:
   2406          {
   \   000000   74F5         MOV     A,#-0xb
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 11
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V0 + 2,R1
   \   000007   EA           MOV     A,R2
   \   000008   FE           MOV     R6,A
   \   000009   EB           MOV     A,R3
   \   00000A   FF           MOV     R7,A
   2407            uint16 dataLen = 0;
   \   00000B   75..00       MOV     ?V0 + 0,#0x0
   \   00000E   75..00       MOV     ?V0 + 1,#0x0
   2408          
   2409            if ( dataType == ZCL_DATATYPE_LONG_CHAR_STR || dataType == ZCL_DATATYPE_LONG_OCTET_STR )
   \   000011   7444         MOV     A,#0x44
   \   000013   65..         XRL     A,?V0 + 2
   \   000015   6006         JZ      ??zclGetAttrDataLength_0
   \   000017   7443         MOV     A,#0x43
   \   000019   65..         XRL     A,?V0 + 2
   \   00001B   7028         JNZ     ??zclGetAttrDataLength_1
   2410            {
   2411              dataLen = BUILD_UINT16( pData[0], pData[1] ) + 2; // long string length + 2 for length field
   \                     ??zclGetAttrDataLength_0:
   \   00001D   8E82         MOV     DPL,R6
   \   00001F   8F83         MOV     DPH,R7
   \   000021   E0           MOVX    A,@DPTR
   \   000022   FA           MOV     R2,A
   \   000023   7B00         MOV     R3,#0x0
   \   000025   8E82         MOV     DPL,R6
   \   000027   8F83         MOV     DPH,R7
   \   000029   A3           INC     DPTR
   \   00002A   E0           MOVX    A,@DPTR
   \   00002B   F8           MOV     R0,A
   \   00002C   7900         MOV     R1,#0x0
   \   00002E   E4           CLR     A
   \   00002F   C8           XCH     A,R0
   \   000030   F9           MOV     R1,A
   \   000031   EA           MOV     A,R2
   \   000032   28           ADD     A,R0
   \   000033   F8           MOV     R0,A
   \   000034   EB           MOV     A,R3
   \   000035   39           ADDC    A,R1
   \   000036   F9           MOV     R1,A
   \   000037   E8           MOV     A,R0
   \   000038   2402         ADD     A,#0x2
   \   00003A   F8           MOV     R0,A
   \   00003B   E9           MOV     A,R1
   \   00003C   3400         ADDC    A,#0x0
   \   00003E   F9           MOV     R1,A
   \   00003F   88..         MOV     ?V0 + 0,R0
   \   000041   89..         MOV     ?V0 + 1,R1
   \   000043   802E         SJMP    ??zclGetAttrDataLength_2
   2412            }
   2413            else if ( dataType == ZCL_DATATYPE_CHAR_STR || dataType == ZCL_DATATYPE_OCTET_STR )
   \                     ??zclGetAttrDataLength_1:
   \   000045   7442         MOV     A,#0x42
   \   000047   65..         XRL     A,?V0 + 2
   \   000049   6006         JZ      ??zclGetAttrDataLength_3
   \   00004B   7441         MOV     A,#0x41
   \   00004D   65..         XRL     A,?V0 + 2
   \   00004F   7015         JNZ     ??zclGetAttrDataLength_4
   2414            {
   2415              dataLen = *pData + 1; // string length + 1 for length field
   \                     ??zclGetAttrDataLength_3:
   \   000051   8E82         MOV     DPL,R6
   \   000053   8F83         MOV     DPH,R7
   \   000055   E0           MOVX    A,@DPTR
   \   000056   F8           MOV     R0,A
   \   000057   7900         MOV     R1,#0x0
   \   000059   2401         ADD     A,#0x1
   \   00005B   F8           MOV     R0,A
   \   00005C   E9           MOV     A,R1
   \   00005D   3400         ADDC    A,#0x0
   \   00005F   F9           MOV     R1,A
   \   000060   88..         MOV     ?V0 + 0,R0
   \   000062   89..         MOV     ?V0 + 1,R1
   \   000064   800D         SJMP    ??zclGetAttrDataLength_2
   2416            }
   2417            else
   2418            {
   2419              dataLen = zclGetDataTypeLength( dataType );
   \                     ??zclGetAttrDataLength_4:
   \   000066                ; Setup parameters for call to function zclGetDataTypeLength
   \   000066   A9..         MOV     R1,?V0 + 2
   \   000068   12....       LCALL   ??zclGetDataTypeLength?relay
   \   00006B   E9           MOV     A,R1
   \   00006C   F8           MOV     R0,A
   \   00006D   7900         MOV     R1,#0x0
   \   00006F   88..         MOV     ?V0 + 0,R0
   \   000071   89..         MOV     ?V0 + 1,R1
   2420            }
   2421          
   2422            return ( dataLen );
   \                     ??zclGetAttrDataLength_2:
   \   000073   AA..         MOV     R2,?V0 + 0
   \   000075   AB..         MOV     R3,?V0 + 1
   \   000077   7F03         MOV     R7,#0x3
   \   000079   02....       LJMP    ?BANKED_LEAVE_XDATA
   2423          }
   2424          
   2425          /*********************************************************************
   2426           * @fn      zclReadAttrData
   2427           *
   2428           * @brief   Read the attribute's current value into pAttrData.
   2429           *
   2430           * @param   pAttrData - where to put attribute data
   2431           * @param   pAttr - pointer to attribute
   2432           * @param   pDataLen - where to put attribute data length
   2433           *
   2434           * @return Success
   2435           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2436          uint8 zclReadAttrData( uint8 *pAttrData, zclAttrRec_t *pAttr, uint16 *pDataLen )
   \                     zclReadAttrData:
   2437          {
   \   000000   74EE         MOV     A,#-0x12
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 18
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV     ?V0 + 8,R2
   \   000007   8B..         MOV     ?V0 + 9,R3
   \   000009   EC           MOV     A,R4
   \   00000A   FE           MOV     R6,A
   \   00000B   ED           MOV     A,R5
   \   00000C   FF           MOV     R7,A
   \   00000D   7412         MOV     A,#0x12
   \   00000F   12....       LCALL   ?XSTACK_DISP0_8
   \   000012   E0           MOVX    A,@DPTR
   \   000013   F5..         MOV     ?V0 + 0,A
   \   000015   A3           INC     DPTR
   \   000016   E0           MOVX    A,@DPTR
   \   000017   F5..         MOV     ?V0 + 1,A
   2438            uint16 dataLen;
   2439          
   2440            dataLen = zclGetAttrDataLength( pAttr->attr.dataType, (uint8*)(pAttr->attr.dataPtr) );
   \   000019                ; Setup parameters for call to function zclGetAttrDataLength
   \   000019   8E82         MOV     DPL,R6
   \   00001B   8F83         MOV     DPH,R7
   \   00001D   A3           INC     DPTR
   \   00001E   A3           INC     DPTR
   \   00001F   A3           INC     DPTR
   \   000020   A3           INC     DPTR
   \   000021   A3           INC     DPTR
   \   000022   A3           INC     DPTR
   \   000023   E0           MOVX    A,@DPTR
   \   000024   FA           MOV     R2,A
   \   000025   A3           INC     DPTR
   \   000026   E0           MOVX    A,@DPTR
   \   000027   FB           MOV     R3,A
   \   000028   8E82         MOV     DPL,R6
   \   00002A   8F83         MOV     DPH,R7
   \   00002C   A3           INC     DPTR
   \   00002D   A3           INC     DPTR
   \   00002E   A3           INC     DPTR
   \   00002F   A3           INC     DPTR
   \   000030   E0           MOVX    A,@DPTR
   \   000031   F9           MOV     R1,A
   \   000032   12....       LCALL   ??zclGetAttrDataLength?relay
   \   000035   8A..         MOV     ?V0 + 4,R2
   \   000037   8B..         MOV     ?V0 + 5,R3
   \   000039   85....       MOV     ?V0 + 2,?V0 + 4
   \   00003C   85....       MOV     ?V0 + 3,?V0 + 5
   2441            osal_memcpy( pAttrData, pAttr->attr.dataPtr, dataLen );
   \   00003F                ; Setup parameters for call to function osal_memcpy
   \   00003F   8E82         MOV     DPL,R6
   \   000041   8F83         MOV     DPH,R7
   \   000043   A3           INC     DPTR
   \   000044   A3           INC     DPTR
   \   000045   A3           INC     DPTR
   \   000046   A3           INC     DPTR
   \   000047   A3           INC     DPTR
   \   000048   A3           INC     DPTR
   \   000049   E0           MOVX    A,@DPTR
   \   00004A   F5..         MOV     ?V0 + 4,A
   \   00004C   A3           INC     DPTR
   \   00004D   E0           MOVX    A,@DPTR
   \   00004E   F5..         MOV     ?V0 + 5,A
   \   000050   75..00       MOV     ?V0 + 6,#0x0
   \   000053   78..         MOV     R0,#?V0 + 4
   \   000055   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   000058   AC..         MOV     R4,?V0 + 2
   \   00005A   AD..         MOV     R5,?V0 + 3
   \   00005C   AA..         MOV     R2,?V0 + 8
   \   00005E   AB..         MOV     R3,?V0 + 9
   \   000060   12....       LCALL   ??osal_memcpy?relay
   \   000063   7403         MOV     A,#0x3
   \   000065   12....       LCALL   ?DEALLOC_XSTACK8
   2442          
   2443            if ( pDataLen != NULL )
   \   000068   E5..         MOV     A,?V0 + 0
   \   00006A   45..         ORL     A,?V0 + 1
   \   00006C   600D         JZ      ??zclReadAttrData_0
   2444            {
   2445              *pDataLen = dataLen;
   \   00006E   85..82       MOV     DPL,?V0 + 0
   \   000071   85..83       MOV     DPH,?V0 + 1
   \   000074   E5..         MOV     A,?V0 + 2
   \   000076   F0           MOVX    @DPTR,A
   \   000077   A3           INC     DPTR
   \   000078   E5..         MOV     A,?V0 + 3
   \   00007A   F0           MOVX    @DPTR,A
   2446            }
   2447          
   2448            return ( ZCL_STATUS_SUCCESS );
   \                     ??zclReadAttrData_0:
   \   00007B   7900         MOV     R1,#0x0
   \   00007D   7F0A         MOV     R7,#0xa
   \   00007F   02....       LJMP    ?BANKED_LEAVE_XDATA
   2449          }
   2450          
   2451          #ifdef ZCL_READ
   2452          /*********************************************************************
   2453           * @fn      zclGetAttrDataLengthUsingCB
   2454           *
   2455           * @brief   Use application's callback to get the length of the attribute's
   2456           *          current value stored in the database.
   2457           *
   2458           * @param   endpoint - application's endpoint
   2459           * @param   clusterId - cluster that attribute belongs to
   2460           * @param   attrId - attribute id
   2461           *
   2462           * @return  returns attribute length
   2463           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2464          static uint16 zclGetAttrDataLengthUsingCB( uint8 endpoint, uint16 clusterId, uint16 attrId )
   \                     zclGetAttrDataLengthUsingCB:
   2465          {
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   89..         MOV     ?V0 + 4,R1
   \   00000C   8A..         MOV     ?V0 + 2,R2
   \   00000E   8B..         MOV     ?V0 + 3,R3
   \   000010   8C..         MOV     ?V0 + 0,R4
   \   000012   8D..         MOV     ?V0 + 1,R5
   2466            uint16 dataLen = 0;
   \   000014   85..82       MOV     DPL,?XSP + 0
   \   000017   85..83       MOV     DPH,?XSP + 1
   \   00001A   7400         MOV     A,#0x0
   \   00001C   F0           MOVX    @DPTR,A
   \   00001D   A3           INC     DPTR
   \   00001E   7400         MOV     A,#0x0
   \   000020   F0           MOVX    @DPTR,A
   2467            zclReadWriteCB_t pfnReadWriteCB = zclGetReadWriteCB( endpoint );
   \   000021                ; Setup parameters for call to function zclGetReadWriteCB
   \   000021   A9..         MOV     R1,?V0 + 4
   \   000023   12....       LCALL   ??zclGetReadWriteCB?relay
   \   000026   8A..         MOV     ?V0 + 6,R2
   \   000028   8B..         MOV     ?V0 + 7,R3
   \   00002A   AE..         MOV     R6,?V0 + 6
   \   00002C   AF..         MOV     R7,?V0 + 7
   2468          
   2469            if ( pfnReadWriteCB != NULL )
   \   00002E   EE           MOV     A,R6
   \   00002F   4F           ORL     A,R7
   \   000030   6032         JZ      ??zclGetAttrDataLengthUsingCB_0
   2470            {
   2471              // Only get the attribute length
   2472              (*pfnReadWriteCB)( clusterId, attrId, ZCL_OPER_LEN, NULL, &dataLen );
   \   000032                ; Setup parameters for indirect call
   \   000032   85..82       MOV     DPL,?XSP + 0
   \   000035   85..83       MOV     DPH,?XSP + 1
   \   000038   8582..       MOV     ?V0 + 6,DPL
   \   00003B   8583..       MOV     ?V0 + 7,DPH
   \   00003E   78..         MOV     R0,#?V0 + 6
   \   000040   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000043   E4           CLR     A
   \   000044   F5..         MOV     ?V0 + 6,A
   \   000046   F5..         MOV     ?V0 + 7,A
   \   000048   78..         MOV     R0,#?V0 + 6
   \   00004A   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00004D   7900         MOV     R1,#0x0
   \   00004F   AC..         MOV     R4,?V0 + 0
   \   000051   AD..         MOV     R5,?V0 + 1
   \   000053   AA..         MOV     R2,?V0 + 2
   \   000055   AB..         MOV     R3,?V0 + 3
   \   000057   8E82         MOV     DPL,R6
   \   000059   8F83         MOV     DPH,R7
   \   00005B   12....       LCALL   ?CALL_IND
   \   00005E   7404         MOV     A,#0x4
   \   000060   12....       LCALL   ?DEALLOC_XSTACK8
   \   000063   E9           MOV     A,R1
   2473            }
   2474          
   2475            return ( dataLen );
   \                     ??zclGetAttrDataLengthUsingCB_0:
   \   000064   85..82       MOV     DPL,?XSP + 0
   \   000067   85..83       MOV     DPH,?XSP + 1
   \   00006A   E0           MOVX    A,@DPTR
   \   00006B   FA           MOV     R2,A
   \   00006C   A3           INC     DPTR
   \   00006D   E0           MOVX    A,@DPTR
   \   00006E   FB           MOV     R3,A
   \   00006F   7402         MOV     A,#0x2
   \   000071   12....       LCALL   ?DEALLOC_XSTACK8
   \   000074   7F08         MOV     R7,#0x8
   \   000076   02....       LJMP    ?BANKED_LEAVE_XDATA
   2476          }
   2477          
   2478          /*********************************************************************
   2479           * @fn      zclReadAttrDataUsingCB
   2480           *
   2481           * @brief   Use application's callback to read the attribute's current
   2482           *          value stored in the database.
   2483           *
   2484           * @param   endpoint - application's endpoint
   2485           * @param   clusterId - cluster that attribute belongs to
   2486           * @param   attrId - attribute id
   2487           * @param   pAttrData - where to put attribute data
   2488           * @param   pDataLen - where to put attribute data length
   2489           *
   2490           * @return  Successful if data was read
   2491           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2492          static ZStatus_t zclReadAttrDataUsingCB( uint8 endpoint, uint16 clusterId, uint16 attrId,
   \                     zclReadAttrDataUsingCB:
   2493                                                   uint8 *pAttrData, uint16 *pDataLen )
   2494          {
   \   000000   74EC         MOV     A,#-0x14
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 20
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V0 + 4,R1
   \   000007   8A..         MOV     ?V0 + 2,R2
   \   000009   8B..         MOV     ?V0 + 3,R3
   \   00000B   8C..         MOV     ?V0 + 0,R4
   \   00000D   8D..         MOV     ?V0 + 1,R5
   \   00000F   7414         MOV     A,#0x14
   \   000011   12....       LCALL   ?XSTACK_DISP0_8
   \   000014   E0           MOVX    A,@DPTR
   \   000015   F5..         MOV     ?V0 + 8,A
   \   000017   A3           INC     DPTR
   \   000018   E0           MOVX    A,@DPTR
   \   000019   F5..         MOV     ?V0 + 9,A
   \   00001B   7416         MOV     A,#0x16
   \   00001D   12....       LCALL   ?XSTACK_DISP0_8
   \   000020   E0           MOVX    A,@DPTR
   \   000021   F5..         MOV     ?V0 + 6,A
   \   000023   A3           INC     DPTR
   \   000024   E0           MOVX    A,@DPTR
   \   000025   F5..         MOV     ?V0 + 7,A
   2495            zclReadWriteCB_t pfnReadWriteCB = zclGetReadWriteCB( endpoint );
   \   000027                ; Setup parameters for call to function zclGetReadWriteCB
   \   000027   A9..         MOV     R1,?V0 + 4
   \   000029   12....       LCALL   ??zclGetReadWriteCB?relay
   \   00002C   8A..         MOV     ?V0 + 10,R2
   \   00002E   8B..         MOV     ?V0 + 11,R3
   \   000030   AE..         MOV     R6,?V0 + 10
   \   000032   AF..         MOV     R7,?V0 + 11
   2496          
   2497            if ( pDataLen != NULL )
   \   000034   E5..         MOV     A,?V0 + 6
   \   000036   45..         ORL     A,?V0 + 7
   \   000038   600D         JZ      ??zclReadAttrDataUsingCB_0
   2498            {
   2499              *pDataLen = 0; // Always initialize it to 0
   \   00003A   85..82       MOV     DPL,?V0 + 6
   \   00003D   85..83       MOV     DPH,?V0 + 7
   \   000040   7400         MOV     A,#0x0
   \   000042   F0           MOVX    @DPTR,A
   \   000043   A3           INC     DPTR
   \   000044   7400         MOV     A,#0x0
   \   000046   F0           MOVX    @DPTR,A
   2500            }
   2501          
   2502            if ( pfnReadWriteCB != NULL )
   \                     ??zclReadAttrDataUsingCB_0:
   \   000047   EE           MOV     A,R6
   \   000048   4F           ORL     A,R7
   \   000049   6022         JZ      ??zclReadAttrDataUsingCB_1
   2503            {
   2504              // Read the attribute value and its length
   2505              return ( (*pfnReadWriteCB)( clusterId, attrId, ZCL_OPER_READ, pAttrData, pDataLen ) );
   \   00004B                ; Setup parameters for indirect call
   \   00004B   78..         MOV     R0,#?V0 + 6
   \   00004D   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000050   78..         MOV     R0,#?V0 + 8
   \   000052   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000055   7901         MOV     R1,#0x1
   \   000057   AC..         MOV     R4,?V0 + 0
   \   000059   AD..         MOV     R5,?V0 + 1
   \   00005B   AA..         MOV     R2,?V0 + 2
   \   00005D   AB..         MOV     R3,?V0 + 3
   \   00005F   8E82         MOV     DPL,R6
   \   000061   8F83         MOV     DPH,R7
   \   000063   12....       LCALL   ?CALL_IND
   \   000066   7404         MOV     A,#0x4
   \   000068   12....       LCALL   ?DEALLOC_XSTACK8
   \   00006B   8002         SJMP    ??zclReadAttrDataUsingCB_2
   2506            }
   2507          
   2508            return ( ZCL_STATUS_SOFTWARE_FAILURE );
   \                     ??zclReadAttrDataUsingCB_1:
   \   00006D   79C1         MOV     R1,#-0x3f
   \                     ??zclReadAttrDataUsingCB_2:
   \   00006F   7F0C         MOV     R7,#0xc
   \   000071   02....       LJMP    ?BANKED_LEAVE_XDATA
   2509          }
   2510          
   2511          /*********************************************************************
   2512           * @fn      zclAuthorizeRead
   2513           *
   2514           * @brief   Use application's callback to authorize a Read operation
   2515           *          on a given attribute.
   2516           *
   2517           * @param   endpoint - application's endpoint
   2518           * @param   srcAddr - source Address
   2519           * @param   pAttr - pointer to attribute
   2520           *
   2521           * @return  ZCL_STATUS_SUCCESS: Operation authorized
   2522           *          ZCL_STATUS_NOT_AUTHORIZED: Operation not authorized
   2523           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2524          static ZStatus_t zclAuthorizeRead( uint8 endpoint, afAddrType_t *srcAddr, zclAttrRec_t *pAttr )
   \                     zclAuthorizeRead:
   2525          {
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V0 + 4,R1
   \   000007   8A..         MOV     ?V0 + 2,R2
   \   000009   8B..         MOV     ?V0 + 3,R3
   \   00000B   8C..         MOV     ?V0 + 0,R4
   \   00000D   8D..         MOV     ?V0 + 1,R5
   2526            if ( zcl_AccessCtrlAuthRead( pAttr->attr.accessControl ) )
   \   00000F   85..82       MOV     DPL,?V0 + 0
   \   000012   85..83       MOV     DPH,?V0 + 1
   \   000015   A3           INC     DPTR
   \   000016   A3           INC     DPTR
   \   000017   A3           INC     DPTR
   \   000018   A3           INC     DPTR
   \   000019   A3           INC     DPTR
   \   00001A   E0           MOVX    A,@DPTR
   \   00001B   A2E4         MOV     C,0xE0 /* A   */.4
   \   00001D   5024         JNC     ??zclAuthorizeRead_0
   2527            {
   2528              zclAuthorizeCB_t pfnAuthorizeCB = zclGetAuthorizeCB( endpoint );
   \   00001F                ; Setup parameters for call to function zclGetAuthorizeCB
   \   00001F   A9..         MOV     R1,?V0 + 4
   \   000021   12....       LCALL   ??zclGetAuthorizeCB?relay
   \   000024   8A..         MOV     ?V0 + 6,R2
   \   000026   8B..         MOV     ?V0 + 7,R3
   \   000028   AE..         MOV     R6,?V0 + 6
   \   00002A   AF..         MOV     R7,?V0 + 7
   2529          
   2530              if ( pfnAuthorizeCB != NULL )
   \   00002C   EE           MOV     A,R6
   \   00002D   4F           ORL     A,R7
   \   00002E   6013         JZ      ??zclAuthorizeRead_0
   2531              {
   2532                return ( (*pfnAuthorizeCB)( srcAddr, pAttr, ZCL_OPER_READ ) );
   \   000030                ; Setup parameters for indirect call
   \   000030   7901         MOV     R1,#0x1
   \   000032   AC..         MOV     R4,?V0 + 0
   \   000034   AD..         MOV     R5,?V0 + 1
   \   000036   AA..         MOV     R2,?V0 + 2
   \   000038   AB..         MOV     R3,?V0 + 3
   \   00003A   8E82         MOV     DPL,R6
   \   00003C   8F83         MOV     DPH,R7
   \   00003E   12....       LCALL   ?CALL_IND
   \   000041   8002         SJMP    ??zclAuthorizeRead_1
   2533              }
   2534            }
   2535          
   2536            return ( ZCL_STATUS_SUCCESS );
   \                     ??zclAuthorizeRead_0:
   \   000043   7900         MOV     R1,#0x0
   \                     ??zclAuthorizeRead_1:
   \   000045   7F08         MOV     R7,#0x8
   \   000047   02....       LJMP    ?BANKED_LEAVE_XDATA
   2537          }
   2538          #endif // ZCL_READ
   2539          
   2540          #ifdef ZCL_WRITE
   2541          /*********************************************************************
   2542           * @fn      zclWriteAttrData
   2543           *
   2544           * @brief   Write the received data.
   2545           *
   2546           * @param   endpoint - application's endpoint
   2547           * @param   pAttr - where to write data to
   2548           * @param   pWriteRec - data to be written
   2549           *
   2550           * @return  Successful if data was written
   2551           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2552          static ZStatus_t zclWriteAttrData( uint8 endpoint, afAddrType_t *srcAddr,
   \                     zclWriteAttrData:
   2553                                             zclAttrRec_t *pAttr, zclWriteRec_t *pWriteRec )
   2554          {
   \   000000   74EC         MOV     A,#-0x14
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 20
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V0 + 3,R1
   \   000007   8A..         MOV     ?V0 + 10,R2
   \   000009   8B..         MOV     ?V0 + 11,R3
   \   00000B   EC           MOV     A,R4
   \   00000C   FE           MOV     R6,A
   \   00000D   ED           MOV     A,R5
   \   00000E   FF           MOV     R7,A
   \   00000F   7414         MOV     A,#0x14
   \   000011   12....       LCALL   ?XSTACK_DISP0_8
   \   000014   E0           MOVX    A,@DPTR
   \   000015   F5..         MOV     ?V0 + 0,A
   \   000017   A3           INC     DPTR
   \   000018   E0           MOVX    A,@DPTR
   \   000019   F5..         MOV     ?V0 + 1,A
   2555            uint8 status;
   2556          
   2557            if ( zcl_AccessCtrlWrite( pAttr->attr.accessControl ) )
   \   00001B   8E82         MOV     DPL,R6
   \   00001D   8F83         MOV     DPH,R7
   \   00001F   A3           INC     DPTR
   \   000020   A3           INC     DPTR
   \   000021   A3           INC     DPTR
   \   000022   A3           INC     DPTR
   \   000023   A3           INC     DPTR
   \   000024   E0           MOVX    A,@DPTR
   \   000025   A2E1         MOV     C,0xE0 /* A   */.1
   \   000027   4003         JC      $+5
   \   000029   02....       LJMP    ??zclWriteAttrData_0 & 0xFFFF
   2558            {
   2559              status = zclAuthorizeWrite( endpoint, srcAddr, pAttr );
   \   00002C                ; Setup parameters for call to function zclAuthorizeWrite
   \   00002C   EE           MOV     A,R6
   \   00002D   FC           MOV     R4,A
   \   00002E   EF           MOV     A,R7
   \   00002F   FD           MOV     R5,A
   \   000030   AA..         MOV     R2,?V0 + 10
   \   000032   AB..         MOV     R3,?V0 + 11
   \   000034   A9..         MOV     R1,?V0 + 3
   \   000036   12....       LCALL   ??zclAuthorizeWrite?relay
   \   000039   E9           MOV     A,R1
   \   00003A   F5..         MOV     ?V0 + 2,A
   2560              if ( status == ZCL_STATUS_SUCCESS )
   \   00003C   E5..         MOV     A,?V0 + 2
   \   00003E   6003         JZ      $+5
   \   000040   02....       LJMP    ??zclWriteAttrData_1 & 0xFFFF
   2561              {
   2562                if ( ( zcl_ValidateAttrDataCB == NULL ) || zcl_ValidateAttrDataCB( pAttr, pWriteRec ) )
   \   000043   90....       MOV     DPTR,#zcl_ValidateAttrDataCB
   \   000046   E0           MOVX    A,@DPTR
   \   000047   F8           MOV     R0,A
   \   000048   A3           INC     DPTR
   \   000049   E0           MOVX    A,@DPTR
   \   00004A   F9           MOV     R1,A
   \   00004B   E8           MOV     A,R0
   \   00004C   49           ORL     A,R1
   \   00004D   6019         JZ      ??zclWriteAttrData_2
   \   00004F                ; Setup parameters for indirect call
   \   00004F   AC..         MOV     R4,?V0 + 0
   \   000051   AD..         MOV     R5,?V0 + 1
   \   000053   EE           MOV     A,R6
   \   000054   FA           MOV     R2,A
   \   000055   EF           MOV     A,R7
   \   000056   FB           MOV     R3,A
   \   000057   90....       MOV     DPTR,#zcl_ValidateAttrDataCB
   \   00005A   E0           MOVX    A,@DPTR
   \   00005B   F8           MOV     R0,A
   \   00005C   A3           INC     DPTR
   \   00005D   E0           MOVX    A,@DPTR
   \   00005E   F583         MOV     DPH,A
   \   000060   8882         MOV     DPL,R0
   \   000062   12....       LCALL   ?CALL_IND
   \   000065   E9           MOV     A,R1
   \   000066   605D         JZ      ??zclWriteAttrData_3
   2563                {
   2564                  // Write the attribute value
   2565                  uint16 len = zclGetAttrDataLength( pAttr->attr.dataType, pWriteRec->attrData );
   \                     ??zclWriteAttrData_2:
   \   000068                ; Setup parameters for call to function zclGetAttrDataLength
   \   000068   85..82       MOV     DPL,?V0 + 0
   \   00006B   85..83       MOV     DPH,?V0 + 1
   \   00006E   A3           INC     DPTR
   \   00006F   A3           INC     DPTR
   \   000070   A3           INC     DPTR
   \   000071   E0           MOVX    A,@DPTR
   \   000072   FA           MOV     R2,A
   \   000073   A3           INC     DPTR
   \   000074   E0           MOVX    A,@DPTR
   \   000075   FB           MOV     R3,A
   \   000076   8E82         MOV     DPL,R6
   \   000078   8F83         MOV     DPH,R7
   \   00007A   A3           INC     DPTR
   \   00007B   A3           INC     DPTR
   \   00007C   A3           INC     DPTR
   \   00007D   A3           INC     DPTR
   \   00007E   E0           MOVX    A,@DPTR
   \   00007F   F9           MOV     R1,A
   \   000080   12....       LCALL   ??zclGetAttrDataLength?relay
   \   000083   8A..         MOV     ?V0 + 4,R2
   \   000085   8B..         MOV     ?V0 + 5,R3
   \   000087   85....       MOV     ?V0 + 8,?V0 + 4
   \   00008A   85....       MOV     ?V0 + 9,?V0 + 5
   2566                  osal_memcpy( pAttr->attr.dataPtr, pWriteRec->attrData, len );
   \   00008D                ; Setup parameters for call to function osal_memcpy
   \   00008D   85..82       MOV     DPL,?V0 + 0
   \   000090   85..83       MOV     DPH,?V0 + 1
   \   000093   A3           INC     DPTR
   \   000094   A3           INC     DPTR
   \   000095   A3           INC     DPTR
   \   000096   E0           MOVX    A,@DPTR
   \   000097   F5..         MOV     ?V0 + 4,A
   \   000099   A3           INC     DPTR
   \   00009A   E0           MOVX    A,@DPTR
   \   00009B   F5..         MOV     ?V0 + 5,A
   \   00009D   75..00       MOV     ?V0 + 6,#0x0
   \   0000A0   78..         MOV     R0,#?V0 + 4
   \   0000A2   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   0000A5   AC..         MOV     R4,?V0 + 8
   \   0000A7   AD..         MOV     R5,?V0 + 9
   \   0000A9   8E82         MOV     DPL,R6
   \   0000AB   8F83         MOV     DPH,R7
   \   0000AD   A3           INC     DPTR
   \   0000AE   A3           INC     DPTR
   \   0000AF   A3           INC     DPTR
   \   0000B0   A3           INC     DPTR
   \   0000B1   A3           INC     DPTR
   \   0000B2   A3           INC     DPTR
   \   0000B3   E0           MOVX    A,@DPTR
   \   0000B4   FA           MOV     R2,A
   \   0000B5   A3           INC     DPTR
   \   0000B6   E0           MOVX    A,@DPTR
   \   0000B7   FB           MOV     R3,A
   \   0000B8   12....       LCALL   ??osal_memcpy?relay
   \   0000BB   7403         MOV     A,#0x3
   \   0000BD   12....       LCALL   ?DEALLOC_XSTACK8
   2567          
   2568                  status = ZCL_STATUS_SUCCESS;
   \   0000C0   75..00       MOV     ?V0 + 2,#0x0
   \   0000C3   8008         SJMP    ??zclWriteAttrData_1
   2569                }
   2570                else
   2571                {
   2572                  status = ZCL_STATUS_INVALID_VALUE;
   \                     ??zclWriteAttrData_3:
   \   0000C5   75..87       MOV     ?V0 + 2,#-0x79
   \   0000C8   8003         SJMP    ??zclWriteAttrData_1
   2573                }
   2574              }
   2575            }
   2576            else
   2577            {
   2578              status = ZCL_STATUS_READ_ONLY;
   \                     ??zclWriteAttrData_0:
   \   0000CA   75..88       MOV     ?V0 + 2,#-0x78
   2579            }
   2580          
   2581            return ( status );
   \                     ??zclWriteAttrData_1:
   \   0000CD   A9..         MOV     R1,?V0 + 2
   \   0000CF   7F0C         MOV     R7,#0xc
   \   0000D1   02....       LJMP    ?BANKED_LEAVE_XDATA
   2582          }
   2583          
   2584          /*********************************************************************
   2585           * @fn      zclWriteAttrDataUsingCB
   2586           *
   2587           * @brief   Use application's callback to write the attribute's current
   2588           *          value stored in the database.
   2589           *
   2590           * @param   endpoint - application's endpoint
   2591           * @param   pAttr - where to write data to
   2592           * @param   pAttrData - data to be written
   2593           *
   2594           * @return  Successful if data was written
   2595           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2596          static ZStatus_t zclWriteAttrDataUsingCB( uint8 endpoint, afAddrType_t *srcAddr,
   \                     zclWriteAttrDataUsingCB:
   2597                                                    zclAttrRec_t *pAttr, uint8 *pAttrData )
   2598          {
   \   000000   74EE         MOV     A,#-0x12
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 18
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V0 + 1,R1
   \   000007   8A..         MOV     ?V0 + 4,R2
   \   000009   8B..         MOV     ?V0 + 5,R3
   \   00000B   EC           MOV     A,R4
   \   00000C   FE           MOV     R6,A
   \   00000D   ED           MOV     A,R5
   \   00000E   FF           MOV     R7,A
   \   00000F   7412         MOV     A,#0x12
   \   000011   12....       LCALL   ?XSTACK_DISP0_8
   \   000014   E0           MOVX    A,@DPTR
   \   000015   F5..         MOV     ?V0 + 6,A
   \   000017   A3           INC     DPTR
   \   000018   E0           MOVX    A,@DPTR
   \   000019   F5..         MOV     ?V0 + 7,A
   2599            uint8 status;
   2600          
   2601            if ( zcl_AccessCtrlWrite( pAttr->attr.accessControl ) )
   \   00001B   8E82         MOV     DPL,R6
   \   00001D   8F83         MOV     DPH,R7
   \   00001F   A3           INC     DPTR
   \   000020   A3           INC     DPTR
   \   000021   A3           INC     DPTR
   \   000022   A3           INC     DPTR
   \   000023   A3           INC     DPTR
   \   000024   E0           MOVX    A,@DPTR
   \   000025   A2E1         MOV     C,0xE0 /* A   */.1
   \   000027   5066         JNC     ??zclWriteAttrDataUsingCB_0
   2602            {
   2603              status = zclAuthorizeWrite( endpoint, srcAddr, pAttr );
   \   000029                ; Setup parameters for call to function zclAuthorizeWrite
   \   000029   EE           MOV     A,R6
   \   00002A   FC           MOV     R4,A
   \   00002B   EF           MOV     A,R7
   \   00002C   FD           MOV     R5,A
   \   00002D   AA..         MOV     R2,?V0 + 4
   \   00002F   AB..         MOV     R3,?V0 + 5
   \   000031   A9..         MOV     R1,?V0 + 1
   \   000033   12....       LCALL   ??zclAuthorizeWrite?relay
   \   000036   E9           MOV     A,R1
   \   000037   F5..         MOV     ?V0 + 0,A
   2604              if ( status == ZCL_STATUS_SUCCESS )
   \   000039   E5..         MOV     A,?V0 + 0
   \   00003B   7055         JNZ     ??zclWriteAttrDataUsingCB_1
   2605              {
   2606                zclReadWriteCB_t pfnReadWriteCB = zclGetReadWriteCB( endpoint );
   \   00003D                ; Setup parameters for call to function zclGetReadWriteCB
   \   00003D   A9..         MOV     R1,?V0 + 1
   \   00003F   12....       LCALL   ??zclGetReadWriteCB?relay
   \   000042   8A..         MOV     ?V0 + 8,R2
   \   000044   8B..         MOV     ?V0 + 9,R3
   \   000046   85....       MOV     ?V0 + 2,?V0 + 8
   \   000049   85....       MOV     ?V0 + 3,?V0 + 9
   2607                if ( pfnReadWriteCB != NULL )
   \   00004C   E5..         MOV     A,?V0 + 2
   \   00004E   45..         ORL     A,?V0 + 3
   \   000050   6038         JZ      ??zclWriteAttrDataUsingCB_2
   2608                {
   2609                  // Write the attribute value
   2610                  status = (*pfnReadWriteCB)( pAttr->clusterID, pAttr->attr.attrId,
   2611                                              ZCL_OPER_WRITE, pAttrData, NULL );
   \   000052                ; Setup parameters for indirect call
   \   000052   E4           CLR     A
   \   000053   F5..         MOV     ?V0 + 8,A
   \   000055   F5..         MOV     ?V0 + 9,A
   \   000057   78..         MOV     R0,#?V0 + 8
   \   000059   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00005C   78..         MOV     R0,#?V0 + 6
   \   00005E   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000061   7902         MOV     R1,#0x2
   \   000063   8E82         MOV     DPL,R6
   \   000065   8F83         MOV     DPH,R7
   \   000067   A3           INC     DPTR
   \   000068   A3           INC     DPTR
   \   000069   E0           MOVX    A,@DPTR
   \   00006A   FC           MOV     R4,A
   \   00006B   A3           INC     DPTR
   \   00006C   E0           MOVX    A,@DPTR
   \   00006D   FD           MOV     R5,A
   \   00006E   8E82         MOV     DPL,R6
   \   000070   8F83         MOV     DPH,R7
   \   000072   E0           MOVX    A,@DPTR
   \   000073   FA           MOV     R2,A
   \   000074   A3           INC     DPTR
   \   000075   E0           MOVX    A,@DPTR
   \   000076   FB           MOV     R3,A
   \   000077   85..82       MOV     DPL,?V0 + 2
   \   00007A   85..83       MOV     DPH,?V0 + 3
   \   00007D   12....       LCALL   ?CALL_IND
   \   000080   7404         MOV     A,#0x4
   \   000082   12....       LCALL   ?DEALLOC_XSTACK8
   \   000085   E9           MOV     A,R1
   \   000086   F5..         MOV     ?V0 + 0,A
   \   000088   8008         SJMP    ??zclWriteAttrDataUsingCB_1
   2612                }
   2613                else
   2614                {
   2615                  status = ZCL_STATUS_SOFTWARE_FAILURE;
   \                     ??zclWriteAttrDataUsingCB_2:
   \   00008A   75..C1       MOV     ?V0 + 0,#-0x3f
   \   00008D   8003         SJMP    ??zclWriteAttrDataUsingCB_1
   2616                }
   2617              }
   2618            }
   2619            else
   2620            {
   2621              status = ZCL_STATUS_READ_ONLY;
   \                     ??zclWriteAttrDataUsingCB_0:
   \   00008F   75..88       MOV     ?V0 + 0,#-0x78
   2622            }
   2623          
   2624            return ( status );
   \                     ??zclWriteAttrDataUsingCB_1:
   \   000092   A9..         MOV     R1,?V0 + 0
   \   000094   7F0A         MOV     R7,#0xa
   \   000096   02....       LJMP    ?BANKED_LEAVE_XDATA
   2625          }
   2626          
   2627          /*********************************************************************
   2628           * @fn      zclAuthorizeWrite
   2629           *
   2630           * @brief   Use application's callback to authorize a Write operation
   2631           *          on a given attribute.
   2632           *
   2633           * @param   endpoint - application's endpoint
   2634           * @param   srcAddr - source Address
   2635           * @param   pAttr - pointer to attribute
   2636           *
   2637           * @return  ZCL_STATUS_SUCCESS: Operation authorized
   2638           *          ZCL_STATUS_NOT_AUTHORIZED: Operation not authorized
   2639           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2640          static ZStatus_t zclAuthorizeWrite( uint8 endpoint, afAddrType_t *srcAddr, zclAttrRec_t *pAttr )
   \                     zclAuthorizeWrite:
   2641          {
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V0 + 4,R1
   \   000007   8A..         MOV     ?V0 + 2,R2
   \   000009   8B..         MOV     ?V0 + 3,R3
   \   00000B   8C..         MOV     ?V0 + 0,R4
   \   00000D   8D..         MOV     ?V0 + 1,R5
   2642            if ( zcl_AccessCtrlAuthWrite( pAttr->attr.accessControl ) )
   \   00000F   85..82       MOV     DPL,?V0 + 0
   \   000012   85..83       MOV     DPH,?V0 + 1
   \   000015   A3           INC     DPTR
   \   000016   A3           INC     DPTR
   \   000017   A3           INC     DPTR
   \   000018   A3           INC     DPTR
   \   000019   A3           INC     DPTR
   \   00001A   E0           MOVX    A,@DPTR
   \   00001B   A2E5         MOV     C,0xE0 /* A   */.5
   \   00001D   5024         JNC     ??zclAuthorizeWrite_0
   2643            {
   2644              zclAuthorizeCB_t pfnAuthorizeCB = zclGetAuthorizeCB( endpoint );
   \   00001F                ; Setup parameters for call to function zclGetAuthorizeCB
   \   00001F   A9..         MOV     R1,?V0 + 4
   \   000021   12....       LCALL   ??zclGetAuthorizeCB?relay
   \   000024   8A..         MOV     ?V0 + 6,R2
   \   000026   8B..         MOV     ?V0 + 7,R3
   \   000028   AE..         MOV     R6,?V0 + 6
   \   00002A   AF..         MOV     R7,?V0 + 7
   2645          
   2646              if ( pfnAuthorizeCB != NULL )
   \   00002C   EE           MOV     A,R6
   \   00002D   4F           ORL     A,R7
   \   00002E   6013         JZ      ??zclAuthorizeWrite_0
   2647              {
   2648                return ( (*pfnAuthorizeCB)( srcAddr, pAttr, ZCL_OPER_WRITE ) );
   \   000030                ; Setup parameters for indirect call
   \   000030   7902         MOV     R1,#0x2
   \   000032   AC..         MOV     R4,?V0 + 0
   \   000034   AD..         MOV     R5,?V0 + 1
   \   000036   AA..         MOV     R2,?V0 + 2
   \   000038   AB..         MOV     R3,?V0 + 3
   \   00003A   8E82         MOV     DPL,R6
   \   00003C   8F83         MOV     DPH,R7
   \   00003E   12....       LCALL   ?CALL_IND
   \   000041   8002         SJMP    ??zclAuthorizeWrite_1
   2649              }
   2650            }
   2651          
   2652            return ( ZCL_STATUS_SUCCESS );
   \                     ??zclAuthorizeWrite_0:
   \   000043   7900         MOV     R1,#0x0
   \                     ??zclAuthorizeWrite_1:
   \   000045   7F08         MOV     R7,#0x8
   \   000047   02....       LJMP    ?BANKED_LEAVE_XDATA
   2653          }
   2654          #endif // ZCL_WRITE
   2655          
   2656          #ifdef ZCL_READ
   2657          /*********************************************************************
   2658           * @fn      zclParseInReadCmd
   2659           *
   2660           * @brief   Parse the "Profile" Read Commands
   2661           *
   2662           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   2663           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   2664           *
   2665           * @param   pCmd - pointer to incoming data to parse
   2666           *
   2667           * @return  pointer to the parsed command structure
   2668           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2669          void *zclParseInReadCmd( zclParseCmd_t *pCmd )
   \                     zclParseInReadCmd:
   2670          {
   \   000000   74F2         MOV     A,#-0xe
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV     ?V0 + 2,R2
   \   000007   8B..         MOV     ?V0 + 3,R3
   2671            zclReadCmd_t *readCmd;
   2672            uint8 *pBuf = pCmd->pData;
   \   000009   85..82       MOV     DPL,?V0 + 2
   \   00000C   85..83       MOV     DPH,?V0 + 3
   \   00000F   A3           INC     DPTR
   \   000010   A3           INC     DPTR
   \   000011   A3           INC     DPTR
   \   000012   E0           MOVX    A,@DPTR
   \   000013   F8           MOV     R0,A
   \   000014   A3           INC     DPTR
   \   000015   E0           MOVX    A,@DPTR
   \   000016   F9           MOV     R1,A
   \   000017   88..         MOV     ?V0 + 0,R0
   \   000019   89..         MOV     ?V0 + 1,R1
   2673          
   2674            readCmd = (zclReadCmd_t *)osal_mem_alloc( sizeof ( zclReadCmd_t ) + pCmd->dataLen );
   \   00001B                ; Setup parameters for call to function osal_mem_alloc
   \   00001B   85..82       MOV     DPL,?V0 + 2
   \   00001E   85..83       MOV     DPH,?V0 + 3
   \   000021   A3           INC     DPTR
   \   000022   E0           MOVX    A,@DPTR
   \   000023   2401         ADD     A,#0x1
   \   000025   FA           MOV     R2,A
   \   000026   A3           INC     DPTR
   \   000027   E0           MOVX    A,@DPTR
   \   000028   3400         ADDC    A,#0x0
   \   00002A   FB           MOV     R3,A
   \   00002B   12....       LCALL   ??osal_mem_alloc?relay
   \   00002E   8A..         MOV     ?V0 + 4,R2
   \   000030   8B..         MOV     ?V0 + 5,R3
   \   000032   AE..         MOV     R6,?V0 + 4
   \   000034   AF..         MOV     R7,?V0 + 5
   2675            if ( readCmd != NULL )
   \   000036   EE           MOV     A,R6
   \   000037   4F           ORL     A,R7
   \   000038   6078         JZ      ??zclParseInReadCmd_0
   2676            {
   2677              readCmd->numAttr = pCmd->dataLen / 2; // Atrribute ID
   \   00003A   85..82       MOV     DPL,?V0 + 2
   \   00003D   85..83       MOV     DPH,?V0 + 3
   \   000040   A3           INC     DPTR
   \   000041   E0           MOVX    A,@DPTR
   \   000042   F8           MOV     R0,A
   \   000043   A3           INC     DPTR
   \   000044   E0           MOVX    A,@DPTR
   \   000045   F9           MOV     R1,A
   \   000046   C3           CLR     C
   \   000047   13           RRC     A
   \   000048   F9           MOV     R1,A
   \   000049   E8           MOV     A,R0
   \   00004A   13           RRC     A
   \   00004B   F8           MOV     R0,A
   \   00004C   8E82         MOV     DPL,R6
   \   00004E   8F83         MOV     DPH,R7
   \   000050   F0           MOVX    @DPTR,A
   2678              for ( uint8 i = 0; i < readCmd->numAttr; i++ )
   \   000051   7D00         MOV     R5,#0x0
   \                     ??zclParseInReadCmd_1:
   \   000053   8E82         MOV     DPL,R6
   \   000055   8F83         MOV     DPH,R7
   \   000057   E0           MOVX    A,@DPTR
   \   000058   F8           MOV     R0,A
   \   000059   ED           MOV     A,R5
   \   00005A   C3           CLR     C
   \   00005B   98           SUBB    A,R0
   \   00005C   5054         JNC     ??zclParseInReadCmd_0
   2679              {
   2680                readCmd->attrID[i] = BUILD_UINT16( pBuf[0], pBuf[1] );
   \   00005E   85..82       MOV     DPL,?V0 + 0
   \   000061   85..83       MOV     DPH,?V0 + 1
   \   000064   E0           MOVX    A,@DPTR
   \   000065   FA           MOV     R2,A
   \   000066   7B00         MOV     R3,#0x0
   \   000068   85..82       MOV     DPL,?V0 + 0
   \   00006B   85..83       MOV     DPH,?V0 + 1
   \   00006E   A3           INC     DPTR
   \   00006F   E0           MOVX    A,@DPTR
   \   000070   F8           MOV     R0,A
   \   000071   7900         MOV     R1,#0x0
   \   000073   E4           CLR     A
   \   000074   C8           XCH     A,R0
   \   000075   F9           MOV     R1,A
   \   000076   EA           MOV     A,R2
   \   000077   28           ADD     A,R0
   \   000078   FA           MOV     R2,A
   \   000079   EB           MOV     A,R3
   \   00007A   39           ADDC    A,R1
   \   00007B   FB           MOV     R3,A
   \   00007C   ED           MOV     A,R5
   \   00007D   F8           MOV     R0,A
   \   00007E   7900         MOV     R1,#0x0
   \   000080   E8           MOV     A,R0
   \   000081   75F002       MOV     B,#0x2
   \   000084   A4           MUL     AB
   \   000085   C8           XCH     A,R0
   \   000086   ACF0         MOV     R4,B
   \   000088   75F000       MOV     B,#0x0
   \   00008B   A4           MUL     AB
   \   00008C   2C           ADD     A,R4
   \   00008D   FC           MOV     R4,A
   \   00008E   75F002       MOV     B,#0x2
   \   000091   E9           MOV     A,R1
   \   000092   A4           MUL     AB
   \   000093   2C           ADD     A,R4
   \   000094   F9           MOV     R1,A
   \   000095   EE           MOV     A,R6
   \   000096   28           ADD     A,R0
   \   000097   F582         MOV     DPL,A
   \   000099   EF           MOV     A,R7
   \   00009A   39           ADDC    A,R1
   \   00009B   F583         MOV     DPH,A
   \   00009D   A3           INC     DPTR
   \   00009E   EA           MOV     A,R2
   \   00009F   F0           MOVX    @DPTR,A
   \   0000A0   A3           INC     DPTR
   \   0000A1   EB           MOV     A,R3
   \   0000A2   F0           MOVX    @DPTR,A
   2681                pBuf += 2;
   \   0000A3   E5..         MOV     A,?V0 + 0
   \   0000A5   2402         ADD     A,#0x2
   \   0000A7   F5..         MOV     ?V0 + 0,A
   \   0000A9   E5..         MOV     A,?V0 + 1
   \   0000AB   3400         ADDC    A,#0x0
   \   0000AD   F5..         MOV     ?V0 + 1,A
   2682              }
   \   0000AF   0D           INC     R5
   \   0000B0   80A1         SJMP    ??zclParseInReadCmd_1
   2683            }
   2684          
   2685            return ( (void *)readCmd );
   \                     ??zclParseInReadCmd_0:
   \   0000B2   EE           MOV     A,R6
   \   0000B3   FA           MOV     R2,A
   \   0000B4   EF           MOV     A,R7
   \   0000B5   FB           MOV     R3,A
   \   0000B6   7F06         MOV     R7,#0x6
   \   0000B8   02....       LJMP    ?BANKED_LEAVE_XDATA
   2686          }
   2687          
   2688          /*********************************************************************
   2689           * @fn      zclParseInReadRspCmd
   2690           *
   2691           * @brief   Parse the "Profile" Read Response Commands
   2692           *
   2693           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   2694           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   2695           *
   2696           * @param   pCmd - pointer to incoming data to parse
   2697           *
   2698           * @return  pointer to the parsed command structure
   2699           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2700          static void *zclParseInReadRspCmd( zclParseCmd_t *pCmd )
   \                     zclParseInReadRspCmd:
   2701          {
   \   000000   74E8         MOV     A,#-0x18
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 24
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V0 + 14,R2
   \   00000C   8B..         MOV     ?V0 + 15,R3
   2702            zclReadRspCmd_t *readRspCmd;
   2703            uint8 *pBuf = pCmd->pData;
   \   00000E   85..82       MOV     DPL,?V0 + 14
   \   000011   85..83       MOV     DPH,?V0 + 15
   \   000014   A3           INC     DPTR
   \   000015   A3           INC     DPTR
   \   000016   A3           INC     DPTR
   \   000017   E0           MOVX    A,@DPTR
   \   000018   FE           MOV     R6,A
   \   000019   A3           INC     DPTR
   \   00001A   E0           MOVX    A,@DPTR
   \   00001B   FF           MOV     R7,A
   2704            uint8 *dataPtr;
   2705            uint8 numAttr = 0;
   \   00001C   75..00       MOV     ?V0 + 7,#0x0
   2706            uint8 hdrLen;
   2707            uint16 dataLen = 0;
   \   00001F   85..82       MOV     DPL,?XSP + 0
   \   000022   85..83       MOV     DPH,?XSP + 1
   \   000025   7400         MOV     A,#0x0
   \   000027   F0           MOVX    @DPTR,A
   \   000028   A3           INC     DPTR
   \   000029   7400         MOV     A,#0x0
   \   00002B   F0           MOVX    @DPTR,A
   2708            uint16 attrDataLen;
   2709          
   2710            // find out the number of attributes and the length of attribute data
   2711            while ( pBuf < ( pCmd->pData + pCmd->dataLen ) )
   \                     ??zclParseInReadRspCmd_0:
   \   00002C   85..82       MOV     DPL,?V0 + 14
   \   00002F   85..83       MOV     DPH,?V0 + 15
   \   000032   A3           INC     DPTR
   \   000033   E0           MOVX    A,@DPTR
   \   000034   F8           MOV     R0,A
   \   000035   A3           INC     DPTR
   \   000036   E0           MOVX    A,@DPTR
   \   000037   F9           MOV     R1,A
   \   000038   85..82       MOV     DPL,?V0 + 14
   \   00003B   85..83       MOV     DPH,?V0 + 15
   \   00003E   A3           INC     DPTR
   \   00003F   A3           INC     DPTR
   \   000040   A3           INC     DPTR
   \   000041   E0           MOVX    A,@DPTR
   \   000042   28           ADD     A,R0
   \   000043   F8           MOV     R0,A
   \   000044   A3           INC     DPTR
   \   000045   E0           MOVX    A,@DPTR
   \   000046   39           ADDC    A,R1
   \   000047   F9           MOV     R1,A
   \   000048   C3           CLR     C
   \   000049   EE           MOV     A,R6
   \   00004A   98           SUBB    A,R0
   \   00004B   EF           MOV     A,R7
   \   00004C   99           SUBB    A,R1
   \   00004D   506D         JNC     ??zclParseInReadRspCmd_1
   2712            {
   2713              uint8 status;
   2714          
   2715              numAttr++;
   \   00004F   05..         INC     ?V0 + 7
   2716              pBuf += 2; // move pass attribute id
   \   000051   EE           MOV     A,R6
   \   000052   2402         ADD     A,#0x2
   \   000054   FE           MOV     R6,A
   \   000055   EF           MOV     A,R7
   \   000056   3400         ADDC    A,#0x0
   \   000058   FF           MOV     R7,A
   2717          
   2718              status = *pBuf++;
   \   000059   8E82         MOV     DPL,R6
   \   00005B   8F83         MOV     DPH,R7
   \   00005D   E0           MOVX    A,@DPTR
   \   00005E   F5..         MOV     ?V0 + 4,A
   \   000060   8E82         MOV     DPL,R6
   \   000062   8F83         MOV     DPH,R7
   \   000064   A3           INC     DPTR
   \   000065   AE82         MOV     R6,DPL
   \   000067   AF83         MOV     R7,DPH
   2719              if ( status == ZCL_STATUS_SUCCESS )
   \   000069   E5..         MOV     A,?V0 + 4
   \   00006B   70BF         JNZ     ??zclParseInReadRspCmd_0
   2720              {
   2721                uint8 dataType = *pBuf++;
   \   00006D   8E82         MOV     DPL,R6
   \   00006F   8F83         MOV     DPH,R7
   \   000071   E0           MOVX    A,@DPTR
   \   000072   F5..         MOV     ?V0 + 5,A
   \   000074   8E82         MOV     DPL,R6
   \   000076   8F83         MOV     DPH,R7
   \   000078   A3           INC     DPTR
   \   000079   AE82         MOV     R6,DPL
   \   00007B   AF83         MOV     R7,DPH
   2722          
   2723                attrDataLen = zclGetAttrDataLength( dataType, pBuf );
   \   00007D                ; Setup parameters for call to function zclGetAttrDataLength
   \   00007D   EE           MOV     A,R6
   \   00007E   FA           MOV     R2,A
   \   00007F   EF           MOV     A,R7
   \   000080   FB           MOV     R3,A
   \   000081   A9..         MOV     R1,?V0 + 5
   \   000083   12....       LCALL   ??zclGetAttrDataLength?relay
   \   000086   8A..         MOV     ?V0 + 0,R2
   \   000088   8B..         MOV     ?V0 + 1,R3
   \   00008A   85....       MOV     ?V0 + 2,?V0 + 0
   \   00008D   85....       MOV     ?V0 + 3,?V0 + 1
   2724                pBuf += attrDataLen; // move pass attribute data
   \   000090   EE           MOV     A,R6
   \   000091   25..         ADD     A,?V0 + 2
   \   000093   FE           MOV     R6,A
   \   000094   EF           MOV     A,R7
   \   000095   35..         ADDC    A,?V0 + 3
   \   000097   FF           MOV     R7,A
   2725          
   2726                // add padding if needed
   2727                if ( PADDING_NEEDED( attrDataLen ) )
   \   000098   E5..         MOV     A,?V0 + 2
   \   00009A   A2E0         MOV     C,0xE0 /* A   */.0
   \   00009C   500C         JNC     ??zclParseInReadRspCmd_2
   2728                {
   2729                  attrDataLen++;
   \   00009E   E5..         MOV     A,?V0 + 2
   \   0000A0   2401         ADD     A,#0x1
   \   0000A2   F5..         MOV     ?V0 + 2,A
   \   0000A4   E5..         MOV     A,?V0 + 3
   \   0000A6   3400         ADDC    A,#0x0
   \   0000A8   F5..         MOV     ?V0 + 3,A
   2730                }
   2731          
   2732                dataLen += attrDataLen;
   \                     ??zclParseInReadRspCmd_2:
   \   0000AA   85..82       MOV     DPL,?XSP + 0
   \   0000AD   85..83       MOV     DPH,?XSP + 1
   \   0000B0   E0           MOVX    A,@DPTR
   \   0000B1   25..         ADD     A,?V0 + 2
   \   0000B3   F0           MOVX    @DPTR,A
   \   0000B4   A3           INC     DPTR
   \   0000B5   E0           MOVX    A,@DPTR
   \   0000B6   35..         ADDC    A,?V0 + 3
   \   0000B8   F0           MOVX    @DPTR,A
   \   0000B9   02....       LJMP    ??zclParseInReadRspCmd_0 & 0xFFFF
   2733              }
   2734            }
   2735          
   2736            // calculate the length of the response header
   2737            hdrLen = sizeof( zclReadRspCmd_t ) + ( numAttr * sizeof( zclReadRspStatus_t ) );
   \                     ??zclParseInReadRspCmd_1:
   \   0000BC   75F006       MOV     B,#0x6
   \   0000BF   E5..         MOV     A,?V0 + 7
   \   0000C1   A4           MUL     AB
   \   0000C2   2401         ADD     A,#0x1
   \   0000C4   F5..         MOV     ?V0 + 9,A
   2738          
   2739            readRspCmd = (zclReadRspCmd_t *)osal_mem_alloc( hdrLen + dataLen );
   \   0000C6                ; Setup parameters for call to function osal_mem_alloc
   \   0000C6   85....       MOV     ?V0 + 0,?V0 + 9
   \   0000C9   75..00       MOV     ?V0 + 1,#0x0
   \   0000CC   85..82       MOV     DPL,?XSP + 0
   \   0000CF   85..83       MOV     DPH,?XSP + 1
   \   0000D2   E0           MOVX    A,@DPTR
   \   0000D3   25..         ADD     A,?V0 + 0
   \   0000D5   FA           MOV     R2,A
   \   0000D6   A3           INC     DPTR
   \   0000D7   E0           MOVX    A,@DPTR
   \   0000D8   35..         ADDC    A,?V0 + 1
   \   0000DA   FB           MOV     R3,A
   \   0000DB   12....       LCALL   ??osal_mem_alloc?relay
   \   0000DE   8A..         MOV     ?V0 + 0,R2
   \   0000E0   8B..         MOV     ?V0 + 1,R3
   \   0000E2   85....       MOV     ?V0 + 12,?V0 + 0
   \   0000E5   85....       MOV     ?V0 + 13,?V0 + 1
   2740            if ( readRspCmd != NULL )
   \   0000E8   E5..         MOV     A,?V0 + 12
   \   0000EA   45..         ORL     A,?V0 + 13
   \   0000EC   7003         JNZ     $+5
   \   0000EE   02....       LJMP    ??zclParseInReadRspCmd_3 & 0xFFFF
   2741            {
   2742              pBuf = pCmd->pData;
   \   0000F1   85..82       MOV     DPL,?V0 + 14
   \   0000F4   85..83       MOV     DPH,?V0 + 15
   \   0000F7   A3           INC     DPTR
   \   0000F8   A3           INC     DPTR
   \   0000F9   A3           INC     DPTR
   \   0000FA   E0           MOVX    A,@DPTR
   \   0000FB   F8           MOV     R0,A
   \   0000FC   A3           INC     DPTR
   \   0000FD   E0           MOVX    A,@DPTR
   \   0000FE   F9           MOV     R1,A
   \   0000FF   E8           MOV     A,R0
   \   000100   FE           MOV     R6,A
   \   000101   E9           MOV     A,R1
   \   000102   FF           MOV     R7,A
   2743              dataPtr = (uint8 *)( (uint8 *)readRspCmd + hdrLen );
   \   000103   85....       MOV     ?V0 + 0,?V0 + 9
   \   000106   75..00       MOV     ?V0 + 1,#0x0
   \   000109   E5..         MOV     A,?V0 + 12
   \   00010B   25..         ADD     A,?V0 + 0
   \   00010D   F8           MOV     R0,A
   \   00010E   E5..         MOV     A,?V0 + 13
   \   000110   35..         ADDC    A,?V0 + 1
   \   000112   F9           MOV     R1,A
   \   000113   88..         MOV     ?V0 + 10,R0
   \   000115   89..         MOV     ?V0 + 11,R1
   2744          
   2745              readRspCmd->numAttr = numAttr;
   \   000117   E5..         MOV     A,?V0 + 7
   \   000119   85..82       MOV     DPL,?V0 + 12
   \   00011C   85..83       MOV     DPH,?V0 + 13
   \   00011F   E5..         MOV     A,?V0 + 7
   \   000121   F0           MOVX    @DPTR,A
   2746              for ( uint8 i = 0; i < numAttr; i++ )
   \   000122   75..00       MOV     ?V0 + 8,#0x0
   \                     ??zclParseInReadRspCmd_4:
   \   000125   E5..         MOV     A,?V0 + 8
   \   000127   C3           CLR     C
   \   000128   95..         SUBB    A,?V0 + 7
   \   00012A   4003         JC      $+5
   \   00012C   02....       LJMP    ??zclParseInReadRspCmd_3 & 0xFFFF
   2747              {
   2748                zclReadRspStatus_t *statusRec = &(readRspCmd->attrList[i]);
   \   00012F   E5..         MOV     A,?V0 + 8
   \   000131   A8..         MOV     R0,?V0 + 8
   \   000133   7900         MOV     R1,#0x0
   \   000135   E8           MOV     A,R0
   \   000136   75F006       MOV     B,#0x6
   \   000139   A4           MUL     AB
   \   00013A   C8           XCH     A,R0
   \   00013B   AAF0         MOV     R2,B
   \   00013D   75F000       MOV     B,#0x0
   \   000140   A4           MUL     AB
   \   000141   2A           ADD     A,R2
   \   000142   FA           MOV     R2,A
   \   000143   75F006       MOV     B,#0x6
   \   000146   E9           MOV     A,R1
   \   000147   A4           MUL     AB
   \   000148   2A           ADD     A,R2
   \   000149   F9           MOV     R1,A
   \   00014A   E5..         MOV     A,?V0 + 12
   \   00014C   28           ADD     A,R0
   \   00014D   F582         MOV     DPL,A
   \   00014F   E5..         MOV     A,?V0 + 13
   \   000151   39           ADDC    A,R1
   \   000152   F583         MOV     DPH,A
   \   000154   A3           INC     DPTR
   \   000155   8582..       MOV     ?V0 + 0,DPL
   \   000158   8583..       MOV     ?V0 + 1,DPH
   2749          
   2750                statusRec->attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   \   00015B   8E82         MOV     DPL,R6
   \   00015D   8F83         MOV     DPH,R7
   \   00015F   E0           MOVX    A,@DPTR
   \   000160   FA           MOV     R2,A
   \   000161   7B00         MOV     R3,#0x0
   \   000163   8E82         MOV     DPL,R6
   \   000165   8F83         MOV     DPH,R7
   \   000167   A3           INC     DPTR
   \   000168   E0           MOVX    A,@DPTR
   \   000169   F8           MOV     R0,A
   \   00016A   7900         MOV     R1,#0x0
   \   00016C   E4           CLR     A
   \   00016D   C8           XCH     A,R0
   \   00016E   F9           MOV     R1,A
   \   00016F   EA           MOV     A,R2
   \   000170   28           ADD     A,R0
   \   000171   F8           MOV     R0,A
   \   000172   EB           MOV     A,R3
   \   000173   39           ADDC    A,R1
   \   000174   F9           MOV     R1,A
   \   000175   85..82       MOV     DPL,?V0 + 0
   \   000178   85..83       MOV     DPH,?V0 + 1
   \   00017B   E8           MOV     A,R0
   \   00017C   F0           MOVX    @DPTR,A
   \   00017D   A3           INC     DPTR
   \   00017E   E9           MOV     A,R1
   \   00017F   F0           MOVX    @DPTR,A
   2751                pBuf += 2;
   \   000180   EE           MOV     A,R6
   \   000181   2402         ADD     A,#0x2
   \   000183   FE           MOV     R6,A
   \   000184   EF           MOV     A,R7
   \   000185   3400         ADDC    A,#0x0
   \   000187   FF           MOV     R7,A
   2752          
   2753                statusRec->status = *pBuf++;
   \   000188   8E82         MOV     DPL,R6
   \   00018A   8F83         MOV     DPH,R7
   \   00018C   E0           MOVX    A,@DPTR
   \   00018D   85..82       MOV     DPL,?V0 + 0
   \   000190   85..83       MOV     DPH,?V0 + 1
   \   000193   A3           INC     DPTR
   \   000194   A3           INC     DPTR
   \   000195   F0           MOVX    @DPTR,A
   \   000196   8E82         MOV     DPL,R6
   \   000198   8F83         MOV     DPH,R7
   \   00019A   A3           INC     DPTR
   \   00019B   AE82         MOV     R6,DPL
   \   00019D   AF83         MOV     R7,DPH
   2754                if ( statusRec->status == ZCL_STATUS_SUCCESS )
   \   00019F   85..82       MOV     DPL,?V0 + 0
   \   0001A2   85..83       MOV     DPH,?V0 + 1
   \   0001A5   A3           INC     DPTR
   \   0001A6   A3           INC     DPTR
   \   0001A7   E0           MOVX    A,@DPTR
   \   0001A8   6003         JZ      $+5
   \   0001AA   02....       LJMP    ??zclParseInReadRspCmd_5 & 0xFFFF
   2755                {
   2756                  statusRec->dataType = *pBuf++;
   \   0001AD   8E82         MOV     DPL,R6
   \   0001AF   8F83         MOV     DPH,R7
   \   0001B1   E0           MOVX    A,@DPTR
   \   0001B2   85..82       MOV     DPL,?V0 + 0
   \   0001B5   85..83       MOV     DPH,?V0 + 1
   \   0001B8   A3           INC     DPTR
   \   0001B9   A3           INC     DPTR
   \   0001BA   A3           INC     DPTR
   \   0001BB   F0           MOVX    @DPTR,A
   \   0001BC   8E82         MOV     DPL,R6
   \   0001BE   8F83         MOV     DPH,R7
   \   0001C0   A3           INC     DPTR
   \   0001C1   AE82         MOV     R6,DPL
   \   0001C3   AF83         MOV     R7,DPH
   2757          
   2758                  attrDataLen = zclGetAttrDataLength( statusRec->dataType, pBuf );
   \   0001C5                ; Setup parameters for call to function zclGetAttrDataLength
   \   0001C5   EE           MOV     A,R6
   \   0001C6   FA           MOV     R2,A
   \   0001C7   EF           MOV     A,R7
   \   0001C8   FB           MOV     R3,A
   \   0001C9   85..82       MOV     DPL,?V0 + 0
   \   0001CC   85..83       MOV     DPH,?V0 + 1
   \   0001CF   A3           INC     DPTR
   \   0001D0   A3           INC     DPTR
   \   0001D1   A3           INC     DPTR
   \   0001D2   E0           MOVX    A,@DPTR
   \   0001D3   F9           MOV     R1,A
   \   0001D4   12....       LCALL   ??zclGetAttrDataLength?relay
   \   0001D7   8A..         MOV     ?V0 + 4,R2
   \   0001D9   8B..         MOV     ?V0 + 5,R3
   \   0001DB   85....       MOV     ?V0 + 2,?V0 + 4
   \   0001DE   85....       MOV     ?V0 + 3,?V0 + 5
   2759                  osal_memcpy( dataPtr, pBuf, attrDataLen);
   \   0001E1                ; Setup parameters for call to function osal_memcpy
   \   0001E1   8E..         MOV     ?V0 + 4,R6
   \   0001E3   8F..         MOV     ?V0 + 5,R7
   \   0001E5   75..00       MOV     ?V0 + 6,#0x0
   \   0001E8   78..         MOV     R0,#?V0 + 4
   \   0001EA   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   0001ED   AC..         MOV     R4,?V0 + 2
   \   0001EF   AD..         MOV     R5,?V0 + 3
   \   0001F1   AA..         MOV     R2,?V0 + 10
   \   0001F3   AB..         MOV     R3,?V0 + 11
   \   0001F5   12....       LCALL   ??osal_memcpy?relay
   \   0001F8   7403         MOV     A,#0x3
   \   0001FA   12....       LCALL   ?DEALLOC_XSTACK8
   2760                  statusRec->data = dataPtr;
   \   0001FD   85..82       MOV     DPL,?V0 + 0
   \   000200   85..83       MOV     DPH,?V0 + 1
   \   000203   A3           INC     DPTR
   \   000204   A3           INC     DPTR
   \   000205   A3           INC     DPTR
   \   000206   A3           INC     DPTR
   \   000207   E5..         MOV     A,?V0 + 10
   \   000209   F0           MOVX    @DPTR,A
   \   00020A   A3           INC     DPTR
   \   00020B   E5..         MOV     A,?V0 + 11
   \   00020D   F0           MOVX    @DPTR,A
   2761          
   2762                  pBuf += attrDataLen; // move pass attribute data
   \   00020E   EE           MOV     A,R6
   \   00020F   25..         ADD     A,?V0 + 2
   \   000211   FE           MOV     R6,A
   \   000212   EF           MOV     A,R7
   \   000213   35..         ADDC    A,?V0 + 3
   \   000215   FF           MOV     R7,A
   2763          
   2764                  // advance attribute data pointer
   2765                  if ( PADDING_NEEDED( attrDataLen ) )
   \   000216   E5..         MOV     A,?V0 + 2
   \   000218   A2E0         MOV     C,0xE0 /* A   */.0
   \   00021A   500C         JNC     ??zclParseInReadRspCmd_6
   2766                  {
   2767                    attrDataLen++;
   \   00021C   E5..         MOV     A,?V0 + 2
   \   00021E   2401         ADD     A,#0x1
   \   000220   F5..         MOV     ?V0 + 2,A
   \   000222   E5..         MOV     A,?V0 + 3
   \   000224   3400         ADDC    A,#0x0
   \   000226   F5..         MOV     ?V0 + 3,A
   2768                  }
   2769          
   2770                  dataPtr += attrDataLen;
   \                     ??zclParseInReadRspCmd_6:
   \   000228   E5..         MOV     A,?V0 + 10
   \   00022A   25..         ADD     A,?V0 + 2
   \   00022C   F5..         MOV     ?V0 + 10,A
   \   00022E   E5..         MOV     A,?V0 + 11
   \   000230   35..         ADDC    A,?V0 + 3
   \   000232   F5..         MOV     ?V0 + 11,A
   2771                }
   2772              }
   \                     ??zclParseInReadRspCmd_5:
   \   000234   05..         INC     ?V0 + 8
   \   000236   02....       LJMP    ??zclParseInReadRspCmd_4 & 0xFFFF
   2773            }
   2774          
   2775            return ( (void *)readRspCmd );
   \                     ??zclParseInReadRspCmd_3:
   \   000239   AA..         MOV     R2,?V0 + 12
   \   00023B   AB..         MOV     R3,?V0 + 13
   \   00023D   7402         MOV     A,#0x2
   \   00023F   12....       LCALL   ?DEALLOC_XSTACK8
   \   000242   7F10         MOV     R7,#0x10
   \   000244   02....       LJMP    ?BANKED_LEAVE_XDATA
   2776          }
   2777          #endif // ZCL_READ
   2778          
   2779          #ifdef ZCL_WRITE
   2780          /*********************************************************************
   2781           * @fn      zclParseInWriteCmd
   2782           *
   2783           * @brief   Parse the "Profile" Write, Write Undivided and Write No
   2784           *          Response Commands
   2785           *
   2786           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   2787           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   2788           *
   2789           * @param   pCmd - pointer to incoming data to parse
   2790           *
   2791           * @return  pointer to the parsed command structure
   2792           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2793          void *zclParseInWriteCmd( zclParseCmd_t *pCmd )
   \                     zclParseInWriteCmd:
   2794          {
   \   000000   74E8         MOV     A,#-0x18
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 24
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V0 + 14,R2
   \   00000C   8B..         MOV     ?V0 + 15,R3
   2795            zclWriteCmd_t *writeCmd;
   2796            uint8 *pBuf = pCmd->pData;
   \   00000E   85..82       MOV     DPL,?V0 + 14
   \   000011   85..83       MOV     DPH,?V0 + 15
   \   000014   A3           INC     DPTR
   \   000015   A3           INC     DPTR
   \   000016   A3           INC     DPTR
   \   000017   E0           MOVX    A,@DPTR
   \   000018   FE           MOV     R6,A
   \   000019   A3           INC     DPTR
   \   00001A   E0           MOVX    A,@DPTR
   \   00001B   FF           MOV     R7,A
   2797            uint16 attrDataLen;
   2798            uint8 *dataPtr;
   2799            uint8 numAttr = 0;
   \   00001C   75..00       MOV     ?V0 + 7,#0x0
   2800            uint8 hdrLen;
   2801            uint16 dataLen = 0;
   \   00001F   85..82       MOV     DPL,?XSP + 0
   \   000022   85..83       MOV     DPH,?XSP + 1
   \   000025   7400         MOV     A,#0x0
   \   000027   F0           MOVX    @DPTR,A
   \   000028   A3           INC     DPTR
   \   000029   7400         MOV     A,#0x0
   \   00002B   F0           MOVX    @DPTR,A
   2802          
   2803            // find out the number of attributes and the length of attribute data
   2804            while ( pBuf < ( pCmd->pData + pCmd->dataLen ) )
   \                     ??zclParseInWriteCmd_0:
   \   00002C   85..82       MOV     DPL,?V0 + 14
   \   00002F   85..83       MOV     DPH,?V0 + 15
   \   000032   A3           INC     DPTR
   \   000033   E0           MOVX    A,@DPTR
   \   000034   F8           MOV     R0,A
   \   000035   A3           INC     DPTR
   \   000036   E0           MOVX    A,@DPTR
   \   000037   F9           MOV     R1,A
   \   000038   85..82       MOV     DPL,?V0 + 14
   \   00003B   85..83       MOV     DPH,?V0 + 15
   \   00003E   A3           INC     DPTR
   \   00003F   A3           INC     DPTR
   \   000040   A3           INC     DPTR
   \   000041   E0           MOVX    A,@DPTR
   \   000042   28           ADD     A,R0
   \   000043   F8           MOV     R0,A
   \   000044   A3           INC     DPTR
   \   000045   E0           MOVX    A,@DPTR
   \   000046   39           ADDC    A,R1
   \   000047   F9           MOV     R1,A
   \   000048   C3           CLR     C
   \   000049   EE           MOV     A,R6
   \   00004A   98           SUBB    A,R0
   \   00004B   EF           MOV     A,R7
   \   00004C   99           SUBB    A,R1
   \   00004D   5058         JNC     ??zclParseInWriteCmd_1
   2805            {
   2806              uint8 dataType;
   2807          
   2808              numAttr++;
   \   00004F   05..         INC     ?V0 + 7
   2809              pBuf += 2; // move pass attribute id
   \   000051   EE           MOV     A,R6
   \   000052   2402         ADD     A,#0x2
   \   000054   FE           MOV     R6,A
   \   000055   EF           MOV     A,R7
   \   000056   3400         ADDC    A,#0x0
   \   000058   FF           MOV     R7,A
   2810          
   2811              dataType = *pBuf++;
   \   000059   8E82         MOV     DPL,R6
   \   00005B   8F83         MOV     DPH,R7
   \   00005D   E0           MOVX    A,@DPTR
   \   00005E   F5..         MOV     ?V0 + 6,A
   \   000060   8E82         MOV     DPL,R6
   \   000062   8F83         MOV     DPH,R7
   \   000064   A3           INC     DPTR
   \   000065   AE82         MOV     R6,DPL
   \   000067   AF83         MOV     R7,DPH
   2812          
   2813              attrDataLen = zclGetAttrDataLength( dataType, pBuf );
   \   000069                ; Setup parameters for call to function zclGetAttrDataLength
   \   000069   EE           MOV     A,R6
   \   00006A   FA           MOV     R2,A
   \   00006B   EF           MOV     A,R7
   \   00006C   FB           MOV     R3,A
   \   00006D   A9..         MOV     R1,?V0 + 6
   \   00006F   12....       LCALL   ??zclGetAttrDataLength?relay
   \   000072   8A..         MOV     ?V0 + 4,R2
   \   000074   8B..         MOV     ?V0 + 5,R3
   \   000076   85....       MOV     ?V0 + 0,?V0 + 4
   \   000079   85....       MOV     ?V0 + 1,?V0 + 5
   2814              pBuf += attrDataLen; // move pass attribute data
   \   00007C   EE           MOV     A,R6
   \   00007D   25..         ADD     A,?V0 + 0
   \   00007F   FE           MOV     R6,A
   \   000080   EF           MOV     A,R7
   \   000081   35..         ADDC    A,?V0 + 1
   \   000083   FF           MOV     R7,A
   2815          
   2816              // add padding if needed
   2817              if ( PADDING_NEEDED( attrDataLen ) )
   \   000084   E5..         MOV     A,?V0 + 0
   \   000086   A2E0         MOV     C,0xE0 /* A   */.0
   \   000088   500C         JNC     ??zclParseInWriteCmd_2
   2818              {
   2819                attrDataLen++;
   \   00008A   E5..         MOV     A,?V0 + 0
   \   00008C   2401         ADD     A,#0x1
   \   00008E   F5..         MOV     ?V0 + 0,A
   \   000090   E5..         MOV     A,?V0 + 1
   \   000092   3400         ADDC    A,#0x0
   \   000094   F5..         MOV     ?V0 + 1,A
   2820              }
   2821          
   2822              dataLen += attrDataLen;
   \                     ??zclParseInWriteCmd_2:
   \   000096   85..82       MOV     DPL,?XSP + 0
   \   000099   85..83       MOV     DPH,?XSP + 1
   \   00009C   E0           MOVX    A,@DPTR
   \   00009D   25..         ADD     A,?V0 + 0
   \   00009F   F0           MOVX    @DPTR,A
   \   0000A0   A3           INC     DPTR
   \   0000A1   E0           MOVX    A,@DPTR
   \   0000A2   35..         ADDC    A,?V0 + 1
   \   0000A4   F0           MOVX    @DPTR,A
   \   0000A5   8085         SJMP    ??zclParseInWriteCmd_0
   2823            }
   2824          
   2825            // calculate the length of the response header
   2826            hdrLen = sizeof( zclWriteCmd_t ) + ( numAttr * sizeof( zclWriteRec_t ) );
   \                     ??zclParseInWriteCmd_1:
   \   0000A7   75F005       MOV     B,#0x5
   \   0000AA   E5..         MOV     A,?V0 + 7
   \   0000AC   A4           MUL     AB
   \   0000AD   2401         ADD     A,#0x1
   \   0000AF   F5..         MOV     ?V0 + 9,A
   2827          
   2828            writeCmd = (zclWriteCmd_t *)osal_mem_alloc( hdrLen + dataLen );
   \   0000B1                ; Setup parameters for call to function osal_mem_alloc
   \   0000B1   85....       MOV     ?V0 + 4,?V0 + 9
   \   0000B4   75..00       MOV     ?V0 + 5,#0x0
   \   0000B7   85..82       MOV     DPL,?XSP + 0
   \   0000BA   85..83       MOV     DPH,?XSP + 1
   \   0000BD   E0           MOVX    A,@DPTR
   \   0000BE   25..         ADD     A,?V0 + 4
   \   0000C0   FA           MOV     R2,A
   \   0000C1   A3           INC     DPTR
   \   0000C2   E0           MOVX    A,@DPTR
   \   0000C3   35..         ADDC    A,?V0 + 5
   \   0000C5   FB           MOV     R3,A
   \   0000C6   12....       LCALL   ??osal_mem_alloc?relay
   \   0000C9   8A..         MOV     ?V0 + 4,R2
   \   0000CB   8B..         MOV     ?V0 + 5,R3
   \   0000CD   85....       MOV     ?V0 + 10,?V0 + 4
   \   0000D0   85....       MOV     ?V0 + 11,?V0 + 5
   2829            if ( writeCmd != NULL )
   \   0000D3   E5..         MOV     A,?V0 + 10
   \   0000D5   45..         ORL     A,?V0 + 11
   \   0000D7   7003         JNZ     $+5
   \   0000D9   02....       LJMP    ??zclParseInWriteCmd_3 & 0xFFFF
   2830            {
   2831              pBuf = pCmd->pData;
   \   0000DC   85..82       MOV     DPL,?V0 + 14
   \   0000DF   85..83       MOV     DPH,?V0 + 15
   \   0000E2   A3           INC     DPTR
   \   0000E3   A3           INC     DPTR
   \   0000E4   A3           INC     DPTR
   \   0000E5   E0           MOVX    A,@DPTR
   \   0000E6   F8           MOV     R0,A
   \   0000E7   A3           INC     DPTR
   \   0000E8   E0           MOVX    A,@DPTR
   \   0000E9   F9           MOV     R1,A
   \   0000EA   E8           MOV     A,R0
   \   0000EB   FE           MOV     R6,A
   \   0000EC   E9           MOV     A,R1
   \   0000ED   FF           MOV     R7,A
   2832              dataPtr = (uint8 *)( (uint8 *)writeCmd + hdrLen );
   \   0000EE   85....       MOV     ?V0 + 4,?V0 + 9
   \   0000F1   75..00       MOV     ?V0 + 5,#0x0
   \   0000F4   E5..         MOV     A,?V0 + 10
   \   0000F6   25..         ADD     A,?V0 + 4
   \   0000F8   F8           MOV     R0,A
   \   0000F9   E5..         MOV     A,?V0 + 11
   \   0000FB   35..         ADDC    A,?V0 + 5
   \   0000FD   F9           MOV     R1,A
   \   0000FE   88..         MOV     ?V0 + 2,R0
   \   000100   89..         MOV     ?V0 + 3,R1
   2833          
   2834              writeCmd->numAttr = numAttr;
   \   000102   E5..         MOV     A,?V0 + 7
   \   000104   85..82       MOV     DPL,?V0 + 10
   \   000107   85..83       MOV     DPH,?V0 + 11
   \   00010A   E5..         MOV     A,?V0 + 7
   \   00010C   F0           MOVX    @DPTR,A
   2835              for ( uint8 i = 0; i < numAttr; i++ )
   \   00010D   75..00       MOV     ?V0 + 8,#0x0
   \                     ??zclParseInWriteCmd_4:
   \   000110   E5..         MOV     A,?V0 + 8
   \   000112   C3           CLR     C
   \   000113   95..         SUBB    A,?V0 + 7
   \   000115   4003         JC      $+5
   \   000117   02....       LJMP    ??zclParseInWriteCmd_3 & 0xFFFF
   2836              {
   2837                zclWriteRec_t *statusRec = &(writeCmd->attrList[i]);
   \   00011A   E5..         MOV     A,?V0 + 8
   \   00011C   A8..         MOV     R0,?V0 + 8
   \   00011E   7900         MOV     R1,#0x0
   \   000120   E8           MOV     A,R0
   \   000121   75F005       MOV     B,#0x5
   \   000124   A4           MUL     AB
   \   000125   C8           XCH     A,R0
   \   000126   AAF0         MOV     R2,B
   \   000128   75F000       MOV     B,#0x0
   \   00012B   A4           MUL     AB
   \   00012C   2A           ADD     A,R2
   \   00012D   FA           MOV     R2,A
   \   00012E   75F005       MOV     B,#0x5
   \   000131   E9           MOV     A,R1
   \   000132   A4           MUL     AB
   \   000133   2A           ADD     A,R2
   \   000134   F9           MOV     R1,A
   \   000135   E5..         MOV     A,?V0 + 10
   \   000137   28           ADD     A,R0
   \   000138   F582         MOV     DPL,A
   \   00013A   E5..         MOV     A,?V0 + 11
   \   00013C   39           ADDC    A,R1
   \   00013D   F583         MOV     DPH,A
   \   00013F   A3           INC     DPTR
   \   000140   8582..       MOV     ?V0 + 12,DPL
   \   000143   8583..       MOV     ?V0 + 13,DPH
   2838          
   2839                statusRec->attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   \   000146   8E82         MOV     DPL,R6
   \   000148   8F83         MOV     DPH,R7
   \   00014A   E0           MOVX    A,@DPTR
   \   00014B   FA           MOV     R2,A
   \   00014C   7B00         MOV     R3,#0x0
   \   00014E   8E82         MOV     DPL,R6
   \   000150   8F83         MOV     DPH,R7
   \   000152   A3           INC     DPTR
   \   000153   E0           MOVX    A,@DPTR
   \   000154   F8           MOV     R0,A
   \   000155   7900         MOV     R1,#0x0
   \   000157   E4           CLR     A
   \   000158   C8           XCH     A,R0
   \   000159   F9           MOV     R1,A
   \   00015A   EA           MOV     A,R2
   \   00015B   28           ADD     A,R0
   \   00015C   F8           MOV     R0,A
   \   00015D   EB           MOV     A,R3
   \   00015E   39           ADDC    A,R1
   \   00015F   F9           MOV     R1,A
   \   000160   85..82       MOV     DPL,?V0 + 12
   \   000163   85..83       MOV     DPH,?V0 + 13
   \   000166   E8           MOV     A,R0
   \   000167   F0           MOVX    @DPTR,A
   \   000168   A3           INC     DPTR
   \   000169   E9           MOV     A,R1
   \   00016A   F0           MOVX    @DPTR,A
   2840                pBuf += 2;
   \   00016B   EE           MOV     A,R6
   \   00016C   2402         ADD     A,#0x2
   \   00016E   FE           MOV     R6,A
   \   00016F   EF           MOV     A,R7
   \   000170   3400         ADDC    A,#0x0
   \   000172   FF           MOV     R7,A
   2841                statusRec->dataType = *pBuf++;
   \   000173   8E82         MOV     DPL,R6
   \   000175   8F83         MOV     DPH,R7
   \   000177   E0           MOVX    A,@DPTR
   \   000178   85..82       MOV     DPL,?V0 + 12
   \   00017B   85..83       MOV     DPH,?V0 + 13
   \   00017E   A3           INC     DPTR
   \   00017F   A3           INC     DPTR
   \   000180   F0           MOVX    @DPTR,A
   \   000181   8E82         MOV     DPL,R6
   \   000183   8F83         MOV     DPH,R7
   \   000185   A3           INC     DPTR
   \   000186   AE82         MOV     R6,DPL
   \   000188   AF83         MOV     R7,DPH
   2842          
   2843                attrDataLen = zclGetAttrDataLength( statusRec->dataType, pBuf );
   \   00018A                ; Setup parameters for call to function zclGetAttrDataLength
   \   00018A   EE           MOV     A,R6
   \   00018B   FA           MOV     R2,A
   \   00018C   EF           MOV     A,R7
   \   00018D   FB           MOV     R3,A
   \   00018E   85..82       MOV     DPL,?V0 + 12
   \   000191   85..83       MOV     DPH,?V0 + 13
   \   000194   A3           INC     DPTR
   \   000195   A3           INC     DPTR
   \   000196   E0           MOVX    A,@DPTR
   \   000197   F9           MOV     R1,A
   \   000198   12....       LCALL   ??zclGetAttrDataLength?relay
   \   00019B   8A..         MOV     ?V0 + 4,R2
   \   00019D   8B..         MOV     ?V0 + 5,R3
   \   00019F   85....       MOV     ?V0 + 0,?V0 + 4
   \   0001A2   85....       MOV     ?V0 + 1,?V0 + 5
   2844                osal_memcpy( dataPtr, pBuf, attrDataLen);
   \   0001A5                ; Setup parameters for call to function osal_memcpy
   \   0001A5   8E..         MOV     ?V0 + 4,R6
   \   0001A7   8F..         MOV     ?V0 + 5,R7
   \   0001A9   75..00       MOV     ?V0 + 6,#0x0
   \   0001AC   78..         MOV     R0,#?V0 + 4
   \   0001AE   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   0001B1   AC..         MOV     R4,?V0 + 0
   \   0001B3   AD..         MOV     R5,?V0 + 1
   \   0001B5   AA..         MOV     R2,?V0 + 2
   \   0001B7   AB..         MOV     R3,?V0 + 3
   \   0001B9   12....       LCALL   ??osal_memcpy?relay
   \   0001BC   7403         MOV     A,#0x3
   \   0001BE   12....       LCALL   ?DEALLOC_XSTACK8
   2845                statusRec->attrData = dataPtr;
   \   0001C1   85..82       MOV     DPL,?V0 + 12
   \   0001C4   85..83       MOV     DPH,?V0 + 13
   \   0001C7   A3           INC     DPTR
   \   0001C8   A3           INC     DPTR
   \   0001C9   A3           INC     DPTR
   \   0001CA   E5..         MOV     A,?V0 + 2
   \   0001CC   F0           MOVX    @DPTR,A
   \   0001CD   A3           INC     DPTR
   \   0001CE   E5..         MOV     A,?V0 + 3
   \   0001D0   F0           MOVX    @DPTR,A
   2846          
   2847                pBuf += attrDataLen; // move pass attribute data
   \   0001D1   EE           MOV     A,R6
   \   0001D2   25..         ADD     A,?V0 + 0
   \   0001D4   FE           MOV     R6,A
   \   0001D5   EF           MOV     A,R7
   \   0001D6   35..         ADDC    A,?V0 + 1
   \   0001D8   FF           MOV     R7,A
   2848          
   2849                // advance attribute data pointer
   2850                if ( PADDING_NEEDED( attrDataLen ) )
   \   0001D9   E5..         MOV     A,?V0 + 0
   \   0001DB   A2E0         MOV     C,0xE0 /* A   */.0
   \   0001DD   500C         JNC     ??zclParseInWriteCmd_5
   2851                {
   2852                  attrDataLen++;
   \   0001DF   E5..         MOV     A,?V0 + 0
   \   0001E1   2401         ADD     A,#0x1
   \   0001E3   F5..         MOV     ?V0 + 0,A
   \   0001E5   E5..         MOV     A,?V0 + 1
   \   0001E7   3400         ADDC    A,#0x0
   \   0001E9   F5..         MOV     ?V0 + 1,A
   2853                }
   2854          
   2855                dataPtr += attrDataLen;
   \                     ??zclParseInWriteCmd_5:
   \   0001EB   E5..         MOV     A,?V0 + 2
   \   0001ED   25..         ADD     A,?V0 + 0
   \   0001EF   F5..         MOV     ?V0 + 2,A
   \   0001F1   E5..         MOV     A,?V0 + 3
   \   0001F3   35..         ADDC    A,?V0 + 1
   \   0001F5   F5..         MOV     ?V0 + 3,A
   2856              }
   \   0001F7   05..         INC     ?V0 + 8
   \   0001F9   02....       LJMP    ??zclParseInWriteCmd_4 & 0xFFFF
   2857            }
   2858          
   2859            return ( (void *)writeCmd );
   \                     ??zclParseInWriteCmd_3:
   \   0001FC   AA..         MOV     R2,?V0 + 10
   \   0001FE   AB..         MOV     R3,?V0 + 11
   \   000200   7402         MOV     A,#0x2
   \   000202   12....       LCALL   ?DEALLOC_XSTACK8
   \   000205   7F10         MOV     R7,#0x10
   \   000207   02....       LJMP    ?BANKED_LEAVE_XDATA
   2860          }
   2861          
   2862          /*********************************************************************
   2863           * @fn      zclParseInWriteRspCmd
   2864           *
   2865           * @brief   Parse the "Profile" Write Response Commands
   2866           *
   2867           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   2868           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   2869           *
   2870           * @param   pCmd - pointer to incoming data to parse
   2871           *
   2872           * @return  pointer to the parsed command structure
   2873           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2874          static void *zclParseInWriteRspCmd( zclParseCmd_t *pCmd )
   \                     zclParseInWriteRspCmd:
   2875          {
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV     ?V0 + 2,R2
   \   000007   8B..         MOV     ?V0 + 3,R3
   2876            zclWriteRspCmd_t *writeRspCmd;
   2877            uint8 *pBuf = pCmd->pData;
   \   000009   85..82       MOV     DPL,?V0 + 2
   \   00000C   85..83       MOV     DPH,?V0 + 3
   \   00000F   A3           INC     DPTR
   \   000010   A3           INC     DPTR
   \   000011   A3           INC     DPTR
   \   000012   E0           MOVX    A,@DPTR
   \   000013   F5..         MOV     ?V0 + 0,A
   \   000015   A3           INC     DPTR
   \   000016   E0           MOVX    A,@DPTR
   \   000017   F5..         MOV     ?V0 + 1,A
   2878            uint8 i = 0;
   \   000019   75..00       MOV     ?V0 + 4,#0x0
   2879          
   2880            writeRspCmd = (zclWriteRspCmd_t *)osal_mem_alloc( sizeof ( zclWriteRspCmd_t ) + pCmd->dataLen );
   \   00001C                ; Setup parameters for call to function osal_mem_alloc
   \   00001C   85..82       MOV     DPL,?V0 + 2
   \   00001F   85..83       MOV     DPH,?V0 + 3
   \   000022   A3           INC     DPTR
   \   000023   E0           MOVX    A,@DPTR
   \   000024   2401         ADD     A,#0x1
   \   000026   FA           MOV     R2,A
   \   000027   A3           INC     DPTR
   \   000028   E0           MOVX    A,@DPTR
   \   000029   3400         ADDC    A,#0x0
   \   00002B   FB           MOV     R3,A
   \   00002C   12....       LCALL   ??osal_mem_alloc?relay
   \   00002F   8A..         MOV     ?V0 + 6,R2
   \   000031   8B..         MOV     ?V0 + 7,R3
   \   000033   AE..         MOV     R6,?V0 + 6
   \   000035   AF..         MOV     R7,?V0 + 7
   2881            if ( writeRspCmd != NULL )
   \   000037   EE           MOV     A,R6
   \   000038   4F           ORL     A,R7
   \   000039   7003         JNZ     $+5
   \   00003B   02....       LJMP    ??zclParseInWriteRspCmd_0 & 0xFFFF
   2882            {
   2883              if ( pCmd->dataLen == 1 )
   \   00003E   85..82       MOV     DPL,?V0 + 2
   \   000041   85..83       MOV     DPH,?V0 + 3
   \   000044   A3           INC     DPTR
   \   000045   E0           MOVX    A,@DPTR
   \   000046   6401         XRL     A,#0x1
   \   000048   7004         JNZ     ??zclParseInWriteRspCmd_1
   \   00004A   A3           INC     DPTR
   \   00004B   E0           MOVX    A,@DPTR
   \   00004C   6400         XRL     A,#0x0
   \                     ??zclParseInWriteRspCmd_1:
   \   00004E   7035         JNZ     ??zclParseInWriteRspCmd_2
   2884              {
   2885                // special case when all writes were successfull
   2886                writeRspCmd->attrList[i++].status = *pBuf;
   \   000050   85..82       MOV     DPL,?V0 + 0
   \   000053   85..83       MOV     DPH,?V0 + 1
   \   000056   E0           MOVX    A,@DPTR
   \   000057   C0E0         PUSH    A
   \   000059   E5..         MOV     A,?V0 + 4
   \   00005B   A8..         MOV     R0,?V0 + 4
   \   00005D   7900         MOV     R1,#0x0
   \   00005F   E8           MOV     A,R0
   \   000060   75F003       MOV     B,#0x3
   \   000063   A4           MUL     AB
   \   000064   C8           XCH     A,R0
   \   000065   AAF0         MOV     R2,B
   \   000067   75F000       MOV     B,#0x0
   \   00006A   A4           MUL     AB
   \   00006B   2A           ADD     A,R2
   \   00006C   FA           MOV     R2,A
   \   00006D   75F003       MOV     B,#0x3
   \   000070   E9           MOV     A,R1
   \   000071   A4           MUL     AB
   \   000072   2A           ADD     A,R2
   \   000073   F9           MOV     R1,A
   \   000074   EE           MOV     A,R6
   \   000075   28           ADD     A,R0
   \   000076   F582         MOV     DPL,A
   \   000078   EF           MOV     A,R7
   \   000079   39           ADDC    A,R1
   \   00007A   F583         MOV     DPH,A
   \   00007C   A3           INC     DPTR
   \   00007D   D0E0         POP     A
   \   00007F   F0           MOVX    @DPTR,A
   \   000080   05..         INC     ?V0 + 4
   \   000082   02....       LJMP    ??zclParseInWriteRspCmd_3 & 0xFFFF
   2887              }
   2888              else
   2889              {
   2890                while ( pBuf < ( pCmd->pData + pCmd->dataLen ) )
   \                     ??zclParseInWriteRspCmd_2:
   \   000085   85..82       MOV     DPL,?V0 + 2
   \   000088   85..83       MOV     DPH,?V0 + 3
   \   00008B   A3           INC     DPTR
   \   00008C   E0           MOVX    A,@DPTR
   \   00008D   F8           MOV     R0,A
   \   00008E   A3           INC     DPTR
   \   00008F   E0           MOVX    A,@DPTR
   \   000090   F9           MOV     R1,A
   \   000091   85..82       MOV     DPL,?V0 + 2
   \   000094   85..83       MOV     DPH,?V0 + 3
   \   000097   A3           INC     DPTR
   \   000098   A3           INC     DPTR
   \   000099   A3           INC     DPTR
   \   00009A   E0           MOVX    A,@DPTR
   \   00009B   28           ADD     A,R0
   \   00009C   F8           MOV     R0,A
   \   00009D   A3           INC     DPTR
   \   00009E   E0           MOVX    A,@DPTR
   \   00009F   39           ADDC    A,R1
   \   0000A0   F9           MOV     R1,A
   \   0000A1   C3           CLR     C
   \   0000A2   E5..         MOV     A,?V0 + 0
   \   0000A4   98           SUBB    A,R0
   \   0000A5   E5..         MOV     A,?V0 + 1
   \   0000A7   99           SUBB    A,R1
   \   0000A8   4003         JC      $+5
   \   0000AA   02....       LJMP    ??zclParseInWriteRspCmd_3 & 0xFFFF
   2891                {
   2892                  writeRspCmd->attrList[i].status = *pBuf++;
   \   0000AD   85..82       MOV     DPL,?V0 + 0
   \   0000B0   85..83       MOV     DPH,?V0 + 1
   \   0000B3   E0           MOVX    A,@DPTR
   \   0000B4   C0E0         PUSH    A
   \   0000B6   E5..         MOV     A,?V0 + 4
   \   0000B8   A8..         MOV     R0,?V0 + 4
   \   0000BA   7900         MOV     R1,#0x0
   \   0000BC   E8           MOV     A,R0
   \   0000BD   75F003       MOV     B,#0x3
   \   0000C0   A4           MUL     AB
   \   0000C1   C8           XCH     A,R0
   \   0000C2   AAF0         MOV     R2,B
   \   0000C4   75F000       MOV     B,#0x0
   \   0000C7   A4           MUL     AB
   \   0000C8   2A           ADD     A,R2
   \   0000C9   FA           MOV     R2,A
   \   0000CA   75F003       MOV     B,#0x3
   \   0000CD   E9           MOV     A,R1
   \   0000CE   A4           MUL     AB
   \   0000CF   2A           ADD     A,R2
   \   0000D0   F9           MOV     R1,A
   \   0000D1   EE           MOV     A,R6
   \   0000D2   28           ADD     A,R0
   \   0000D3   F582         MOV     DPL,A
   \   0000D5   EF           MOV     A,R7
   \   0000D6   39           ADDC    A,R1
   \   0000D7   F583         MOV     DPH,A
   \   0000D9   A3           INC     DPTR
   \   0000DA   D0E0         POP     A
   \   0000DC   F0           MOVX    @DPTR,A
   \   0000DD   85..82       MOV     DPL,?V0 + 0
   \   0000E0   85..83       MOV     DPH,?V0 + 1
   \   0000E3   A3           INC     DPTR
   \   0000E4   8582..       MOV     ?V0 + 0,DPL
   \   0000E7   8583..       MOV     ?V0 + 1,DPH
   2893                  writeRspCmd->attrList[i++].attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   \   0000EA   85..82       MOV     DPL,?V0 + 0
   \   0000ED   85..83       MOV     DPH,?V0 + 1
   \   0000F0   E0           MOVX    A,@DPTR
   \   0000F1   FA           MOV     R2,A
   \   0000F2   7B00         MOV     R3,#0x0
   \   0000F4   85..82       MOV     DPL,?V0 + 0
   \   0000F7   85..83       MOV     DPH,?V0 + 1
   \   0000FA   A3           INC     DPTR
   \   0000FB   E0           MOVX    A,@DPTR
   \   0000FC   F8           MOV     R0,A
   \   0000FD   7900         MOV     R1,#0x0
   \   0000FF   E4           CLR     A
   \   000100   C8           XCH     A,R0
   \   000101   F9           MOV     R1,A
   \   000102   EA           MOV     A,R2
   \   000103   28           ADD     A,R0
   \   000104   FA           MOV     R2,A
   \   000105   EB           MOV     A,R3
   \   000106   39           ADDC    A,R1
   \   000107   FB           MOV     R3,A
   \   000108   E5..         MOV     A,?V0 + 4
   \   00010A   A8..         MOV     R0,?V0 + 4
   \   00010C   7900         MOV     R1,#0x0
   \   00010E   E8           MOV     A,R0
   \   00010F   75F003       MOV     B,#0x3
   \   000112   A4           MUL     AB
   \   000113   C8           XCH     A,R0
   \   000114   ACF0         MOV     R4,B
   \   000116   75F000       MOV     B,#0x0
   \   000119   A4           MUL     AB
   \   00011A   2C           ADD     A,R4
   \   00011B   FC           MOV     R4,A
   \   00011C   75F003       MOV     B,#0x3
   \   00011F   E9           MOV     A,R1
   \   000120   A4           MUL     AB
   \   000121   2C           ADD     A,R4
   \   000122   F9           MOV     R1,A
   \   000123   EE           MOV     A,R6
   \   000124   28           ADD     A,R0
   \   000125   F582         MOV     DPL,A
   \   000127   EF           MOV     A,R7
   \   000128   39           ADDC    A,R1
   \   000129   F583         MOV     DPH,A
   \   00012B   A3           INC     DPTR
   \   00012C   A3           INC     DPTR
   \   00012D   EA           MOV     A,R2
   \   00012E   F0           MOVX    @DPTR,A
   \   00012F   A3           INC     DPTR
   \   000130   EB           MOV     A,R3
   \   000131   F0           MOVX    @DPTR,A
   \   000132   05..         INC     ?V0 + 4
   2894                  pBuf += 2;
   \   000134   E5..         MOV     A,?V0 + 0
   \   000136   2402         ADD     A,#0x2
   \   000138   F5..         MOV     ?V0 + 0,A
   \   00013A   E5..         MOV     A,?V0 + 1
   \   00013C   3400         ADDC    A,#0x0
   \   00013E   F5..         MOV     ?V0 + 1,A
   \   000140   02....       LJMP    ??zclParseInWriteRspCmd_2 & 0xFFFF
   2895                }
   2896              }
   2897          
   2898              writeRspCmd->numAttr = i;
   \                     ??zclParseInWriteRspCmd_3:
   \   000143   E5..         MOV     A,?V0 + 4
   \   000145   8E82         MOV     DPL,R6
   \   000147   8F83         MOV     DPH,R7
   \   000149   E5..         MOV     A,?V0 + 4
   \   00014B   F0           MOVX    @DPTR,A
   2899            }
   2900          
   2901            return ( (void *)writeRspCmd );
   \                     ??zclParseInWriteRspCmd_0:
   \   00014C   EE           MOV     A,R6
   \   00014D   FA           MOV     R2,A
   \   00014E   EF           MOV     A,R7
   \   00014F   FB           MOV     R3,A
   \   000150   7F08         MOV     R7,#0x8
   \   000152   02....       LJMP    ?BANKED_LEAVE_XDATA
   2902          }
   2903          #endif // ZCL_WRITE
   2904          
   2905          #ifdef ZCL_REPORT
   2906          /*********************************************************************
   2907           * @fn      zclParseInConfigReportCmd
   2908           *
   2909           * @brief   Parse the "Profile" Configure Reporting Command
   2910           *
   2911           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   2912           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   2913           *
   2914           * @param   pCmd - pointer to incoming data to parse
   2915           *
   2916           * @return  pointer to the parsed command structure
   2917           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2918          void *zclParseInConfigReportCmd( zclParseCmd_t *pCmd )
   \                     zclParseInConfigReportCmd:
   2919          {
   \   000000   74E9         MOV     A,#-0x17
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 23
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V0 + 12,R2
   \   00000C   8B..         MOV     ?V0 + 13,R3
   2920            zclCfgReportCmd_t *cfgReportCmd;
   2921            uint8 *pBuf = pCmd->pData;
   \   00000E   85..82       MOV     DPL,?V0 + 12
   \   000011   85..83       MOV     DPH,?V0 + 13
   \   000014   A3           INC     DPTR
   \   000015   A3           INC     DPTR
   \   000016   A3           INC     DPTR
   \   000017   E0           MOVX    A,@DPTR
   \   000018   FE           MOV     R6,A
   \   000019   A3           INC     DPTR
   \   00001A   E0           MOVX    A,@DPTR
   \   00001B   FF           MOV     R7,A
   2922            uint8 *dataPtr;
   2923            uint8 numAttr = 0;
   \   00001C   75..00       MOV     ?V0 + 1,#0x0
   2924            uint8 dataType;
   2925            uint8 hdrLen;
   2926            uint16 dataLen = 0;
   \   00001F   85..82       MOV     DPL,?XSP + 0
   \   000022   85..83       MOV     DPH,?XSP + 1
   \   000025   7400         MOV     A,#0x0
   \   000027   F0           MOVX    @DPTR,A
   \   000028   A3           INC     DPTR
   \   000029   7400         MOV     A,#0x0
   \   00002B   F0           MOVX    @DPTR,A
   2927            uint8 reportChangeLen; // length of Reportable Change field
   2928          
   2929            // Calculate the length of the Request command
   2930            while ( pBuf < ( pCmd->pData + pCmd->dataLen ) )
   \                     ??zclParseInConfigReportCmd_0:
   \   00002C   85..82       MOV     DPL,?V0 + 12
   \   00002F   85..83       MOV     DPH,?V0 + 13
   \   000032   A3           INC     DPTR
   \   000033   E0           MOVX    A,@DPTR
   \   000034   F8           MOV     R0,A
   \   000035   A3           INC     DPTR
   \   000036   E0           MOVX    A,@DPTR
   \   000037   F9           MOV     R1,A
   \   000038   85..82       MOV     DPL,?V0 + 12
   \   00003B   85..83       MOV     DPH,?V0 + 13
   \   00003E   A3           INC     DPTR
   \   00003F   A3           INC     DPTR
   \   000040   A3           INC     DPTR
   \   000041   E0           MOVX    A,@DPTR
   \   000042   28           ADD     A,R0
   \   000043   F8           MOV     R0,A
   \   000044   A3           INC     DPTR
   \   000045   E0           MOVX    A,@DPTR
   \   000046   39           ADDC    A,R1
   \   000047   F9           MOV     R1,A
   \   000048   C3           CLR     C
   \   000049   EE           MOV     A,R6
   \   00004A   98           SUBB    A,R0
   \   00004B   EF           MOV     A,R7
   \   00004C   99           SUBB    A,R1
   \   00004D   4003         JC      $+5
   \   00004F   02....       LJMP    ??zclParseInConfigReportCmd_1 & 0xFFFF
   2931            {
   2932              uint8 direction;
   2933          
   2934              numAttr++;
   \   000052   05..         INC     ?V0 + 1
   2935              direction = *pBuf++;
   \   000054   8E82         MOV     DPL,R6
   \   000056   8F83         MOV     DPH,R7
   \   000058   E0           MOVX    A,@DPTR
   \   000059   F5..         MOV     ?V0 + 4,A
   \   00005B   8E82         MOV     DPL,R6
   \   00005D   8F83         MOV     DPH,R7
   \   00005F   A3           INC     DPTR
   \   000060   AE82         MOV     R6,DPL
   \   000062   AF83         MOV     R7,DPH
   2936              pBuf += 2; // move pass the attribute ID
   \   000064   E582         MOV     A,DPL
   \   000066   2402         ADD     A,#0x2
   \   000068   FE           MOV     R6,A
   \   000069   E583         MOV     A,DPH
   \   00006B   3400         ADDC    A,#0x0
   \   00006D   FF           MOV     R7,A
   2937          
   2938              // Is there a Reportable Change field?
   2939              if ( direction == ZCL_SEND_ATTR_REPORTS )
   \   00006E   E5..         MOV     A,?V0 + 4
   \   000070   705C         JNZ     ??zclParseInConfigReportCmd_2
   2940              {
   2941                dataType = *pBuf++;
   \   000072   8E82         MOV     DPL,R6
   \   000074   8F83         MOV     DPH,R7
   \   000076   E0           MOVX    A,@DPTR
   \   000077   F5..         MOV     ?V0 + 14,A
   \   000079   8E82         MOV     DPL,R6
   \   00007B   8F83         MOV     DPH,R7
   \   00007D   A3           INC     DPTR
   \   00007E   AE82         MOV     R6,DPL
   \   000080   AF83         MOV     R7,DPH
   2942                pBuf += 4; // move pass the Min and Max Reporting Intervals
   \   000082   E582         MOV     A,DPL
   \   000084   2404         ADD     A,#0x4
   \   000086   FE           MOV     R6,A
   \   000087   E583         MOV     A,DPH
   \   000089   3400         ADDC    A,#0x0
   \   00008B   FF           MOV     R7,A
   2943          
   2944                // For attributes of 'discrete' data types this field is omitted
   2945                if ( zclAnalogDataType( dataType ) )
   \   00008C                ; Setup parameters for call to function zclAnalogDataType
   \   00008C   A9..         MOV     R1,?V0 + 14
   \   00008E   12....       LCALL   ??zclAnalogDataType?relay
   \   000091   E9           MOV     A,R1
   \   000092   6098         JZ      ??zclParseInConfigReportCmd_0
   2946                {
   2947                  reportChangeLen = zclGetDataTypeLength( dataType );
   \   000094                ; Setup parameters for call to function zclGetDataTypeLength
   \   000094   A9..         MOV     R1,?V0 + 14
   \   000096   12....       LCALL   ??zclGetDataTypeLength?relay
   \   000099   E9           MOV     A,R1
   \   00009A   F5..         MOV     ?V0 + 0,A
   2948                  pBuf += reportChangeLen;
   \   00009C   85....       MOV     ?V0 + 2,?V0 + 0
   \   00009F   75..00       MOV     ?V0 + 3,#0x0
   \   0000A2   EE           MOV     A,R6
   \   0000A3   25..         ADD     A,?V0 + 2
   \   0000A5   FE           MOV     R6,A
   \   0000A6   EF           MOV     A,R7
   \   0000A7   35..         ADDC    A,?V0 + 3
   \   0000A9   FF           MOV     R7,A
   2949          
   2950                  // add padding if needed
   2951                  if ( PADDING_NEEDED( reportChangeLen ) )
   \   0000AA   E5..         MOV     A,?V0 + 0
   \   0000AC   75F002       MOV     B,#0x2
   \   0000AF   84           DIV     AB
   \   0000B0   E5F0         MOV     A,B
   \   0000B2   6002         JZ      ??zclParseInConfigReportCmd_3
   2952                  {
   2953                    reportChangeLen++;
   \   0000B4   05..         INC     ?V0 + 0
   2954                  }
   2955          
   2956                  dataLen += reportChangeLen;
   \                     ??zclParseInConfigReportCmd_3:
   \   0000B6   85....       MOV     ?V0 + 2,?V0 + 0
   \   0000B9   75..00       MOV     ?V0 + 3,#0x0
   \   0000BC   85..82       MOV     DPL,?XSP + 0
   \   0000BF   85..83       MOV     DPH,?XSP + 1
   \   0000C2   E0           MOVX    A,@DPTR
   \   0000C3   25..         ADD     A,?V0 + 2
   \   0000C5   F0           MOVX    @DPTR,A
   \   0000C6   A3           INC     DPTR
   \   0000C7   E0           MOVX    A,@DPTR
   \   0000C8   35..         ADDC    A,?V0 + 3
   \   0000CA   F0           MOVX    @DPTR,A
   \   0000CB   02....       LJMP    ??zclParseInConfigReportCmd_0 & 0xFFFF
   2957                }
   2958              }
   2959              else
   2960              {
   2961                pBuf += 2; // move pass the Timeout Period
   \                     ??zclParseInConfigReportCmd_2:
   \   0000CE   EE           MOV     A,R6
   \   0000CF   2402         ADD     A,#0x2
   \   0000D1   FE           MOV     R6,A
   \   0000D2   EF           MOV     A,R7
   \   0000D3   3400         ADDC    A,#0x0
   \   0000D5   FF           MOV     R7,A
   \   0000D6   02....       LJMP    ??zclParseInConfigReportCmd_0 & 0xFFFF
   2962              }
   2963            } // while loop
   2964          
   2965            hdrLen = sizeof( zclCfgReportCmd_t ) + ( numAttr * sizeof( zclCfgReportRec_t ) );
   \                     ??zclParseInConfigReportCmd_1:
   \   0000D9   75F00C       MOV     B,#0xc
   \   0000DC   E5..         MOV     A,?V0 + 1
   \   0000DE   A4           MUL     AB
   \   0000DF   2401         ADD     A,#0x1
   \   0000E1   F5..         MOV     ?V0 + 5,A
   2966          
   2967            cfgReportCmd = (zclCfgReportCmd_t *)osal_mem_alloc( hdrLen + dataLen );
   \   0000E3                ; Setup parameters for call to function osal_mem_alloc
   \   0000E3   85....       MOV     ?V0 + 2,?V0 + 5
   \   0000E6   75..00       MOV     ?V0 + 3,#0x0
   \   0000E9   85..82       MOV     DPL,?XSP + 0
   \   0000EC   85..83       MOV     DPH,?XSP + 1
   \   0000EF   E0           MOVX    A,@DPTR
   \   0000F0   25..         ADD     A,?V0 + 2
   \   0000F2   FA           MOV     R2,A
   \   0000F3   A3           INC     DPTR
   \   0000F4   E0           MOVX    A,@DPTR
   \   0000F5   35..         ADDC    A,?V0 + 3
   \   0000F7   FB           MOV     R3,A
   \   0000F8   12....       LCALL   ??osal_mem_alloc?relay
   \   0000FB   8A..         MOV     ?V0 + 2,R2
   \   0000FD   8B..         MOV     ?V0 + 3,R3
   \   0000FF   85....       MOV     ?V0 + 8,?V0 + 2
   \   000102   85....       MOV     ?V0 + 9,?V0 + 3
   2968            if ( cfgReportCmd != NULL )
   \   000105   E5..         MOV     A,?V0 + 8
   \   000107   45..         ORL     A,?V0 + 9
   \   000109   7003         JNZ     $+5
   \   00010B   02....       LJMP    ??zclParseInConfigReportCmd_4 & 0xFFFF
   2969            {
   2970              pBuf = pCmd->pData;
   \   00010E   85..82       MOV     DPL,?V0 + 12
   \   000111   85..83       MOV     DPH,?V0 + 13
   \   000114   A3           INC     DPTR
   \   000115   A3           INC     DPTR
   \   000116   A3           INC     DPTR
   \   000117   E0           MOVX    A,@DPTR
   \   000118   F8           MOV     R0,A
   \   000119   A3           INC     DPTR
   \   00011A   E0           MOVX    A,@DPTR
   \   00011B   F9           MOV     R1,A
   \   00011C   E8           MOV     A,R0
   \   00011D   FE           MOV     R6,A
   \   00011E   E9           MOV     A,R1
   \   00011F   FF           MOV     R7,A
   2971              dataPtr = (uint8 *)( (uint8 *)cfgReportCmd + hdrLen );
   \   000120   85....       MOV     ?V0 + 2,?V0 + 5
   \   000123   75..00       MOV     ?V0 + 3,#0x0
   \   000126   E5..         MOV     A,?V0 + 8
   \   000128   25..         ADD     A,?V0 + 2
   \   00012A   F8           MOV     R0,A
   \   00012B   E5..         MOV     A,?V0 + 9
   \   00012D   35..         ADDC    A,?V0 + 3
   \   00012F   F9           MOV     R1,A
   \   000130   88..         MOV     ?V0 + 6,R0
   \   000132   89..         MOV     ?V0 + 7,R1
   2972          
   2973              cfgReportCmd->numAttr = numAttr;
   \   000134   E5..         MOV     A,?V0 + 1
   \   000136   85..82       MOV     DPL,?V0 + 8
   \   000139   85..83       MOV     DPH,?V0 + 9
   \   00013C   E5..         MOV     A,?V0 + 1
   \   00013E   F0           MOVX    @DPTR,A
   2974              for ( uint8 i = 0; i < numAttr; i++ )
   \   00013F   75..00       MOV     ?V0 + 4,#0x0
   \                     ??zclParseInConfigReportCmd_5:
   \   000142   E5..         MOV     A,?V0 + 4
   \   000144   C3           CLR     C
   \   000145   95..         SUBB    A,?V0 + 1
   \   000147   4003         JC      $+5
   \   000149   02....       LJMP    ??zclParseInConfigReportCmd_4 & 0xFFFF
   2975              {
   2976                zclCfgReportRec_t *reportRec = &(cfgReportCmd->attrList[i]);
   \   00014C   E5..         MOV     A,?V0 + 4
   \   00014E   A8..         MOV     R0,?V0 + 4
   \   000150   7900         MOV     R1,#0x0
   \   000152   E8           MOV     A,R0
   \   000153   75F00C       MOV     B,#0xc
   \   000156   A4           MUL     AB
   \   000157   C8           XCH     A,R0
   \   000158   AAF0         MOV     R2,B
   \   00015A   75F000       MOV     B,#0x0
   \   00015D   A4           MUL     AB
   \   00015E   2A           ADD     A,R2
   \   00015F   FA           MOV     R2,A
   \   000160   75F00C       MOV     B,#0xc
   \   000163   E9           MOV     A,R1
   \   000164   A4           MUL     AB
   \   000165   2A           ADD     A,R2
   \   000166   F9           MOV     R1,A
   \   000167   E5..         MOV     A,?V0 + 8
   \   000169   28           ADD     A,R0
   \   00016A   F582         MOV     DPL,A
   \   00016C   E5..         MOV     A,?V0 + 9
   \   00016E   39           ADDC    A,R1
   \   00016F   F583         MOV     DPH,A
   \   000171   A3           INC     DPTR
   \   000172   8582..       MOV     ?V0 + 2,DPL
   \   000175   8583..       MOV     ?V0 + 3,DPH
   2977          
   2978                osal_memset( reportRec, 0, sizeof( zclCfgReportRec_t ) );
   \   000178                ; Setup parameters for call to function osal_memset
   \   000178   7C0C         MOV     R4,#0xc
   \   00017A   7D00         MOV     R5,#0x0
   \   00017C   7900         MOV     R1,#0x0
   \   00017E   AA..         MOV     R2,?V0 + 2
   \   000180   AB..         MOV     R3,?V0 + 3
   \   000182   12....       LCALL   ??osal_memset?relay
   2979          
   2980                reportRec->direction = *pBuf++;
   \   000185   8E82         MOV     DPL,R6
   \   000187   8F83         MOV     DPH,R7
   \   000189   E0           MOVX    A,@DPTR
   \   00018A   85..82       MOV     DPL,?V0 + 2
   \   00018D   85..83       MOV     DPH,?V0 + 3
   \   000190   F0           MOVX    @DPTR,A
   \   000191   8E82         MOV     DPL,R6
   \   000193   8F83         MOV     DPH,R7
   \   000195   A3           INC     DPTR
   \   000196   AE82         MOV     R6,DPL
   \   000198   AF83         MOV     R7,DPH
   2981                reportRec->attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   \   00019A   8E82         MOV     DPL,R6
   \   00019C   8F83         MOV     DPH,R7
   \   00019E   E0           MOVX    A,@DPTR
   \   00019F   FA           MOV     R2,A
   \   0001A0   7B00         MOV     R3,#0x0
   \   0001A2   8E82         MOV     DPL,R6
   \   0001A4   8F83         MOV     DPH,R7
   \   0001A6   A3           INC     DPTR
   \   0001A7   E0           MOVX    A,@DPTR
   \   0001A8   F8           MOV     R0,A
   \   0001A9   7900         MOV     R1,#0x0
   \   0001AB   E4           CLR     A
   \   0001AC   C8           XCH     A,R0
   \   0001AD   F9           MOV     R1,A
   \   0001AE   EA           MOV     A,R2
   \   0001AF   28           ADD     A,R0
   \   0001B0   F8           MOV     R0,A
   \   0001B1   EB           MOV     A,R3
   \   0001B2   39           ADDC    A,R1
   \   0001B3   F9           MOV     R1,A
   \   0001B4   85..82       MOV     DPL,?V0 + 2
   \   0001B7   85..83       MOV     DPH,?V0 + 3
   \   0001BA   A3           INC     DPTR
   \   0001BB   E8           MOV     A,R0
   \   0001BC   F0           MOVX    @DPTR,A
   \   0001BD   A3           INC     DPTR
   \   0001BE   E9           MOV     A,R1
   \   0001BF   F0           MOVX    @DPTR,A
   2982                pBuf += 2;
   \   0001C0   EE           MOV     A,R6
   \   0001C1   2402         ADD     A,#0x2
   \   0001C3   FE           MOV     R6,A
   \   0001C4   EF           MOV     A,R7
   \   0001C5   3400         ADDC    A,#0x0
   \   0001C7   FF           MOV     R7,A
   2983                if ( reportRec->direction == ZCL_SEND_ATTR_REPORTS )
   \   0001C8   85..82       MOV     DPL,?V0 + 2
   \   0001CB   85..83       MOV     DPH,?V0 + 3
   \   0001CE   E0           MOVX    A,@DPTR
   \   0001CF   6003         JZ      $+5
   \   0001D1   02....       LJMP    ??zclParseInConfigReportCmd_6 & 0xFFFF
   2984                {
   2985                  // Attribute to be reported
   2986                  reportRec->dataType = *pBuf++;
   \   0001D4   8E82         MOV     DPL,R6
   \   0001D6   8F83         MOV     DPH,R7
   \   0001D8   E0           MOVX    A,@DPTR
   \   0001D9   85..82       MOV     DPL,?V0 + 2
   \   0001DC   85..83       MOV     DPH,?V0 + 3
   \   0001DF   A3           INC     DPTR
   \   0001E0   A3           INC     DPTR
   \   0001E1   A3           INC     DPTR
   \   0001E2   F0           MOVX    @DPTR,A
   \   0001E3   8E82         MOV     DPL,R6
   \   0001E5   8F83         MOV     DPH,R7
   \   0001E7   A3           INC     DPTR
   \   0001E8   AE82         MOV     R6,DPL
   \   0001EA   AF83         MOV     R7,DPH
   2987                  reportRec->minReportInt = BUILD_UINT16( pBuf[0], pBuf[1] );
   \   0001EC   8E82         MOV     DPL,R6
   \   0001EE   8F83         MOV     DPH,R7
   \   0001F0   E0           MOVX    A,@DPTR
   \   0001F1   FA           MOV     R2,A
   \   0001F2   7B00         MOV     R3,#0x0
   \   0001F4   8E82         MOV     DPL,R6
   \   0001F6   8F83         MOV     DPH,R7
   \   0001F8   A3           INC     DPTR
   \   0001F9   E0           MOVX    A,@DPTR
   \   0001FA   F8           MOV     R0,A
   \   0001FB   7900         MOV     R1,#0x0
   \   0001FD   E4           CLR     A
   \   0001FE   C8           XCH     A,R0
   \   0001FF   F9           MOV     R1,A
   \   000200   EA           MOV     A,R2
   \   000201   28           ADD     A,R0
   \   000202   F8           MOV     R0,A
   \   000203   EB           MOV     A,R3
   \   000204   39           ADDC    A,R1
   \   000205   F9           MOV     R1,A
   \   000206   85..82       MOV     DPL,?V0 + 2
   \   000209   85..83       MOV     DPH,?V0 + 3
   \   00020C   A3           INC     DPTR
   \   00020D   A3           INC     DPTR
   \   00020E   A3           INC     DPTR
   \   00020F   A3           INC     DPTR
   \   000210   E8           MOV     A,R0
   \   000211   F0           MOVX    @DPTR,A
   \   000212   A3           INC     DPTR
   \   000213   E9           MOV     A,R1
   \   000214   F0           MOVX    @DPTR,A
   2988                  pBuf += 2;
   \   000215   EE           MOV     A,R6
   \   000216   2402         ADD     A,#0x2
   \   000218   FE           MOV     R6,A
   \   000219   EF           MOV     A,R7
   \   00021A   3400         ADDC    A,#0x0
   \   00021C   FF           MOV     R7,A
   2989                  reportRec->maxReportInt = BUILD_UINT16( pBuf[0], pBuf[1] );
   \   00021D   8E82         MOV     DPL,R6
   \   00021F   8F83         MOV     DPH,R7
   \   000221   E0           MOVX    A,@DPTR
   \   000222   FA           MOV     R2,A
   \   000223   7B00         MOV     R3,#0x0
   \   000225   8E82         MOV     DPL,R6
   \   000227   8F83         MOV     DPH,R7
   \   000229   A3           INC     DPTR
   \   00022A   E0           MOVX    A,@DPTR
   \   00022B   F8           MOV     R0,A
   \   00022C   7900         MOV     R1,#0x0
   \   00022E   E4           CLR     A
   \   00022F   C8           XCH     A,R0
   \   000230   F9           MOV     R1,A
   \   000231   EA           MOV     A,R2
   \   000232   28           ADD     A,R0
   \   000233   F8           MOV     R0,A
   \   000234   EB           MOV     A,R3
   \   000235   39           ADDC    A,R1
   \   000236   F9           MOV     R1,A
   \   000237   85..82       MOV     DPL,?V0 + 2
   \   00023A   85..83       MOV     DPH,?V0 + 3
   \   00023D   A3           INC     DPTR
   \   00023E   A3           INC     DPTR
   \   00023F   A3           INC     DPTR
   \   000240   A3           INC     DPTR
   \   000241   A3           INC     DPTR
   \   000242   A3           INC     DPTR
   \   000243   E8           MOV     A,R0
   \   000244   F0           MOVX    @DPTR,A
   \   000245   A3           INC     DPTR
   \   000246   E9           MOV     A,R1
   \   000247   F0           MOVX    @DPTR,A
   2990                  pBuf += 2;
   \   000248   EE           MOV     A,R6
   \   000249   2402         ADD     A,#0x2
   \   00024B   FE           MOV     R6,A
   \   00024C   EF           MOV     A,R7
   \   00024D   3400         ADDC    A,#0x0
   \   00024F   FF           MOV     R7,A
   2991          
   2992                  // For attributes of 'discrete' data types this field is omitted
   2993                  if ( zclAnalogDataType( reportRec->dataType ) )
   \   000250                ; Setup parameters for call to function zclAnalogDataType
   \   000250   85..82       MOV     DPL,?V0 + 2
   \   000253   85..83       MOV     DPH,?V0 + 3
   \   000256   A3           INC     DPTR
   \   000257   A3           INC     DPTR
   \   000258   A3           INC     DPTR
   \   000259   E0           MOVX    A,@DPTR
   \   00025A   F9           MOV     R1,A
   \   00025B   12....       LCALL   ??zclAnalogDataType?relay
   \   00025E   E9           MOV     A,R1
   \   00025F   7003         JNZ     $+5
   \   000261   02....       LJMP    ??zclParseInConfigReportCmd_7 & 0xFFFF
   2994                  {
   2995                    zcl_BuildAnalogData( reportRec->dataType, dataPtr, pBuf);
   \   000264                ; Setup parameters for call to function zcl_BuildAnalogData
   \   000264   EE           MOV     A,R6
   \   000265   FC           MOV     R4,A
   \   000266   EF           MOV     A,R7
   \   000267   FD           MOV     R5,A
   \   000268   AA..         MOV     R2,?V0 + 6
   \   00026A   AB..         MOV     R3,?V0 + 7
   \   00026C   85..82       MOV     DPL,?V0 + 2
   \   00026F   85..83       MOV     DPH,?V0 + 3
   \   000272   A3           INC     DPTR
   \   000273   A3           INC     DPTR
   \   000274   A3           INC     DPTR
   \   000275   E0           MOVX    A,@DPTR
   \   000276   F9           MOV     R1,A
   \   000277   12....       LCALL   ??zcl_BuildAnalogData?relay
   2996                    reportRec->reportableChange = dataPtr;
   \   00027A   85..82       MOV     DPL,?V0 + 2
   \   00027D   85..83       MOV     DPH,?V0 + 3
   \   000280   A3           INC     DPTR
   \   000281   A3           INC     DPTR
   \   000282   A3           INC     DPTR
   \   000283   A3           INC     DPTR
   \   000284   A3           INC     DPTR
   \   000285   A3           INC     DPTR
   \   000286   A3           INC     DPTR
   \   000287   A3           INC     DPTR
   \   000288   A3           INC     DPTR
   \   000289   A3           INC     DPTR
   \   00028A   E5..         MOV     A,?V0 + 6
   \   00028C   F0           MOVX    @DPTR,A
   \   00028D   A3           INC     DPTR
   \   00028E   E5..         MOV     A,?V0 + 7
   \   000290   F0           MOVX    @DPTR,A
   2997          
   2998                    reportChangeLen = zclGetDataTypeLength( reportRec->dataType );
   \   000291                ; Setup parameters for call to function zclGetDataTypeLength
   \   000291   85..82       MOV     DPL,?V0 + 2
   \   000294   85..83       MOV     DPH,?V0 + 3
   \   000297   A3           INC     DPTR
   \   000298   A3           INC     DPTR
   \   000299   A3           INC     DPTR
   \   00029A   E0           MOVX    A,@DPTR
   \   00029B   F9           MOV     R1,A
   \   00029C   12....       LCALL   ??zclGetDataTypeLength?relay
   \   00029F   E9           MOV     A,R1
   \   0002A0   F5..         MOV     ?V0 + 0,A
   2999                    pBuf += reportChangeLen;
   \   0002A2   85....       MOV     ?V0 + 10,?V0 + 0
   \   0002A5   75..00       MOV     ?V0 + 11,#0x0
   \   0002A8   EE           MOV     A,R6
   \   0002A9   25..         ADD     A,?V0 + 10
   \   0002AB   FE           MOV     R6,A
   \   0002AC   EF           MOV     A,R7
   \   0002AD   35..         ADDC    A,?V0 + 11
   \   0002AF   FF           MOV     R7,A
   3000          
   3001                    // advance attribute data pointer
   3002                    if ( PADDING_NEEDED( reportChangeLen ) )
   \   0002B0   E5..         MOV     A,?V0 + 0
   \   0002B2   75F002       MOV     B,#0x2
   \   0002B5   84           DIV     AB
   \   0002B6   E5F0         MOV     A,B
   \   0002B8   6002         JZ      ??zclParseInConfigReportCmd_8
   3003                    {
   3004                      reportChangeLen++;
   \   0002BA   05..         INC     ?V0 + 0
   3005                    }
   3006          
   3007                    dataPtr += reportChangeLen;
   \                     ??zclParseInConfigReportCmd_8:
   \   0002BC   85....       MOV     ?V0 + 10,?V0 + 0
   \   0002BF   75..00       MOV     ?V0 + 11,#0x0
   \   0002C2   E5..         MOV     A,?V0 + 6
   \   0002C4   25..         ADD     A,?V0 + 10
   \   0002C6   F5..         MOV     ?V0 + 6,A
   \   0002C8   E5..         MOV     A,?V0 + 7
   \   0002CA   35..         ADDC    A,?V0 + 11
   \   0002CC   F5..         MOV     ?V0 + 7,A
   \   0002CE   8035         SJMP    ??zclParseInConfigReportCmd_7
   3008                  }
   3009                }
   3010                else
   3011                {
   3012                  // Attribute reports to be received
   3013                  reportRec->timeoutPeriod = BUILD_UINT16( pBuf[0], pBuf[1] );
   \                     ??zclParseInConfigReportCmd_6:
   \   0002D0   8E82         MOV     DPL,R6
   \   0002D2   8F83         MOV     DPH,R7
   \   0002D4   E0           MOVX    A,@DPTR
   \   0002D5   FA           MOV     R2,A
   \   0002D6   7B00         MOV     R3,#0x0
   \   0002D8   8E82         MOV     DPL,R6
   \   0002DA   8F83         MOV     DPH,R7
   \   0002DC   A3           INC     DPTR
   \   0002DD   E0           MOVX    A,@DPTR
   \   0002DE   F8           MOV     R0,A
   \   0002DF   7900         MOV     R1,#0x0
   \   0002E1   E4           CLR     A
   \   0002E2   C8           XCH     A,R0
   \   0002E3   F9           MOV     R1,A
   \   0002E4   EA           MOV     A,R2
   \   0002E5   28           ADD     A,R0
   \   0002E6   F8           MOV     R0,A
   \   0002E7   EB           MOV     A,R3
   \   0002E8   39           ADDC    A,R1
   \   0002E9   F9           MOV     R1,A
   \   0002EA   85..82       MOV     DPL,?V0 + 2
   \   0002ED   85..83       MOV     DPH,?V0 + 3
   \   0002F0   A3           INC     DPTR
   \   0002F1   A3           INC     DPTR
   \   0002F2   A3           INC     DPTR
   \   0002F3   A3           INC     DPTR
   \   0002F4   A3           INC     DPTR
   \   0002F5   A3           INC     DPTR
   \   0002F6   A3           INC     DPTR
   \   0002F7   A3           INC     DPTR
   \   0002F8   E8           MOV     A,R0
   \   0002F9   F0           MOVX    @DPTR,A
   \   0002FA   A3           INC     DPTR
   \   0002FB   E9           MOV     A,R1
   \   0002FC   F0           MOVX    @DPTR,A
   3014                  pBuf += 2;
   \   0002FD   EE           MOV     A,R6
   \   0002FE   2402         ADD     A,#0x2
   \   000300   FE           MOV     R6,A
   \   000301   EF           MOV     A,R7
   \   000302   3400         ADDC    A,#0x0
   \   000304   FF           MOV     R7,A
   3015                }
   3016              } // while loop
   \                     ??zclParseInConfigReportCmd_7:
   \   000305   05..         INC     ?V0 + 4
   \   000307   02....       LJMP    ??zclParseInConfigReportCmd_5 & 0xFFFF
   3017            }
   3018          
   3019            return ( (void *)cfgReportCmd );
   \                     ??zclParseInConfigReportCmd_4:
   \   00030A   AA..         MOV     R2,?V0 + 8
   \   00030C   AB..         MOV     R3,?V0 + 9
   \   00030E   7402         MOV     A,#0x2
   \   000310   12....       LCALL   ?DEALLOC_XSTACK8
   \   000313   7F0F         MOV     R7,#0xf
   \   000315   02....       LJMP    ?BANKED_LEAVE_XDATA
   3020          }
   3021          
   3022          /*********************************************************************
   3023           * @fn      zclParseInConfigReportRspCmd
   3024           *
   3025           * @brief   Parse the "Profile" Configure Reporting Response Command
   3026           *
   3027           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   3028           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   3029           *
   3030           * @param   pCmd - pointer to incoming data to parse
   3031           *
   3032           * @return  pointer to the parsed command structure
   3033           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3034          static void *zclParseInConfigReportRspCmd( zclParseCmd_t *pCmd )
   \                     zclParseInConfigReportRspCmd:
   3035          {
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV     ?V0 + 2,R2
   \   000007   8B..         MOV     ?V0 + 3,R3
   3036            zclCfgReportRspCmd_t *cfgReportRspCmd;
   3037            uint8 *pBuf = pCmd->pData;
   \   000009   85..82       MOV     DPL,?V0 + 2
   \   00000C   85..83       MOV     DPH,?V0 + 3
   \   00000F   A3           INC     DPTR
   \   000010   A3           INC     DPTR
   \   000011   A3           INC     DPTR
   \   000012   E0           MOVX    A,@DPTR
   \   000013   FE           MOV     R6,A
   \   000014   A3           INC     DPTR
   \   000015   E0           MOVX    A,@DPTR
   \   000016   FF           MOV     R7,A
   3038            uint8 numAttr;
   3039          
   3040            numAttr = pCmd->dataLen / ( 1 + 1 + 2 ); // Status + Direction + Attribute ID
   \   000017   85..82       MOV     DPL,?V0 + 2
   \   00001A   85..83       MOV     DPH,?V0 + 3
   \   00001D   A3           INC     DPTR
   \   00001E   E0           MOVX    A,@DPTR
   \   00001F   F5..         MOV     ?V0 + 6,A
   \   000021   A3           INC     DPTR
   \   000022   E0           MOVX    A,@DPTR
   \   000023   F5..         MOV     ?V0 + 7,A
   \   000025   7402         MOV     A,#0x2
   \   000027   78..         MOV     R0,#?V0 + 6
   \   000029   12....       LCALL   ?US_SHR
   \   00002C   E5..         MOV     A,?V0 + 6
   \   00002E   F5..         MOV     ?V0 + 4,A
   3041          
   3042            cfgReportRspCmd = (zclCfgReportRspCmd_t *)osal_mem_alloc( sizeof( zclCfgReportRspCmd_t )
   3043                                                      + ( numAttr * sizeof( zclCfgReportStatus_t ) ) );
   \   000030                ; Setup parameters for call to function osal_mem_alloc
   \   000030   E5..         MOV     A,?V0 + 4
   \   000032   A8..         MOV     R0,?V0 + 4
   \   000034   7900         MOV     R1,#0x0
   \   000036   E8           MOV     A,R0
   \   000037   75F004       MOV     B,#0x4
   \   00003A   A4           MUL     AB
   \   00003B   C8           XCH     A,R0
   \   00003C   AAF0         MOV     R2,B
   \   00003E   75F000       MOV     B,#0x0
   \   000041   A4           MUL     AB
   \   000042   2A           ADD     A,R2
   \   000043   FA           MOV     R2,A
   \   000044   75F004       MOV     B,#0x4
   \   000047   E9           MOV     A,R1
   \   000048   A4           MUL     AB
   \   000049   2A           ADD     A,R2
   \   00004A   F9           MOV     R1,A
   \   00004B   E8           MOV     A,R0
   \   00004C   2401         ADD     A,#0x1
   \   00004E   FA           MOV     R2,A
   \   00004F   E9           MOV     A,R1
   \   000050   3400         ADDC    A,#0x0
   \   000052   FB           MOV     R3,A
   \   000053   12....       LCALL   ??osal_mem_alloc?relay
   \   000056   8A..         MOV     ?V0 + 6,R2
   \   000058   8B..         MOV     ?V0 + 7,R3
   \   00005A   85....       MOV     ?V0 + 0,?V0 + 6
   \   00005D   85....       MOV     ?V0 + 1,?V0 + 7
   3044            if ( cfgReportRspCmd != NULL )
   \   000060   E5..         MOV     A,?V0 + 0
   \   000062   45..         ORL     A,?V0 + 1
   \   000064   7003         JNZ     $+5
   \   000066   02....       LJMP    ??zclParseInConfigReportRspCmd_0 & 0xFFFF
   3045            {
   3046              cfgReportRspCmd->numAttr = numAttr;
   \   000069   E5..         MOV     A,?V0 + 4
   \   00006B   85..82       MOV     DPL,?V0 + 0
   \   00006E   85..83       MOV     DPH,?V0 + 1
   \   000071   E5..         MOV     A,?V0 + 4
   \   000073   F0           MOVX    @DPTR,A
   3047              for ( uint8 i = 0; i < cfgReportRspCmd->numAttr; i++ )
   \   000074   7C00         MOV     R4,#0x0
   \                     ??zclParseInConfigReportRspCmd_1:
   \   000076   85..82       MOV     DPL,?V0 + 0
   \   000079   85..83       MOV     DPH,?V0 + 1
   \   00007C   E0           MOVX    A,@DPTR
   \   00007D   F8           MOV     R0,A
   \   00007E   EC           MOV     A,R4
   \   00007F   C3           CLR     C
   \   000080   98           SUBB    A,R0
   \   000081   4003         JC      $+5
   \   000083   02....       LJMP    ??zclParseInConfigReportRspCmd_0 & 0xFFFF
   3048              {
   3049                cfgReportRspCmd->attrList[i].status = *pBuf++;
   \   000086   8E82         MOV     DPL,R6
   \   000088   8F83         MOV     DPH,R7
   \   00008A   E0           MOVX    A,@DPTR
   \   00008B   C0E0         PUSH    A
   \   00008D   EC           MOV     A,R4
   \   00008E   F8           MOV     R0,A
   \   00008F   7900         MOV     R1,#0x0
   \   000091   E8           MOV     A,R0
   \   000092   75F004       MOV     B,#0x4
   \   000095   A4           MUL     AB
   \   000096   C8           XCH     A,R0
   \   000097   AAF0         MOV     R2,B
   \   000099   75F000       MOV     B,#0x0
   \   00009C   A4           MUL     AB
   \   00009D   2A           ADD     A,R2
   \   00009E   FA           MOV     R2,A
   \   00009F   75F004       MOV     B,#0x4
   \   0000A2   E9           MOV     A,R1
   \   0000A3   A4           MUL     AB
   \   0000A4   2A           ADD     A,R2
   \   0000A5   F9           MOV     R1,A
   \   0000A6   E5..         MOV     A,?V0 + 0
   \   0000A8   28           ADD     A,R0
   \   0000A9   F582         MOV     DPL,A
   \   0000AB   E5..         MOV     A,?V0 + 1
   \   0000AD   39           ADDC    A,R1
   \   0000AE   F583         MOV     DPH,A
   \   0000B0   A3           INC     DPTR
   \   0000B1   D0E0         POP     A
   \   0000B3   F0           MOVX    @DPTR,A
   \   0000B4   8E82         MOV     DPL,R6
   \   0000B6   8F83         MOV     DPH,R7
   \   0000B8   A3           INC     DPTR
   \   0000B9   AE82         MOV     R6,DPL
   \   0000BB   AF83         MOV     R7,DPH
   3050                cfgReportRspCmd->attrList[i].direction = *pBuf++;
   \   0000BD   8E82         MOV     DPL,R6
   \   0000BF   8F83         MOV     DPH,R7
   \   0000C1   E0           MOVX    A,@DPTR
   \   0000C2   C0E0         PUSH    A
   \   0000C4   EC           MOV     A,R4
   \   0000C5   F8           MOV     R0,A
   \   0000C6   7900         MOV     R1,#0x0
   \   0000C8   E8           MOV     A,R0
   \   0000C9   75F004       MOV     B,#0x4
   \   0000CC   A4           MUL     AB
   \   0000CD   C8           XCH     A,R0
   \   0000CE   AAF0         MOV     R2,B
   \   0000D0   75F000       MOV     B,#0x0
   \   0000D3   A4           MUL     AB
   \   0000D4   2A           ADD     A,R2
   \   0000D5   FA           MOV     R2,A
   \   0000D6   75F004       MOV     B,#0x4
   \   0000D9   E9           MOV     A,R1
   \   0000DA   A4           MUL     AB
   \   0000DB   2A           ADD     A,R2
   \   0000DC   F9           MOV     R1,A
   \   0000DD   E5..         MOV     A,?V0 + 0
   \   0000DF   28           ADD     A,R0
   \   0000E0   F582         MOV     DPL,A
   \   0000E2   E5..         MOV     A,?V0 + 1
   \   0000E4   39           ADDC    A,R1
   \   0000E5   F583         MOV     DPH,A
   \   0000E7   A3           INC     DPTR
   \   0000E8   A3           INC     DPTR
   \   0000E9   D0E0         POP     A
   \   0000EB   F0           MOVX    @DPTR,A
   \   0000EC   8E82         MOV     DPL,R6
   \   0000EE   8F83         MOV     DPH,R7
   \   0000F0   A3           INC     DPTR
   \   0000F1   AE82         MOV     R6,DPL
   \   0000F3   AF83         MOV     R7,DPH
   3051                cfgReportRspCmd->attrList[i].attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   \   0000F5   8E82         MOV     DPL,R6
   \   0000F7   8F83         MOV     DPH,R7
   \   0000F9   E0           MOVX    A,@DPTR
   \   0000FA   FA           MOV     R2,A
   \   0000FB   7B00         MOV     R3,#0x0
   \   0000FD   8E82         MOV     DPL,R6
   \   0000FF   8F83         MOV     DPH,R7
   \   000101   A3           INC     DPTR
   \   000102   E0           MOVX    A,@DPTR
   \   000103   F8           MOV     R0,A
   \   000104   7900         MOV     R1,#0x0
   \   000106   E4           CLR     A
   \   000107   C8           XCH     A,R0
   \   000108   F9           MOV     R1,A
   \   000109   EA           MOV     A,R2
   \   00010A   28           ADD     A,R0
   \   00010B   FA           MOV     R2,A
   \   00010C   EB           MOV     A,R3
   \   00010D   39           ADDC    A,R1
   \   00010E   FB           MOV     R3,A
   \   00010F   EC           MOV     A,R4
   \   000110   F8           MOV     R0,A
   \   000111   7900         MOV     R1,#0x0
   \   000113   E8           MOV     A,R0
   \   000114   75F004       MOV     B,#0x4
   \   000117   A4           MUL     AB
   \   000118   C8           XCH     A,R0
   \   000119   ADF0         MOV     R5,B
   \   00011B   75F000       MOV     B,#0x0
   \   00011E   A4           MUL     AB
   \   00011F   2D           ADD     A,R5
   \   000120   FD           MOV     R5,A
   \   000121   75F004       MOV     B,#0x4
   \   000124   E9           MOV     A,R1
   \   000125   A4           MUL     AB
   \   000126   2D           ADD     A,R5
   \   000127   F9           MOV     R1,A
   \   000128   E5..         MOV     A,?V0 + 0
   \   00012A   28           ADD     A,R0
   \   00012B   F582         MOV     DPL,A
   \   00012D   E5..         MOV     A,?V0 + 1
   \   00012F   39           ADDC    A,R1
   \   000130   F583         MOV     DPH,A
   \   000132   A3           INC     DPTR
   \   000133   A3           INC     DPTR
   \   000134   A3           INC     DPTR
   \   000135   EA           MOV     A,R2
   \   000136   F0           MOVX    @DPTR,A
   \   000137   A3           INC     DPTR
   \   000138   EB           MOV     A,R3
   \   000139   F0           MOVX    @DPTR,A
   3052                pBuf += 2;
   \   00013A   EE           MOV     A,R6
   \   00013B   2402         ADD     A,#0x2
   \   00013D   FE           MOV     R6,A
   \   00013E   EF           MOV     A,R7
   \   00013F   3400         ADDC    A,#0x0
   \   000141   FF           MOV     R7,A
   3053              }
   \   000142   0C           INC     R4
   \   000143   02....       LJMP    ??zclParseInConfigReportRspCmd_1 & 0xFFFF
   3054            }
   3055          
   3056            return ( (void *)cfgReportRspCmd );
   \                     ??zclParseInConfigReportRspCmd_0:
   \   000146   AA..         MOV     R2,?V0 + 0
   \   000148   AB..         MOV     R3,?V0 + 1
   \   00014A   7F08         MOV     R7,#0x8
   \   00014C   02....       LJMP    ?BANKED_LEAVE_XDATA
   3057          }
   3058          
   3059          /*********************************************************************
   3060           * @fn      zclParseInReadReportCfgCmd
   3061           *
   3062           * @brief   Parse the "Profile" Read Reporting Configuration Command
   3063           *
   3064           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   3065           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   3066           *
   3067           * @param   pCmd - pointer to incoming data to parse
   3068           *
   3069           * @return  pointer to the parsed command structure
   3070           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3071          void *zclParseInReadReportCfgCmd( zclParseCmd_t *pCmd )
   \                     zclParseInReadReportCfgCmd:
   3072          {
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV     ?V0 + 2,R2
   \   000007   8B..         MOV     ?V0 + 3,R3
   3073            zclReadReportCfgCmd_t *readReportCfgCmd;
   3074            uint8 *pBuf = pCmd->pData;
   \   000009   85..82       MOV     DPL,?V0 + 2
   \   00000C   85..83       MOV     DPH,?V0 + 3
   \   00000F   A3           INC     DPTR
   \   000010   A3           INC     DPTR
   \   000011   A3           INC     DPTR
   \   000012   E0           MOVX    A,@DPTR
   \   000013   F5..         MOV     ?V0 + 0,A
   \   000015   A3           INC     DPTR
   \   000016   E0           MOVX    A,@DPTR
   \   000017   F5..         MOV     ?V0 + 1,A
   3075            uint8 numAttr;
   3076          
   3077            numAttr = pCmd->dataLen / ( 1 + 2 ); // Direction + Attribute ID
   \   000019   85..82       MOV     DPL,?V0 + 2
   \   00001C   85..83       MOV     DPH,?V0 + 3
   \   00001F   A3           INC     DPTR
   \   000020   E0           MOVX    A,@DPTR
   \   000021   F8           MOV     R0,A
   \   000022   A3           INC     DPTR
   \   000023   E0           MOVX    A,@DPTR
   \   000024   F9           MOV     R1,A
   \   000025   7A03         MOV     R2,#0x3
   \   000027   7B00         MOV     R3,#0x0
   \   000029   12....       LCALL   ?US_DIV_MOD
   \   00002C   E8           MOV     A,R0
   \   00002D   F5..         MOV     ?V0 + 4,A
   3078          
   3079            readReportCfgCmd = (zclReadReportCfgCmd_t *)osal_mem_alloc( sizeof( zclReadReportCfgCmd_t )
   3080                                                            + ( numAttr * sizeof( zclReadReportCfgRec_t ) ) );
   \   00002F                ; Setup parameters for call to function osal_mem_alloc
   \   00002F   E5..         MOV     A,?V0 + 4
   \   000031   A8..         MOV     R0,?V0 + 4
   \   000033   7900         MOV     R1,#0x0
   \   000035   E8           MOV     A,R0
   \   000036   75F003       MOV     B,#0x3
   \   000039   A4           MUL     AB
   \   00003A   C8           XCH     A,R0
   \   00003B   AAF0         MOV     R2,B
   \   00003D   75F000       MOV     B,#0x0
   \   000040   A4           MUL     AB
   \   000041   2A           ADD     A,R2
   \   000042   FA           MOV     R2,A
   \   000043   75F003       MOV     B,#0x3
   \   000046   E9           MOV     A,R1
   \   000047   A4           MUL     AB
   \   000048   2A           ADD     A,R2
   \   000049   F9           MOV     R1,A
   \   00004A   E8           MOV     A,R0
   \   00004B   2401         ADD     A,#0x1
   \   00004D   FA           MOV     R2,A
   \   00004E   E9           MOV     A,R1
   \   00004F   3400         ADDC    A,#0x0
   \   000051   FB           MOV     R3,A
   \   000052   12....       LCALL   ??osal_mem_alloc?relay
   \   000055   8A..         MOV     ?V0 + 6,R2
   \   000057   8B..         MOV     ?V0 + 7,R3
   \   000059   AE..         MOV     R6,?V0 + 6
   \   00005B   AF..         MOV     R7,?V0 + 7
   3081            if ( readReportCfgCmd != NULL )
   \   00005D   EE           MOV     A,R6
   \   00005E   4F           ORL     A,R7
   \   00005F   7003         JNZ     $+5
   \   000061   02....       LJMP    ??zclParseInReadReportCfgCmd_0 & 0xFFFF
   3082            {
   3083              readReportCfgCmd->numAttr = numAttr;
   \   000064   E5..         MOV     A,?V0 + 4
   \   000066   8E82         MOV     DPL,R6
   \   000068   8F83         MOV     DPH,R7
   \   00006A   E5..         MOV     A,?V0 + 4
   \   00006C   F0           MOVX    @DPTR,A
   3084              for ( uint8 i = 0; i < readReportCfgCmd->numAttr; i++)
   \   00006D   7D00         MOV     R5,#0x0
   \                     ??zclParseInReadReportCfgCmd_1:
   \   00006F   8E82         MOV     DPL,R6
   \   000071   8F83         MOV     DPH,R7
   \   000073   E0           MOVX    A,@DPTR
   \   000074   F8           MOV     R0,A
   \   000075   ED           MOV     A,R5
   \   000076   C3           CLR     C
   \   000077   98           SUBB    A,R0
   \   000078   4003         JC      $+5
   \   00007A   02....       LJMP    ??zclParseInReadReportCfgCmd_0 & 0xFFFF
   3085              {
   3086                readReportCfgCmd->attrList[i].direction = *pBuf++;;
   \   00007D   85..82       MOV     DPL,?V0 + 0
   \   000080   85..83       MOV     DPH,?V0 + 1
   \   000083   E0           MOVX    A,@DPTR
   \   000084   C0E0         PUSH    A
   \   000086   ED           MOV     A,R5
   \   000087   F8           MOV     R0,A
   \   000088   7900         MOV     R1,#0x0
   \   00008A   E8           MOV     A,R0
   \   00008B   75F003       MOV     B,#0x3
   \   00008E   A4           MUL     AB
   \   00008F   C8           XCH     A,R0
   \   000090   AAF0         MOV     R2,B
   \   000092   75F000       MOV     B,#0x0
   \   000095   A4           MUL     AB
   \   000096   2A           ADD     A,R2
   \   000097   FA           MOV     R2,A
   \   000098   75F003       MOV     B,#0x3
   \   00009B   E9           MOV     A,R1
   \   00009C   A4           MUL     AB
   \   00009D   2A           ADD     A,R2
   \   00009E   F9           MOV     R1,A
   \   00009F   EE           MOV     A,R6
   \   0000A0   28           ADD     A,R0
   \   0000A1   F582         MOV     DPL,A
   \   0000A3   EF           MOV     A,R7
   \   0000A4   39           ADDC    A,R1
   \   0000A5   F583         MOV     DPH,A
   \   0000A7   A3           INC     DPTR
   \   0000A8   D0E0         POP     A
   \   0000AA   F0           MOVX    @DPTR,A
   \   0000AB   85..82       MOV     DPL,?V0 + 0
   \   0000AE   85..83       MOV     DPH,?V0 + 1
   \   0000B1   A3           INC     DPTR
   \   0000B2   8582..       MOV     ?V0 + 0,DPL
   \   0000B5   8583..       MOV     ?V0 + 1,DPH
   3087                readReportCfgCmd->attrList[i].attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   \   0000B8   85..82       MOV     DPL,?V0 + 0
   \   0000BB   85..83       MOV     DPH,?V0 + 1
   \   0000BE   E0           MOVX    A,@DPTR
   \   0000BF   FA           MOV     R2,A
   \   0000C0   7B00         MOV     R3,#0x0
   \   0000C2   85..82       MOV     DPL,?V0 + 0
   \   0000C5   85..83       MOV     DPH,?V0 + 1
   \   0000C8   A3           INC     DPTR
   \   0000C9   E0           MOVX    A,@DPTR
   \   0000CA   F8           MOV     R0,A
   \   0000CB   7900         MOV     R1,#0x0
   \   0000CD   E4           CLR     A
   \   0000CE   C8           XCH     A,R0
   \   0000CF   F9           MOV     R1,A
   \   0000D0   EA           MOV     A,R2
   \   0000D1   28           ADD     A,R0
   \   0000D2   FA           MOV     R2,A
   \   0000D3   EB           MOV     A,R3
   \   0000D4   39           ADDC    A,R1
   \   0000D5   FB           MOV     R3,A
   \   0000D6   ED           MOV     A,R5
   \   0000D7   F8           MOV     R0,A
   \   0000D8   7900         MOV     R1,#0x0
   \   0000DA   E8           MOV     A,R0
   \   0000DB   75F003       MOV     B,#0x3
   \   0000DE   A4           MUL     AB
   \   0000DF   C8           XCH     A,R0
   \   0000E0   ACF0         MOV     R4,B
   \   0000E2   75F000       MOV     B,#0x0
   \   0000E5   A4           MUL     AB
   \   0000E6   2C           ADD     A,R4
   \   0000E7   FC           MOV     R4,A
   \   0000E8   75F003       MOV     B,#0x3
   \   0000EB   E9           MOV     A,R1
   \   0000EC   A4           MUL     AB
   \   0000ED   2C           ADD     A,R4
   \   0000EE   F9           MOV     R1,A
   \   0000EF   EE           MOV     A,R6
   \   0000F0   28           ADD     A,R0
   \   0000F1   F582         MOV     DPL,A
   \   0000F3   EF           MOV     A,R7
   \   0000F4   39           ADDC    A,R1
   \   0000F5   F583         MOV     DPH,A
   \   0000F7   A3           INC     DPTR
   \   0000F8   A3           INC     DPTR
   \   0000F9   EA           MOV     A,R2
   \   0000FA   F0           MOVX    @DPTR,A
   \   0000FB   A3           INC     DPTR
   \   0000FC   EB           MOV     A,R3
   \   0000FD   F0           MOVX    @DPTR,A
   3088                pBuf += 2;
   \   0000FE   E5..         MOV     A,?V0 + 0
   \   000100   2402         ADD     A,#0x2
   \   000102   F5..         MOV     ?V0 + 0,A
   \   000104   E5..         MOV     A,?V0 + 1
   \   000106   3400         ADDC    A,#0x0
   \   000108   F5..         MOV     ?V0 + 1,A
   3089              }
   \   00010A   0D           INC     R5
   \   00010B   02....       LJMP    ??zclParseInReadReportCfgCmd_1 & 0xFFFF
   3090            }
   3091          
   3092            return ( (void *)readReportCfgCmd );
   \                     ??zclParseInReadReportCfgCmd_0:
   \   00010E   EE           MOV     A,R6
   \   00010F   FA           MOV     R2,A
   \   000110   EF           MOV     A,R7
   \   000111   FB           MOV     R3,A
   \   000112   7F08         MOV     R7,#0x8
   \   000114   02....       LJMP    ?BANKED_LEAVE_XDATA
   3093          }
   3094          
   3095          /*********************************************************************
   3096           * @fn      zclParseInReadReportCfgRspCmd
   3097           *
   3098           * @brief   Parse the "Profile" Read Reporting Configuration Response Command
   3099           *
   3100           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   3101           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   3102           *
   3103           * @param   pCmd - pointer to incoming data to parse
   3104           *
   3105           * @return  pointer to the parsed command structure
   3106           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3107          static void *zclParseInReadReportCfgRspCmd( zclParseCmd_t *pCmd )
   \                     zclParseInReadReportCfgRspCmd:
   3108          {
   \   000000   74E8         MOV     A,#-0x18
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 24
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV     ?V0 + 12,R2
   \   000007   8B..         MOV     ?V0 + 13,R3
   3109            zclReadReportCfgRspCmd_t *readReportCfgRspCmd;
   3110            uint8 reportChangeLen;
   3111            uint8 *pBuf = pCmd->pData;
   \   000009   85..82       MOV     DPL,?V0 + 12
   \   00000C   85..83       MOV     DPH,?V0 + 13
   \   00000F   A3           INC     DPTR
   \   000010   A3           INC     DPTR
   \   000011   A3           INC     DPTR
   \   000012   E0           MOVX    A,@DPTR
   \   000013   FE           MOV     R6,A
   \   000014   A3           INC     DPTR
   \   000015   E0           MOVX    A,@DPTR
   \   000016   FF           MOV     R7,A
   3112            uint8 *dataPtr;
   3113            uint8 numAttr = 0;
   \   000017   75..00       MOV     ?V0 + 3,#0x0
   3114            uint8 hdrLen;
   3115            uint16 dataLen = 0;
   \   00001A   75..00       MOV     ?V0 + 14,#0x0
   \   00001D   75..00       MOV     ?V0 + 15,#0x0
   3116          
   3117            // Calculate the length of the response command
   3118            while ( pBuf < ( pCmd->pData + pCmd->dataLen ) )
   \                     ??zclParseInReadReportCfgRspCmd_0:
   \   000020   85..82       MOV     DPL,?V0 + 12
   \   000023   85..83       MOV     DPH,?V0 + 13
   \   000026   A3           INC     DPTR
   \   000027   E0           MOVX    A,@DPTR
   \   000028   F8           MOV     R0,A
   \   000029   A3           INC     DPTR
   \   00002A   E0           MOVX    A,@DPTR
   \   00002B   F9           MOV     R1,A
   \   00002C   85..82       MOV     DPL,?V0 + 12
   \   00002F   85..83       MOV     DPH,?V0 + 13
   \   000032   A3           INC     DPTR
   \   000033   A3           INC     DPTR
   \   000034   A3           INC     DPTR
   \   000035   E0           MOVX    A,@DPTR
   \   000036   28           ADD     A,R0
   \   000037   F8           MOV     R0,A
   \   000038   A3           INC     DPTR
   \   000039   E0           MOVX    A,@DPTR
   \   00003A   39           ADDC    A,R1
   \   00003B   F9           MOV     R1,A
   \   00003C   C3           CLR     C
   \   00003D   EE           MOV     A,R6
   \   00003E   98           SUBB    A,R0
   \   00003F   EF           MOV     A,R7
   \   000040   99           SUBB    A,R1
   \   000041   4003         JC      $+5
   \   000043   02....       LJMP    ??zclParseInReadReportCfgRspCmd_1 & 0xFFFF
   3119            {
   3120              uint8 status;
   3121              uint8 direction;
   3122          
   3123              numAttr++;
   \   000046   05..         INC     ?V0 + 3
   3124              status = *pBuf++;
   \   000048   8E82         MOV     DPL,R6
   \   00004A   8F83         MOV     DPH,R7
   \   00004C   E0           MOVX    A,@DPTR
   \   00004D   F5..         MOV     ?V0 + 10,A
   \   00004F   8E82         MOV     DPL,R6
   \   000051   8F83         MOV     DPH,R7
   \   000053   A3           INC     DPTR
   \   000054   AE82         MOV     R6,DPL
   \   000056   AF83         MOV     R7,DPH
   3125              direction = *pBuf++;
   \   000058   8E82         MOV     DPL,R6
   \   00005A   8F83         MOV     DPH,R7
   \   00005C   E0           MOVX    A,@DPTR
   \   00005D   F5..         MOV     ?V0 + 11,A
   \   00005F   8E82         MOV     DPL,R6
   \   000061   8F83         MOV     DPH,R7
   \   000063   A3           INC     DPTR
   \   000064   AE82         MOV     R6,DPL
   \   000066   AF83         MOV     R7,DPH
   3126              pBuf += 2; // move pass the attribute ID
   \   000068   E582         MOV     A,DPL
   \   00006A   2402         ADD     A,#0x2
   \   00006C   FE           MOV     R6,A
   \   00006D   E583         MOV     A,DPH
   \   00006F   3400         ADDC    A,#0x0
   \   000071   FF           MOV     R7,A
   3127          
   3128              if ( status == ZCL_STATUS_SUCCESS )
   \   000072   E5..         MOV     A,?V0 + 10
   \   000074   70AA         JNZ     ??zclParseInReadReportCfgRspCmd_0
   3129              {
   3130                if ( direction == ZCL_SEND_ATTR_REPORTS )
   \   000076   E5..         MOV     A,?V0 + 11
   \   000078   7059         JNZ     ??zclParseInReadReportCfgRspCmd_2
   3131                {
   3132                  uint8 dataType = *pBuf++;
   \   00007A   8E82         MOV     DPL,R6
   \   00007C   8F83         MOV     DPH,R7
   \   00007E   E0           MOVX    A,@DPTR
   \   00007F   F5..         MOV     ?V0 + 4,A
   \   000081   8E82         MOV     DPL,R6
   \   000083   8F83         MOV     DPH,R7
   \   000085   A3           INC     DPTR
   \   000086   AE82         MOV     R6,DPL
   \   000088   AF83         MOV     R7,DPH
   3133                  pBuf += 4; // move pass the Min and Max Reporting Intervals
   \   00008A   E582         MOV     A,DPL
   \   00008C   2404         ADD     A,#0x4
   \   00008E   FE           MOV     R6,A
   \   00008F   E583         MOV     A,DPH
   \   000091   3400         ADDC    A,#0x0
   \   000093   FF           MOV     R7,A
   3134          
   3135                  // For attributes of 'discrete' data types this field is omitted
   3136                  if ( zclAnalogDataType( dataType ) )
   \   000094                ; Setup parameters for call to function zclAnalogDataType
   \   000094   A9..         MOV     R1,?V0 + 4
   \   000096   12....       LCALL   ??zclAnalogDataType?relay
   \   000099   E9           MOV     A,R1
   \   00009A   6084         JZ      ??zclParseInReadReportCfgRspCmd_0
   3137                  {
   3138                    reportChangeLen = zclGetDataTypeLength( dataType );
   \   00009C                ; Setup parameters for call to function zclGetDataTypeLength
   \   00009C   A9..         MOV     R1,?V0 + 4
   \   00009E   12....       LCALL   ??zclGetDataTypeLength?relay
   \   0000A1   E9           MOV     A,R1
   \   0000A2   F5..         MOV     ?V0 + 2,A
   3139                    pBuf += reportChangeLen;
   \   0000A4   85....       MOV     ?V0 + 0,?V0 + 2
   \   0000A7   75..00       MOV     ?V0 + 1,#0x0
   \   0000AA   EE           MOV     A,R6
   \   0000AB   25..         ADD     A,?V0 + 0
   \   0000AD   FE           MOV     R6,A
   \   0000AE   EF           MOV     A,R7
   \   0000AF   35..         ADDC    A,?V0 + 1
   \   0000B1   FF           MOV     R7,A
   3140          
   3141                    // add padding if needed
   3142                    if ( PADDING_NEEDED( reportChangeLen ) )
   \   0000B2   E5..         MOV     A,?V0 + 2
   \   0000B4   75F002       MOV     B,#0x2
   \   0000B7   84           DIV     AB
   \   0000B8   E5F0         MOV     A,B
   \   0000BA   6002         JZ      ??zclParseInReadReportCfgRspCmd_3
   3143                    {
   3144                      reportChangeLen++;
   \   0000BC   05..         INC     ?V0 + 2
   3145                    }
   3146          
   3147                    dataLen += reportChangeLen;
   \                     ??zclParseInReadReportCfgRspCmd_3:
   \   0000BE   85....       MOV     ?V0 + 0,?V0 + 2
   \   0000C1   75..00       MOV     ?V0 + 1,#0x0
   \   0000C4   E5..         MOV     A,?V0 + 14
   \   0000C6   25..         ADD     A,?V0 + 0
   \   0000C8   F5..         MOV     ?V0 + 14,A
   \   0000CA   E5..         MOV     A,?V0 + 15
   \   0000CC   35..         ADDC    A,?V0 + 1
   \   0000CE   F5..         MOV     ?V0 + 15,A
   \   0000D0   02....       LJMP    ??zclParseInReadReportCfgRspCmd_0 & 0xFFFF
   3148                  }
   3149                }
   3150                else
   3151                {
   3152                  pBuf += 2; // move pass the Timeout field
   \                     ??zclParseInReadReportCfgRspCmd_2:
   \   0000D3   EE           MOV     A,R6
   \   0000D4   2402         ADD     A,#0x2
   \   0000D6   FE           MOV     R6,A
   \   0000D7   EF           MOV     A,R7
   \   0000D8   3400         ADDC    A,#0x0
   \   0000DA   FF           MOV     R7,A
   \   0000DB   02....       LJMP    ??zclParseInReadReportCfgRspCmd_0 & 0xFFFF
   3153                }
   3154              }
   3155            } // while loop
   3156          
   3157            hdrLen = sizeof( zclReadReportCfgRspCmd_t ) + ( numAttr * sizeof( zclReportCfgRspRec_t ) );
   \                     ??zclParseInReadReportCfgRspCmd_1:
   \   0000DE   75F00D       MOV     B,#0xd
   \   0000E1   E5..         MOV     A,?V0 + 3
   \   0000E3   A4           MUL     AB
   \   0000E4   2401         ADD     A,#0x1
   \   0000E6   F5..         MOV     ?V0 + 5,A
   3158          
   3159            readReportCfgRspCmd = (zclReadReportCfgRspCmd_t *)osal_mem_alloc( hdrLen + dataLen );
   \   0000E8                ; Setup parameters for call to function osal_mem_alloc
   \   0000E8   85....       MOV     ?V0 + 0,?V0 + 5
   \   0000EB   75..00       MOV     ?V0 + 1,#0x0
   \   0000EE   E5..         MOV     A,?V0 + 0
   \   0000F0   25..         ADD     A,?V0 + 14
   \   0000F2   FA           MOV     R2,A
   \   0000F3   E5..         MOV     A,?V0 + 1
   \   0000F5   35..         ADDC    A,?V0 + 15
   \   0000F7   FB           MOV     R3,A
   \   0000F8   12....       LCALL   ??osal_mem_alloc?relay
   \   0000FB   8A..         MOV     ?V0 + 0,R2
   \   0000FD   8B..         MOV     ?V0 + 1,R3
   \   0000FF   85....       MOV     ?V0 + 8,?V0 + 0
   \   000102   85....       MOV     ?V0 + 9,?V0 + 1
   3160            if ( readReportCfgRspCmd != NULL )
   \   000105   E5..         MOV     A,?V0 + 8
   \   000107   45..         ORL     A,?V0 + 9
   \   000109   7003         JNZ     $+5
   \   00010B   02....       LJMP    ??zclParseInReadReportCfgRspCmd_4 & 0xFFFF
   3161            {
   3162              pBuf = pCmd->pData;
   \   00010E   85..82       MOV     DPL,?V0 + 12
   \   000111   85..83       MOV     DPH,?V0 + 13
   \   000114   A3           INC     DPTR
   \   000115   A3           INC     DPTR
   \   000116   A3           INC     DPTR
   \   000117   E0           MOVX    A,@DPTR
   \   000118   F8           MOV     R0,A
   \   000119   A3           INC     DPTR
   \   00011A   E0           MOVX    A,@DPTR
   \   00011B   F9           MOV     R1,A
   \   00011C   E8           MOV     A,R0
   \   00011D   FE           MOV     R6,A
   \   00011E   E9           MOV     A,R1
   \   00011F   FF           MOV     R7,A
   3163              dataPtr = (uint8 *)( (uint8 *)readReportCfgRspCmd + hdrLen );
   \   000120   85....       MOV     ?V0 + 0,?V0 + 5
   \   000123   75..00       MOV     ?V0 + 1,#0x0
   \   000126   E5..         MOV     A,?V0 + 8
   \   000128   25..         ADD     A,?V0 + 0
   \   00012A   F8           MOV     R0,A
   \   00012B   E5..         MOV     A,?V0 + 9
   \   00012D   35..         ADDC    A,?V0 + 1
   \   00012F   F9           MOV     R1,A
   \   000130   88..         MOV     ?V0 + 6,R0
   \   000132   89..         MOV     ?V0 + 7,R1
   3164          
   3165              readReportCfgRspCmd->numAttr = numAttr;
   \   000134   E5..         MOV     A,?V0 + 3
   \   000136   85..82       MOV     DPL,?V0 + 8
   \   000139   85..83       MOV     DPH,?V0 + 9
   \   00013C   E5..         MOV     A,?V0 + 3
   \   00013E   F0           MOVX    @DPTR,A
   3166              for ( uint8 i = 0; i < numAttr; i++ )
   \   00013F   75..00       MOV     ?V0 + 4,#0x0
   \                     ??zclParseInReadReportCfgRspCmd_5:
   \   000142   E5..         MOV     A,?V0 + 4
   \   000144   C3           CLR     C
   \   000145   95..         SUBB    A,?V0 + 3
   \   000147   4003         JC      $+5
   \   000149   02....       LJMP    ??zclParseInReadReportCfgRspCmd_4 & 0xFFFF
   3167              {
   3168                zclReportCfgRspRec_t *reportRspRec = &(readReportCfgRspCmd->attrList[i]);
   \   00014C   E5..         MOV     A,?V0 + 4
   \   00014E   A8..         MOV     R0,?V0 + 4
   \   000150   7900         MOV     R1,#0x0
   \   000152   E8           MOV     A,R0
   \   000153   75F00D       MOV     B,#0xd
   \   000156   A4           MUL     AB
   \   000157   C8           XCH     A,R0
   \   000158   AAF0         MOV     R2,B
   \   00015A   75F000       MOV     B,#0x0
   \   00015D   A4           MUL     AB
   \   00015E   2A           ADD     A,R2
   \   00015F   FA           MOV     R2,A
   \   000160   75F00D       MOV     B,#0xd
   \   000163   E9           MOV     A,R1
   \   000164   A4           MUL     AB
   \   000165   2A           ADD     A,R2
   \   000166   F9           MOV     R1,A
   \   000167   E5..         MOV     A,?V0 + 8
   \   000169   28           ADD     A,R0
   \   00016A   F582         MOV     DPL,A
   \   00016C   E5..         MOV     A,?V0 + 9
   \   00016E   39           ADDC    A,R1
   \   00016F   F583         MOV     DPH,A
   \   000171   A3           INC     DPTR
   \   000172   8582..       MOV     ?V0 + 0,DPL
   \   000175   8583..       MOV     ?V0 + 1,DPH
   3169          
   3170                reportRspRec->status = *pBuf++;
   \   000178   8E82         MOV     DPL,R6
   \   00017A   8F83         MOV     DPH,R7
   \   00017C   E0           MOVX    A,@DPTR
   \   00017D   85..82       MOV     DPL,?V0 + 0
   \   000180   85..83       MOV     DPH,?V0 + 1
   \   000183   F0           MOVX    @DPTR,A
   \   000184   8E82         MOV     DPL,R6
   \   000186   8F83         MOV     DPH,R7
   \   000188   A3           INC     DPTR
   \   000189   AE82         MOV     R6,DPL
   \   00018B   AF83         MOV     R7,DPH
   3171                reportRspRec->direction = *pBuf++;
   \   00018D   8E82         MOV     DPL,R6
   \   00018F   8F83         MOV     DPH,R7
   \   000191   E0           MOVX    A,@DPTR
   \   000192   85..82       MOV     DPL,?V0 + 0
   \   000195   85..83       MOV     DPH,?V0 + 1
   \   000198   A3           INC     DPTR
   \   000199   F0           MOVX    @DPTR,A
   \   00019A   8E82         MOV     DPL,R6
   \   00019C   8F83         MOV     DPH,R7
   \   00019E   A3           INC     DPTR
   \   00019F   AE82         MOV     R6,DPL
   \   0001A1   AF83         MOV     R7,DPH
   3172                reportRspRec->attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   \   0001A3   8E82         MOV     DPL,R6
   \   0001A5   8F83         MOV     DPH,R7
   \   0001A7   E0           MOVX    A,@DPTR
   \   0001A8   FA           MOV     R2,A
   \   0001A9   7B00         MOV     R3,#0x0
   \   0001AB   8E82         MOV     DPL,R6
   \   0001AD   8F83         MOV     DPH,R7
   \   0001AF   A3           INC     DPTR
   \   0001B0   E0           MOVX    A,@DPTR
   \   0001B1   F8           MOV     R0,A
   \   0001B2   7900         MOV     R1,#0x0
   \   0001B4   E4           CLR     A
   \   0001B5   C8           XCH     A,R0
   \   0001B6   F9           MOV     R1,A
   \   0001B7   EA           MOV     A,R2
   \   0001B8   28           ADD     A,R0
   \   0001B9   F8           MOV     R0,A
   \   0001BA   EB           MOV     A,R3
   \   0001BB   39           ADDC    A,R1
   \   0001BC   F9           MOV     R1,A
   \   0001BD   85..82       MOV     DPL,?V0 + 0
   \   0001C0   85..83       MOV     DPH,?V0 + 1
   \   0001C3   A3           INC     DPTR
   \   0001C4   A3           INC     DPTR
   \   0001C5   E8           MOV     A,R0
   \   0001C6   F0           MOVX    @DPTR,A
   \   0001C7   A3           INC     DPTR
   \   0001C8   E9           MOV     A,R1
   \   0001C9   F0           MOVX    @DPTR,A
   3173                pBuf += 2;
   \   0001CA   EE           MOV     A,R6
   \   0001CB   2402         ADD     A,#0x2
   \   0001CD   FE           MOV     R6,A
   \   0001CE   EF           MOV     A,R7
   \   0001CF   3400         ADDC    A,#0x0
   \   0001D1   FF           MOV     R7,A
   3174          
   3175                if ( reportRspRec->status == ZCL_STATUS_SUCCESS )
   \   0001D2   85..82       MOV     DPL,?V0 + 0
   \   0001D5   85..83       MOV     DPH,?V0 + 1
   \   0001D8   E0           MOVX    A,@DPTR
   \   0001D9   6003         JZ      $+5
   \   0001DB   02....       LJMP    ??zclParseInReadReportCfgRspCmd_6 & 0xFFFF
   3176                {
   3177                  if ( reportRspRec->direction == ZCL_SEND_ATTR_REPORTS )
   \   0001DE   85..82       MOV     DPL,?V0 + 0
   \   0001E1   85..83       MOV     DPH,?V0 + 1
   \   0001E4   A3           INC     DPTR
   \   0001E5   E0           MOVX    A,@DPTR
   \   0001E6   6003         JZ      $+5
   \   0001E8   02....       LJMP    ??zclParseInReadReportCfgRspCmd_7 & 0xFFFF
   3178                  {
   3179                    reportRspRec->dataType = *pBuf++;
   \   0001EB   8E82         MOV     DPL,R6
   \   0001ED   8F83         MOV     DPH,R7
   \   0001EF   E0           MOVX    A,@DPTR
   \   0001F0   85..82       MOV     DPL,?V0 + 0
   \   0001F3   85..83       MOV     DPH,?V0 + 1
   \   0001F6   A3           INC     DPTR
   \   0001F7   A3           INC     DPTR
   \   0001F8   A3           INC     DPTR
   \   0001F9   A3           INC     DPTR
   \   0001FA   F0           MOVX    @DPTR,A
   \   0001FB   8E82         MOV     DPL,R6
   \   0001FD   8F83         MOV     DPH,R7
   \   0001FF   A3           INC     DPTR
   \   000200   AE82         MOV     R6,DPL
   \   000202   AF83         MOV     R7,DPH
   3180                    reportRspRec->minReportInt = BUILD_UINT16( pBuf[0], pBuf[1] );
   \   000204   8E82         MOV     DPL,R6
   \   000206   8F83         MOV     DPH,R7
   \   000208   E0           MOVX    A,@DPTR
   \   000209   FA           MOV     R2,A
   \   00020A   7B00         MOV     R3,#0x0
   \   00020C   8E82         MOV     DPL,R6
   \   00020E   8F83         MOV     DPH,R7
   \   000210   A3           INC     DPTR
   \   000211   E0           MOVX    A,@DPTR
   \   000212   F8           MOV     R0,A
   \   000213   7900         MOV     R1,#0x0
   \   000215   E4           CLR     A
   \   000216   C8           XCH     A,R0
   \   000217   F9           MOV     R1,A
   \   000218   EA           MOV     A,R2
   \   000219   28           ADD     A,R0
   \   00021A   F8           MOV     R0,A
   \   00021B   EB           MOV     A,R3
   \   00021C   39           ADDC    A,R1
   \   00021D   F9           MOV     R1,A
   \   00021E   85..82       MOV     DPL,?V0 + 0
   \   000221   85..83       MOV     DPH,?V0 + 1
   \   000224   A3           INC     DPTR
   \   000225   A3           INC     DPTR
   \   000226   A3           INC     DPTR
   \   000227   A3           INC     DPTR
   \   000228   A3           INC     DPTR
   \   000229   E8           MOV     A,R0
   \   00022A   F0           MOVX    @DPTR,A
   \   00022B   A3           INC     DPTR
   \   00022C   E9           MOV     A,R1
   \   00022D   F0           MOVX    @DPTR,A
   3181                    pBuf += 2;
   \   00022E   EE           MOV     A,R6
   \   00022F   2402         ADD     A,#0x2
   \   000231   FE           MOV     R6,A
   \   000232   EF           MOV     A,R7
   \   000233   3400         ADDC    A,#0x0
   \   000235   FF           MOV     R7,A
   3182                    reportRspRec->maxReportInt = BUILD_UINT16( pBuf[0], pBuf[1] );
   \   000236   8E82         MOV     DPL,R6
   \   000238   8F83         MOV     DPH,R7
   \   00023A   E0           MOVX    A,@DPTR
   \   00023B   FA           MOV     R2,A
   \   00023C   7B00         MOV     R3,#0x0
   \   00023E   8E82         MOV     DPL,R6
   \   000240   8F83         MOV     DPH,R7
   \   000242   A3           INC     DPTR
   \   000243   E0           MOVX    A,@DPTR
   \   000244   F8           MOV     R0,A
   \   000245   7900         MOV     R1,#0x0
   \   000247   E4           CLR     A
   \   000248   C8           XCH     A,R0
   \   000249   F9           MOV     R1,A
   \   00024A   EA           MOV     A,R2
   \   00024B   28           ADD     A,R0
   \   00024C   F8           MOV     R0,A
   \   00024D   EB           MOV     A,R3
   \   00024E   39           ADDC    A,R1
   \   00024F   F9           MOV     R1,A
   \   000250   85..82       MOV     DPL,?V0 + 0
   \   000253   85..83       MOV     DPH,?V0 + 1
   \   000256   A3           INC     DPTR
   \   000257   A3           INC     DPTR
   \   000258   A3           INC     DPTR
   \   000259   A3           INC     DPTR
   \   00025A   A3           INC     DPTR
   \   00025B   A3           INC     DPTR
   \   00025C   A3           INC     DPTR
   \   00025D   E8           MOV     A,R0
   \   00025E   F0           MOVX    @DPTR,A
   \   00025F   A3           INC     DPTR
   \   000260   E9           MOV     A,R1
   \   000261   F0           MOVX    @DPTR,A
   3183                    pBuf += 2;
   \   000262   EE           MOV     A,R6
   \   000263   2402         ADD     A,#0x2
   \   000265   FE           MOV     R6,A
   \   000266   EF           MOV     A,R7
   \   000267   3400         ADDC    A,#0x0
   \   000269   FF           MOV     R7,A
   3184          
   3185                    if ( zclAnalogDataType( reportRspRec->dataType ) )
   \   00026A                ; Setup parameters for call to function zclAnalogDataType
   \   00026A   85..82       MOV     DPL,?V0 + 0
   \   00026D   85..83       MOV     DPH,?V0 + 1
   \   000270   A3           INC     DPTR
   \   000271   A3           INC     DPTR
   \   000272   A3           INC     DPTR
   \   000273   A3           INC     DPTR
   \   000274   E0           MOVX    A,@DPTR
   \   000275   F9           MOV     R1,A
   \   000276   12....       LCALL   ??zclAnalogDataType?relay
   \   000279   E9           MOV     A,R1
   \   00027A   7003         JNZ     $+5
   \   00027C   02....       LJMP    ??zclParseInReadReportCfgRspCmd_6 & 0xFFFF
   3186                    {
   3187                      zcl_BuildAnalogData( reportRspRec->dataType, dataPtr, pBuf);
   \   00027F                ; Setup parameters for call to function zcl_BuildAnalogData
   \   00027F   EE           MOV     A,R6
   \   000280   FC           MOV     R4,A
   \   000281   EF           MOV     A,R7
   \   000282   FD           MOV     R5,A
   \   000283   AA..         MOV     R2,?V0 + 6
   \   000285   AB..         MOV     R3,?V0 + 7
   \   000287   85..82       MOV     DPL,?V0 + 0
   \   00028A   85..83       MOV     DPH,?V0 + 1
   \   00028D   A3           INC     DPTR
   \   00028E   A3           INC     DPTR
   \   00028F   A3           INC     DPTR
   \   000290   A3           INC     DPTR
   \   000291   E0           MOVX    A,@DPTR
   \   000292   F9           MOV     R1,A
   \   000293   12....       LCALL   ??zcl_BuildAnalogData?relay
   3188                      reportRspRec->reportableChange = dataPtr;
   \   000296   E5..         MOV     A,?V0 + 0
   \   000298   240B         ADD     A,#0xb
   \   00029A   F582         MOV     DPL,A
   \   00029C   E5..         MOV     A,?V0 + 1
   \   00029E   3400         ADDC    A,#0x0
   \   0002A0   F583         MOV     DPH,A
   \   0002A2   E5..         MOV     A,?V0 + 6
   \   0002A4   F0           MOVX    @DPTR,A
   \   0002A5   A3           INC     DPTR
   \   0002A6   E5..         MOV     A,?V0 + 7
   \   0002A8   F0           MOVX    @DPTR,A
   3189          
   3190                      reportChangeLen = zclGetDataTypeLength( reportRspRec->dataType );
   \   0002A9                ; Setup parameters for call to function zclGetDataTypeLength
   \   0002A9   85..82       MOV     DPL,?V0 + 0
   \   0002AC   85..83       MOV     DPH,?V0 + 1
   \   0002AF   A3           INC     DPTR
   \   0002B0   A3           INC     DPTR
   \   0002B1   A3           INC     DPTR
   \   0002B2   A3           INC     DPTR
   \   0002B3   E0           MOVX    A,@DPTR
   \   0002B4   F9           MOV     R1,A
   \   0002B5   12....       LCALL   ??zclGetDataTypeLength?relay
   \   0002B8   E9           MOV     A,R1
   \   0002B9   F5..         MOV     ?V0 + 2,A
   3191                      pBuf += reportChangeLen;
   \   0002BB   85....       MOV     ?V0 + 10,?V0 + 2
   \   0002BE   75..00       MOV     ?V0 + 11,#0x0
   \   0002C1   EE           MOV     A,R6
   \   0002C2   25..         ADD     A,?V0 + 10
   \   0002C4   FE           MOV     R6,A
   \   0002C5   EF           MOV     A,R7
   \   0002C6   35..         ADDC    A,?V0 + 11
   \   0002C8   FF           MOV     R7,A
   3192          
   3193                      // advance attribute data pointer
   3194                      if ( PADDING_NEEDED( reportChangeLen ) )
   \   0002C9   E5..         MOV     A,?V0 + 2
   \   0002CB   75F002       MOV     B,#0x2
   \   0002CE   84           DIV     AB
   \   0002CF   E5F0         MOV     A,B
   \   0002D1   6002         JZ      ??zclParseInReadReportCfgRspCmd_8
   3195                      {
   3196                        reportChangeLen++;
   \   0002D3   05..         INC     ?V0 + 2
   3197                      }
   3198          
   3199                      dataPtr += reportChangeLen;
   \                     ??zclParseInReadReportCfgRspCmd_8:
   \   0002D5   85....       MOV     ?V0 + 10,?V0 + 2
   \   0002D8   75..00       MOV     ?V0 + 11,#0x0
   \   0002DB   E5..         MOV     A,?V0 + 6
   \   0002DD   25..         ADD     A,?V0 + 10
   \   0002DF   F5..         MOV     ?V0 + 6,A
   \   0002E1   E5..         MOV     A,?V0 + 7
   \   0002E3   35..         ADDC    A,?V0 + 11
   \   0002E5   F5..         MOV     ?V0 + 7,A
   \   0002E7   8036         SJMP    ??zclParseInReadReportCfgRspCmd_6
   3200                    }
   3201                  }
   3202                  else
   3203                  {
   3204                    reportRspRec->timeoutPeriod = BUILD_UINT16( pBuf[0], pBuf[1] );
   \                     ??zclParseInReadReportCfgRspCmd_7:
   \   0002E9   8E82         MOV     DPL,R6
   \   0002EB   8F83         MOV     DPH,R7
   \   0002ED   E0           MOVX    A,@DPTR
   \   0002EE   FA           MOV     R2,A
   \   0002EF   7B00         MOV     R3,#0x0
   \   0002F1   8E82         MOV     DPL,R6
   \   0002F3   8F83         MOV     DPH,R7
   \   0002F5   A3           INC     DPTR
   \   0002F6   E0           MOVX    A,@DPTR
   \   0002F7   F8           MOV     R0,A
   \   0002F8   7900         MOV     R1,#0x0
   \   0002FA   E4           CLR     A
   \   0002FB   C8           XCH     A,R0
   \   0002FC   F9           MOV     R1,A
   \   0002FD   EA           MOV     A,R2
   \   0002FE   28           ADD     A,R0
   \   0002FF   F8           MOV     R0,A
   \   000300   EB           MOV     A,R3
   \   000301   39           ADDC    A,R1
   \   000302   F9           MOV     R1,A
   \   000303   85..82       MOV     DPL,?V0 + 0
   \   000306   85..83       MOV     DPH,?V0 + 1
   \   000309   A3           INC     DPTR
   \   00030A   A3           INC     DPTR
   \   00030B   A3           INC     DPTR
   \   00030C   A3           INC     DPTR
   \   00030D   A3           INC     DPTR
   \   00030E   A3           INC     DPTR
   \   00030F   A3           INC     DPTR
   \   000310   A3           INC     DPTR
   \   000311   A3           INC     DPTR
   \   000312   E8           MOV     A,R0
   \   000313   F0           MOVX    @DPTR,A
   \   000314   A3           INC     DPTR
   \   000315   E9           MOV     A,R1
   \   000316   F0           MOVX    @DPTR,A
   3205                    pBuf += 2;
   \   000317   EE           MOV     A,R6
   \   000318   2402         ADD     A,#0x2
   \   00031A   FE           MOV     R6,A
   \   00031B   EF           MOV     A,R7
   \   00031C   3400         ADDC    A,#0x0
   \   00031E   FF           MOV     R7,A
   3206                  }
   3207                }
   3208              }
   \                     ??zclParseInReadReportCfgRspCmd_6:
   \   00031F   05..         INC     ?V0 + 4
   \   000321   02....       LJMP    ??zclParseInReadReportCfgRspCmd_5 & 0xFFFF
   3209            }
   3210          
   3211            return ( (void *)readReportCfgRspCmd );
   \                     ??zclParseInReadReportCfgRspCmd_4:
   \   000324   AA..         MOV     R2,?V0 + 8
   \   000326   AB..         MOV     R3,?V0 + 9
   \   000328   7F10         MOV     R7,#0x10
   \   00032A   02....       LJMP    ?BANKED_LEAVE_XDATA
   3212          }
   3213          
   3214          /*********************************************************************
   3215           * @fn      zclParseInReportCmd
   3216           *
   3217           * @brief   Parse the "Profile" Report Command
   3218           *
   3219           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   3220           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   3221           *
   3222           * @param   pCmd - pointer to incoming data to parse
   3223           *
   3224           * @return  pointer to the parsed command structure
   3225           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3226          void *zclParseInReportCmd( zclParseCmd_t *pCmd )
   \                     zclParseInReportCmd:
   3227          {
   \   000000   74E8         MOV     A,#-0x18
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 24
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V0 + 14,R2
   \   00000C   8B..         MOV     ?V0 + 15,R3
   3228            zclReportCmd_t *reportCmd;
   3229            uint8 *pBuf = pCmd->pData;
   \   00000E   85..82       MOV     DPL,?V0 + 14
   \   000011   85..83       MOV     DPH,?V0 + 15
   \   000014   A3           INC     DPTR
   \   000015   A3           INC     DPTR
   \   000016   A3           INC     DPTR
   \   000017   E0           MOVX    A,@DPTR
   \   000018   FE           MOV     R6,A
   \   000019   A3           INC     DPTR
   \   00001A   E0           MOVX    A,@DPTR
   \   00001B   FF           MOV     R7,A
   3230            uint16 attrDataLen;
   3231            uint8 *dataPtr;
   3232            uint8 numAttr = 0;
   \   00001C   75..00       MOV     ?V0 + 7,#0x0
   3233            uint8 hdrLen;
   3234            uint16 dataLen = 0;
   \   00001F   85..82       MOV     DPL,?XSP + 0
   \   000022   85..83       MOV     DPH,?XSP + 1
   \   000025   7400         MOV     A,#0x0
   \   000027   F0           MOVX    @DPTR,A
   \   000028   A3           INC     DPTR
   \   000029   7400         MOV     A,#0x0
   \   00002B   F0           MOVX    @DPTR,A
   3235          
   3236            // find out the number of attributes and the length of attribute data
   3237            while ( pBuf < ( pCmd->pData + pCmd->dataLen ) )
   \                     ??zclParseInReportCmd_0:
   \   00002C   85..82       MOV     DPL,?V0 + 14
   \   00002F   85..83       MOV     DPH,?V0 + 15
   \   000032   A3           INC     DPTR
   \   000033   E0           MOVX    A,@DPTR
   \   000034   F8           MOV     R0,A
   \   000035   A3           INC     DPTR
   \   000036   E0           MOVX    A,@DPTR
   \   000037   F9           MOV     R1,A
   \   000038   85..82       MOV     DPL,?V0 + 14
   \   00003B   85..83       MOV     DPH,?V0 + 15
   \   00003E   A3           INC     DPTR
   \   00003F   A3           INC     DPTR
   \   000040   A3           INC     DPTR
   \   000041   E0           MOVX    A,@DPTR
   \   000042   28           ADD     A,R0
   \   000043   F8           MOV     R0,A
   \   000044   A3           INC     DPTR
   \   000045   E0           MOVX    A,@DPTR
   \   000046   39           ADDC    A,R1
   \   000047   F9           MOV     R1,A
   \   000048   C3           CLR     C
   \   000049   EE           MOV     A,R6
   \   00004A   98           SUBB    A,R0
   \   00004B   EF           MOV     A,R7
   \   00004C   99           SUBB    A,R1
   \   00004D   5058         JNC     ??zclParseInReportCmd_1
   3238            {
   3239              uint8 dataType;
   3240          
   3241              numAttr++;
   \   00004F   05..         INC     ?V0 + 7
   3242              pBuf += 2; // move pass attribute id
   \   000051   EE           MOV     A,R6
   \   000052   2402         ADD     A,#0x2
   \   000054   FE           MOV     R6,A
   \   000055   EF           MOV     A,R7
   \   000056   3400         ADDC    A,#0x0
   \   000058   FF           MOV     R7,A
   3243          
   3244              dataType = *pBuf++;
   \   000059   8E82         MOV     DPL,R6
   \   00005B   8F83         MOV     DPH,R7
   \   00005D   E0           MOVX    A,@DPTR
   \   00005E   F5..         MOV     ?V0 + 6,A
   \   000060   8E82         MOV     DPL,R6
   \   000062   8F83         MOV     DPH,R7
   \   000064   A3           INC     DPTR
   \   000065   AE82         MOV     R6,DPL
   \   000067   AF83         MOV     R7,DPH
   3245          
   3246              attrDataLen = zclGetAttrDataLength( dataType, pBuf );
   \   000069                ; Setup parameters for call to function zclGetAttrDataLength
   \   000069   EE           MOV     A,R6
   \   00006A   FA           MOV     R2,A
   \   00006B   EF           MOV     A,R7
   \   00006C   FB           MOV     R3,A
   \   00006D   A9..         MOV     R1,?V0 + 6
   \   00006F   12....       LCALL   ??zclGetAttrDataLength?relay
   \   000072   8A..         MOV     ?V0 + 4,R2
   \   000074   8B..         MOV     ?V0 + 5,R3
   \   000076   85....       MOV     ?V0 + 0,?V0 + 4
   \   000079   85....       MOV     ?V0 + 1,?V0 + 5
   3247              pBuf += attrDataLen; // move pass attribute data
   \   00007C   EE           MOV     A,R6
   \   00007D   25..         ADD     A,?V0 + 0
   \   00007F   FE           MOV     R6,A
   \   000080   EF           MOV     A,R7
   \   000081   35..         ADDC    A,?V0 + 1
   \   000083   FF           MOV     R7,A
   3248          
   3249              // add padding if needed
   3250              if ( PADDING_NEEDED( attrDataLen ) )
   \   000084   E5..         MOV     A,?V0 + 0
   \   000086   A2E0         MOV     C,0xE0 /* A   */.0
   \   000088   500C         JNC     ??zclParseInReportCmd_2
   3251              {
   3252                attrDataLen++;
   \   00008A   E5..         MOV     A,?V0 + 0
   \   00008C   2401         ADD     A,#0x1
   \   00008E   F5..         MOV     ?V0 + 0,A
   \   000090   E5..         MOV     A,?V0 + 1
   \   000092   3400         ADDC    A,#0x0
   \   000094   F5..         MOV     ?V0 + 1,A
   3253              }
   3254          
   3255              dataLen += attrDataLen;
   \                     ??zclParseInReportCmd_2:
   \   000096   85..82       MOV     DPL,?XSP + 0
   \   000099   85..83       MOV     DPH,?XSP + 1
   \   00009C   E0           MOVX    A,@DPTR
   \   00009D   25..         ADD     A,?V0 + 0
   \   00009F   F0           MOVX    @DPTR,A
   \   0000A0   A3           INC     DPTR
   \   0000A1   E0           MOVX    A,@DPTR
   \   0000A2   35..         ADDC    A,?V0 + 1
   \   0000A4   F0           MOVX    @DPTR,A
   \   0000A5   8085         SJMP    ??zclParseInReportCmd_0
   3256            }
   3257          
   3258            hdrLen = sizeof( zclReportCmd_t ) + ( numAttr * sizeof( zclReport_t ) );
   \                     ??zclParseInReportCmd_1:
   \   0000A7   75F005       MOV     B,#0x5
   \   0000AA   E5..         MOV     A,?V0 + 7
   \   0000AC   A4           MUL     AB
   \   0000AD   2401         ADD     A,#0x1
   \   0000AF   F5..         MOV     ?V0 + 9,A
   3259          
   3260            reportCmd = (zclReportCmd_t *)osal_mem_alloc( hdrLen + dataLen );
   \   0000B1                ; Setup parameters for call to function osal_mem_alloc
   \   0000B1   85....       MOV     ?V0 + 4,?V0 + 9
   \   0000B4   75..00       MOV     ?V0 + 5,#0x0
   \   0000B7   85..82       MOV     DPL,?XSP + 0
   \   0000BA   85..83       MOV     DPH,?XSP + 1
   \   0000BD   E0           MOVX    A,@DPTR
   \   0000BE   25..         ADD     A,?V0 + 4
   \   0000C0   FA           MOV     R2,A
   \   0000C1   A3           INC     DPTR
   \   0000C2   E0           MOVX    A,@DPTR
   \   0000C3   35..         ADDC    A,?V0 + 5
   \   0000C5   FB           MOV     R3,A
   \   0000C6   12....       LCALL   ??osal_mem_alloc?relay
   \   0000C9   8A..         MOV     ?V0 + 4,R2
   \   0000CB   8B..         MOV     ?V0 + 5,R3
   \   0000CD   85....       MOV     ?V0 + 10,?V0 + 4
   \   0000D0   85....       MOV     ?V0 + 11,?V0 + 5
   3261            if (reportCmd != NULL )
   \   0000D3   E5..         MOV     A,?V0 + 10
   \   0000D5   45..         ORL     A,?V0 + 11
   \   0000D7   7003         JNZ     $+5
   \   0000D9   02....       LJMP    ??zclParseInReportCmd_3 & 0xFFFF
   3262            {
   3263              pBuf = pCmd->pData;
   \   0000DC   85..82       MOV     DPL,?V0 + 14
   \   0000DF   85..83       MOV     DPH,?V0 + 15
   \   0000E2   A3           INC     DPTR
   \   0000E3   A3           INC     DPTR
   \   0000E4   A3           INC     DPTR
   \   0000E5   E0           MOVX    A,@DPTR
   \   0000E6   F8           MOV     R0,A
   \   0000E7   A3           INC     DPTR
   \   0000E8   E0           MOVX    A,@DPTR
   \   0000E9   F9           MOV     R1,A
   \   0000EA   E8           MOV     A,R0
   \   0000EB   FE           MOV     R6,A
   \   0000EC   E9           MOV     A,R1
   \   0000ED   FF           MOV     R7,A
   3264              dataPtr = (uint8 *)( (uint8 *)reportCmd + hdrLen );
   \   0000EE   85....       MOV     ?V0 + 4,?V0 + 9
   \   0000F1   75..00       MOV     ?V0 + 5,#0x0
   \   0000F4   E5..         MOV     A,?V0 + 10
   \   0000F6   25..         ADD     A,?V0 + 4
   \   0000F8   F8           MOV     R0,A
   \   0000F9   E5..         MOV     A,?V0 + 11
   \   0000FB   35..         ADDC    A,?V0 + 5
   \   0000FD   F9           MOV     R1,A
   \   0000FE   88..         MOV     ?V0 + 2,R0
   \   000100   89..         MOV     ?V0 + 3,R1
   3265          
   3266              reportCmd->numAttr = numAttr;
   \   000102   E5..         MOV     A,?V0 + 7
   \   000104   85..82       MOV     DPL,?V0 + 10
   \   000107   85..83       MOV     DPH,?V0 + 11
   \   00010A   E5..         MOV     A,?V0 + 7
   \   00010C   F0           MOVX    @DPTR,A
   3267              for ( uint8 i = 0; i < numAttr; i++ )
   \   00010D   75..00       MOV     ?V0 + 8,#0x0
   \                     ??zclParseInReportCmd_4:
   \   000110   E5..         MOV     A,?V0 + 8
   \   000112   C3           CLR     C
   \   000113   95..         SUBB    A,?V0 + 7
   \   000115   4003         JC      $+5
   \   000117   02....       LJMP    ??zclParseInReportCmd_3 & 0xFFFF
   3268              {
   3269                zclReport_t *reportRec = &(reportCmd->attrList[i]);
   \   00011A   E5..         MOV     A,?V0 + 8
   \   00011C   A8..         MOV     R0,?V0 + 8
   \   00011E   7900         MOV     R1,#0x0
   \   000120   E8           MOV     A,R0
   \   000121   75F005       MOV     B,#0x5
   \   000124   A4           MUL     AB
   \   000125   C8           XCH     A,R0
   \   000126   AAF0         MOV     R2,B
   \   000128   75F000       MOV     B,#0x0
   \   00012B   A4           MUL     AB
   \   00012C   2A           ADD     A,R2
   \   00012D   FA           MOV     R2,A
   \   00012E   75F005       MOV     B,#0x5
   \   000131   E9           MOV     A,R1
   \   000132   A4           MUL     AB
   \   000133   2A           ADD     A,R2
   \   000134   F9           MOV     R1,A
   \   000135   E5..         MOV     A,?V0 + 10
   \   000137   28           ADD     A,R0
   \   000138   F582         MOV     DPL,A
   \   00013A   E5..         MOV     A,?V0 + 11
   \   00013C   39           ADDC    A,R1
   \   00013D   F583         MOV     DPH,A
   \   00013F   A3           INC     DPTR
   \   000140   8582..       MOV     ?V0 + 12,DPL
   \   000143   8583..       MOV     ?V0 + 13,DPH
   3270          
   3271                reportRec->attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   \   000146   8E82         MOV     DPL,R6
   \   000148   8F83         MOV     DPH,R7
   \   00014A   E0           MOVX    A,@DPTR
   \   00014B   FA           MOV     R2,A
   \   00014C   7B00         MOV     R3,#0x0
   \   00014E   8E82         MOV     DPL,R6
   \   000150   8F83         MOV     DPH,R7
   \   000152   A3           INC     DPTR
   \   000153   E0           MOVX    A,@DPTR
   \   000154   F8           MOV     R0,A
   \   000155   7900         MOV     R1,#0x0
   \   000157   E4           CLR     A
   \   000158   C8           XCH     A,R0
   \   000159   F9           MOV     R1,A
   \   00015A   EA           MOV     A,R2
   \   00015B   28           ADD     A,R0
   \   00015C   F8           MOV     R0,A
   \   00015D   EB           MOV     A,R3
   \   00015E   39           ADDC    A,R1
   \   00015F   F9           MOV     R1,A
   \   000160   85..82       MOV     DPL,?V0 + 12
   \   000163   85..83       MOV     DPH,?V0 + 13
   \   000166   E8           MOV     A,R0
   \   000167   F0           MOVX    @DPTR,A
   \   000168   A3           INC     DPTR
   \   000169   E9           MOV     A,R1
   \   00016A   F0           MOVX    @DPTR,A
   3272                pBuf += 2;
   \   00016B   EE           MOV     A,R6
   \   00016C   2402         ADD     A,#0x2
   \   00016E   FE           MOV     R6,A
   \   00016F   EF           MOV     A,R7
   \   000170   3400         ADDC    A,#0x0
   \   000172   FF           MOV     R7,A
   3273                reportRec->dataType = *pBuf++;
   \   000173   8E82         MOV     DPL,R6
   \   000175   8F83         MOV     DPH,R7
   \   000177   E0           MOVX    A,@DPTR
   \   000178   85..82       MOV     DPL,?V0 + 12
   \   00017B   85..83       MOV     DPH,?V0 + 13
   \   00017E   A3           INC     DPTR
   \   00017F   A3           INC     DPTR
   \   000180   F0           MOVX    @DPTR,A
   \   000181   8E82         MOV     DPL,R6
   \   000183   8F83         MOV     DPH,R7
   \   000185   A3           INC     DPTR
   \   000186   AE82         MOV     R6,DPL
   \   000188   AF83         MOV     R7,DPH
   3274          
   3275                attrDataLen = zclGetAttrDataLength( reportRec->dataType, pBuf );
   \   00018A                ; Setup parameters for call to function zclGetAttrDataLength
   \   00018A   EE           MOV     A,R6
   \   00018B   FA           MOV     R2,A
   \   00018C   EF           MOV     A,R7
   \   00018D   FB           MOV     R3,A
   \   00018E   85..82       MOV     DPL,?V0 + 12
   \   000191   85..83       MOV     DPH,?V0 + 13
   \   000194   A3           INC     DPTR
   \   000195   A3           INC     DPTR
   \   000196   E0           MOVX    A,@DPTR
   \   000197   F9           MOV     R1,A
   \   000198   12....       LCALL   ??zclGetAttrDataLength?relay
   \   00019B   8A..         MOV     ?V0 + 4,R2
   \   00019D   8B..         MOV     ?V0 + 5,R3
   \   00019F   85....       MOV     ?V0 + 0,?V0 + 4
   \   0001A2   85....       MOV     ?V0 + 1,?V0 + 5
   3276                osal_memcpy( dataPtr, pBuf, attrDataLen );
   \   0001A5                ; Setup parameters for call to function osal_memcpy
   \   0001A5   8E..         MOV     ?V0 + 4,R6
   \   0001A7   8F..         MOV     ?V0 + 5,R7
   \   0001A9   75..00       MOV     ?V0 + 6,#0x0
   \   0001AC   78..         MOV     R0,#?V0 + 4
   \   0001AE   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   0001B1   AC..         MOV     R4,?V0 + 0
   \   0001B3   AD..         MOV     R5,?V0 + 1
   \   0001B5   AA..         MOV     R2,?V0 + 2
   \   0001B7   AB..         MOV     R3,?V0 + 3
   \   0001B9   12....       LCALL   ??osal_memcpy?relay
   \   0001BC   7403         MOV     A,#0x3
   \   0001BE   12....       LCALL   ?DEALLOC_XSTACK8
   3277                reportRec->attrData = dataPtr;
   \   0001C1   85..82       MOV     DPL,?V0 + 12
   \   0001C4   85..83       MOV     DPH,?V0 + 13
   \   0001C7   A3           INC     DPTR
   \   0001C8   A3           INC     DPTR
   \   0001C9   A3           INC     DPTR
   \   0001CA   E5..         MOV     A,?V0 + 2
   \   0001CC   F0           MOVX    @DPTR,A
   \   0001CD   A3           INC     DPTR
   \   0001CE   E5..         MOV     A,?V0 + 3
   \   0001D0   F0           MOVX    @DPTR,A
   3278          
   3279                pBuf += attrDataLen; // move pass attribute data
   \   0001D1   EE           MOV     A,R6
   \   0001D2   25..         ADD     A,?V0 + 0
   \   0001D4   FE           MOV     R6,A
   \   0001D5   EF           MOV     A,R7
   \   0001D6   35..         ADDC    A,?V0 + 1
   \   0001D8   FF           MOV     R7,A
   3280          
   3281                // advance attribute data pointer
   3282                if ( PADDING_NEEDED( attrDataLen ) )
   \   0001D9   E5..         MOV     A,?V0 + 0
   \   0001DB   A2E0         MOV     C,0xE0 /* A   */.0
   \   0001DD   500C         JNC     ??zclParseInReportCmd_5
   3283                {
   3284                  attrDataLen++;
   \   0001DF   E5..         MOV     A,?V0 + 0
   \   0001E1   2401         ADD     A,#0x1
   \   0001E3   F5..         MOV     ?V0 + 0,A
   \   0001E5   E5..         MOV     A,?V0 + 1
   \   0001E7   3400         ADDC    A,#0x0
   \   0001E9   F5..         MOV     ?V0 + 1,A
   3285                }
   3286          
   3287                dataPtr += attrDataLen;
   \                     ??zclParseInReportCmd_5:
   \   0001EB   E5..         MOV     A,?V0 + 2
   \   0001ED   25..         ADD     A,?V0 + 0
   \   0001EF   F5..         MOV     ?V0 + 2,A
   \   0001F1   E5..         MOV     A,?V0 + 3
   \   0001F3   35..         ADDC    A,?V0 + 1
   \   0001F5   F5..         MOV     ?V0 + 3,A
   3288              }
   \   0001F7   05..         INC     ?V0 + 8
   \   0001F9   02....       LJMP    ??zclParseInReportCmd_4 & 0xFFFF
   3289            }
   3290          
   3291            return ( (void *)reportCmd );
   \                     ??zclParseInReportCmd_3:
   \   0001FC   AA..         MOV     R2,?V0 + 10
   \   0001FE   AB..         MOV     R3,?V0 + 11
   \   000200   7402         MOV     A,#0x2
   \   000202   12....       LCALL   ?DEALLOC_XSTACK8
   \   000205   7F10         MOV     R7,#0x10
   \   000207   02....       LJMP    ?BANKED_LEAVE_XDATA
   3292          }
   3293          #endif // ZCL_REPORT
   3294          
   3295          /*********************************************************************
   3296           * @fn      zclParseInDefaultRspCmd
   3297           *
   3298           * @brief   Parse the "Profile" Default Response Command
   3299           *
   3300           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   3301           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   3302           *
   3303           * @param   pCmd - pointer to incoming data to parse
   3304           *
   3305           * @return  pointer to the parsed command structure
   3306           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3307          static void *zclParseInDefaultRspCmd( zclParseCmd_t *pCmd )
   \                     zclParseInDefaultRspCmd:
   3308          {
   \   000000   74F2         MOV     A,#-0xe
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV     ?V0 + 2,R2
   \   000007   8B..         MOV     ?V0 + 3,R3
   3309            zclDefaultRspCmd_t *defaultRspCmd;
   3310            uint8 *pBuf = pCmd->pData;
   \   000009   85..82       MOV     DPL,?V0 + 2
   \   00000C   85..83       MOV     DPH,?V0 + 3
   \   00000F   A3           INC     DPTR
   \   000010   A3           INC     DPTR
   \   000011   A3           INC     DPTR
   \   000012   E0           MOVX    A,@DPTR
   \   000013   FE           MOV     R6,A
   \   000014   A3           INC     DPTR
   \   000015   E0           MOVX    A,@DPTR
   \   000016   FF           MOV     R7,A
   3311          
   3312            defaultRspCmd = (zclDefaultRspCmd_t *)osal_mem_alloc( sizeof ( zclDefaultRspCmd_t ) );
   \   000017                ; Setup parameters for call to function osal_mem_alloc
   \   000017   7A02         MOV     R2,#0x2
   \   000019   7B00         MOV     R3,#0x0
   \   00001B   12....       LCALL   ??osal_mem_alloc?relay
   \   00001E   8A..         MOV     ?V0 + 4,R2
   \   000020   8B..         MOV     ?V0 + 5,R3
   \   000022   85....       MOV     ?V0 + 0,?V0 + 4
   \   000025   85....       MOV     ?V0 + 1,?V0 + 5
   3313            if ( defaultRspCmd != NULL )
   \   000028   E5..         MOV     A,?V0 + 0
   \   00002A   45..         ORL     A,?V0 + 1
   \   00002C   6022         JZ      ??zclParseInDefaultRspCmd_0
   3314            {
   3315              defaultRspCmd->commandID = *pBuf++;
   \   00002E   8E82         MOV     DPL,R6
   \   000030   8F83         MOV     DPH,R7
   \   000032   E0           MOVX    A,@DPTR
   \   000033   85..82       MOV     DPL,?V0 + 0
   \   000036   85..83       MOV     DPH,?V0 + 1
   \   000039   F0           MOVX    @DPTR,A
   \   00003A   8E82         MOV     DPL,R6
   \   00003C   8F83         MOV     DPH,R7
   \   00003E   A3           INC     DPTR
   \   00003F   AE82         MOV     R6,DPL
   \   000041   AF83         MOV     R7,DPH
   3316              defaultRspCmd->statusCode = *pBuf;
   \   000043   8E82         MOV     DPL,R6
   \   000045   8F83         MOV     DPH,R7
   \   000047   E0           MOVX    A,@DPTR
   \   000048   85..82       MOV     DPL,?V0 + 0
   \   00004B   85..83       MOV     DPH,?V0 + 1
   \   00004E   A3           INC     DPTR
   \   00004F   F0           MOVX    @DPTR,A
   3317            }
   3318          
   3319            return ( (void *)defaultRspCmd );
   \                     ??zclParseInDefaultRspCmd_0:
   \   000050   AA..         MOV     R2,?V0 + 0
   \   000052   AB..         MOV     R3,?V0 + 1
   \   000054   7F06         MOV     R7,#0x6
   \   000056   02....       LJMP    ?BANKED_LEAVE_XDATA
   3320          }
   3321          
   3322          #ifdef ZCL_DISCOVER
   3323          /*********************************************************************
   3324           * @fn      zclParseInDiscCmd
   3325           *
   3326           * @brief   Parse the "Profile" Discovery Commands
   3327           *
   3328           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   3329           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   3330           *
   3331           * @param   pCmd - pointer to incoming data to parse
   3332           *
   3333           * @return  pointer to the parsed command structure
   3334           */
   3335          void *zclParseInDiscCmd( zclParseCmd_t *pCmd )
   3336          {
   3337            zclDiscoverCmd_t *discoverCmd;
   3338            uint8 *pBuf = pCmd->pData;
   3339          
   3340            discoverCmd = (zclDiscoverCmd_t *)osal_mem_alloc( sizeof ( zclDiscoverCmd_t ) );
   3341            if ( discoverCmd != NULL )
   3342            {
   3343              discoverCmd->startAttr = BUILD_UINT16( pBuf[0], pBuf[1] );
   3344              pBuf += 2;
   3345              discoverCmd->maxAttrIDs = *pBuf;
   3346            }
   3347          
   3348            return ( (void *)discoverCmd );
   3349          }
   3350          
   3351          /*********************************************************************
   3352           * @fn      zclParseInDiscRspCmd
   3353           *
   3354           * @brief   Parse the "Profile" Discovery Response Commands
   3355           *
   3356           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   3357           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   3358           *
   3359           * @param   pCmd - pointer to incoming data to parse
   3360           *
   3361           * @return  pointer to the parsed command structure
   3362           */
   3363          #define ZCLDISCRSPCMD_DATALEN(a)  ((a)-1) // data len - Discovery Complete
   3364          static void *zclParseInDiscRspCmd( zclParseCmd_t *pCmd )
   3365          {
   3366            zclDiscoverRspCmd_t *discoverRspCmd;
   3367            uint8 *pBuf = pCmd->pData;
   3368            uint8 numAttr = ZCLDISCRSPCMD_DATALEN(pCmd->dataLen) / ( 2 + 1 ); // Attr ID + Data Type
   3369          
   3370            discoverRspCmd = (zclDiscoverRspCmd_t *)osal_mem_alloc( sizeof ( zclDiscoverRspCmd_t )
   3371                                                           + ( numAttr * sizeof(zclDiscoverInfo_t) ) );
   3372            if ( discoverRspCmd != NULL )
   3373            {
   3374              discoverRspCmd->discComplete = *pBuf++;
   3375              discoverRspCmd->numAttr = numAttr;
   3376          
   3377              for ( uint8 i = 0; i < numAttr; i++ )
   3378              {
   3379                discoverRspCmd->attrList[i].attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   3380                pBuf += 2;
   3381                discoverRspCmd->attrList[i].dataType = *pBuf++;;
   3382              }
   3383            }
   3384          
   3385            return ( (void *)discoverRspCmd );
   3386          }
   3387          #endif // ZCL_DISCOVER
   3388          
   3389          #ifdef ZCL_READ
   3390          /*********************************************************************
   3391           * @fn      zclProcessInReadCmd
   3392           *
   3393           * @brief   Process the "Profile" Read Command
   3394           *
   3395           * @param   pInMsg - incoming message to process
   3396           *
   3397           * @return  TRUE if command processed. FALSE, otherwise.
   3398           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3399          static uint8 zclProcessInReadCmd( zclIncoming_t *pInMsg )
   \                     zclProcessInReadCmd:
   3400          {
   \   000000   74EC         MOV     A,#-0x14
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 20
   \   000005                ; Auto size: 8
   \   000005   74F8         MOV     A,#-0x8
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   3401            zclReadCmd_t *readCmd;
   3402            zclReadRspCmd_t *readRspCmd;
   3403            zclAttrRec_t attrRec;
   3404            uint16 len;
   3405          
   3406            readCmd = (zclReadCmd_t *)pInMsg->attrCmd;
   \   00000E   EE           MOV     A,R6
   \   00000F   240C         ADD     A,#0xc
   \   000011   F582         MOV     DPL,A
   \   000013   EF           MOV     A,R7
   \   000014   3400         ADDC    A,#0x0
   \   000016   F583         MOV     DPH,A
   \   000018   E0           MOVX    A,@DPTR
   \   000019   F8           MOV     R0,A
   \   00001A   A3           INC     DPTR
   \   00001B   E0           MOVX    A,@DPTR
   \   00001C   F9           MOV     R1,A
   \   00001D   88..         MOV     ?V0 + 4,R0
   \   00001F   89..         MOV     ?V0 + 5,R1
   3407          
   3408            // calculate the length of the response status record
   3409            len = sizeof( zclReadRspCmd_t ) + (readCmd->numAttr * sizeof( zclReadRspStatus_t ));
   \   000021   85..82       MOV     DPL,?V0 + 4
   \   000024   85..83       MOV     DPH,?V0 + 5
   \   000027   E0           MOVX    A,@DPTR
   \   000028   F8           MOV     R0,A
   \   000029   7900         MOV     R1,#0x0
   \   00002B   E8           MOV     A,R0
   \   00002C   75F006       MOV     B,#0x6
   \   00002F   A4           MUL     AB
   \   000030   C8           XCH     A,R0
   \   000031   AAF0         MOV     R2,B
   \   000033   75F000       MOV     B,#0x0
   \   000036   A4           MUL     AB
   \   000037   2A           ADD     A,R2
   \   000038   FA           MOV     R2,A
   \   000039   75F006       MOV     B,#0x6
   \   00003C   E9           MOV     A,R1
   \   00003D   A4           MUL     AB
   \   00003E   2A           ADD     A,R2
   \   00003F   F9           MOV     R1,A
   \   000040   E8           MOV     A,R0
   \   000041   2401         ADD     A,#0x1
   \   000043   F8           MOV     R0,A
   \   000044   E9           MOV     A,R1
   \   000045   3400         ADDC    A,#0x0
   \   000047   F9           MOV     R1,A
   \   000048   88..         MOV     ?V0 + 6,R0
   \   00004A   89..         MOV     ?V0 + 7,R1
   3410          
   3411            readRspCmd = osal_mem_alloc( len );
   \   00004C                ; Setup parameters for call to function osal_mem_alloc
   \   00004C   AA..         MOV     R2,?V0 + 6
   \   00004E   AB..         MOV     R3,?V0 + 7
   \   000050   12....       LCALL   ??osal_mem_alloc?relay
   \   000053   8A..         MOV     ?V0 + 0,R2
   \   000055   8B..         MOV     ?V0 + 1,R3
   \   000057   85....       MOV     ?V0 + 8,?V0 + 0
   \   00005A   85....       MOV     ?V0 + 9,?V0 + 1
   3412            if ( readRspCmd == NULL )
   \   00005D   E5..         MOV     A,?V0 + 8
   \   00005F   45..         ORL     A,?V0 + 9
   \   000061   7005         JNZ     ??zclProcessInReadCmd_0
   3413            {
   3414              return FALSE; // EMBEDDED RETURN
   \   000063   7900         MOV     R1,#0x0
   \   000065   02....       LJMP    ??zclProcessInReadCmd_1 & 0xFFFF
   3415            }
   3416          
   3417            readRspCmd->numAttr = readCmd->numAttr;
   \                     ??zclProcessInReadCmd_0:
   \   000068   85..82       MOV     DPL,?V0 + 4
   \   00006B   85..83       MOV     DPH,?V0 + 5
   \   00006E   E0           MOVX    A,@DPTR
   \   00006F   85..82       MOV     DPL,?V0 + 8
   \   000072   85..83       MOV     DPH,?V0 + 9
   \   000075   F0           MOVX    @DPTR,A
   3418            for ( uint8 i = 0; i < readCmd->numAttr; i++ )
   \   000076   75..00       MOV     ?V0 + 0,#0x0
   \                     ??zclProcessInReadCmd_2:
   \   000079   85..82       MOV     DPL,?V0 + 4
   \   00007C   85..83       MOV     DPH,?V0 + 5
   \   00007F   E0           MOVX    A,@DPTR
   \   000080   F8           MOV     R0,A
   \   000081   E5..         MOV     A,?V0 + 0
   \   000083   C3           CLR     C
   \   000084   98           SUBB    A,R0
   \   000085   4003         JC      $+5
   \   000087   02....       LJMP    ??zclProcessInReadCmd_3 & 0xFFFF
   3419            {
   3420              zclReadRspStatus_t *statusRec = &(readRspCmd->attrList[i]);
   \   00008A   E5..         MOV     A,?V0 + 0
   \   00008C   A8..         MOV     R0,?V0 + 0
   \   00008E   7900         MOV     R1,#0x0
   \   000090   E8           MOV     A,R0
   \   000091   75F006       MOV     B,#0x6
   \   000094   A4           MUL     AB
   \   000095   C8           XCH     A,R0
   \   000096   AAF0         MOV     R2,B
   \   000098   75F000       MOV     B,#0x0
   \   00009B   A4           MUL     AB
   \   00009C   2A           ADD     A,R2
   \   00009D   FA           MOV     R2,A
   \   00009E   75F006       MOV     B,#0x6
   \   0000A1   E9           MOV     A,R1
   \   0000A2   A4           MUL     AB
   \   0000A3   2A           ADD     A,R2
   \   0000A4   F9           MOV     R1,A
   \   0000A5   E5..         MOV     A,?V0 + 8
   \   0000A7   28           ADD     A,R0
   \   0000A8   F582         MOV     DPL,A
   \   0000AA   E5..         MOV     A,?V0 + 9
   \   0000AC   39           ADDC    A,R1
   \   0000AD   F583         MOV     DPH,A
   \   0000AF   A3           INC     DPTR
   \   0000B0   8582..       MOV     ?V0 + 2,DPL
   \   0000B3   8583..       MOV     ?V0 + 3,DPH
   3421          
   3422              statusRec->attrID = readCmd->attrID[i];
   \   0000B6   E5..         MOV     A,?V0 + 0
   \   0000B8   A8..         MOV     R0,?V0 + 0
   \   0000BA   7900         MOV     R1,#0x0
   \   0000BC   E8           MOV     A,R0
   \   0000BD   75F002       MOV     B,#0x2
   \   0000C0   A4           MUL     AB
   \   0000C1   C8           XCH     A,R0
   \   0000C2   AAF0         MOV     R2,B
   \   0000C4   75F000       MOV     B,#0x0
   \   0000C7   A4           MUL     AB
   \   0000C8   2A           ADD     A,R2
   \   0000C9   FA           MOV     R2,A
   \   0000CA   75F002       MOV     B,#0x2
   \   0000CD   E9           MOV     A,R1
   \   0000CE   A4           MUL     AB
   \   0000CF   2A           ADD     A,R2
   \   0000D0   F9           MOV     R1,A
   \   0000D1   E5..         MOV     A,?V0 + 4
   \   0000D3   28           ADD     A,R0
   \   0000D4   F582         MOV     DPL,A
   \   0000D6   E5..         MOV     A,?V0 + 5
   \   0000D8   39           ADDC    A,R1
   \   0000D9   F583         MOV     DPH,A
   \   0000DB   A3           INC     DPTR
   \   0000DC   E0           MOVX    A,@DPTR
   \   0000DD   F8           MOV     R0,A
   \   0000DE   A3           INC     DPTR
   \   0000DF   E0           MOVX    A,@DPTR
   \   0000E0   F9           MOV     R1,A
   \   0000E1   85..82       MOV     DPL,?V0 + 2
   \   0000E4   85..83       MOV     DPH,?V0 + 3
   \   0000E7   E8           MOV     A,R0
   \   0000E8   F0           MOVX    @DPTR,A
   \   0000E9   A3           INC     DPTR
   \   0000EA   E9           MOV     A,R1
   \   0000EB   F0           MOVX    @DPTR,A
   3423          
   3424              if ( zclFindAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId,
   3425                                   readCmd->attrID[i], &attrRec ) )
   \   0000EC                ; Setup parameters for call to function zclFindAttrRec
   \   0000EC   85..82       MOV     DPL,?XSP + 0
   \   0000EF   85..83       MOV     DPH,?XSP + 1
   \   0000F2   8582..       MOV     ?V0 + 10,DPL
   \   0000F5   8583..       MOV     ?V0 + 11,DPH
   \   0000F8   78..         MOV     R0,#?V0 + 10
   \   0000FA   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000FD   E5..         MOV     A,?V0 + 0
   \   0000FF   A8..         MOV     R0,?V0 + 0
   \   000101   7900         MOV     R1,#0x0
   \   000103   E8           MOV     A,R0
   \   000104   75F002       MOV     B,#0x2
   \   000107   A4           MUL     AB
   \   000108   C8           XCH     A,R0
   \   000109   AAF0         MOV     R2,B
   \   00010B   75F000       MOV     B,#0x0
   \   00010E   A4           MUL     AB
   \   00010F   2A           ADD     A,R2
   \   000110   FA           MOV     R2,A
   \   000111   75F002       MOV     B,#0x2
   \   000114   E9           MOV     A,R1
   \   000115   A4           MUL     AB
   \   000116   2A           ADD     A,R2
   \   000117   F9           MOV     R1,A
   \   000118   E5..         MOV     A,?V0 + 4
   \   00011A   28           ADD     A,R0
   \   00011B   F582         MOV     DPL,A
   \   00011D   E5..         MOV     A,?V0 + 5
   \   00011F   39           ADDC    A,R1
   \   000120   F583         MOV     DPH,A
   \   000122   A3           INC     DPTR
   \   000123   E0           MOVX    A,@DPTR
   \   000124   FC           MOV     R4,A
   \   000125   A3           INC     DPTR
   \   000126   E0           MOVX    A,@DPTR
   \   000127   FD           MOV     R5,A
   \   000128   8E82         MOV     DPL,R6
   \   00012A   8F83         MOV     DPH,R7
   \   00012C   E0           MOVX    A,@DPTR
   \   00012D   F8           MOV     R0,A
   \   00012E   A3           INC     DPTR
   \   00012F   E0           MOVX    A,@DPTR
   \   000130   F583         MOV     DPH,A
   \   000132   8882         MOV     DPL,R0
   \   000134   A3           INC     DPTR
   \   000135   A3           INC     DPTR
   \   000136   A3           INC     DPTR
   \   000137   A3           INC     DPTR
   \   000138   E0           MOVX    A,@DPTR
   \   000139   FA           MOV     R2,A
   \   00013A   A3           INC     DPTR
   \   00013B   E0           MOVX    A,@DPTR
   \   00013C   FB           MOV     R3,A
   \   00013D   8E82         MOV     DPL,R6
   \   00013F   8F83         MOV     DPH,R7
   \   000141   E0           MOVX    A,@DPTR
   \   000142   F8           MOV     R0,A
   \   000143   A3           INC     DPTR
   \   000144   E0           MOVX    A,@DPTR
   \   000145   C8           XCH     A,R0
   \   000146   2414         ADD     A,#0x14
   \   000148   F582         MOV     DPL,A
   \   00014A   E8           MOV     A,R0
   \   00014B   3400         ADDC    A,#0x0
   \   00014D   F583         MOV     DPH,A
   \   00014F   E0           MOVX    A,@DPTR
   \   000150   F9           MOV     R1,A
   \   000151   12....       LCALL   ??zclFindAttrRec?relay
   \   000154   7402         MOV     A,#0x2
   \   000156   12....       LCALL   ?DEALLOC_XSTACK8
   \   000159   E9           MOV     A,R1
   \   00015A   7003         JNZ     $+5
   \   00015C   02....       LJMP    ??zclProcessInReadCmd_4 & 0xFFFF
   3426              {
   3427                if ( zcl_AccessCtrlRead( attrRec.attr.accessControl ) )
   \   00015F   7405         MOV     A,#0x5
   \   000161   12....       LCALL   ?XSTACK_DISP0_8
   \   000164   E0           MOVX    A,@DPTR
   \   000165   A2E0         MOV     C,0xE0 /* A   */.0
   \   000167   506E         JNC     ??zclProcessInReadCmd_5
   3428                {
   3429                  statusRec->status = zclAuthorizeRead( pInMsg->msg->endPoint,
   3430                                                        &(pInMsg->msg->srcAddr), &attrRec );
   \   000169                ; Setup parameters for call to function zclAuthorizeRead
   \   000169   85..82       MOV     DPL,?XSP + 0
   \   00016C   85..83       MOV     DPH,?XSP + 1
   \   00016F   AC82         MOV     R4,DPL
   \   000171   AD83         MOV     R5,DPH
   \   000173   8E82         MOV     DPL,R6
   \   000175   8F83         MOV     DPH,R7
   \   000177   E0           MOVX    A,@DPTR
   \   000178   2406         ADD     A,#0x6
   \   00017A   FA           MOV     R2,A
   \   00017B   A3           INC     DPTR
   \   00017C   E0           MOVX    A,@DPTR
   \   00017D   3400         ADDC    A,#0x0
   \   00017F   FB           MOV     R3,A
   \   000180   8E82         MOV     DPL,R6
   \   000182   8F83         MOV     DPH,R7
   \   000184   E0           MOVX    A,@DPTR
   \   000185   F8           MOV     R0,A
   \   000186   A3           INC     DPTR
   \   000187   E0           MOVX    A,@DPTR
   \   000188   C8           XCH     A,R0
   \   000189   2414         ADD     A,#0x14
   \   00018B   F582         MOV     DPL,A
   \   00018D   E8           MOV     A,R0
   \   00018E   3400         ADDC    A,#0x0
   \   000190   F583         MOV     DPH,A
   \   000192   E0           MOVX    A,@DPTR
   \   000193   F9           MOV     R1,A
   \   000194   12....       LCALL   ??zclAuthorizeRead?relay
   \   000197   E9           MOV     A,R1
   \   000198   85..82       MOV     DPL,?V0 + 2
   \   00019B   85..83       MOV     DPH,?V0 + 3
   \   00019E   A3           INC     DPTR
   \   00019F   A3           INC     DPTR
   \   0001A0   F0           MOVX    @DPTR,A
   3431                  if ( statusRec->status == ZCL_STATUS_SUCCESS )
   \   0001A1   85..82       MOV     DPL,?V0 + 2
   \   0001A4   85..83       MOV     DPH,?V0 + 3
   \   0001A7   A3           INC     DPTR
   \   0001A8   A3           INC     DPTR
   \   0001A9   E0           MOVX    A,@DPTR
   \   0001AA   7043         JNZ     ??zclProcessInReadCmd_6
   3432                  {
   3433                    statusRec->data = attrRec.attr.dataPtr;
   \   0001AC   7406         MOV     A,#0x6
   \   0001AE   12....       LCALL   ?XSTACK_DISP0_8
   \   0001B1   E0           MOVX    A,@DPTR
   \   0001B2   F8           MOV     R0,A
   \   0001B3   A3           INC     DPTR
   \   0001B4   E0           MOVX    A,@DPTR
   \   0001B5   F9           MOV     R1,A
   \   0001B6   85..82       MOV     DPL,?V0 + 2
   \   0001B9   85..83       MOV     DPH,?V0 + 3
   \   0001BC   A3           INC     DPTR
   \   0001BD   A3           INC     DPTR
   \   0001BE   A3           INC     DPTR
   \   0001BF   A3           INC     DPTR
   \   0001C0   E8           MOV     A,R0
   \   0001C1   F0           MOVX    @DPTR,A
   \   0001C2   A3           INC     DPTR
   \   0001C3   E9           MOV     A,R1
   \   0001C4   F0           MOVX    @DPTR,A
   3434                    statusRec->dataType = attrRec.attr.dataType;
   \   0001C5   7404         MOV     A,#0x4
   \   0001C7   12....       LCALL   ?XSTACK_DISP0_8
   \   0001CA   E0           MOVX    A,@DPTR
   \   0001CB   85..82       MOV     DPL,?V0 + 2
   \   0001CE   85..83       MOV     DPH,?V0 + 3
   \   0001D1   A3           INC     DPTR
   \   0001D2   A3           INC     DPTR
   \   0001D3   A3           INC     DPTR
   \   0001D4   F0           MOVX    @DPTR,A
   \   0001D5   8018         SJMP    ??zclProcessInReadCmd_6
   3435                  }
   3436                }
   3437                else
   3438                {
   3439                  statusRec->status = ZCL_STATUS_WRITE_ONLY;
   \                     ??zclProcessInReadCmd_5:
   \   0001D7   85..82       MOV     DPL,?V0 + 2
   \   0001DA   85..83       MOV     DPH,?V0 + 3
   \   0001DD   A3           INC     DPTR
   \   0001DE   A3           INC     DPTR
   \   0001DF   748F         MOV     A,#-0x71
   \   0001E1   F0           MOVX    @DPTR,A
   \   0001E2   800B         SJMP    ??zclProcessInReadCmd_6
   3440                }
   3441              }
   3442              else
   3443              {
   3444                statusRec->status = ZCL_STATUS_UNSUPPORTED_ATTRIBUTE;
   \                     ??zclProcessInReadCmd_4:
   \   0001E4   85..82       MOV     DPL,?V0 + 2
   \   0001E7   85..83       MOV     DPH,?V0 + 3
   \   0001EA   A3           INC     DPTR
   \   0001EB   A3           INC     DPTR
   \   0001EC   7486         MOV     A,#-0x7a
   \   0001EE   F0           MOVX    @DPTR,A
   3445              }
   3446            }
   \                     ??zclProcessInReadCmd_6:
   \   0001EF   05..         INC     ?V0 + 0
   \   0001F1   02....       LJMP    ??zclProcessInReadCmd_2 & 0xFFFF
   3447          
   3448            // Build and send Read Response command
   3449            zcl_SendReadRsp( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr), pInMsg->msg->clusterId,
   3450                             readRspCmd, ZCL_FRAME_SERVER_CLIENT_DIR,
   3451                             true, pInMsg->hdr.transSeqNum );
   \                     ??zclProcessInReadCmd_3:
   \   0001F4                ; Setup parameters for call to function zcl_SendReadRsp
   \   0001F4   8E82         MOV     DPL,R6
   \   0001F6   8F83         MOV     DPH,R7
   \   0001F8   A3           INC     DPTR
   \   0001F9   A3           INC     DPTR
   \   0001FA   A3           INC     DPTR
   \   0001FB   A3           INC     DPTR
   \   0001FC   A3           INC     DPTR
   \   0001FD   A3           INC     DPTR
   \   0001FE   E0           MOVX    A,@DPTR
   \   0001FF   F5..         MOV     ?V0 + 0,A
   \   000201   78..         MOV     R0,#?V0 + 0
   \   000203   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000206   75..01       MOV     ?V0 + 0,#0x1
   \   000209   78..         MOV     R0,#?V0 + 0
   \   00020B   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00020E   75..01       MOV     ?V0 + 0,#0x1
   \   000211   78..         MOV     R0,#?V0 + 0
   \   000213   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000216   78..         MOV     R0,#?V0 + 8
   \   000218   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00021B   8E82         MOV     DPL,R6
   \   00021D   8F83         MOV     DPH,R7
   \   00021F   E0           MOVX    A,@DPTR
   \   000220   F8           MOV     R0,A
   \   000221   A3           INC     DPTR
   \   000222   E0           MOVX    A,@DPTR
   \   000223   F583         MOV     DPH,A
   \   000225   8882         MOV     DPL,R0
   \   000227   A3           INC     DPTR
   \   000228   A3           INC     DPTR
   \   000229   A3           INC     DPTR
   \   00022A   A3           INC     DPTR
   \   00022B   E0           MOVX    A,@DPTR
   \   00022C   FC           MOV     R4,A
   \   00022D   A3           INC     DPTR
   \   00022E   E0           MOVX    A,@DPTR
   \   00022F   FD           MOV     R5,A
   \   000230   8E82         MOV     DPL,R6
   \   000232   8F83         MOV     DPH,R7
   \   000234   E0           MOVX    A,@DPTR
   \   000235   2406         ADD     A,#0x6
   \   000237   FA           MOV     R2,A
   \   000238   A3           INC     DPTR
   \   000239   E0           MOVX    A,@DPTR
   \   00023A   3400         ADDC    A,#0x0
   \   00023C   FB           MOV     R3,A
   \   00023D   8E82         MOV     DPL,R6
   \   00023F   8F83         MOV     DPH,R7
   \   000241   E0           MOVX    A,@DPTR
   \   000242   F8           MOV     R0,A
   \   000243   A3           INC     DPTR
   \   000244   E0           MOVX    A,@DPTR
   \   000245   C8           XCH     A,R0
   \   000246   2414         ADD     A,#0x14
   \   000248   F582         MOV     DPL,A
   \   00024A   E8           MOV     A,R0
   \   00024B   3400         ADDC    A,#0x0
   \   00024D   F583         MOV     DPH,A
   \   00024F   E0           MOVX    A,@DPTR
   \   000250   F9           MOV     R1,A
   \   000251   12....       LCALL   ??zcl_SendReadRsp?relay
   \   000254   7405         MOV     A,#0x5
   \   000256   12....       LCALL   ?DEALLOC_XSTACK8
   \   000259   E9           MOV     A,R1
   3452            osal_mem_free( readRspCmd );
   \   00025A                ; Setup parameters for call to function osal_mem_free
   \   00025A   AA..         MOV     R2,?V0 + 8
   \   00025C   AB..         MOV     R3,?V0 + 9
   \   00025E   12....       LCALL   ??osal_mem_free?relay
   3453          
   3454            return TRUE;
   \   000261   7901         MOV     R1,#0x1
   \                     ??zclProcessInReadCmd_1:
   \   000263   7408         MOV     A,#0x8
   \   000265   12....       LCALL   ?DEALLOC_XSTACK8
   \   000268   7F0C         MOV     R7,#0xc
   \   00026A   02....       LJMP    ?BANKED_LEAVE_XDATA
   3455          }
   3456          #endif // ZCL_READ
   3457          
   3458          #ifdef ZCL_WRITE
   3459          /*********************************************************************
   3460           * @fn      processInWriteCmd
   3461           *
   3462           * @brief   Process the "Profile" Write and Write No Response Commands
   3463           *
   3464           * @param   pInMsg - incoming message to process
   3465           *
   3466           * @return  TRUE if command processed. FALSE, otherwise.
   3467           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3468          static uint8 zclProcessInWriteCmd( zclIncoming_t *pInMsg )
   \                     zclProcessInWriteCmd:
   3469          {
   \   000000   74EC         MOV     A,#-0x14
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 20
   \   000005                ; Auto size: 8
   \   000005   74F8         MOV     A,#-0x8
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V0 + 0,R2
   \   00000C   8B..         MOV     ?V0 + 1,R3
   3470            zclWriteCmd_t *writeCmd;
   3471            zclWriteRspCmd_t *writeRspCmd;
   3472            uint8 sendRsp = FALSE;
   \   00000E   75..00       MOV     ?V0 + 2,#0x0
   3473            uint8 j = 0;
   \   000011   7E00         MOV     R6,#0x0
   3474          
   3475            writeCmd = (zclWriteCmd_t *)pInMsg->attrCmd;
   \   000013   E5..         MOV     A,?V0 + 0
   \   000015   240C         ADD     A,#0xc
   \   000017   F582         MOV     DPL,A
   \   000019   E5..         MOV     A,?V0 + 1
   \   00001B   3400         ADDC    A,#0x0
   \   00001D   F583         MOV     DPH,A
   \   00001F   E0           MOVX    A,@DPTR
   \   000020   F8           MOV     R0,A
   \   000021   A3           INC     DPTR
   \   000022   E0           MOVX    A,@DPTR
   \   000023   F9           MOV     R1,A
   \   000024   88..         MOV     ?V0 + 4,R0
   \   000026   89..         MOV     ?V0 + 5,R1
   3476            if ( pInMsg->hdr.commandID == ZCL_CMD_WRITE )
   \   000028   85..82       MOV     DPL,?V0 + 0
   \   00002B   85..83       MOV     DPH,?V0 + 1
   \   00002E   A3           INC     DPTR
   \   00002F   A3           INC     DPTR
   \   000030   A3           INC     DPTR
   \   000031   A3           INC     DPTR
   \   000032   A3           INC     DPTR
   \   000033   A3           INC     DPTR
   \   000034   A3           INC     DPTR
   \   000035   E0           MOVX    A,@DPTR
   \   000036   6402         XRL     A,#0x2
   \   000038   7042         JNZ     ??zclProcessInWriteCmd_0
   3477            {
   3478              // We need to send a response back - allocate space for it
   3479              writeRspCmd = (zclWriteRspCmd_t *)osal_mem_alloc( sizeof( zclWriteRspCmd_t )
   3480                      + sizeof( zclWriteRspStatus_t ) * writeCmd->numAttr );
   \   00003A                ; Setup parameters for call to function osal_mem_alloc
   \   00003A   85..82       MOV     DPL,?V0 + 4
   \   00003D   85..83       MOV     DPH,?V0 + 5
   \   000040   E0           MOVX    A,@DPTR
   \   000041   F8           MOV     R0,A
   \   000042   7900         MOV     R1,#0x0
   \   000044   E8           MOV     A,R0
   \   000045   75F003       MOV     B,#0x3
   \   000048   A4           MUL     AB
   \   000049   C8           XCH     A,R0
   \   00004A   AAF0         MOV     R2,B
   \   00004C   75F000       MOV     B,#0x0
   \   00004F   A4           MUL     AB
   \   000050   2A           ADD     A,R2
   \   000051   FA           MOV     R2,A
   \   000052   75F003       MOV     B,#0x3
   \   000055   E9           MOV     A,R1
   \   000056   A4           MUL     AB
   \   000057   2A           ADD     A,R2
   \   000058   F9           MOV     R1,A
   \   000059   E8           MOV     A,R0
   \   00005A   2401         ADD     A,#0x1
   \   00005C   FA           MOV     R2,A
   \   00005D   E9           MOV     A,R1
   \   00005E   3400         ADDC    A,#0x0
   \   000060   FB           MOV     R3,A
   \   000061   12....       LCALL   ??osal_mem_alloc?relay
   \   000064   8A..         MOV     ?V0 + 6,R2
   \   000066   8B..         MOV     ?V0 + 7,R3
   \   000068   85....       MOV     ?V0 + 8,?V0 + 6
   \   00006B   85....       MOV     ?V0 + 9,?V0 + 7
   3481              if ( writeRspCmd == NULL )
   \   00006E   E5..         MOV     A,?V0 + 8
   \   000070   45..         ORL     A,?V0 + 9
   \   000072   7005         JNZ     ??zclProcessInWriteCmd_1
   3482              {
   3483                return FALSE; // EMBEDDED RETURN
   \   000074   7900         MOV     R1,#0x0
   \   000076   02....       LJMP    ??zclProcessInWriteCmd_2 & 0xFFFF
   3484              }
   3485          
   3486              sendRsp = TRUE;
   \                     ??zclProcessInWriteCmd_1:
   \   000079   75..01       MOV     ?V0 + 2,#0x1
   3487            }
   3488          
   3489            for ( uint8 i = 0; i < writeCmd->numAttr; i++ )
   \                     ??zclProcessInWriteCmd_0:
   \   00007C   75..00       MOV     ?V0 + 3,#0x0
   \                     ??zclProcessInWriteCmd_3:
   \   00007F   85..82       MOV     DPL,?V0 + 4
   \   000082   85..83       MOV     DPH,?V0 + 5
   \   000085   E0           MOVX    A,@DPTR
   \   000086   F8           MOV     R0,A
   \   000087   E5..         MOV     A,?V0 + 3
   \   000089   C3           CLR     C
   \   00008A   98           SUBB    A,R0
   \   00008B   4003         JC      $+5
   \   00008D   02....       LJMP    ??zclProcessInWriteCmd_4 & 0xFFFF
   3490            {
   3491              zclAttrRec_t attrRec;
   3492              zclWriteRec_t *statusRec = &(writeCmd->attrList[i]);
   \   000090   E5..         MOV     A,?V0 + 3
   \   000092   A8..         MOV     R0,?V0 + 3
   \   000094   7900         MOV     R1,#0x0
   \   000096   E8           MOV     A,R0
   \   000097   75F005       MOV     B,#0x5
   \   00009A   A4           MUL     AB
   \   00009B   C8           XCH     A,R0
   \   00009C   AAF0         MOV     R2,B
   \   00009E   75F000       MOV     B,#0x0
   \   0000A1   A4           MUL     AB
   \   0000A2   2A           ADD     A,R2
   \   0000A3   FA           MOV     R2,A
   \   0000A4   75F005       MOV     B,#0x5
   \   0000A7   E9           MOV     A,R1
   \   0000A8   A4           MUL     AB
   \   0000A9   2A           ADD     A,R2
   \   0000AA   F9           MOV     R1,A
   \   0000AB   E5..         MOV     A,?V0 + 4
   \   0000AD   28           ADD     A,R0
   \   0000AE   F582         MOV     DPL,A
   \   0000B0   E5..         MOV     A,?V0 + 5
   \   0000B2   39           ADDC    A,R1
   \   0000B3   F583         MOV     DPH,A
   \   0000B5   A3           INC     DPTR
   \   0000B6   8582..       MOV     ?V0 + 6,DPL
   \   0000B9   8583..       MOV     ?V0 + 7,DPH
   3493          
   3494              if ( zclFindAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId,
   3495                                   statusRec->attrID, &attrRec ) )
   \   0000BC                ; Setup parameters for call to function zclFindAttrRec
   \   0000BC   85..82       MOV     DPL,?XSP + 0
   \   0000BF   85..83       MOV     DPH,?XSP + 1
   \   0000C2   8582..       MOV     ?V0 + 10,DPL
   \   0000C5   8583..       MOV     ?V0 + 11,DPH
   \   0000C8   78..         MOV     R0,#?V0 + 10
   \   0000CA   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000CD   85..82       MOV     DPL,?V0 + 6
   \   0000D0   85..83       MOV     DPH,?V0 + 7
   \   0000D3   E0           MOVX    A,@DPTR
   \   0000D4   FC           MOV     R4,A
   \   0000D5   A3           INC     DPTR
   \   0000D6   E0           MOVX    A,@DPTR
   \   0000D7   FD           MOV     R5,A
   \   0000D8   85..82       MOV     DPL,?V0 + 0
   \   0000DB   85..83       MOV     DPH,?V0 + 1
   \   0000DE   E0           MOVX    A,@DPTR
   \   0000DF   F8           MOV     R0,A
   \   0000E0   A3           INC     DPTR
   \   0000E1   E0           MOVX    A,@DPTR
   \   0000E2   F583         MOV     DPH,A
   \   0000E4   8882         MOV     DPL,R0
   \   0000E6   A3           INC     DPTR
   \   0000E7   A3           INC     DPTR
   \   0000E8   A3           INC     DPTR
   \   0000E9   A3           INC     DPTR
   \   0000EA   E0           MOVX    A,@DPTR
   \   0000EB   FA           MOV     R2,A
   \   0000EC   A3           INC     DPTR
   \   0000ED   E0           MOVX    A,@DPTR
   \   0000EE   FB           MOV     R3,A
   \   0000EF   85..82       MOV     DPL,?V0 + 0
   \   0000F2   85..83       MOV     DPH,?V0 + 1
   \   0000F5   E0           MOVX    A,@DPTR
   \   0000F6   F8           MOV     R0,A
   \   0000F7   A3           INC     DPTR
   \   0000F8   E0           MOVX    A,@DPTR
   \   0000F9   C8           XCH     A,R0
   \   0000FA   2414         ADD     A,#0x14
   \   0000FC   F582         MOV     DPL,A
   \   0000FE   E8           MOV     A,R0
   \   0000FF   3400         ADDC    A,#0x0
   \   000101   F583         MOV     DPH,A
   \   000103   E0           MOVX    A,@DPTR
   \   000104   F9           MOV     R1,A
   \   000105   12....       LCALL   ??zclFindAttrRec?relay
   \   000108   7402         MOV     A,#0x2
   \   00010A   12....       LCALL   ?DEALLOC_XSTACK8
   \   00010D   E9           MOV     A,R1
   \   00010E   7003         JNZ     $+5
   \   000110   02....       LJMP    ??zclProcessInWriteCmd_5 & 0xFFFF
   3496              {
   3497                if ( statusRec->dataType == attrRec.attr.dataType )
   \   000113   85..82       MOV     DPL,?V0 + 6
   \   000116   85..83       MOV     DPH,?V0 + 7
   \   000119   A3           INC     DPTR
   \   00011A   A3           INC     DPTR
   \   00011B   E0           MOVX    A,@DPTR
   \   00011C   F8           MOV     R0,A
   \   00011D   7404         MOV     A,#0x4
   \   00011F   12....       LCALL   ?XSTACK_DISP0_8
   \   000122   E0           MOVX    A,@DPTR
   \   000123   68           XRL     A,R0
   \   000124   6003         JZ      $+5
   \   000126   02....       LJMP    ??zclProcessInWriteCmd_6 & 0xFFFF
   3498                {
   3499                  uint8 status;
   3500          
   3501                  // Write the new attribute value
   3502                  if ( attrRec.attr.dataPtr != NULL )
   \   000129   7406         MOV     A,#0x6
   \   00012B   12....       LCALL   ?XSTACK_DISP0_8
   \   00012E   E0           MOVX    A,@DPTR
   \   00012F   F8           MOV     R0,A
   \   000130   A3           INC     DPTR
   \   000131   E0           MOVX    A,@DPTR
   \   000132   F9           MOV     R1,A
   \   000133   E8           MOV     A,R0
   \   000134   49           ORL     A,R1
   \   000135   603F         JZ      ??zclProcessInWriteCmd_7
   3503                  {
   3504                    status = zclWriteAttrData( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr),
   3505                                               &attrRec, statusRec );
   \   000137                ; Setup parameters for call to function zclWriteAttrData
   \   000137   78..         MOV     R0,#?V0 + 6
   \   000139   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00013C   7402         MOV     A,#0x2
   \   00013E   12....       LCALL   ?XSTACK_DISP0_8
   \   000141   AC82         MOV     R4,DPL
   \   000143   AD83         MOV     R5,DPH
   \   000145   85..82       MOV     DPL,?V0 + 0
   \   000148   85..83       MOV     DPH,?V0 + 1
   \   00014B   E0           MOVX    A,@DPTR
   \   00014C   2406         ADD     A,#0x6
   \   00014E   FA           MOV     R2,A
   \   00014F   A3           INC     DPTR
   \   000150   E0           MOVX    A,@DPTR
   \   000151   3400         ADDC    A,#0x0
   \   000153   FB           MOV     R3,A
   \   000154   85..82       MOV     DPL,?V0 + 0
   \   000157   85..83       MOV     DPH,?V0 + 1
   \   00015A   E0           MOVX    A,@DPTR
   \   00015B   F8           MOV     R0,A
   \   00015C   A3           INC     DPTR
   \   00015D   E0           MOVX    A,@DPTR
   \   00015E   C8           XCH     A,R0
   \   00015F   2414         ADD     A,#0x14
   \   000161   F582         MOV     DPL,A
   \   000163   E8           MOV     A,R0
   \   000164   3400         ADDC    A,#0x0
   \   000166   F583         MOV     DPH,A
   \   000168   E0           MOVX    A,@DPTR
   \   000169   F9           MOV     R1,A
   \   00016A   12....       LCALL   ??zclWriteAttrData?relay
   \   00016D   7402         MOV     A,#0x2
   \   00016F   12....       LCALL   ?DEALLOC_XSTACK8
   \   000172   E9           MOV     A,R1
   \   000173   FF           MOV     R7,A
   \   000174   8044         SJMP    ??zclProcessInWriteCmd_8
   3506                  }
   3507                  else // Use CB
   3508                  {
   3509                    status = zclWriteAttrDataUsingCB( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr),
   3510                                                      &attrRec, statusRec->attrData );
   \                     ??zclProcessInWriteCmd_7:
   \   000176                ; Setup parameters for call to function zclWriteAttrDataUsingCB
   \   000176   85..82       MOV     DPL,?V0 + 6
   \   000179   85..83       MOV     DPH,?V0 + 7
   \   00017C   A3           INC     DPTR
   \   00017D   A3           INC     DPTR
   \   00017E   A3           INC     DPTR
   \   00017F   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   000182   7402         MOV     A,#0x2
   \   000184   12....       LCALL   ?XSTACK_DISP0_8
   \   000187   AC82         MOV     R4,DPL
   \   000189   AD83         MOV     R5,DPH
   \   00018B   85..82       MOV     DPL,?V0 + 0
   \   00018E   85..83       MOV     DPH,?V0 + 1
   \   000191   E0           MOVX    A,@DPTR
   \   000192   2406         ADD     A,#0x6
   \   000194   FA           MOV     R2,A
   \   000195   A3           INC     DPTR
   \   000196   E0           MOVX    A,@DPTR
   \   000197   3400         ADDC    A,#0x0
   \   000199   FB           MOV     R3,A
   \   00019A   85..82       MOV     DPL,?V0 + 0
   \   00019D   85..83       MOV     DPH,?V0 + 1
   \   0001A0   E0           MOVX    A,@DPTR
   \   0001A1   F8           MOV     R0,A
   \   0001A2   A3           INC     DPTR
   \   0001A3   E0           MOVX    A,@DPTR
   \   0001A4   C8           XCH     A,R0
   \   0001A5   2414         ADD     A,#0x14
   \   0001A7   F582         MOV     DPL,A
   \   0001A9   E8           MOV     A,R0
   \   0001AA   3400         ADDC    A,#0x0
   \   0001AC   F583         MOV     DPH,A
   \   0001AE   E0           MOVX    A,@DPTR
   \   0001AF   F9           MOV     R1,A
   \   0001B0   12....       LCALL   ??zclWriteAttrDataUsingCB?relay
   \   0001B3   7402         MOV     A,#0x2
   \   0001B5   12....       LCALL   ?DEALLOC_XSTACK8
   \   0001B8   E9           MOV     A,R1
   \   0001B9   FF           MOV     R7,A
   3511                  }
   3512          
   3513                  // If successful, a write attribute status record shall NOT be generated
   3514                  if ( sendRsp && status != ZCL_STATUS_SUCCESS )
   \                     ??zclProcessInWriteCmd_8:
   \   0001BA   E5..         MOV     A,?V0 + 2
   \   0001BC   7003         JNZ     $+5
   \   0001BE   02....       LJMP    ??zclProcessInWriteCmd_9 & 0xFFFF
   \   0001C1   EF           MOV     A,R7
   \   0001C2   7003         JNZ     $+5
   \   0001C4   02....       LJMP    ??zclProcessInWriteCmd_9 & 0xFFFF
   3515                  {
   3516                    // Attribute is read only - move on to the next write attribute record
   3517                    writeRspCmd->attrList[j].status = status;
   \   0001C7   EF           MOV     A,R7
   \   0001C8   C0E0         PUSH    A
   \   0001CA   EE           MOV     A,R6
   \   0001CB   F8           MOV     R0,A
   \   0001CC   7900         MOV     R1,#0x0
   \   0001CE   E8           MOV     A,R0
   \   0001CF   75F003       MOV     B,#0x3
   \   0001D2   A4           MUL     AB
   \   0001D3   C8           XCH     A,R0
   \   0001D4   AAF0         MOV     R2,B
   \   0001D6   75F000       MOV     B,#0x0
   \   0001D9   A4           MUL     AB
   \   0001DA   2A           ADD     A,R2
   \   0001DB   FA           MOV     R2,A
   \   0001DC   75F003       MOV     B,#0x3
   \   0001DF   E9           MOV     A,R1
   \   0001E0   A4           MUL     AB
   \   0001E1   2A           ADD     A,R2
   \   0001E2   F9           MOV     R1,A
   \   0001E3   E5..         MOV     A,?V0 + 8
   \   0001E5   28           ADD     A,R0
   \   0001E6   F582         MOV     DPL,A
   \   0001E8   E5..         MOV     A,?V0 + 9
   \   0001EA   39           ADDC    A,R1
   \   0001EB   F583         MOV     DPH,A
   \   0001ED   A3           INC     DPTR
   \   0001EE   D0E0         POP     A
   \   0001F0   F0           MOVX    @DPTR,A
   3518                    writeRspCmd->attrList[j++].attrID = statusRec->attrID;
   \   0001F1   85..82       MOV     DPL,?V0 + 6
   \   0001F4   85..83       MOV     DPH,?V0 + 7
   \   0001F7   E0           MOVX    A,@DPTR
   \   0001F8   FA           MOV     R2,A
   \   0001F9   A3           INC     DPTR
   \   0001FA   E0           MOVX    A,@DPTR
   \   0001FB   FB           MOV     R3,A
   \   0001FC   EE           MOV     A,R6
   \   0001FD   F8           MOV     R0,A
   \   0001FE   7900         MOV     R1,#0x0
   \   000200   E8           MOV     A,R0
   \   000201   75F003       MOV     B,#0x3
   \   000204   A4           MUL     AB
   \   000205   C8           XCH     A,R0
   \   000206   ACF0         MOV     R4,B
   \   000208   75F000       MOV     B,#0x0
   \   00020B   A4           MUL     AB
   \   00020C   2C           ADD     A,R4
   \   00020D   FC           MOV     R4,A
   \   00020E   75F003       MOV     B,#0x3
   \   000211   E9           MOV     A,R1
   \   000212   A4           MUL     AB
   \   000213   2C           ADD     A,R4
   \   000214   F9           MOV     R1,A
   \   000215   E5..         MOV     A,?V0 + 8
   \   000217   28           ADD     A,R0
   \   000218   F582         MOV     DPL,A
   \   00021A   E5..         MOV     A,?V0 + 9
   \   00021C   39           ADDC    A,R1
   \   00021D   F583         MOV     DPH,A
   \   00021F   A3           INC     DPTR
   \   000220   A3           INC     DPTR
   \   000221   EA           MOV     A,R2
   \   000222   F0           MOVX    @DPTR,A
   \   000223   A3           INC     DPTR
   \   000224   EB           MOV     A,R3
   \   000225   F0           MOVX    @DPTR,A
   \   000226   0E           INC     R6
   \   000227   02....       LJMP    ??zclProcessInWriteCmd_9 & 0xFFFF
   3519                  }
   3520                }
   3521                else
   3522                {
   3523                  // Attribute data type is incorrect - move on to the next write attribute record
   3524                  if ( sendRsp )
   \                     ??zclProcessInWriteCmd_6:
   \   00022A   E5..         MOV     A,?V0 + 2
   \   00022C   7003         JNZ     $+5
   \   00022E   02....       LJMP    ??zclProcessInWriteCmd_9 & 0xFFFF
   3525                  {
   3526                    writeRspCmd->attrList[j].status = ZCL_STATUS_INVALID_DATA_TYPE;
   \   000231   EE           MOV     A,R6
   \   000232   F8           MOV     R0,A
   \   000233   7900         MOV     R1,#0x0
   \   000235   E8           MOV     A,R0
   \   000236   75F003       MOV     B,#0x3
   \   000239   A4           MUL     AB
   \   00023A   C8           XCH     A,R0
   \   00023B   AAF0         MOV     R2,B
   \   00023D   75F000       MOV     B,#0x0
   \   000240   A4           MUL     AB
   \   000241   2A           ADD     A,R2
   \   000242   FA           MOV     R2,A
   \   000243   75F003       MOV     B,#0x3
   \   000246   E9           MOV     A,R1
   \   000247   A4           MUL     AB
   \   000248   2A           ADD     A,R2
   \   000249   F9           MOV     R1,A
   \   00024A   E5..         MOV     A,?V0 + 8
   \   00024C   28           ADD     A,R0
   \   00024D   F582         MOV     DPL,A
   \   00024F   E5..         MOV     A,?V0 + 9
   \   000251   39           ADDC    A,R1
   \   000252   F583         MOV     DPH,A
   \   000254   A3           INC     DPTR
   \   000255   748D         MOV     A,#-0x73
   \   000257   F0           MOVX    @DPTR,A
   3527                    writeRspCmd->attrList[j++].attrID = statusRec->attrID;
   \   000258   85..82       MOV     DPL,?V0 + 6
   \   00025B   85..83       MOV     DPH,?V0 + 7
   \   00025E   E0           MOVX    A,@DPTR
   \   00025F   FA           MOV     R2,A
   \   000260   A3           INC     DPTR
   \   000261   E0           MOVX    A,@DPTR
   \   000262   FB           MOV     R3,A
   \   000263   EE           MOV     A,R6
   \   000264   F8           MOV     R0,A
   \   000265   7900         MOV     R1,#0x0
   \   000267   E8           MOV     A,R0
   \   000268   75F003       MOV     B,#0x3
   \   00026B   A4           MUL     AB
   \   00026C   C8           XCH     A,R0
   \   00026D   ACF0         MOV     R4,B
   \   00026F   75F000       MOV     B,#0x0
   \   000272   A4           MUL     AB
   \   000273   2C           ADD     A,R4
   \   000274   FC           MOV     R4,A
   \   000275   75F003       MOV     B,#0x3
   \   000278   E9           MOV     A,R1
   \   000279   A4           MUL     AB
   \   00027A   2C           ADD     A,R4
   \   00027B   F9           MOV     R1,A
   \   00027C   E5..         MOV     A,?V0 + 8
   \   00027E   28           ADD     A,R0
   \   00027F   F582         MOV     DPL,A
   \   000281   E5..         MOV     A,?V0 + 9
   \   000283   39           ADDC    A,R1
   \   000284   F583         MOV     DPH,A
   \   000286   A3           INC     DPTR
   \   000287   A3           INC     DPTR
   \   000288   EA           MOV     A,R2
   \   000289   F0           MOVX    @DPTR,A
   \   00028A   A3           INC     DPTR
   \   00028B   EB           MOV     A,R3
   \   00028C   F0           MOVX    @DPTR,A
   \   00028D   0E           INC     R6
   \   00028E   8061         SJMP    ??zclProcessInWriteCmd_9
   3528                  }
   3529                }
   3530              }
   3531              else
   3532              {
   3533                // Attribute is not supported - move on to the next write attribute record
   3534                if ( sendRsp )
   \                     ??zclProcessInWriteCmd_5:
   \   000290   E5..         MOV     A,?V0 + 2
   \   000292   605D         JZ      ??zclProcessInWriteCmd_9
   3535                {
   3536                  writeRspCmd->attrList[j].status = ZCL_STATUS_UNSUPPORTED_ATTRIBUTE;
   \   000294   EE           MOV     A,R6
   \   000295   F8           MOV     R0,A
   \   000296   7900         MOV     R1,#0x0
   \   000298   E8           MOV     A,R0
   \   000299   75F003       MOV     B,#0x3
   \   00029C   A4           MUL     AB
   \   00029D   C8           XCH     A,R0
   \   00029E   AAF0         MOV     R2,B
   \   0002A0   75F000       MOV     B,#0x0
   \   0002A3   A4           MUL     AB
   \   0002A4   2A           ADD     A,R2
   \   0002A5   FA           MOV     R2,A
   \   0002A6   75F003       MOV     B,#0x3
   \   0002A9   E9           MOV     A,R1
   \   0002AA   A4           MUL     AB
   \   0002AB   2A           ADD     A,R2
   \   0002AC   F9           MOV     R1,A
   \   0002AD   E5..         MOV     A,?V0 + 8
   \   0002AF   28           ADD     A,R0
   \   0002B0   F582         MOV     DPL,A
   \   0002B2   E5..         MOV     A,?V0 + 9
   \   0002B4   39           ADDC    A,R1
   \   0002B5   F583         MOV     DPH,A
   \   0002B7   A3           INC     DPTR
   \   0002B8   7486         MOV     A,#-0x7a
   \   0002BA   F0           MOVX    @DPTR,A
   3537                  writeRspCmd->attrList[j++].attrID = statusRec->attrID;
   \   0002BB   85..82       MOV     DPL,?V0 + 6
   \   0002BE   85..83       MOV     DPH,?V0 + 7
   \   0002C1   E0           MOVX    A,@DPTR
   \   0002C2   FA           MOV     R2,A
   \   0002C3   A3           INC     DPTR
   \   0002C4   E0           MOVX    A,@DPTR
   \   0002C5   FB           MOV     R3,A
   \   0002C6   EE           MOV     A,R6
   \   0002C7   F8           MOV     R0,A
   \   0002C8   7900         MOV     R1,#0x0
   \   0002CA   E8           MOV     A,R0
   \   0002CB   75F003       MOV     B,#0x3
   \   0002CE   A4           MUL     AB
   \   0002CF   C8           XCH     A,R0
   \   0002D0   ACF0         MOV     R4,B
   \   0002D2   75F000       MOV     B,#0x0
   \   0002D5   A4           MUL     AB
   \   0002D6   2C           ADD     A,R4
   \   0002D7   FC           MOV     R4,A
   \   0002D8   75F003       MOV     B,#0x3
   \   0002DB   E9           MOV     A,R1
   \   0002DC   A4           MUL     AB
   \   0002DD   2C           ADD     A,R4
   \   0002DE   F9           MOV     R1,A
   \   0002DF   E5..         MOV     A,?V0 + 8
   \   0002E1   28           ADD     A,R0
   \   0002E2   F582         MOV     DPL,A
   \   0002E4   E5..         MOV     A,?V0 + 9
   \   0002E6   39           ADDC    A,R1
   \   0002E7   F583         MOV     DPH,A
   \   0002E9   A3           INC     DPTR
   \   0002EA   A3           INC     DPTR
   \   0002EB   EA           MOV     A,R2
   \   0002EC   F0           MOVX    @DPTR,A
   \   0002ED   A3           INC     DPTR
   \   0002EE   EB           MOV     A,R3
   \   0002EF   F0           MOVX    @DPTR,A
   \   0002F0   0E           INC     R6
   3538                }
   3539              }
   3540            } // for loop
   \                     ??zclProcessInWriteCmd_9:
   \   0002F1   05..         INC     ?V0 + 3
   \   0002F3   02....       LJMP    ??zclProcessInWriteCmd_3 & 0xFFFF
   3541          
   3542            if ( sendRsp )
   \                     ??zclProcessInWriteCmd_4:
   \   0002F6   E5..         MOV     A,?V0 + 2
   \   0002F8   7003         JNZ     $+5
   \   0002FA   02....       LJMP    ??zclProcessInWriteCmd_10 & 0xFFFF
   3543            {
   3544              writeRspCmd->numAttr = j;
   \   0002FD   EE           MOV     A,R6
   \   0002FE   85..82       MOV     DPL,?V0 + 8
   \   000301   85..83       MOV     DPH,?V0 + 9
   \   000304   F0           MOVX    @DPTR,A
   3545              if ( writeRspCmd->numAttr == 0 )
   \   000305   85..82       MOV     DPL,?V0 + 8
   \   000308   85..83       MOV     DPH,?V0 + 9
   \   00030B   E0           MOVX    A,@DPTR
   \   00030C   7013         JNZ     ??zclProcessInWriteCmd_11
   3546              {
   3547                // Since all records were written successful, include a single status record
   3548                // in the resonse command with the status field set to SUCCESS and the
   3549                // attribute ID field omitted.
   3550                writeRspCmd->attrList[0].status = ZCL_STATUS_SUCCESS;
   \   00030E   85..82       MOV     DPL,?V0 + 8
   \   000311   85..83       MOV     DPH,?V0 + 9
   \   000314   A3           INC     DPTR
   \   000315   7400         MOV     A,#0x0
   \   000317   F0           MOVX    @DPTR,A
   3551                writeRspCmd->numAttr = 1;
   \   000318   85..82       MOV     DPL,?V0 + 8
   \   00031B   85..83       MOV     DPH,?V0 + 9
   \   00031E   7401         MOV     A,#0x1
   \   000320   F0           MOVX    @DPTR,A
   3552              }
   3553          
   3554              zcl_SendWriteRsp( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr),
   3555                                pInMsg->msg->clusterId, writeRspCmd, ZCL_FRAME_SERVER_CLIENT_DIR,
   3556                                true, pInMsg->hdr.transSeqNum );
   \                     ??zclProcessInWriteCmd_11:
   \   000321                ; Setup parameters for call to function zcl_SendWriteRsp
   \   000321   85..82       MOV     DPL,?V0 + 0
   \   000324   85..83       MOV     DPH,?V0 + 1
   \   000327   A3           INC     DPTR
   \   000328   A3           INC     DPTR
   \   000329   A3           INC     DPTR
   \   00032A   A3           INC     DPTR
   \   00032B   A3           INC     DPTR
   \   00032C   A3           INC     DPTR
   \   00032D   E0           MOVX    A,@DPTR
   \   00032E   F5..         MOV     ?V0 + 3,A
   \   000330   78..         MOV     R0,#?V0 + 3
   \   000332   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000335   75..01       MOV     ?V0 + 3,#0x1
   \   000338   78..         MOV     R0,#?V0 + 3
   \   00033A   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00033D   75..01       MOV     ?V0 + 3,#0x1
   \   000340   78..         MOV     R0,#?V0 + 3
   \   000342   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000345   78..         MOV     R0,#?V0 + 8
   \   000347   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00034A   85..82       MOV     DPL,?V0 + 0
   \   00034D   85..83       MOV     DPH,?V0 + 1
   \   000350   E0           MOVX    A,@DPTR
   \   000351   F8           MOV     R0,A
   \   000352   A3           INC     DPTR
   \   000353   E0           MOVX    A,@DPTR
   \   000354   F583         MOV     DPH,A
   \   000356   8882         MOV     DPL,R0
   \   000358   A3           INC     DPTR
   \   000359   A3           INC     DPTR
   \   00035A   A3           INC     DPTR
   \   00035B   A3           INC     DPTR
   \   00035C   E0           MOVX    A,@DPTR
   \   00035D   FC           MOV     R4,A
   \   00035E   A3           INC     DPTR
   \   00035F   E0           MOVX    A,@DPTR
   \   000360   FD           MOV     R5,A
   \   000361   85..82       MOV     DPL,?V0 + 0
   \   000364   85..83       MOV     DPH,?V0 + 1
   \   000367   E0           MOVX    A,@DPTR
   \   000368   2406         ADD     A,#0x6
   \   00036A   FA           MOV     R2,A
   \   00036B   A3           INC     DPTR
   \   00036C   E0           MOVX    A,@DPTR
   \   00036D   3400         ADDC    A,#0x0
   \   00036F   FB           MOV     R3,A
   \   000370   85..82       MOV     DPL,?V0 + 0
   \   000373   85..83       MOV     DPH,?V0 + 1
   \   000376   E0           MOVX    A,@DPTR
   \   000377   F8           MOV     R0,A
   \   000378   A3           INC     DPTR
   \   000379   E0           MOVX    A,@DPTR
   \   00037A   C8           XCH     A,R0
   \   00037B   2414         ADD     A,#0x14
   \   00037D   F582         MOV     DPL,A
   \   00037F   E8           MOV     A,R0
   \   000380   3400         ADDC    A,#0x0
   \   000382   F583         MOV     DPH,A
   \   000384   E0           MOVX    A,@DPTR
   \   000385   F9           MOV     R1,A
   \   000386   12....       LCALL   ??zcl_SendWriteRsp?relay
   \   000389   7405         MOV     A,#0x5
   \   00038B   12....       LCALL   ?DEALLOC_XSTACK8
   \   00038E   E9           MOV     A,R1
   3557              osal_mem_free( writeRspCmd );
   \   00038F                ; Setup parameters for call to function osal_mem_free
   \   00038F   AA..         MOV     R2,?V0 + 8
   \   000391   AB..         MOV     R3,?V0 + 9
   \   000393   12....       LCALL   ??osal_mem_free?relay
   3558            }
   3559          
   3560            return TRUE;
   \                     ??zclProcessInWriteCmd_10:
   \   000396   7901         MOV     R1,#0x1
   \                     ??zclProcessInWriteCmd_2:
   \   000398   7408         MOV     A,#0x8
   \   00039A   12....       LCALL   ?DEALLOC_XSTACK8
   \   00039D   7F0C         MOV     R7,#0xc
   \   00039F   02....       LJMP    ?BANKED_LEAVE_XDATA
   3561          }
   3562          
   3563          /*********************************************************************
   3564           * @fn      zclRevertWriteUndividedCmd
   3565           *
   3566           * @brief   Revert the "Profile" Write Undevided Command
   3567           *
   3568           * @param   pInMsg - incoming message to process
   3569           * @param   curWriteRec - old data
   3570           * @param   numAttr - number of attributes to be reverted
   3571           *
   3572           * @return  none
   3573           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3574          static void zclRevertWriteUndividedCmd( zclIncoming_t *pInMsg,
   \                     zclRevertWriteUndividedCmd:
   3575                                              zclWriteRec_t *curWriteRec, uint16 numAttr )
   3576          {
   \   000000   74EA         MOV     A,#-0x16
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 22
   \   000005                ; Auto size: 8
   \   000005   74F8         MOV     A,#-0x8
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V0 + 8,R2
   \   00000C   8B..         MOV     ?V0 + 9,R3
   \   00000E   8C..         MOV     ?V0 + 12,R4
   \   000010   8D..         MOV     ?V0 + 13,R5
   \   000012   741E         MOV     A,#0x1e
   \   000014   12....       LCALL   ?XSTACK_DISP0_8
   \   000017   E0           MOVX    A,@DPTR
   \   000018   F5..         MOV     ?V0 + 10,A
   \   00001A   A3           INC     DPTR
   \   00001B   E0           MOVX    A,@DPTR
   \   00001C   F5..         MOV     ?V0 + 11,A
   3577            for ( uint8 i = 0; i < numAttr; i++ )
   \   00001E   7E00         MOV     R6,#0x0
   \                     ??zclRevertWriteUndividedCmd_0:
   \   000020   8E..         MOV     ?V0 + 0,R6
   \   000022   75..00       MOV     ?V0 + 1,#0x0
   \   000025   C3           CLR     C
   \   000026   E5..         MOV     A,?V0 + 0
   \   000028   95..         SUBB    A,?V0 + 10
   \   00002A   E5..         MOV     A,?V0 + 1
   \   00002C   95..         SUBB    A,?V0 + 11
   \   00002E   4003         JC      $+5
   \   000030   02....       LJMP    ??zclRevertWriteUndividedCmd_1 & 0xFFFF
   3578            {
   3579              zclAttrRec_t attrRec;
   3580              zclWriteRec_t *statusRec = &(curWriteRec[i]);
   \   000033   EE           MOV     A,R6
   \   000034   F8           MOV     R0,A
   \   000035   7900         MOV     R1,#0x0
   \   000037   E8           MOV     A,R0
   \   000038   75F005       MOV     B,#0x5
   \   00003B   A4           MUL     AB
   \   00003C   C8           XCH     A,R0
   \   00003D   AAF0         MOV     R2,B
   \   00003F   75F000       MOV     B,#0x0
   \   000042   A4           MUL     AB
   \   000043   2A           ADD     A,R2
   \   000044   FA           MOV     R2,A
   \   000045   75F005       MOV     B,#0x5
   \   000048   E9           MOV     A,R1
   \   000049   A4           MUL     AB
   \   00004A   2A           ADD     A,R2
   \   00004B   F9           MOV     R1,A
   \   00004C   E5..         MOV     A,?V0 + 12
   \   00004E   28           ADD     A,R0
   \   00004F   F5..         MOV     ?V0 + 0,A
   \   000051   E5..         MOV     A,?V0 + 13
   \   000053   39           ADDC    A,R1
   \   000054   F5..         MOV     ?V0 + 1,A
   3581          
   3582              if ( !zclFindAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId,
   3583                                    statusRec->attrID, &attrRec ) )
   \   000056                ; Setup parameters for call to function zclFindAttrRec
   \   000056   85..82       MOV     DPL,?XSP + 0
   \   000059   85..83       MOV     DPH,?XSP + 1
   \   00005C   8582..       MOV     ?V0 + 2,DPL
   \   00005F   8583..       MOV     ?V0 + 3,DPH
   \   000062   78..         MOV     R0,#?V0 + 2
   \   000064   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000067   85..82       MOV     DPL,?V0 + 0
   \   00006A   85..83       MOV     DPH,?V0 + 1
   \   00006D   E0           MOVX    A,@DPTR
   \   00006E   FC           MOV     R4,A
   \   00006F   A3           INC     DPTR
   \   000070   E0           MOVX    A,@DPTR
   \   000071   FD           MOV     R5,A
   \   000072   85..82       MOV     DPL,?V0 + 8
   \   000075   85..83       MOV     DPH,?V0 + 9
   \   000078   E0           MOVX    A,@DPTR
   \   000079   F8           MOV     R0,A
   \   00007A   A3           INC     DPTR
   \   00007B   E0           MOVX    A,@DPTR
   \   00007C   F583         MOV     DPH,A
   \   00007E   8882         MOV     DPL,R0
   \   000080   A3           INC     DPTR
   \   000081   A3           INC     DPTR
   \   000082   A3           INC     DPTR
   \   000083   A3           INC     DPTR
   \   000084   E0           MOVX    A,@DPTR
   \   000085   FA           MOV     R2,A
   \   000086   A3           INC     DPTR
   \   000087   E0           MOVX    A,@DPTR
   \   000088   FB           MOV     R3,A
   \   000089   85..82       MOV     DPL,?V0 + 8
   \   00008C   85..83       MOV     DPH,?V0 + 9
   \   00008F   E0           MOVX    A,@DPTR
   \   000090   F8           MOV     R0,A
   \   000091   A3           INC     DPTR
   \   000092   E0           MOVX    A,@DPTR
   \   000093   C8           XCH     A,R0
   \   000094   2414         ADD     A,#0x14
   \   000096   F582         MOV     DPL,A
   \   000098   E8           MOV     A,R0
   \   000099   3400         ADDC    A,#0x0
   \   00009B   F583         MOV     DPH,A
   \   00009D   E0           MOVX    A,@DPTR
   \   00009E   F9           MOV     R1,A
   \   00009F   12....       LCALL   ??zclFindAttrRec?relay
   \   0000A2   7402         MOV     A,#0x2
   \   0000A4   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000A7   E9           MOV     A,R1
   \   0000A8   7003         JNZ     $+5
   \   0000AA   02....       LJMP    ??zclRevertWriteUndividedCmd_1 & 0xFFFF
   3584              {
   3585                break; // should never happen
   3586              }
   3587          
   3588              if ( attrRec.attr.dataPtr != NULL )
   \   0000AD   7406         MOV     A,#0x6
   \   0000AF   12....       LCALL   ?XSTACK_DISP0_8
   \   0000B2   E0           MOVX    A,@DPTR
   \   0000B3   F8           MOV     R0,A
   \   0000B4   A3           INC     DPTR
   \   0000B5   E0           MOVX    A,@DPTR
   \   0000B6   F9           MOV     R1,A
   \   0000B7   E8           MOV     A,R0
   \   0000B8   49           ORL     A,R1
   \   0000B9   6052         JZ      ??zclRevertWriteUndividedCmd_2
   3589              {
   3590                // Just copy the old data back - no need to validate the data
   3591                uint16 dataLen = zclGetAttrDataLength( attrRec.attr.dataType, statusRec->attrData );
   \   0000BB                ; Setup parameters for call to function zclGetAttrDataLength
   \   0000BB   85..82       MOV     DPL,?V0 + 0
   \   0000BE   85..83       MOV     DPH,?V0 + 1
   \   0000C1   A3           INC     DPTR
   \   0000C2   A3           INC     DPTR
   \   0000C3   A3           INC     DPTR
   \   0000C4   E0           MOVX    A,@DPTR
   \   0000C5   FA           MOV     R2,A
   \   0000C6   A3           INC     DPTR
   \   0000C7   E0           MOVX    A,@DPTR
   \   0000C8   FB           MOV     R3,A
   \   0000C9   7404         MOV     A,#0x4
   \   0000CB   12....       LCALL   ?XSTACK_DISP0_8
   \   0000CE   E0           MOVX    A,@DPTR
   \   0000CF   F9           MOV     R1,A
   \   0000D0   12....       LCALL   ??zclGetAttrDataLength?relay
   \   0000D3   8A..         MOV     ?V0 + 4,R2
   \   0000D5   8B..         MOV     ?V0 + 5,R3
   \   0000D7   85....       MOV     ?V0 + 2,?V0 + 4
   \   0000DA   85....       MOV     ?V0 + 3,?V0 + 5
   3592                osal_memcpy( attrRec.attr.dataPtr, statusRec->attrData, dataLen );
   \   0000DD                ; Setup parameters for call to function osal_memcpy
   \   0000DD   85..82       MOV     DPL,?V0 + 0
   \   0000E0   85..83       MOV     DPH,?V0 + 1
   \   0000E3   A3           INC     DPTR
   \   0000E4   A3           INC     DPTR
   \   0000E5   A3           INC     DPTR
   \   0000E6   E0           MOVX    A,@DPTR
   \   0000E7   F5..         MOV     ?V0 + 4,A
   \   0000E9   A3           INC     DPTR
   \   0000EA   E0           MOVX    A,@DPTR
   \   0000EB   F5..         MOV     ?V0 + 5,A
   \   0000ED   75..00       MOV     ?V0 + 6,#0x0
   \   0000F0   78..         MOV     R0,#?V0 + 4
   \   0000F2   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   0000F5   AC..         MOV     R4,?V0 + 2
   \   0000F7   AD..         MOV     R5,?V0 + 3
   \   0000F9   7409         MOV     A,#0x9
   \   0000FB   12....       LCALL   ?XSTACK_DISP0_8
   \   0000FE   E0           MOVX    A,@DPTR
   \   0000FF   FA           MOV     R2,A
   \   000100   A3           INC     DPTR
   \   000101   E0           MOVX    A,@DPTR
   \   000102   FB           MOV     R3,A
   \   000103   12....       LCALL   ??osal_memcpy?relay
   \   000106   7403         MOV     A,#0x3
   \   000108   12....       LCALL   ?DEALLOC_XSTACK8
   \   00010B   8043         SJMP    ??zclRevertWriteUndividedCmd_3
   3593              }
   3594              else // Use CB
   3595              {
   3596                // Write the old data back
   3597                zclWriteAttrDataUsingCB( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr),
   3598                                         &attrRec, statusRec->attrData );
   \                     ??zclRevertWriteUndividedCmd_2:
   \   00010D                ; Setup parameters for call to function zclWriteAttrDataUsingCB
   \   00010D   85..82       MOV     DPL,?V0 + 0
   \   000110   85..83       MOV     DPH,?V0 + 1
   \   000113   A3           INC     DPTR
   \   000114   A3           INC     DPTR
   \   000115   A3           INC     DPTR
   \   000116   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   000119   7402         MOV     A,#0x2
   \   00011B   12....       LCALL   ?XSTACK_DISP0_8
   \   00011E   AC82         MOV     R4,DPL
   \   000120   AD83         MOV     R5,DPH
   \   000122   85..82       MOV     DPL,?V0 + 8
   \   000125   85..83       MOV     DPH,?V0 + 9
   \   000128   E0           MOVX    A,@DPTR
   \   000129   2406         ADD     A,#0x6
   \   00012B   FA           MOV     R2,A
   \   00012C   A3           INC     DPTR
   \   00012D   E0           MOVX    A,@DPTR
   \   00012E   3400         ADDC    A,#0x0
   \   000130   FB           MOV     R3,A
   \   000131   85..82       MOV     DPL,?V0 + 8
   \   000134   85..83       MOV     DPH,?V0 + 9
   \   000137   E0           MOVX    A,@DPTR
   \   000138   F8           MOV     R0,A
   \   000139   A3           INC     DPTR
   \   00013A   E0           MOVX    A,@DPTR
   \   00013B   C8           XCH     A,R0
   \   00013C   2414         ADD     A,#0x14
   \   00013E   F582         MOV     DPL,A
   \   000140   E8           MOV     A,R0
   \   000141   3400         ADDC    A,#0x0
   \   000143   F583         MOV     DPH,A
   \   000145   E0           MOVX    A,@DPTR
   \   000146   F9           MOV     R1,A
   \   000147   12....       LCALL   ??zclWriteAttrDataUsingCB?relay
   \   00014A   7402         MOV     A,#0x2
   \   00014C   12....       LCALL   ?DEALLOC_XSTACK8
   \   00014F   E9           MOV     A,R1
   3599              }
   3600            } // for loop
   \                     ??zclRevertWriteUndividedCmd_3:
   \   000150   0E           INC     R6
   \   000151   02....       LJMP    ??zclRevertWriteUndividedCmd_0 & 0xFFFF
   3601          }
   \                     ??zclRevertWriteUndividedCmd_1:
   \   000154   7408         MOV     A,#0x8
   \   000156   12....       LCALL   ?DEALLOC_XSTACK8
   \   000159   7F0E         MOV     R7,#0xe
   \   00015B   02....       LJMP    ?BANKED_LEAVE_XDATA
   3602          
   3603          /*********************************************************************
   3604           * @fn      zclProcessInWriteUndividedCmd
   3605           *
   3606           * @brief   Process the "Profile" Write Undivided Command
   3607           *
   3608           * @param   pInMsg - incoming message to process
   3609           *
   3610           * @return  TRUE if command processed. FALSE, otherwise.
   3611           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3612          static uint8 zclProcessInWriteUndividedCmd( zclIncoming_t *pInMsg )
   \                     zclProcessInWriteUndividedCmd:
   3613          {
   \   000000   74E8         MOV     A,#-0x18
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 24
   \   000005                ; Auto size: 14
   \   000005   74F2         MOV     A,#-0xe
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V0 + 2,R2
   \   00000C   8B..         MOV     ?V0 + 3,R3
   3614            zclWriteCmd_t *writeCmd;
   3615            zclWriteRspCmd_t *writeRspCmd;
   3616            zclAttrRec_t attrRec;
   3617            uint16 dataLen;
   3618            uint16 curLen = 0;
   \   00000E   7404         MOV     A,#0x4
   \   000010   12....       LCALL   ?XSTACK_DISP0_8
   \   000013   7400         MOV     A,#0x0
   \   000015   F0           MOVX    @DPTR,A
   \   000016   A3           INC     DPTR
   \   000017   7400         MOV     A,#0x0
   \   000019   F0           MOVX    @DPTR,A
   3619            uint8 j = 0;
   \   00001A   7E00         MOV     R6,#0x0
   3620          
   3621            writeCmd = (zclWriteCmd_t *)pInMsg->attrCmd;
   \   00001C   E5..         MOV     A,?V0 + 2
   \   00001E   240C         ADD     A,#0xc
   \   000020   F582         MOV     DPL,A
   \   000022   E5..         MOV     A,?V0 + 3
   \   000024   3400         ADDC    A,#0x0
   \   000026   F583         MOV     DPH,A
   \   000028   E0           MOVX    A,@DPTR
   \   000029   F8           MOV     R0,A
   \   00002A   A3           INC     DPTR
   \   00002B   E0           MOVX    A,@DPTR
   \   00002C   F9           MOV     R1,A
   \   00002D   88..         MOV     ?V0 + 14,R0
   \   00002F   89..         MOV     ?V0 + 15,R1
   3622          
   3623            // Allocate space for Write Response Command
   3624            writeRspCmd = (zclWriteRspCmd_t *)osal_mem_alloc( sizeof( zclWriteRspCmd_t )
   3625                             + sizeof( zclWriteRspStatus_t )* writeCmd->numAttr );
   \   000031                ; Setup parameters for call to function osal_mem_alloc
   \   000031   85..82       MOV     DPL,?V0 + 14
   \   000034   85..83       MOV     DPH,?V0 + 15
   \   000037   E0           MOVX    A,@DPTR
   \   000038   F8           MOV     R0,A
   \   000039   7900         MOV     R1,#0x0
   \   00003B   E8           MOV     A,R0
   \   00003C   75F003       MOV     B,#0x3
   \   00003F   A4           MUL     AB
   \   000040   C8           XCH     A,R0
   \   000041   AAF0         MOV     R2,B
   \   000043   75F000       MOV     B,#0x0
   \   000046   A4           MUL     AB
   \   000047   2A           ADD     A,R2
   \   000048   FA           MOV     R2,A
   \   000049   75F003       MOV     B,#0x3
   \   00004C   E9           MOV     A,R1
   \   00004D   A4           MUL     AB
   \   00004E   2A           ADD     A,R2
   \   00004F   F9           MOV     R1,A
   \   000050   E8           MOV     A,R0
   \   000051   2401         ADD     A,#0x1
   \   000053   FA           MOV     R2,A
   \   000054   E9           MOV     A,R1
   \   000055   3400         ADDC    A,#0x0
   \   000057   FB           MOV     R3,A
   \   000058   12....       LCALL   ??osal_mem_alloc?relay
   \   00005B   8A..         MOV     ?V0 + 4,R2
   \   00005D   8B..         MOV     ?V0 + 5,R3
   \   00005F   85....       MOV     ?V0 + 0,?V0 + 4
   \   000062   85....       MOV     ?V0 + 1,?V0 + 5
   3626            if ( writeRspCmd == NULL )
   \   000065   E5..         MOV     A,?V0 + 0
   \   000067   45..         ORL     A,?V0 + 1
   \   000069   7005         JNZ     ??zclProcessInWriteUndividedCmd_0
   3627            {
   3628              return FALSE; // EMBEDDED RETURN
   \   00006B   7900         MOV     R1,#0x0
   \   00006D   02....       LJMP    ??zclProcessInWriteUndividedCmd_1 & 0xFFFF
   3629            }
   3630          
   3631            // If any attribute cannot be written, no attribute values are changed. Hence,
   3632            // make sure all the attributes are supported and writable
   3633            for ( uint8 i = 0; i < writeCmd->numAttr; i++ )
   \                     ??zclProcessInWriteUndividedCmd_0:
   \   000070   7F00         MOV     R7,#0x0
   \                     ??zclProcessInWriteUndividedCmd_2:
   \   000072   85..82       MOV     DPL,?V0 + 14
   \   000075   85..83       MOV     DPH,?V0 + 15
   \   000078   E0           MOVX    A,@DPTR
   \   000079   F8           MOV     R0,A
   \   00007A   EF           MOV     A,R7
   \   00007B   C3           CLR     C
   \   00007C   98           SUBB    A,R0
   \   00007D   4003         JC      $+5
   \   00007F   02....       LJMP    ??zclProcessInWriteUndividedCmd_3 & 0xFFFF
   3634            {
   3635              zclWriteRec_t *statusRec = &(writeCmd->attrList[i]);
   \   000082   EF           MOV     A,R7
   \   000083   F8           MOV     R0,A
   \   000084   7900         MOV     R1,#0x0
   \   000086   E8           MOV     A,R0
   \   000087   75F005       MOV     B,#0x5
   \   00008A   A4           MUL     AB
   \   00008B   C8           XCH     A,R0
   \   00008C   AAF0         MOV     R2,B
   \   00008E   75F000       MOV     B,#0x0
   \   000091   A4           MUL     AB
   \   000092   2A           ADD     A,R2
   \   000093   FA           MOV     R2,A
   \   000094   75F005       MOV     B,#0x5
   \   000097   E9           MOV     A,R1
   \   000098   A4           MUL     AB
   \   000099   2A           ADD     A,R2
   \   00009A   F9           MOV     R1,A
   \   00009B   E5..         MOV     A,?V0 + 14
   \   00009D   28           ADD     A,R0
   \   00009E   F582         MOV     DPL,A
   \   0000A0   E5..         MOV     A,?V0 + 15
   \   0000A2   39           ADDC    A,R1
   \   0000A3   F583         MOV     DPH,A
   \   0000A5   A3           INC     DPTR
   \   0000A6   8582..       MOV     ?V0 + 4,DPL
   \   0000A9   8583..       MOV     ?V0 + 5,DPH
   3636          
   3637              if ( !zclFindAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId,
   3638                                    statusRec->attrID, &attrRec ) )
   \   0000AC                ; Setup parameters for call to function zclFindAttrRec
   \   0000AC   7406         MOV     A,#0x6
   \   0000AE   12....       LCALL   ?XSTACK_DISP0_8
   \   0000B1   8582..       MOV     ?V0 + 6,DPL
   \   0000B4   8583..       MOV     ?V0 + 7,DPH
   \   0000B7   78..         MOV     R0,#?V0 + 6
   \   0000B9   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000BC   85..82       MOV     DPL,?V0 + 4
   \   0000BF   85..83       MOV     DPH,?V0 + 5
   \   0000C2   E0           MOVX    A,@DPTR
   \   0000C3   FC           MOV     R4,A
   \   0000C4   A3           INC     DPTR
   \   0000C5   E0           MOVX    A,@DPTR
   \   0000C6   FD           MOV     R5,A
   \   0000C7   85..82       MOV     DPL,?V0 + 2
   \   0000CA   85..83       MOV     DPH,?V0 + 3
   \   0000CD   E0           MOVX    A,@DPTR
   \   0000CE   F8           MOV     R0,A
   \   0000CF   A3           INC     DPTR
   \   0000D0   E0           MOVX    A,@DPTR
   \   0000D1   F583         MOV     DPH,A
   \   0000D3   8882         MOV     DPL,R0
   \   0000D5   A3           INC     DPTR
   \   0000D6   A3           INC     DPTR
   \   0000D7   A3           INC     DPTR
   \   0000D8   A3           INC     DPTR
   \   0000D9   E0           MOVX    A,@DPTR
   \   0000DA   FA           MOV     R2,A
   \   0000DB   A3           INC     DPTR
   \   0000DC   E0           MOVX    A,@DPTR
   \   0000DD   FB           MOV     R3,A
   \   0000DE   85..82       MOV     DPL,?V0 + 2
   \   0000E1   85..83       MOV     DPH,?V0 + 3
   \   0000E4   E0           MOVX    A,@DPTR
   \   0000E5   F8           MOV     R0,A
   \   0000E6   A3           INC     DPTR
   \   0000E7   E0           MOVX    A,@DPTR
   \   0000E8   C8           XCH     A,R0
   \   0000E9   2414         ADD     A,#0x14
   \   0000EB   F582         MOV     DPL,A
   \   0000ED   E8           MOV     A,R0
   \   0000EE   3400         ADDC    A,#0x0
   \   0000F0   F583         MOV     DPH,A
   \   0000F2   E0           MOVX    A,@DPTR
   \   0000F3   F9           MOV     R1,A
   \   0000F4   12....       LCALL   ??zclFindAttrRec?relay
   \   0000F7   7402         MOV     A,#0x2
   \   0000F9   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000FC   E9           MOV     A,R1
   \   0000FD   7060         JNZ     ??zclProcessInWriteUndividedCmd_4
   3639              {
   3640                // Attribute is not supported - stop here
   3641                writeRspCmd->attrList[j].status = ZCL_STATUS_UNSUPPORTED_ATTRIBUTE;
   \   0000FF   EE           MOV     A,R6
   \   000100   F8           MOV     R0,A
   \   000101   7900         MOV     R1,#0x0
   \   000103   E8           MOV     A,R0
   \   000104   75F003       MOV     B,#0x3
   \   000107   A4           MUL     AB
   \   000108   C8           XCH     A,R0
   \   000109   AAF0         MOV     R2,B
   \   00010B   75F000       MOV     B,#0x0
   \   00010E   A4           MUL     AB
   \   00010F   2A           ADD     A,R2
   \   000110   FA           MOV     R2,A
   \   000111   75F003       MOV     B,#0x3
   \   000114   E9           MOV     A,R1
   \   000115   A4           MUL     AB
   \   000116   2A           ADD     A,R2
   \   000117   F9           MOV     R1,A
   \   000118   E5..         MOV     A,?V0 + 0
   \   00011A   28           ADD     A,R0
   \   00011B   F582         MOV     DPL,A
   \   00011D   E5..         MOV     A,?V0 + 1
   \   00011F   39           ADDC    A,R1
   \   000120   F583         MOV     DPH,A
   \   000122   A3           INC     DPTR
   \   000123   7486         MOV     A,#-0x7a
   \   000125   F0           MOVX    @DPTR,A
   3642                writeRspCmd->attrList[j++].attrID = statusRec->attrID;
   \   000126   85..82       MOV     DPL,?V0 + 4
   \   000129   85..83       MOV     DPH,?V0 + 5
   \   00012C   E0           MOVX    A,@DPTR
   \   00012D   FA           MOV     R2,A
   \   00012E   A3           INC     DPTR
   \   00012F   E0           MOVX    A,@DPTR
   \   000130   FB           MOV     R3,A
   \   000131   EE           MOV     A,R6
   \   000132   F8           MOV     R0,A
   \   000133   7900         MOV     R1,#0x0
   \   000135   E8           MOV     A,R0
   \   000136   75F003       MOV     B,#0x3
   \   000139   A4           MUL     AB
   \   00013A   C8           XCH     A,R0
   \   00013B   ACF0         MOV     R4,B
   \   00013D   75F000       MOV     B,#0x0
   \   000140   A4           MUL     AB
   \   000141   2C           ADD     A,R4
   \   000142   FC           MOV     R4,A
   \   000143   75F003       MOV     B,#0x3
   \   000146   E9           MOV     A,R1
   \   000147   A4           MUL     AB
   \   000148   2C           ADD     A,R4
   \   000149   F9           MOV     R1,A
   \   00014A   E5..         MOV     A,?V0 + 0
   \   00014C   28           ADD     A,R0
   \   00014D   F582         MOV     DPL,A
   \   00014F   E5..         MOV     A,?V0 + 1
   \   000151   39           ADDC    A,R1
   \   000152   F583         MOV     DPH,A
   \   000154   A3           INC     DPTR
   \   000155   A3           INC     DPTR
   \   000156   EA           MOV     A,R2
   \   000157   F0           MOVX    @DPTR,A
   \   000158   A3           INC     DPTR
   \   000159   EB           MOV     A,R3
   \   00015A   F0           MOVX    @DPTR,A
   \   00015B   0E           INC     R6
   3643                break;
   \   00015C   02....       LJMP    ??zclProcessInWriteUndividedCmd_3 & 0xFFFF
   3644              }
   3645          
   3646              if ( statusRec->dataType != attrRec.attr.dataType )
   \                     ??zclProcessInWriteUndividedCmd_4:
   \   00015F   85..82       MOV     DPL,?V0 + 4
   \   000162   85..83       MOV     DPH,?V0 + 5
   \   000165   A3           INC     DPTR
   \   000166   A3           INC     DPTR
   \   000167   E0           MOVX    A,@DPTR
   \   000168   F8           MOV     R0,A
   \   000169   740A         MOV     A,#0xa
   \   00016B   12....       LCALL   ?XSTACK_DISP0_8
   \   00016E   E0           MOVX    A,@DPTR
   \   00016F   68           XRL     A,R0
   \   000170   6060         JZ      ??zclProcessInWriteUndividedCmd_5
   3647              {
   3648                // Attribute data type is incorrect - stope here
   3649                writeRspCmd->attrList[j].status = ZCL_STATUS_INVALID_DATA_TYPE;
   \   000172   EE           MOV     A,R6
   \   000173   F8           MOV     R0,A
   \   000174   7900         MOV     R1,#0x0
   \   000176   E8           MOV     A,R0
   \   000177   75F003       MOV     B,#0x3
   \   00017A   A4           MUL     AB
   \   00017B   C8           XCH     A,R0
   \   00017C   AAF0         MOV     R2,B
   \   00017E   75F000       MOV     B,#0x0
   \   000181   A4           MUL     AB
   \   000182   2A           ADD     A,R2
   \   000183   FA           MOV     R2,A
   \   000184   75F003       MOV     B,#0x3
   \   000187   E9           MOV     A,R1
   \   000188   A4           MUL     AB
   \   000189   2A           ADD     A,R2
   \   00018A   F9           MOV     R1,A
   \   00018B   E5..         MOV     A,?V0 + 0
   \   00018D   28           ADD     A,R0
   \   00018E   F582         MOV     DPL,A
   \   000190   E5..         MOV     A,?V0 + 1
   \   000192   39           ADDC    A,R1
   \   000193   F583         MOV     DPH,A
   \   000195   A3           INC     DPTR
   \   000196   748D         MOV     A,#-0x73
   \   000198   F0           MOVX    @DPTR,A
   3650                writeRspCmd->attrList[j++].attrID = statusRec->attrID;
   \   000199   85..82       MOV     DPL,?V0 + 4
   \   00019C   85..83       MOV     DPH,?V0 + 5
   \   00019F   E0           MOVX    A,@DPTR
   \   0001A0   FA           MOV     R2,A
   \   0001A1   A3           INC     DPTR
   \   0001A2   E0           MOVX    A,@DPTR
   \   0001A3   FB           MOV     R3,A
   \   0001A4   EE           MOV     A,R6
   \   0001A5   F8           MOV     R0,A
   \   0001A6   7900         MOV     R1,#0x0
   \   0001A8   E8           MOV     A,R0
   \   0001A9   75F003       MOV     B,#0x3
   \   0001AC   A4           MUL     AB
   \   0001AD   C8           XCH     A,R0
   \   0001AE   ACF0         MOV     R4,B
   \   0001B0   75F000       MOV     B,#0x0
   \   0001B3   A4           MUL     AB
   \   0001B4   2C           ADD     A,R4
   \   0001B5   FC           MOV     R4,A
   \   0001B6   75F003       MOV     B,#0x3
   \   0001B9   E9           MOV     A,R1
   \   0001BA   A4           MUL     AB
   \   0001BB   2C           ADD     A,R4
   \   0001BC   F9           MOV     R1,A
   \   0001BD   E5..         MOV     A,?V0 + 0
   \   0001BF   28           ADD     A,R0
   \   0001C0   F582         MOV     DPL,A
   \   0001C2   E5..         MOV     A,?V0 + 1
   \   0001C4   39           ADDC    A,R1
   \   0001C5   F583         MOV     DPH,A
   \   0001C7   A3           INC     DPTR
   \   0001C8   A3           INC     DPTR
   \   0001C9   EA           MOV     A,R2
   \   0001CA   F0           MOVX    @DPTR,A
   \   0001CB   A3           INC     DPTR
   \   0001CC   EB           MOV     A,R3
   \   0001CD   F0           MOVX    @DPTR,A
   \   0001CE   0E           INC     R6
   3651                break;
   \   0001CF   02....       LJMP    ??zclProcessInWriteUndividedCmd_3 & 0xFFFF
   3652              }
   3653          
   3654              if ( !zcl_AccessCtrlWrite( attrRec.attr.accessControl ) )
   \                     ??zclProcessInWriteUndividedCmd_5:
   \   0001D2   740B         MOV     A,#0xb
   \   0001D4   12....       LCALL   ?XSTACK_DISP0_8
   \   0001D7   E0           MOVX    A,@DPTR
   \   0001D8   A2E1         MOV     C,0xE0 /* A   */.1
   \   0001DA   4060         JC      ??zclProcessInWriteUndividedCmd_6
   3655              {
   3656                // Attribute is not writable - stop here
   3657                writeRspCmd->attrList[j].status = ZCL_STATUS_READ_ONLY;
   \   0001DC   EE           MOV     A,R6
   \   0001DD   F8           MOV     R0,A
   \   0001DE   7900         MOV     R1,#0x0
   \   0001E0   E8           MOV     A,R0
   \   0001E1   75F003       MOV     B,#0x3
   \   0001E4   A4           MUL     AB
   \   0001E5   C8           XCH     A,R0
   \   0001E6   AAF0         MOV     R2,B
   \   0001E8   75F000       MOV     B,#0x0
   \   0001EB   A4           MUL     AB
   \   0001EC   2A           ADD     A,R2
   \   0001ED   FA           MOV     R2,A
   \   0001EE   75F003       MOV     B,#0x3
   \   0001F1   E9           MOV     A,R1
   \   0001F2   A4           MUL     AB
   \   0001F3   2A           ADD     A,R2
   \   0001F4   F9           MOV     R1,A
   \   0001F5   E5..         MOV     A,?V0 + 0
   \   0001F7   28           ADD     A,R0
   \   0001F8   F582         MOV     DPL,A
   \   0001FA   E5..         MOV     A,?V0 + 1
   \   0001FC   39           ADDC    A,R1
   \   0001FD   F583         MOV     DPH,A
   \   0001FF   A3           INC     DPTR
   \   000200   7488         MOV     A,#-0x78
   \   000202   F0           MOVX    @DPTR,A
   3658                writeRspCmd->attrList[j++].attrID = statusRec->attrID;
   \   000203   85..82       MOV     DPL,?V0 + 4
   \   000206   85..83       MOV     DPH,?V0 + 5
   \   000209   E0           MOVX    A,@DPTR
   \   00020A   FA           MOV     R2,A
   \   00020B   A3           INC     DPTR
   \   00020C   E0           MOVX    A,@DPTR
   \   00020D   FB           MOV     R3,A
   \   00020E   EE           MOV     A,R6
   \   00020F   F8           MOV     R0,A
   \   000210   7900         MOV     R1,#0x0
   \   000212   E8           MOV     A,R0
   \   000213   75F003       MOV     B,#0x3
   \   000216   A4           MUL     AB
   \   000217   C8           XCH     A,R0
   \   000218   ACF0         MOV     R4,B
   \   00021A   75F000       MOV     B,#0x0
   \   00021D   A4           MUL     AB
   \   00021E   2C           ADD     A,R4
   \   00021F   FC           MOV     R4,A
   \   000220   75F003       MOV     B,#0x3
   \   000223   E9           MOV     A,R1
   \   000224   A4           MUL     AB
   \   000225   2C           ADD     A,R4
   \   000226   F9           MOV     R1,A
   \   000227   E5..         MOV     A,?V0 + 0
   \   000229   28           ADD     A,R0
   \   00022A   F582         MOV     DPL,A
   \   00022C   E5..         MOV     A,?V0 + 1
   \   00022E   39           ADDC    A,R1
   \   00022F   F583         MOV     DPH,A
   \   000231   A3           INC     DPTR
   \   000232   A3           INC     DPTR
   \   000233   EA           MOV     A,R2
   \   000234   F0           MOVX    @DPTR,A
   \   000235   A3           INC     DPTR
   \   000236   EB           MOV     A,R3
   \   000237   F0           MOVX    @DPTR,A
   \   000238   0E           INC     R6
   3659                break;
   \   000239   02....       LJMP    ??zclProcessInWriteUndividedCmd_3 & 0xFFFF
   3660              }
   3661          
   3662              if ( zcl_AccessCtrlAuthWrite( attrRec.attr.accessControl ) )
   \                     ??zclProcessInWriteUndividedCmd_6:
   \   00023C   740B         MOV     A,#0xb
   \   00023E   12....       LCALL   ?XSTACK_DISP0_8
   \   000241   E0           MOVX    A,@DPTR
   \   000242   A2E5         MOV     C,0xE0 /* A   */.5
   \   000244   5060         JNC     ??zclProcessInWriteUndividedCmd_7
   3663              {
   3664                // Not authorized to write - stop here
   3665                writeRspCmd->attrList[j].status = ZCL_STATUS_NOT_AUTHORIZED;
   \   000246   EE           MOV     A,R6
   \   000247   F8           MOV     R0,A
   \   000248   7900         MOV     R1,#0x0
   \   00024A   E8           MOV     A,R0
   \   00024B   75F003       MOV     B,#0x3
   \   00024E   A4           MUL     AB
   \   00024F   C8           XCH     A,R0
   \   000250   AAF0         MOV     R2,B
   \   000252   75F000       MOV     B,#0x0
   \   000255   A4           MUL     AB
   \   000256   2A           ADD     A,R2
   \   000257   FA           MOV     R2,A
   \   000258   75F003       MOV     B,#0x3
   \   00025B   E9           MOV     A,R1
   \   00025C   A4           MUL     AB
   \   00025D   2A           ADD     A,R2
   \   00025E   F9           MOV     R1,A
   \   00025F   E5..         MOV     A,?V0 + 0
   \   000261   28           ADD     A,R0
   \   000262   F582         MOV     DPL,A
   \   000264   E5..         MOV     A,?V0 + 1
   \   000266   39           ADDC    A,R1
   \   000267   F583         MOV     DPH,A
   \   000269   A3           INC     DPTR
   \   00026A   747E         MOV     A,#0x7e
   \   00026C   F0           MOVX    @DPTR,A
   3666                writeRspCmd->attrList[j++].attrID = statusRec->attrID;
   \   00026D   85..82       MOV     DPL,?V0 + 4
   \   000270   85..83       MOV     DPH,?V0 + 5
   \   000273   E0           MOVX    A,@DPTR
   \   000274   FA           MOV     R2,A
   \   000275   A3           INC     DPTR
   \   000276   E0           MOVX    A,@DPTR
   \   000277   FB           MOV     R3,A
   \   000278   EE           MOV     A,R6
   \   000279   F8           MOV     R0,A
   \   00027A   7900         MOV     R1,#0x0
   \   00027C   E8           MOV     A,R0
   \   00027D   75F003       MOV     B,#0x3
   \   000280   A4           MUL     AB
   \   000281   C8           XCH     A,R0
   \   000282   ACF0         MOV     R4,B
   \   000284   75F000       MOV     B,#0x0
   \   000287   A4           MUL     AB
   \   000288   2C           ADD     A,R4
   \   000289   FC           MOV     R4,A
   \   00028A   75F003       MOV     B,#0x3
   \   00028D   E9           MOV     A,R1
   \   00028E   A4           MUL     AB
   \   00028F   2C           ADD     A,R4
   \   000290   F9           MOV     R1,A
   \   000291   E5..         MOV     A,?V0 + 0
   \   000293   28           ADD     A,R0
   \   000294   F582         MOV     DPL,A
   \   000296   E5..         MOV     A,?V0 + 1
   \   000298   39           ADDC    A,R1
   \   000299   F583         MOV     DPH,A
   \   00029B   A3           INC     DPTR
   \   00029C   A3           INC     DPTR
   \   00029D   EA           MOV     A,R2
   \   00029E   F0           MOVX    @DPTR,A
   \   00029F   A3           INC     DPTR
   \   0002A0   EB           MOV     A,R3
   \   0002A1   F0           MOVX    @DPTR,A
   \   0002A2   0E           INC     R6
   3667                break;
   \   0002A3   02....       LJMP    ??zclProcessInWriteUndividedCmd_3 & 0xFFFF
   3668              }
   3669          
   3670              // Attribute Data length
   3671              if ( attrRec.attr.dataPtr != NULL )
   \                     ??zclProcessInWriteUndividedCmd_7:
   \   0002A6   740C         MOV     A,#0xc
   \   0002A8   12....       LCALL   ?XSTACK_DISP0_8
   \   0002AB   E0           MOVX    A,@DPTR
   \   0002AC   F8           MOV     R0,A
   \   0002AD   A3           INC     DPTR
   \   0002AE   E0           MOVX    A,@DPTR
   \   0002AF   F9           MOV     R1,A
   \   0002B0   E8           MOV     A,R0
   \   0002B1   49           ORL     A,R1
   \   0002B2   6021         JZ      ??zclProcessInWriteUndividedCmd_8
   3672              {
   3673                dataLen = zclGetAttrDataLength( attrRec.attr.dataType, attrRec.attr.dataPtr );
   \   0002B4                ; Setup parameters for call to function zclGetAttrDataLength
   \   0002B4   740C         MOV     A,#0xc
   \   0002B6   12....       LCALL   ?XSTACK_DISP0_8
   \   0002B9   E0           MOVX    A,@DPTR
   \   0002BA   FA           MOV     R2,A
   \   0002BB   A3           INC     DPTR
   \   0002BC   E0           MOVX    A,@DPTR
   \   0002BD   FB           MOV     R3,A
   \   0002BE   740A         MOV     A,#0xa
   \   0002C0   12....       LCALL   ?XSTACK_DISP0_8
   \   0002C3   E0           MOVX    A,@DPTR
   \   0002C4   F9           MOV     R1,A
   \   0002C5   12....       LCALL   ??zclGetAttrDataLength?relay
   \   0002C8   85..82       MOV     DPL,?XSP + 0
   \   0002CB   85..83       MOV     DPH,?XSP + 1
   \   0002CE   EA           MOV     A,R2
   \   0002CF   F0           MOVX    @DPTR,A
   \   0002D0   A3           INC     DPTR
   \   0002D1   EB           MOV     A,R3
   \   0002D2   F0           MOVX    @DPTR,A
   \   0002D3   8046         SJMP    ??zclProcessInWriteUndividedCmd_9
   3674              }
   3675              else // Use CB
   3676              {
   3677                dataLen = zclGetAttrDataLengthUsingCB( pInMsg->msg->endPoint, pInMsg->msg->clusterId,
   3678                                                       statusRec->attrID );
   \                     ??zclProcessInWriteUndividedCmd_8:
   \   0002D5                ; Setup parameters for call to function zclGetAttrDataLengthUsingCB
   \   0002D5   85..82       MOV     DPL,?V0 + 4
   \   0002D8   85..83       MOV     DPH,?V0 + 5
   \   0002DB   E0           MOVX    A,@DPTR
   \   0002DC   FC           MOV     R4,A
   \   0002DD   A3           INC     DPTR
   \   0002DE   E0           MOVX    A,@DPTR
   \   0002DF   FD           MOV     R5,A
   \   0002E0   85..82       MOV     DPL,?V0 + 2
   \   0002E3   85..83       MOV     DPH,?V0 + 3
   \   0002E6   E0           MOVX    A,@DPTR
   \   0002E7   F8           MOV     R0,A
   \   0002E8   A3           INC     DPTR
   \   0002E9   E0           MOVX    A,@DPTR
   \   0002EA   F583         MOV     DPH,A
   \   0002EC   8882         MOV     DPL,R0
   \   0002EE   A3           INC     DPTR
   \   0002EF   A3           INC     DPTR
   \   0002F0   A3           INC     DPTR
   \   0002F1   A3           INC     DPTR
   \   0002F2   E0           MOVX    A,@DPTR
   \   0002F3   FA           MOV     R2,A
   \   0002F4   A3           INC     DPTR
   \   0002F5   E0           MOVX    A,@DPTR
   \   0002F6   FB           MOV     R3,A
   \   0002F7   85..82       MOV     DPL,?V0 + 2
   \   0002FA   85..83       MOV     DPH,?V0 + 3
   \   0002FD   E0           MOVX    A,@DPTR
   \   0002FE   F8           MOV     R0,A
   \   0002FF   A3           INC     DPTR
   \   000300   E0           MOVX    A,@DPTR
   \   000301   C8           XCH     A,R0
   \   000302   2414         ADD     A,#0x14
   \   000304   F582         MOV     DPL,A
   \   000306   E8           MOV     A,R0
   \   000307   3400         ADDC    A,#0x0
   \   000309   F583         MOV     DPH,A
   \   00030B   E0           MOVX    A,@DPTR
   \   00030C   F9           MOV     R1,A
   \   00030D   12....       LCALL   ??zclGetAttrDataLengthUsingCB?relay
   \   000310   85..82       MOV     DPL,?XSP + 0
   \   000313   85..83       MOV     DPH,?XSP + 1
   \   000316   EA           MOV     A,R2
   \   000317   F0           MOVX    @DPTR,A
   \   000318   A3           INC     DPTR
   \   000319   EB           MOV     A,R3
   \   00031A   F0           MOVX    @DPTR,A
   3679              }
   3680          
   3681              // add padding if needed
   3682              if ( PADDING_NEEDED( dataLen ) )
   \                     ??zclProcessInWriteUndividedCmd_9:
   \   00031B   85..82       MOV     DPL,?XSP + 0
   \   00031E   85..83       MOV     DPH,?XSP + 1
   \   000321   E0           MOVX    A,@DPTR
   \   000322   F8           MOV     R0,A
   \   000323   A3           INC     DPTR
   \   000324   E0           MOVX    A,@DPTR
   \   000325   F9           MOV     R1,A
   \   000326   E8           MOV     A,R0
   \   000327   A2E0         MOV     C,0xE0 /* A   */.0
   \   000329   500F         JNC     ??zclProcessInWriteUndividedCmd_10
   3683              {
   3684                dataLen++;
   \   00032B   85..82       MOV     DPL,?XSP + 0
   \   00032E   85..83       MOV     DPH,?XSP + 1
   \   000331   E0           MOVX    A,@DPTR
   \   000332   2401         ADD     A,#0x1
   \   000334   F0           MOVX    @DPTR,A
   \   000335   A3           INC     DPTR
   \   000336   E0           MOVX    A,@DPTR
   \   000337   3400         ADDC    A,#0x0
   \   000339   F0           MOVX    @DPTR,A
   3685              }
   3686          
   3687              curLen += dataLen;
   \                     ??zclProcessInWriteUndividedCmd_10:
   \   00033A   85..82       MOV     DPL,?XSP + 0
   \   00033D   85..83       MOV     DPH,?XSP + 1
   \   000340   E0           MOVX    A,@DPTR
   \   000341   F8           MOV     R0,A
   \   000342   A3           INC     DPTR
   \   000343   E0           MOVX    A,@DPTR
   \   000344   F9           MOV     R1,A
   \   000345   7404         MOV     A,#0x4
   \   000347   12....       LCALL   ?XSTACK_DISP0_8
   \   00034A   E0           MOVX    A,@DPTR
   \   00034B   28           ADD     A,R0
   \   00034C   F0           MOVX    @DPTR,A
   \   00034D   A3           INC     DPTR
   \   00034E   E0           MOVX    A,@DPTR
   \   00034F   39           ADDC    A,R1
   \   000350   F0           MOVX    @DPTR,A
   3688            } // for loop
   \   000351   0F           INC     R7
   \   000352   02....       LJMP    ??zclProcessInWriteUndividedCmd_2 & 0xFFFF
   3689          
   3690            writeRspCmd->numAttr = j;
   \                     ??zclProcessInWriteUndividedCmd_3:
   \   000355   EE           MOV     A,R6
   \   000356   85..82       MOV     DPL,?V0 + 0
   \   000359   85..83       MOV     DPH,?V0 + 1
   \   00035C   F0           MOVX    @DPTR,A
   3691            if ( writeRspCmd->numAttr == 0 ) // All attributes can be written
   \   00035D   85..82       MOV     DPL,?V0 + 0
   \   000360   85..83       MOV     DPH,?V0 + 1
   \   000363   E0           MOVX    A,@DPTR
   \   000364   6003         JZ      $+5
   \   000366   02....       LJMP    ??zclProcessInWriteUndividedCmd_11 & 0xFFFF
   3692            {
   3693              uint8 *curDataPtr;
   3694              zclWriteRec_t *curWriteRec;
   3695          
   3696              // calculate the length of the current data header
   3697              uint8 hdrLen = j * sizeof( zclWriteRec_t );
   \   000369   75F005       MOV     B,#0x5
   \   00036C   EE           MOV     A,R6
   \   00036D   A4           MUL     AB
   \   00036E   F5..         MOV     ?V0 + 5,A
   3698          
   3699              // Allocate space to keep a copy of the current data
   3700              curWriteRec = (zclWriteRec_t *) osal_mem_alloc( hdrLen + curLen );
   \   000370                ; Setup parameters for call to function osal_mem_alloc
   \   000370   85....       MOV     ?V0 + 4,?V0 + 5
   \   000373   85....       MOV     ?V0 + 8,?V0 + 4
   \   000376   75..00       MOV     ?V0 + 9,#0x0
   \   000379   7404         MOV     A,#0x4
   \   00037B   12....       LCALL   ?XSTACK_DISP0_8
   \   00037E   E0           MOVX    A,@DPTR
   \   00037F   25..         ADD     A,?V0 + 8
   \   000381   FA           MOV     R2,A
   \   000382   A3           INC     DPTR
   \   000383   E0           MOVX    A,@DPTR
   \   000384   35..         ADDC    A,?V0 + 9
   \   000386   FB           MOV     R3,A
   \   000387   12....       LCALL   ??osal_mem_alloc?relay
   \   00038A   8A..         MOV     ?V0 + 8,R2
   \   00038C   8B..         MOV     ?V0 + 9,R3
   \   00038E   85....       MOV     ?V0 + 12,?V0 + 8
   \   000391   85....       MOV     ?V0 + 13,?V0 + 9
   3701              if ( curWriteRec == NULL )
   \   000394   E5..         MOV     A,?V0 + 12
   \   000396   45..         ORL     A,?V0 + 13
   \   000398   700C         JNZ     ??zclProcessInWriteUndividedCmd_12
   3702              {
   3703                osal_mem_free(writeRspCmd );
   \   00039A                ; Setup parameters for call to function osal_mem_free
   \   00039A   AA..         MOV     R2,?V0 + 0
   \   00039C   AB..         MOV     R3,?V0 + 1
   \   00039E   12....       LCALL   ??osal_mem_free?relay
   3704                return FALSE; // EMBEDDED RETURN
   \   0003A1   7900         MOV     R1,#0x0
   \   0003A3   02....       LJMP    ??zclProcessInWriteUndividedCmd_1 & 0xFFFF
   3705              }
   3706          
   3707              curDataPtr = (uint8 *)((uint8 *)curWriteRec + hdrLen);
   \                     ??zclProcessInWriteUndividedCmd_12:
   \   0003A6   85....       MOV     ?V0 + 4,?V0 + 5
   \   0003A9   85....       MOV     ?V0 + 8,?V0 + 4
   \   0003AC   75..00       MOV     ?V0 + 9,#0x0
   \   0003AF   E5..         MOV     A,?V0 + 12
   \   0003B1   25..         ADD     A,?V0 + 8
   \   0003B3   F8           MOV     R0,A
   \   0003B4   E5..         MOV     A,?V0 + 13
   \   0003B6   35..         ADDC    A,?V0 + 9
   \   0003B8   F9           MOV     R1,A
   \   0003B9   88..         MOV     ?V0 + 6,R0
   \   0003BB   89..         MOV     ?V0 + 7,R1
   3708          
   3709              // Write the new data over
   3710              for ( uint8 i = 0; i < writeCmd->numAttr; i++ )
   \   0003BD   7F00         MOV     R7,#0x0
   \                     ??zclProcessInWriteUndividedCmd_13:
   \   0003BF   85..82       MOV     DPL,?V0 + 14
   \   0003C2   85..83       MOV     DPH,?V0 + 15
   \   0003C5   E0           MOVX    A,@DPTR
   \   0003C6   F8           MOV     R0,A
   \   0003C7   EF           MOV     A,R7
   \   0003C8   C3           CLR     C
   \   0003C9   98           SUBB    A,R0
   \   0003CA   4003         JC      $+5
   \   0003CC   02....       LJMP    ??zclProcessInWriteUndividedCmd_14 & 0xFFFF
   3711              {
   3712                uint8 status;
   3713                zclWriteRec_t *statusRec = &(writeCmd->attrList[i]);
   \   0003CF   EF           MOV     A,R7
   \   0003D0   F8           MOV     R0,A
   \   0003D1   7900         MOV     R1,#0x0
   \   0003D3   E8           MOV     A,R0
   \   0003D4   75F005       MOV     B,#0x5
   \   0003D7   A4           MUL     AB
   \   0003D8   C8           XCH     A,R0
   \   0003D9   AAF0         MOV     R2,B
   \   0003DB   75F000       MOV     B,#0x0
   \   0003DE   A4           MUL     AB
   \   0003DF   2A           ADD     A,R2
   \   0003E0   FA           MOV     R2,A
   \   0003E1   75F005       MOV     B,#0x5
   \   0003E4   E9           MOV     A,R1
   \   0003E5   A4           MUL     AB
   \   0003E6   2A           ADD     A,R2
   \   0003E7   F9           MOV     R1,A
   \   0003E8   E5..         MOV     A,?V0 + 14
   \   0003EA   28           ADD     A,R0
   \   0003EB   F582         MOV     DPL,A
   \   0003ED   E5..         MOV     A,?V0 + 15
   \   0003EF   39           ADDC    A,R1
   \   0003F0   F583         MOV     DPH,A
   \   0003F2   A3           INC     DPTR
   \   0003F3   8582..       MOV     ?V0 + 8,DPL
   \   0003F6   8583..       MOV     ?V0 + 9,DPH
   3714                zclWriteRec_t *curStatusRec = &(curWriteRec[i]);
   \   0003F9   EF           MOV     A,R7
   \   0003FA   F8           MOV     R0,A
   \   0003FB   7900         MOV     R1,#0x0
   \   0003FD   E8           MOV     A,R0
   \   0003FE   75F005       MOV     B,#0x5
   \   000401   A4           MUL     AB
   \   000402   C8           XCH     A,R0
   \   000403   AAF0         MOV     R2,B
   \   000405   75F000       MOV     B,#0x0
   \   000408   A4           MUL     AB
   \   000409   2A           ADD     A,R2
   \   00040A   FA           MOV     R2,A
   \   00040B   75F005       MOV     B,#0x5
   \   00040E   E9           MOV     A,R1
   \   00040F   A4           MUL     AB
   \   000410   2A           ADD     A,R2
   \   000411   F9           MOV     R1,A
   \   000412   E5..         MOV     A,?V0 + 12
   \   000414   28           ADD     A,R0
   \   000415   F8           MOV     R0,A
   \   000416   E5..         MOV     A,?V0 + 13
   \   000418   39           ADDC    A,R1
   \   000419   F9           MOV     R1,A
   \   00041A   7402         MOV     A,#0x2
   \   00041C   12....       LCALL   ?XSTACK_DISP0_8
   \   00041F   E8           MOV     A,R0
   \   000420   F0           MOVX    @DPTR,A
   \   000421   A3           INC     DPTR
   \   000422   E9           MOV     A,R1
   \   000423   F0           MOVX    @DPTR,A
   3715          
   3716                if ( !zclFindAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId,
   3717                                      statusRec->attrID, &attrRec ) )
   \   000424                ; Setup parameters for call to function zclFindAttrRec
   \   000424   7406         MOV     A,#0x6
   \   000426   12....       LCALL   ?XSTACK_DISP0_8
   \   000429   8582..       MOV     ?V0 + 10,DPL
   \   00042C   8583..       MOV     ?V0 + 11,DPH
   \   00042F   78..         MOV     R0,#?V0 + 10
   \   000431   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000434   85..82       MOV     DPL,?V0 + 8
   \   000437   85..83       MOV     DPH,?V0 + 9
   \   00043A   E0           MOVX    A,@DPTR
   \   00043B   FC           MOV     R4,A
   \   00043C   A3           INC     DPTR
   \   00043D   E0           MOVX    A,@DPTR
   \   00043E   FD           MOV     R5,A
   \   00043F   85..82       MOV     DPL,?V0 + 2
   \   000442   85..83       MOV     DPH,?V0 + 3
   \   000445   E0           MOVX    A,@DPTR
   \   000446   F8           MOV     R0,A
   \   000447   A3           INC     DPTR
   \   000448   E0           MOVX    A,@DPTR
   \   000449   F583         MOV     DPH,A
   \   00044B   8882         MOV     DPL,R0
   \   00044D   A3           INC     DPTR
   \   00044E   A3           INC     DPTR
   \   00044F   A3           INC     DPTR
   \   000450   A3           INC     DPTR
   \   000451   E0           MOVX    A,@DPTR
   \   000452   FA           MOV     R2,A
   \   000453   A3           INC     DPTR
   \   000454   E0           MOVX    A,@DPTR
   \   000455   FB           MOV     R3,A
   \   000456   85..82       MOV     DPL,?V0 + 2
   \   000459   85..83       MOV     DPH,?V0 + 3
   \   00045C   E0           MOVX    A,@DPTR
   \   00045D   F8           MOV     R0,A
   \   00045E   A3           INC     DPTR
   \   00045F   E0           MOVX    A,@DPTR
   \   000460   C8           XCH     A,R0
   \   000461   2414         ADD     A,#0x14
   \   000463   F582         MOV     DPL,A
   \   000465   E8           MOV     A,R0
   \   000466   3400         ADDC    A,#0x0
   \   000468   F583         MOV     DPH,A
   \   00046A   E0           MOVX    A,@DPTR
   \   00046B   F9           MOV     R1,A
   \   00046C   12....       LCALL   ??zclFindAttrRec?relay
   \   00046F   7402         MOV     A,#0x2
   \   000471   12....       LCALL   ?DEALLOC_XSTACK8
   \   000474   E9           MOV     A,R1
   \   000475   7003         JNZ     $+5
   \   000477   02....       LJMP    ??zclProcessInWriteUndividedCmd_14 & 0xFFFF
   3718                {
   3719                  break; // should never happen
   3720                }
   3721          
   3722                // Keep a copy of the current data before before writing the new data over
   3723                curStatusRec->attrID = statusRec->attrID;
   \   00047A   85..82       MOV     DPL,?V0 + 8
   \   00047D   85..83       MOV     DPH,?V0 + 9
   \   000480   E0           MOVX    A,@DPTR
   \   000481   FA           MOV     R2,A
   \   000482   A3           INC     DPTR
   \   000483   E0           MOVX    A,@DPTR
   \   000484   FB           MOV     R3,A
   \   000485   7402         MOV     A,#0x2
   \   000487   12....       LCALL   ?XSTACK_DISP0_8
   \   00048A   E0           MOVX    A,@DPTR
   \   00048B   F8           MOV     R0,A
   \   00048C   A3           INC     DPTR
   \   00048D   E0           MOVX    A,@DPTR
   \   00048E   F583         MOV     DPH,A
   \   000490   8882         MOV     DPL,R0
   \   000492   EA           MOV     A,R2
   \   000493   F0           MOVX    @DPTR,A
   \   000494   A3           INC     DPTR
   \   000495   EB           MOV     A,R3
   \   000496   F0           MOVX    @DPTR,A
   3724                curStatusRec->attrData = curDataPtr;
   \   000497   7402         MOV     A,#0x2
   \   000499   12....       LCALL   ?XSTACK_DISP0_8
   \   00049C   E0           MOVX    A,@DPTR
   \   00049D   F8           MOV     R0,A
   \   00049E   A3           INC     DPTR
   \   00049F   E0           MOVX    A,@DPTR
   \   0004A0   F583         MOV     DPH,A
   \   0004A2   8882         MOV     DPL,R0
   \   0004A4   A3           INC     DPTR
   \   0004A5   A3           INC     DPTR
   \   0004A6   A3           INC     DPTR
   \   0004A7   E5..         MOV     A,?V0 + 6
   \   0004A9   F0           MOVX    @DPTR,A
   \   0004AA   A3           INC     DPTR
   \   0004AB   E5..         MOV     A,?V0 + 7
   \   0004AD   F0           MOVX    @DPTR,A
   3725          
   3726                if ( attrRec.attr.dataPtr != NULL )
   \   0004AE   740C         MOV     A,#0xc
   \   0004B0   12....       LCALL   ?XSTACK_DISP0_8
   \   0004B3   E0           MOVX    A,@DPTR
   \   0004B4   F8           MOV     R0,A
   \   0004B5   A3           INC     DPTR
   \   0004B6   E0           MOVX    A,@DPTR
   \   0004B7   F9           MOV     R1,A
   \   0004B8   E8           MOV     A,R0
   \   0004B9   49           ORL     A,R1
   \   0004BA   6068         JZ      ??zclProcessInWriteUndividedCmd_15
   3727                {
   3728                  // Read the current value
   3729                  zclReadAttrData( curDataPtr, &attrRec, &dataLen );
   \   0004BC                ; Setup parameters for call to function zclReadAttrData
   \   0004BC   85..82       MOV     DPL,?XSP + 0
   \   0004BF   85..83       MOV     DPH,?XSP + 1
   \   0004C2   8582..       MOV     ?V0 + 10,DPL
   \   0004C5   8583..       MOV     ?V0 + 11,DPH
   \   0004C8   78..         MOV     R0,#?V0 + 10
   \   0004CA   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0004CD   7408         MOV     A,#0x8
   \   0004CF   12....       LCALL   ?XSTACK_DISP0_8
   \   0004D2   AC82         MOV     R4,DPL
   \   0004D4   AD83         MOV     R5,DPH
   \   0004D6   AA..         MOV     R2,?V0 + 6
   \   0004D8   AB..         MOV     R3,?V0 + 7
   \   0004DA   12....       LCALL   ??zclReadAttrData?relay
   \   0004DD   7402         MOV     A,#0x2
   \   0004DF   12....       LCALL   ?DEALLOC_XSTACK8
   \   0004E2   E9           MOV     A,R1
   3730          
   3731                  // Write the new attribute value
   3732                  status = zclWriteAttrData( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr),
   3733                                             &attrRec, statusRec );
   \   0004E3                ; Setup parameters for call to function zclWriteAttrData
   \   0004E3   78..         MOV     R0,#?V0 + 8
   \   0004E5   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0004E8   7408         MOV     A,#0x8
   \   0004EA   12....       LCALL   ?XSTACK_DISP0_8
   \   0004ED   AC82         MOV     R4,DPL
   \   0004EF   AD83         MOV     R5,DPH
   \   0004F1   85..82       MOV     DPL,?V0 + 2
   \   0004F4   85..83       MOV     DPH,?V0 + 3
   \   0004F7   E0           MOVX    A,@DPTR
   \   0004F8   2406         ADD     A,#0x6
   \   0004FA   FA           MOV     R2,A
   \   0004FB   A3           INC     DPTR
   \   0004FC   E0           MOVX    A,@DPTR
   \   0004FD   3400         ADDC    A,#0x0
   \   0004FF   FB           MOV     R3,A
   \   000500   85..82       MOV     DPL,?V0 + 2
   \   000503   85..83       MOV     DPH,?V0 + 3
   \   000506   E0           MOVX    A,@DPTR
   \   000507   F8           MOV     R0,A
   \   000508   A3           INC     DPTR
   \   000509   E0           MOVX    A,@DPTR
   \   00050A   C8           XCH     A,R0
   \   00050B   2414         ADD     A,#0x14
   \   00050D   F582         MOV     DPL,A
   \   00050F   E8           MOV     A,R0
   \   000510   3400         ADDC    A,#0x0
   \   000512   F583         MOV     DPH,A
   \   000514   E0           MOVX    A,@DPTR
   \   000515   F9           MOV     R1,A
   \   000516   12....       LCALL   ??zclWriteAttrData?relay
   \   000519   7402         MOV     A,#0x2
   \   00051B   12....       LCALL   ?DEALLOC_XSTACK8
   \   00051E   E9           MOV     A,R1
   \   00051F   F5..         MOV     ?V0 + 4,A
   \   000521   02....       LJMP    ??zclProcessInWriteUndividedCmd_16 & 0xFFFF
   3734                }
   3735                else // Use CBs
   3736                {
   3737                  // Read the current value
   3738                  zclReadAttrDataUsingCB( pInMsg->msg->endPoint, pInMsg->msg->clusterId,
   3739                                          statusRec->attrID, curDataPtr, &dataLen );
   \                     ??zclProcessInWriteUndividedCmd_15:
   \   000524                ; Setup parameters for call to function zclReadAttrDataUsingCB
   \   000524   85..82       MOV     DPL,?XSP + 0
   \   000527   85..83       MOV     DPH,?XSP + 1
   \   00052A   8582..       MOV     ?V0 + 10,DPL
   \   00052D   8583..       MOV     ?V0 + 11,DPH
   \   000530   78..         MOV     R0,#?V0 + 10
   \   000532   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000535   78..         MOV     R0,#?V0 + 6
   \   000537   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00053A   85..82       MOV     DPL,?V0 + 8
   \   00053D   85..83       MOV     DPH,?V0 + 9
   \   000540   E0           MOVX    A,@DPTR
   \   000541   FC           MOV     R4,A
   \   000542   A3           INC     DPTR
   \   000543   E0           MOVX    A,@DPTR
   \   000544   FD           MOV     R5,A
   \   000545   85..82       MOV     DPL,?V0 + 2
   \   000548   85..83       MOV     DPH,?V0 + 3
   \   00054B   E0           MOVX    A,@DPTR
   \   00054C   F8           MOV     R0,A
   \   00054D   A3           INC     DPTR
   \   00054E   E0           MOVX    A,@DPTR
   \   00054F   F583         MOV     DPH,A
   \   000551   8882         MOV     DPL,R0
   \   000553   A3           INC     DPTR
   \   000554   A3           INC     DPTR
   \   000555   A3           INC     DPTR
   \   000556   A3           INC     DPTR
   \   000557   E0           MOVX    A,@DPTR
   \   000558   FA           MOV     R2,A
   \   000559   A3           INC     DPTR
   \   00055A   E0           MOVX    A,@DPTR
   \   00055B   FB           MOV     R3,A
   \   00055C   85..82       MOV     DPL,?V0 + 2
   \   00055F   85..83       MOV     DPH,?V0 + 3
   \   000562   E0           MOVX    A,@DPTR
   \   000563   F8           MOV     R0,A
   \   000564   A3           INC     DPTR
   \   000565   E0           MOVX    A,@DPTR
   \   000566   C8           XCH     A,R0
   \   000567   2414         ADD     A,#0x14
   \   000569   F582         MOV     DPL,A
   \   00056B   E8           MOV     A,R0
   \   00056C   3400         ADDC    A,#0x0
   \   00056E   F583         MOV     DPH,A
   \   000570   E0           MOVX    A,@DPTR
   \   000571   F9           MOV     R1,A
   \   000572   12....       LCALL   ??zclReadAttrDataUsingCB?relay
   \   000575   7404         MOV     A,#0x4
   \   000577   12....       LCALL   ?DEALLOC_XSTACK8
   \   00057A   E9           MOV     A,R1
   3740                  // Write the new attribute value
   3741                  status = zclWriteAttrDataUsingCB( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr),
   3742                                                    &attrRec, statusRec->attrData );
   \   00057B                ; Setup parameters for call to function zclWriteAttrDataUsingCB
   \   00057B   85..82       MOV     DPL,?V0 + 8
   \   00057E   85..83       MOV     DPH,?V0 + 9
   \   000581   A3           INC     DPTR
   \   000582   A3           INC     DPTR
   \   000583   A3           INC     DPTR
   \   000584   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   000587   7408         MOV     A,#0x8
   \   000589   12....       LCALL   ?XSTACK_DISP0_8
   \   00058C   AC82         MOV     R4,DPL
   \   00058E   AD83         MOV     R5,DPH
   \   000590   85..82       MOV     DPL,?V0 + 2
   \   000593   85..83       MOV     DPH,?V0 + 3
   \   000596   E0           MOVX    A,@DPTR
   \   000597   2406         ADD     A,#0x6
   \   000599   FA           MOV     R2,A
   \   00059A   A3           INC     DPTR
   \   00059B   E0           MOVX    A,@DPTR
   \   00059C   3400         ADDC    A,#0x0
   \   00059E   FB           MOV     R3,A
   \   00059F   85..82       MOV     DPL,?V0 + 2
   \   0005A2   85..83       MOV     DPH,?V0 + 3
   \   0005A5   E0           MOVX    A,@DPTR
   \   0005A6   F8           MOV     R0,A
   \   0005A7   A3           INC     DPTR
   \   0005A8   E0           MOVX    A,@DPTR
   \   0005A9   C8           XCH     A,R0
   \   0005AA   2414         ADD     A,#0x14
   \   0005AC   F582         MOV     DPL,A
   \   0005AE   E8           MOV     A,R0
   \   0005AF   3400         ADDC    A,#0x0
   \   0005B1   F583         MOV     DPH,A
   \   0005B3   E0           MOVX    A,@DPTR
   \   0005B4   F9           MOV     R1,A
   \   0005B5   12....       LCALL   ??zclWriteAttrDataUsingCB?relay
   \   0005B8   7402         MOV     A,#0x2
   \   0005BA   12....       LCALL   ?DEALLOC_XSTACK8
   \   0005BD   E9           MOV     A,R1
   \   0005BE   F5..         MOV     ?V0 + 4,A
   3743                }
   3744          
   3745                // If successful, a write attribute status record shall NOT be generated
   3746                if ( status != ZCL_STATUS_SUCCESS )
   \                     ??zclProcessInWriteUndividedCmd_16:
   \   0005C0   E5..         MOV     A,?V0 + 4
   \   0005C2   607B         JZ      ??zclProcessInWriteUndividedCmd_17
   3747                {
   3748                  writeRspCmd->attrList[j].status = status;
   \   0005C4   E5..         MOV     A,?V0 + 4
   \   0005C6   EE           MOV     A,R6
   \   0005C7   F8           MOV     R0,A
   \   0005C8   7900         MOV     R1,#0x0
   \   0005CA   E8           MOV     A,R0
   \   0005CB   75F003       MOV     B,#0x3
   \   0005CE   A4           MUL     AB
   \   0005CF   C8           XCH     A,R0
   \   0005D0   AAF0         MOV     R2,B
   \   0005D2   75F000       MOV     B,#0x0
   \   0005D5   A4           MUL     AB
   \   0005D6   2A           ADD     A,R2
   \   0005D7   FA           MOV     R2,A
   \   0005D8   75F003       MOV     B,#0x3
   \   0005DB   E9           MOV     A,R1
   \   0005DC   A4           MUL     AB
   \   0005DD   2A           ADD     A,R2
   \   0005DE   F9           MOV     R1,A
   \   0005DF   E5..         MOV     A,?V0 + 0
   \   0005E1   28           ADD     A,R0
   \   0005E2   F582         MOV     DPL,A
   \   0005E4   E5..         MOV     A,?V0 + 1
   \   0005E6   39           ADDC    A,R1
   \   0005E7   F583         MOV     DPH,A
   \   0005E9   A3           INC     DPTR
   \   0005EA   E5..         MOV     A,?V0 + 4
   \   0005EC   F0           MOVX    @DPTR,A
   3749                  writeRspCmd->attrList[j++].attrID = statusRec->attrID;
   \   0005ED   85..82       MOV     DPL,?V0 + 8
   \   0005F0   85..83       MOV     DPH,?V0 + 9
   \   0005F3   E0           MOVX    A,@DPTR
   \   0005F4   FA           MOV     R2,A
   \   0005F5   A3           INC     DPTR
   \   0005F6   E0           MOVX    A,@DPTR
   \   0005F7   FB           MOV     R3,A
   \   0005F8   EE           MOV     A,R6
   \   0005F9   F8           MOV     R0,A
   \   0005FA   7900         MOV     R1,#0x0
   \   0005FC   E8           MOV     A,R0
   \   0005FD   75F003       MOV     B,#0x3
   \   000600   A4           MUL     AB
   \   000601   C8           XCH     A,R0
   \   000602   ACF0         MOV     R4,B
   \   000604   75F000       MOV     B,#0x0
   \   000607   A4           MUL     AB
   \   000608   2C           ADD     A,R4
   \   000609   FC           MOV     R4,A
   \   00060A   75F003       MOV     B,#0x3
   \   00060D   E9           MOV     A,R1
   \   00060E   A4           MUL     AB
   \   00060F   2C           ADD     A,R4
   \   000610   F9           MOV     R1,A
   \   000611   E5..         MOV     A,?V0 + 0
   \   000613   28           ADD     A,R0
   \   000614   F582         MOV     DPL,A
   \   000616   E5..         MOV     A,?V0 + 1
   \   000618   39           ADDC    A,R1
   \   000619   F583         MOV     DPH,A
   \   00061B   A3           INC     DPTR
   \   00061C   A3           INC     DPTR
   \   00061D   EA           MOV     A,R2
   \   00061E   F0           MOVX    @DPTR,A
   \   00061F   A3           INC     DPTR
   \   000620   EB           MOV     A,R3
   \   000621   F0           MOVX    @DPTR,A
   \   000622   0E           INC     R6
   3750          
   3751                  // Since this write failed, we need to revert all the pervious writes
   3752                  zclRevertWriteUndividedCmd( pInMsg, curWriteRec, i);
   \   000623                ; Setup parameters for call to function zclRevertWriteUndividedCmd
   \   000623   8F..         MOV     ?V0 + 10,R7
   \   000625   75..00       MOV     ?V0 + 11,#0x0
   \   000628   78..         MOV     R0,#?V0 + 10
   \   00062A   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00062D   AC..         MOV     R4,?V0 + 12
   \   00062F   AD..         MOV     R5,?V0 + 13
   \   000631   AA..         MOV     R2,?V0 + 2
   \   000633   AB..         MOV     R3,?V0 + 3
   \   000635   12....       LCALL   ??zclRevertWriteUndividedCmd?relay
   \   000638   7402         MOV     A,#0x2
   \   00063A   12....       LCALL   ?DEALLOC_XSTACK8
   3753                  break;
   \   00063D   8038         SJMP    ??zclProcessInWriteUndividedCmd_14
   3754                }
   3755          
   3756                // add padding if needed
   3757                if ( PADDING_NEEDED( dataLen ) )
   \                     ??zclProcessInWriteUndividedCmd_17:
   \   00063F   85..82       MOV     DPL,?XSP + 0
   \   000642   85..83       MOV     DPH,?XSP + 1
   \   000645   E0           MOVX    A,@DPTR
   \   000646   F8           MOV     R0,A
   \   000647   A3           INC     DPTR
   \   000648   E0           MOVX    A,@DPTR
   \   000649   F9           MOV     R1,A
   \   00064A   E8           MOV     A,R0
   \   00064B   A2E0         MOV     C,0xE0 /* A   */.0
   \   00064D   500F         JNC     ??zclProcessInWriteUndividedCmd_18
   3758                {
   3759                  dataLen++;
   \   00064F   85..82       MOV     DPL,?XSP + 0
   \   000652   85..83       MOV     DPH,?XSP + 1
   \   000655   E0           MOVX    A,@DPTR
   \   000656   2401         ADD     A,#0x1
   \   000658   F0           MOVX    @DPTR,A
   \   000659   A3           INC     DPTR
   \   00065A   E0           MOVX    A,@DPTR
   \   00065B   3400         ADDC    A,#0x0
   \   00065D   F0           MOVX    @DPTR,A
   3760                }
   3761          
   3762                curDataPtr += dataLen;
   \                     ??zclProcessInWriteUndividedCmd_18:
   \   00065E   85..82       MOV     DPL,?XSP + 0
   \   000661   85..83       MOV     DPH,?XSP + 1
   \   000664   E0           MOVX    A,@DPTR
   \   000665   F8           MOV     R0,A
   \   000666   A3           INC     DPTR
   \   000667   E0           MOVX    A,@DPTR
   \   000668   F9           MOV     R1,A
   \   000669   E5..         MOV     A,?V0 + 6
   \   00066B   28           ADD     A,R0
   \   00066C   F5..         MOV     ?V0 + 6,A
   \   00066E   E5..         MOV     A,?V0 + 7
   \   000670   39           ADDC    A,R1
   \   000671   F5..         MOV     ?V0 + 7,A
   3763              } // for loop
   \   000673   0F           INC     R7
   \   000674   02....       LJMP    ??zclProcessInWriteUndividedCmd_13 & 0xFFFF
   3764          
   3765              writeRspCmd->numAttr = j;
   \                     ??zclProcessInWriteUndividedCmd_14:
   \   000677   EE           MOV     A,R6
   \   000678   85..82       MOV     DPL,?V0 + 0
   \   00067B   85..83       MOV     DPH,?V0 + 1
   \   00067E   F0           MOVX    @DPTR,A
   3766              if ( writeRspCmd->numAttr  == 0 )
   \   00067F   85..82       MOV     DPL,?V0 + 0
   \   000682   85..83       MOV     DPH,?V0 + 1
   \   000685   E0           MOVX    A,@DPTR
   \   000686   7013         JNZ     ??zclProcessInWriteUndividedCmd_19
   3767              {
   3768                // Since all records were written successful, include a single status record
   3769                // in the resonse command with the status field set to SUCCESS and the
   3770                // attribute ID field omitted.
   3771                writeRspCmd->attrList[0].status = ZCL_STATUS_SUCCESS;
   \   000688   85..82       MOV     DPL,?V0 + 0
   \   00068B   85..83       MOV     DPH,?V0 + 1
   \   00068E   A3           INC     DPTR
   \   00068F   7400         MOV     A,#0x0
   \   000691   F0           MOVX    @DPTR,A
   3772                writeRspCmd->numAttr = 1;
   \   000692   85..82       MOV     DPL,?V0 + 0
   \   000695   85..83       MOV     DPH,?V0 + 1
   \   000698   7401         MOV     A,#0x1
   \   00069A   F0           MOVX    @DPTR,A
   3773              }
   3774          
   3775              osal_mem_free( curWriteRec );
   \                     ??zclProcessInWriteUndividedCmd_19:
   \   00069B                ; Setup parameters for call to function osal_mem_free
   \   00069B   AA..         MOV     R2,?V0 + 12
   \   00069D   AB..         MOV     R3,?V0 + 13
   \   00069F   12....       LCALL   ??osal_mem_free?relay
   3776            }
   3777          
   3778            zcl_SendWriteRsp( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr),
   3779                              pInMsg->msg->clusterId, writeRspCmd, ZCL_FRAME_SERVER_CLIENT_DIR,
   3780                              true, pInMsg->hdr.transSeqNum );
   \                     ??zclProcessInWriteUndividedCmd_11:
   \   0006A2                ; Setup parameters for call to function zcl_SendWriteRsp
   \   0006A2   85..82       MOV     DPL,?V0 + 2
   \   0006A5   85..83       MOV     DPH,?V0 + 3
   \   0006A8   A3           INC     DPTR
   \   0006A9   A3           INC     DPTR
   \   0006AA   A3           INC     DPTR
   \   0006AB   A3           INC     DPTR
   \   0006AC   A3           INC     DPTR
   \   0006AD   A3           INC     DPTR
   \   0006AE   E0           MOVX    A,@DPTR
   \   0006AF   F5..         MOV     ?V0 + 4,A
   \   0006B1   78..         MOV     R0,#?V0 + 4
   \   0006B3   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0006B6   75..01       MOV     ?V0 + 4,#0x1
   \   0006B9   78..         MOV     R0,#?V0 + 4
   \   0006BB   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0006BE   75..01       MOV     ?V0 + 4,#0x1
   \   0006C1   78..         MOV     R0,#?V0 + 4
   \   0006C3   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0006C6   78..         MOV     R0,#?V0 + 0
   \   0006C8   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0006CB   85..82       MOV     DPL,?V0 + 2
   \   0006CE   85..83       MOV     DPH,?V0 + 3
   \   0006D1   E0           MOVX    A,@DPTR
   \   0006D2   F8           MOV     R0,A
   \   0006D3   A3           INC     DPTR
   \   0006D4   E0           MOVX    A,@DPTR
   \   0006D5   F583         MOV     DPH,A
   \   0006D7   8882         MOV     DPL,R0
   \   0006D9   A3           INC     DPTR
   \   0006DA   A3           INC     DPTR
   \   0006DB   A3           INC     DPTR
   \   0006DC   A3           INC     DPTR
   \   0006DD   E0           MOVX    A,@DPTR
   \   0006DE   FC           MOV     R4,A
   \   0006DF   A3           INC     DPTR
   \   0006E0   E0           MOVX    A,@DPTR
   \   0006E1   FD           MOV     R5,A
   \   0006E2   85..82       MOV     DPL,?V0 + 2
   \   0006E5   85..83       MOV     DPH,?V0 + 3
   \   0006E8   E0           MOVX    A,@DPTR
   \   0006E9   2406         ADD     A,#0x6
   \   0006EB   FA           MOV     R2,A
   \   0006EC   A3           INC     DPTR
   \   0006ED   E0           MOVX    A,@DPTR
   \   0006EE   3400         ADDC    A,#0x0
   \   0006F0   FB           MOV     R3,A
   \   0006F1   85..82       MOV     DPL,?V0 + 2
   \   0006F4   85..83       MOV     DPH,?V0 + 3
   \   0006F7   E0           MOVX    A,@DPTR
   \   0006F8   F8           MOV     R0,A
   \   0006F9   A3           INC     DPTR
   \   0006FA   E0           MOVX    A,@DPTR
   \   0006FB   C8           XCH     A,R0
   \   0006FC   2414         ADD     A,#0x14
   \   0006FE   F582         MOV     DPL,A
   \   000700   E8           MOV     A,R0
   \   000701   3400         ADDC    A,#0x0
   \   000703   F583         MOV     DPH,A
   \   000705   E0           MOVX    A,@DPTR
   \   000706   F9           MOV     R1,A
   \   000707   12....       LCALL   ??zcl_SendWriteRsp?relay
   \   00070A   7405         MOV     A,#0x5
   \   00070C   12....       LCALL   ?DEALLOC_XSTACK8
   \   00070F   E9           MOV     A,R1
   3781            osal_mem_free( writeRspCmd );
   \   000710                ; Setup parameters for call to function osal_mem_free
   \   000710   AA..         MOV     R2,?V0 + 0
   \   000712   AB..         MOV     R3,?V0 + 1
   \   000714   12....       LCALL   ??osal_mem_free?relay
   3782          
   3783            return TRUE;
   \   000717   7901         MOV     R1,#0x1
   \                     ??zclProcessInWriteUndividedCmd_1:
   \   000719   740E         MOV     A,#0xe
   \   00071B   12....       LCALL   ?DEALLOC_XSTACK8
   \   00071E   7F10         MOV     R7,#0x10
   \   000720   02....       LJMP    ?BANKED_LEAVE_XDATA
   3784          }
   3785          #endif // ZCL_WRITE
   3786          
   3787          #ifdef ZCL_DISCOVER
   3788          /*********************************************************************
   3789           * @fn      zclProcessInDiscCmd
   3790           *
   3791           * @brief   Process the "Profile" Discover Command
   3792           *
   3793           * @param   pInMsg - incoming message to process
   3794           *
   3795           * @return  TRUE if command processed. FALSE, otherwise.
   3796           */
   3797          static uint8 zclProcessInDiscCmd( zclIncoming_t *pInMsg )
   3798          {
   3799            zclDiscoverCmd_t *discoverCmd;
   3800            zclDiscoverRspCmd_t *discoverRspCmd;
   3801            uint8 discComplete = TRUE;
   3802            zclAttrRec_t attrRec;
   3803            uint16 attrID;
   3804            uint8 i;
   3805          
   3806            discoverCmd = (zclDiscoverCmd_t *)pInMsg->attrCmd;
   3807          
   3808            // Find out the number of attributes supported within the specified range
   3809            for ( i = 0, attrID = discoverCmd->startAttr; i < discoverCmd->maxAttrIDs; i++, attrID++ )
   3810            {
   3811              if ( !zclFindNextAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, &attrID, &attrRec ) )
   3812              {
   3813                break;
   3814              }
   3815            }
   3816          
   3817            // Allocate space for the response command
   3818            discoverRspCmd = (zclDiscoverRspCmd_t *)osal_mem_alloc( sizeof (zclDiscoverRspCmd_t)
   3819                                                                   + sizeof ( zclDiscoverInfo_t ) * i );
   3820            if ( discoverRspCmd == NULL )
   3821            {
   3822              return FALSE; // EMEDDED RETURN
   3823            }
   3824          
   3825            discoverRspCmd->numAttr = i;
   3826            if ( discoverRspCmd->numAttr != 0 )
   3827            {
   3828              for ( i = 0, attrID = discoverCmd->startAttr; i < discoverRspCmd->numAttr; i++, attrID++ )
   3829              {
   3830                if ( !zclFindNextAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, &attrID, &attrRec ) )
   3831                {
   3832                  break; // Attribute not supported
   3833                }
   3834          
   3835                discoverRspCmd->attrList[i].attrID = attrRec.attr.attrId;
   3836                discoverRspCmd->attrList[i].dataType = attrRec.attr.dataType;
   3837              }
   3838          
   3839              // Are there more attributes to be discovered?
   3840              if ( zclFindNextAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, &attrID, &attrRec ) )
   3841              {
   3842                discComplete = FALSE;
   3843              }
   3844            }
   3845          
   3846            discoverRspCmd->discComplete = discComplete;
   3847            zcl_SendDiscoverRspCmd( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   3848                                    pInMsg->msg->clusterId, discoverRspCmd, ZCL_FRAME_SERVER_CLIENT_DIR,
   3849                                    true, pInMsg->hdr.transSeqNum );
   3850            osal_mem_free( discoverRspCmd );
   3851          
   3852            return TRUE;
   3853          }
   3854          #endif // ZCL_DISCOVER
   3855          
   3856          /*********************************************************************
   3857           * @fn      zclSendMsg
   3858           *
   3859           * @brief   Send an incoming message to the Application
   3860           *
   3861           * @param   pInMsg - incoming message to process
   3862           *
   3863           * @return  TRUE
   3864           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3865          static uint8 zclSendMsg( zclIncoming_t *pInMsg )
   \                     zclSendMsg:
   3866          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV     ?V0 + 0,R2
   \   000007   8B..         MOV     ?V0 + 1,R3
   3867            zclIncomingMsg_t *pCmd;
   3868          
   3869            if ( zcl_RegisteredMsgTaskID == TASK_NO_TASK )
   \   000009   90....       MOV     DPTR,#zcl_RegisteredMsgTaskID
   \   00000C   E0           MOVX    A,@DPTR
   \   00000D   64FF         XRL     A,#0xff
   \   00000F   7005         JNZ     ??zclSendMsg_0
   3870            {
   3871              return ( TRUE );
   \   000011   7901         MOV     R1,#0x1
   \   000013   02....       LJMP    ??zclSendMsg_1 & 0xFFFF
   3872            }
   3873          
   3874            pCmd = (zclIncomingMsg_t *)osal_msg_allocate( sizeof ( zclIncomingMsg_t ) );
   \                     ??zclSendMsg_0:
   \   000016                ; Setup parameters for call to function osal_msg_allocate
   \   000016   7A19         MOV     R2,#0x19
   \   000018   7B00         MOV     R3,#0x0
   \   00001A   12....       LCALL   ??osal_msg_allocate?relay
   \   00001D   8A..         MOV     ?V0 + 2,R2
   \   00001F   8B..         MOV     ?V0 + 3,R3
   \   000021   AE..         MOV     R6,?V0 + 2
   \   000023   AF..         MOV     R7,?V0 + 3
   3875            if ( pCmd != NULL )
   \   000025   EE           MOV     A,R6
   \   000026   4F           ORL     A,R7
   \   000027   7003         JNZ     $+5
   \   000029   02....       LJMP    ??zclSendMsg_2 & 0xFFFF
   3876            {
   3877              // fill in the message
   3878              pCmd->hdr.event = ZCL_INCOMING_MSG;
   \   00002C   8E82         MOV     DPL,R6
   \   00002E   8F83         MOV     DPH,R7
   \   000030   7434         MOV     A,#0x34
   \   000032   F0           MOVX    @DPTR,A
   3879              pCmd->zclHdr    = pInMsg->hdr;
   \   000033   85..82       MOV     DPL,?V0 + 0
   \   000036   85..83       MOV     DPH,?V0 + 1
   \   000039   A3           INC     DPTR
   \   00003A   A3           INC     DPTR
   \   00003B   EE           MOV     A,R6
   \   00003C   2402         ADD     A,#0x2
   \   00003E   FC           MOV     R4,A
   \   00003F   EF           MOV     A,R7
   \   000040   3400         ADDC    A,#0x0
   \   000042   FD           MOV     R5,A
   \   000043   7406         MOV     A,#0x6
   \   000045   12....       LCALL   ?MOVE_LONG8_XDATA_XDATA
   3880              pCmd->clusterId = pInMsg->msg->clusterId;
   \   000048   85..82       MOV     DPL,?V0 + 0
   \   00004B   85..83       MOV     DPH,?V0 + 1
   \   00004E   E0           MOVX    A,@DPTR
   \   00004F   F8           MOV     R0,A
   \   000050   A3           INC     DPTR
   \   000051   E0           MOVX    A,@DPTR
   \   000052   F583         MOV     DPH,A
   \   000054   8882         MOV     DPL,R0
   \   000056   A3           INC     DPTR
   \   000057   A3           INC     DPTR
   \   000058   A3           INC     DPTR
   \   000059   A3           INC     DPTR
   \   00005A   E0           MOVX    A,@DPTR
   \   00005B   F8           MOV     R0,A
   \   00005C   A3           INC     DPTR
   \   00005D   E0           MOVX    A,@DPTR
   \   00005E   F9           MOV     R1,A
   \   00005F   8E82         MOV     DPL,R6
   \   000061   8F83         MOV     DPH,R7
   \   000063   A3           INC     DPTR
   \   000064   A3           INC     DPTR
   \   000065   A3           INC     DPTR
   \   000066   A3           INC     DPTR
   \   000067   A3           INC     DPTR
   \   000068   A3           INC     DPTR
   \   000069   A3           INC     DPTR
   \   00006A   A3           INC     DPTR
   \   00006B   E8           MOV     A,R0
   \   00006C   F0           MOVX    @DPTR,A
   \   00006D   A3           INC     DPTR
   \   00006E   E9           MOV     A,R1
   \   00006F   F0           MOVX    @DPTR,A
   3881              pCmd->srcAddr   = pInMsg->msg->srcAddr;
   \   000070   85..82       MOV     DPL,?V0 + 0
   \   000073   85..83       MOV     DPH,?V0 + 1
   \   000076   E0           MOVX    A,@DPTR
   \   000077   F8           MOV     R0,A
   \   000078   A3           INC     DPTR
   \   000079   E0           MOVX    A,@DPTR
   \   00007A   C8           XCH     A,R0
   \   00007B   2406         ADD     A,#0x6
   \   00007D   F582         MOV     DPL,A
   \   00007F   E8           MOV     A,R0
   \   000080   3400         ADDC    A,#0x0
   \   000082   F583         MOV     DPH,A
   \   000084   EE           MOV     A,R6
   \   000085   240A         ADD     A,#0xa
   \   000087   FC           MOV     R4,A
   \   000088   EF           MOV     A,R7
   \   000089   3400         ADDC    A,#0x0
   \   00008B   FD           MOV     R5,A
   \   00008C   740C         MOV     A,#0xc
   \   00008E   12....       LCALL   ?MOVE_LONG8_XDATA_XDATA
   3882              pCmd->endPoint  = pInMsg->msg->endPoint;
   \   000091   85..82       MOV     DPL,?V0 + 0
   \   000094   85..83       MOV     DPH,?V0 + 1
   \   000097   E0           MOVX    A,@DPTR
   \   000098   F8           MOV     R0,A
   \   000099   A3           INC     DPTR
   \   00009A   E0           MOVX    A,@DPTR
   \   00009B   C8           XCH     A,R0
   \   00009C   2414         ADD     A,#0x14
   \   00009E   F582         MOV     DPL,A
   \   0000A0   E8           MOV     A,R0
   \   0000A1   3400         ADDC    A,#0x0
   \   0000A3   F583         MOV     DPH,A
   \   0000A5   E0           MOVX    A,@DPTR
   \   0000A6   C0E0         PUSH    A
   \   0000A8   EE           MOV     A,R6
   \   0000A9   2416         ADD     A,#0x16
   \   0000AB   F582         MOV     DPL,A
   \   0000AD   EF           MOV     A,R7
   \   0000AE   3400         ADDC    A,#0x0
   \   0000B0   F583         MOV     DPH,A
   \   0000B2   D0E0         POP     A
   \   0000B4   F0           MOVX    @DPTR,A
   3883              pCmd->attrCmd   = pInMsg->attrCmd;
   \   0000B5   E5..         MOV     A,?V0 + 0
   \   0000B7   240C         ADD     A,#0xc
   \   0000B9   F582         MOV     DPL,A
   \   0000BB   E5..         MOV     A,?V0 + 1
   \   0000BD   3400         ADDC    A,#0x0
   \   0000BF   F583         MOV     DPH,A
   \   0000C1   E0           MOVX    A,@DPTR
   \   0000C2   F8           MOV     R0,A
   \   0000C3   A3           INC     DPTR
   \   0000C4   E0           MOVX    A,@DPTR
   \   0000C5   F9           MOV     R1,A
   \   0000C6   EE           MOV     A,R6
   \   0000C7   2417         ADD     A,#0x17
   \   0000C9   F582         MOV     DPL,A
   \   0000CB   EF           MOV     A,R7
   \   0000CC   3400         ADDC    A,#0x0
   \   0000CE   F583         MOV     DPH,A
   \   0000D0   E8           MOV     A,R0
   \   0000D1   F0           MOVX    @DPTR,A
   \   0000D2   A3           INC     DPTR
   \   0000D3   E9           MOV     A,R1
   \   0000D4   F0           MOVX    @DPTR,A
   3884          
   3885              // Application will free the attrCmd buffer
   3886              pInMsg->attrCmd = NULL;
   \   0000D5   E5..         MOV     A,?V0 + 0
   \   0000D7   240C         ADD     A,#0xc
   \   0000D9   F582         MOV     DPL,A
   \   0000DB   E5..         MOV     A,?V0 + 1
   \   0000DD   3400         ADDC    A,#0x0
   \   0000DF   F583         MOV     DPH,A
   \   0000E1   7400         MOV     A,#0x0
   \   0000E3   F0           MOVX    @DPTR,A
   \   0000E4   A3           INC     DPTR
   \   0000E5   7400         MOV     A,#0x0
   \   0000E7   F0           MOVX    @DPTR,A
   3887          
   3888              /* send message through task message */
   3889              osal_msg_send( zcl_RegisteredMsgTaskID, (uint8 *)pCmd );
   \   0000E8                ; Setup parameters for call to function osal_msg_send
   \   0000E8   EE           MOV     A,R6
   \   0000E9   FA           MOV     R2,A
   \   0000EA   EF           MOV     A,R7
   \   0000EB   FB           MOV     R3,A
   \   0000EC   90....       MOV     DPTR,#zcl_RegisteredMsgTaskID
   \   0000EF   E0           MOVX    A,@DPTR
   \   0000F0   F9           MOV     R1,A
   \   0000F1   12....       LCALL   ??osal_msg_send?relay
   \   0000F4   E9           MOV     A,R1
   3890            }
   3891          
   3892            return ( TRUE );
   \                     ??zclSendMsg_2:
   \   0000F5   7901         MOV     R1,#0x1
   \                     ??zclSendMsg_1:
   \   0000F7   7F04         MOV     R7,#0x4
   \   0000F9   02....       LJMP    ?BANKED_LEAVE_XDATA
   3893          }

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for zcl_RegisteredMsgTaskID>`:
   \   000000   FF           DB 255

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_Init?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_Init

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_event_loop?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_event_loop

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_getRawAFMsg?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_getRawAFMsg

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_registerPlugin?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_registerPlugin

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_registerAttrList?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_registerAttrList

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_registerClusterOptionList?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_registerClusterOptionList

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_registerValidateAttrData?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_registerValidateAttrData

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_registerReadWriteCB?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_registerReadWriteCB

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_registerForMsg?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_registerForMsg

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_DeviceOperational?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_DeviceOperational

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_SendCommand?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_SendCommand

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_SendRead?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_SendRead

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_SendReadRsp?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_SendReadRsp

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_SendWriteRequest?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_SendWriteRequest

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_SendWriteRsp?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_SendWriteRsp

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_SendConfigReportCmd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_SendConfigReportCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_SendConfigReportRspCmd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_SendConfigReportRspCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_SendReadReportCfgCmd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_SendReadReportCfgCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_SendReadReportCfgRspCmd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_SendReadReportCfgRspCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_SendReportCmd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_SendReportCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_SendDefaultRspCmd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_SendDefaultRspCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclProcessMessageMSG?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclProcessMessageMSG

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclParseHdr?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclParseHdr

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclBuildHdr?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclBuildHdr

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclCalcHdrSize?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclCalcHdrSize

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclFindPlugin?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclFindPlugin

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclFindAttrRecsList?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclFindAttrRecsList

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclFindAttrRec?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclFindAttrRec

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclGetReadWriteCB?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclGetReadWriteCB

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclGetAuthorizeCB?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclGetAuthorizeCB

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclFindClusterOption?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclFindClusterOption

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclGetClusterOption?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclGetClusterOption

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclSetSecurityOption?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclSetSecurityOption

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclSerializeData?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclSerializeData

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclAnalogDataType?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclAnalogDataType

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_BuildAnalogData?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_BuildAnalogData

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclGetDataTypeLength?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclGetDataTypeLength

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclGetAttrDataLength?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclGetAttrDataLength

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclReadAttrData?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclReadAttrData

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclGetAttrDataLengthUsingCB?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclGetAttrDataLengthUsingCB

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclReadAttrDataUsingCB?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclReadAttrDataUsingCB

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclAuthorizeRead?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclAuthorizeRead

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclWriteAttrData?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclWriteAttrData

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclWriteAttrDataUsingCB?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclWriteAttrDataUsingCB

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclAuthorizeWrite?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclAuthorizeWrite

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclParseInReadCmd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclParseInReadCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclParseInReadRspCmd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclParseInReadRspCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclParseInWriteCmd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclParseInWriteCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclParseInWriteRspCmd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclParseInWriteRspCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclParseInConfigReportCmd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclParseInConfigReportCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclParseInConfigReportRspCmd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclParseInConfigReportRspCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclParseInReadReportCfgCmd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclParseInReadReportCfgCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclParseInReadReportCfgRspCmd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclParseInReadReportCfgRspCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclParseInReportCmd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclParseInReportCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclParseInDefaultRspCmd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclParseInDefaultRspCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclProcessInReadCmd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclProcessInReadCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclProcessInWriteCmd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclProcessInWriteCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclRevertWriteUndividedCmd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclRevertWriteUndividedCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclProcessInWriteUndividedCmd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclProcessInWriteUndividedCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclSendMsg?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclSendMsg
   3894          
   3895          /*********************************************************************
   3896          *********************************************************************/

   Maximum stack usage in bytes:

   ISTACK PSTACK XSTACK Function
   ------ ------ ------ --------
       2      0     28  zclAnalogDataType
       0      0     44  zclAuthorizeRead
                          0 0 16 -> zclGetAuthorizeCB
       0      0     36  zclAuthorizeWrite
                          0 0 16 -> zclGetAuthorizeCB
       3      0     34  zclBuildHdr
       2      0     34  zclCalcHdrSize
       0      0     56  zclFindAttrRec
                          0 0 16 -> zclFindAttrRecsList
       2      0     16  zclFindAttrRecsList
       0      0     23  zclFindClusterOption
       0      0     48  zclFindPlugin
       0      0     49  zclGetAttrDataLength
                          0 0 11 -> zclGetDataTypeLength
       0      0     60  zclGetAttrDataLengthUsingCB
                          0 0 18 -> zclGetReadWriteCB
       0      0     26  zclGetAuthorizeCB
                          0 0 10 -> zclFindAttrRecsList
       0      0     53  zclGetClusterOption
                          0 0 14 -> zclFindClusterOption
       0      0     28  zclGetDataTypeLength
       0      0     30  zclGetReadWriteCB
                          0 0 10 -> zclFindAttrRecsList
       1      0     51  zclParseHdr
                          0 0 12 -> osal_memset
       1      0     25  zclParseInConfigReportCmd
                          0 0 25 -> osal_mem_alloc
                          0 0 25 -> osal_memset
                          0 0 25 -> zclAnalogDataType
                          0 0 25 -> zclGetDataTypeLength
                          0 0 25 -> zcl_BuildAnalogData
       1      0     16  zclParseInConfigReportRspCmd
                          0 0 16 -> osal_mem_alloc
       1      0     14  zclParseInDefaultRspCmd
                          0 0 14 -> osal_mem_alloc
       1      0     14  zclParseInReadCmd
                          0 0 14 -> osal_mem_alloc
       1      0     16  zclParseInReadReportCfgCmd
                          0 0 16 -> osal_mem_alloc
       1      0     24  zclParseInReadReportCfgRspCmd
                          0 0 24 -> osal_mem_alloc
                          0 0 24 -> zclAnalogDataType
                          0 0 24 -> zclGetDataTypeLength
                          0 0 24 -> zcl_BuildAnalogData
       1      0     29  zclParseInReadRspCmd
                          0 0 26 -> osal_mem_alloc
                          0 0 29 -> osal_memcpy
                          0 0 26 -> zclGetAttrDataLength
       1      0     29  zclParseInReportCmd
                          0 0 26 -> osal_mem_alloc
                          0 0 29 -> osal_memcpy
                          0 0 26 -> zclGetAttrDataLength
       1      0     29  zclParseInWriteCmd
                          0 0 26 -> osal_mem_alloc
                          0 0 29 -> osal_memcpy
                          0 0 26 -> zclGetAttrDataLength
       1      0     16  zclParseInWriteRspCmd
                          0 0 16 -> osal_mem_alloc
       1      0     33  zclProcessInReadCmd
                          0 0 28 -> osal_mem_alloc
                          0 0 28 -> osal_mem_free
                          0 0 28 -> zclAuthorizeRead
                          0 0 30 -> zclFindAttrRec
                          0 0 33 -> zcl_SendReadRsp
       1      0     33  zclProcessInWriteCmd
                          0 0 28 -> osal_mem_alloc
                          0 0 28 -> osal_mem_free
                          0 0 30 -> zclFindAttrRec
                          0 0 30 -> zclWriteAttrData
                          0 0 30 -> zclWriteAttrDataUsingCB
                          0 0 33 -> zcl_SendWriteRsp
       1      0     43  zclProcessInWriteUndividedCmd
                          0 0 38 -> osal_mem_alloc
                          0 0 38 -> osal_mem_free
                          0 0 40 -> zclFindAttrRec
                          0 0 38 -> zclGetAttrDataLength
                          0 0 38 -> zclGetAttrDataLengthUsingCB
                          0 0 40 -> zclReadAttrData
                          0 0 42 -> zclReadAttrDataUsingCB
                          0 0 40 -> zclRevertWriteUndividedCmd
                          0 0 40 -> zclWriteAttrData
                          0 0 40 -> zclWriteAttrDataUsingCB
                          0 0 43 -> zcl_SendWriteRsp
       2      0     60  zclProcessMessageMSG
                          0 0 39 -> afFindEndPointDesc
                          0 0 39 -> osal_mem_free
                          0 0 39 -> zclFindPlugin
                          0 0 39 -> zclGetClusterOption
                          0 0 39 -> zclParseHdr
                          0 0 39 -> zclSetSecurityOption
                          0 0 41 -> zcl_DeviceOperational
                          0 0 46 -> zcl_SendDefaultRspCmd
       0      0     61  zclReadAttrData
                          0 0 21 -> osal_memcpy
                          0 0 18 -> zclGetAttrDataLength
       0      0     66  zclReadAttrDataUsingCB
                          0 0 20 -> zclGetReadWriteCB
       0      0     73  zclRevertWriteUndividedCmd
                          0 0 33 -> osal_memcpy
                          0 0 32 -> zclFindAttrRec
                          0 0 30 -> zclGetAttrDataLength
                          0 0 32 -> zclWriteAttrDataUsingCB
       1      0     12  zclSendMsg
                          0 0 12 -> osal_msg_allocate
                          0 0 12 -> osal_msg_send
       1      0     51  zclSerializeData
                          0 0 23 -> osal_buffer_uint32
                          0 0 22 -> osal_memcpy
       0      0     53  zclSetSecurityOption
                          0 0 14 -> zclFindClusterOption
       0      0     63  zclWriteAttrData
                          0 0 23 -> osal_memcpy
                          0 0 20 -> zclAuthorizeWrite
                          0 0 20 -> zclGetAttrDataLength
       0      0     62  zclWriteAttrDataUsingCB
                          0 0 18 -> zclAuthorizeWrite
                          0 0 18 -> zclGetReadWriteCB
       1      0     36  zcl_BuildAnalogData
                          0 0 11 -> osal_build_uint32
       0      0     68  zcl_DeviceOperational
                          0 0 27 -> zclFindAttrRec
                          0 0 27 -> zclReadAttrData
       2      0      0  zcl_Init
       1      0     82  zcl_SendCommand
                          0 0 43 -> AF_DataRequest
                          0 0 34 -> afFindEndPointDesc
                          0 0 34 -> osal_mem_alloc
                          0 0 34 -> osal_mem_free
                          0 0 37 -> osal_memcpy
                          0 0 34 -> osal_memset
                          0 0 34 -> zclBuildHdr
                          0 0 34 -> zclCalcHdrSize
                          0 0 34 -> zclGetClusterOption
                          0 0 36 -> zcl_DeviceOperational
       1      0     44  zcl_SendConfigReportCmd
                          0 0 28 -> osal_mem_alloc
                          0 0 28 -> osal_mem_free
                          0 0 28 -> zclAnalogDataType
                          0 0 28 -> zclGetDataTypeLength
                          0 0 28 -> zclSerializeData
                          0 0 39 -> zcl_SendCommand
       1      0     42  zcl_SendConfigReportRspCmd
                          0 0 26 -> osal_mem_alloc
                          0 0 26 -> osal_mem_free
                          0 0 37 -> zcl_SendCommand
       1      0     79  zcl_SendDefaultRspCmd
                          0 0 33 -> zcl_SendCommand
       1      0     42  zcl_SendRead
                          0 0 26 -> osal_mem_alloc
                          0 0 26 -> osal_mem_free
                          0 0 37 -> zcl_SendCommand
       1      0     42  zcl_SendReadReportCfgCmd
                          0 0 26 -> osal_mem_alloc
                          0 0 26 -> osal_mem_free
                          0 0 37 -> zcl_SendCommand
       1      0     44  zcl_SendReadReportCfgRspCmd
                          0 0 28 -> osal_mem_alloc
                          0 0 28 -> osal_mem_free
                          0 0 28 -> zclAnalogDataType
                          0 0 28 -> zclGetDataTypeLength
                          0 0 28 -> zclSerializeData
                          0 0 39 -> zcl_SendCommand
       1      0     72  zcl_SendReadRsp
                          0 0 28 -> osal_mem_alloc
                          0 0 28 -> osal_mem_free
                          0 0 28 -> zclGetAttrDataLength
                          0 0 28 -> zclGetAttrDataLengthUsingCB
                          0 0 32 -> zclReadAttrDataUsingCB
                          0 0 28 -> zclSerializeData
                          0 0 39 -> zcl_SendCommand
       1      0     44  zcl_SendReportCmd
                          0 0 28 -> osal_mem_alloc
                          0 0 28 -> osal_mem_free
                          0 0 28 -> zclGetAttrDataLength
                          0 0 28 -> zclSerializeData
                          0 0 39 -> zcl_SendCommand
       1      0     45  zcl_SendWriteRequest
                          0 0 28 -> osal_mem_alloc
                          0 0 28 -> osal_mem_free
                          0 0 28 -> zclGetAttrDataLength
                          0 0 28 -> zclSerializeData
                          0 0 39 -> zcl_SendCommand
       1      0     80  zcl_SendWriteRsp
                          0 0 26 -> osal_mem_alloc
                          0 0 26 -> osal_mem_free
                          0 0 37 -> zcl_SendCommand
       0      0     14  zcl_event_loop
                          0 0 14 -> osal_msg_deallocate
                          0 0 14 -> osal_msg_receive
                          0 0 14 -> osal_msg_send
                          0 0 14 -> zclProcessMessageMSG
       2      0      0  zcl_getRawAFMsg
       1      0     16  zcl_registerAttrList
                          0 0 16 -> osal_mem_alloc
       1      0     16  zcl_registerClusterOptionList
                          0 0 16 -> osal_mem_alloc
       2      0      0  zcl_registerForMsg
       0      0     20  zcl_registerPlugin
                          0 0 18 -> osal_mem_alloc
       0      0     14  zcl_registerReadWriteCB
                          0 0 14 -> zclFindAttrRecsList
       2      0      0  zcl_registerValidateAttrData


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       1  ?<Initializer for zcl_RegisteredMsgTaskID>
       6  ??zclAnalogDataType?relay
       6  ??zclAuthorizeRead?relay
       6  ??zclAuthorizeWrite?relay
       6  ??zclBuildHdr?relay
       6  ??zclCalcHdrSize?relay
       6  ??zclFindAttrRec?relay
       6  ??zclFindAttrRecsList?relay
       6  ??zclFindClusterOption?relay
       6  ??zclFindPlugin?relay
       6  ??zclGetAttrDataLength?relay
       6  ??zclGetAttrDataLengthUsingCB?relay
       6  ??zclGetAuthorizeCB?relay
       6  ??zclGetClusterOption?relay
       6  ??zclGetDataTypeLength?relay
       6  ??zclGetReadWriteCB?relay
       6  ??zclParseHdr?relay
       6  ??zclParseInConfigReportCmd?relay
       6  ??zclParseInConfigReportRspCmd?relay
       6  ??zclParseInDefaultRspCmd?relay
       6  ??zclParseInReadCmd?relay
       6  ??zclParseInReadReportCfgCmd?relay
       6  ??zclParseInReadReportCfgRspCmd?relay
       6  ??zclParseInReadRspCmd?relay
       6  ??zclParseInReportCmd?relay
       6  ??zclParseInWriteCmd?relay
       6  ??zclParseInWriteRspCmd?relay
       6  ??zclProcessInReadCmd?relay
       6  ??zclProcessInWriteCmd?relay
       6  ??zclProcessInWriteUndividedCmd?relay
       6  ??zclProcessMessageMSG?relay
       6  ??zclReadAttrData?relay
       6  ??zclReadAttrDataUsingCB?relay
       6  ??zclRevertWriteUndividedCmd?relay
       6  ??zclSendMsg?relay
       6  ??zclSerializeData?relay
       6  ??zclSetSecurityOption?relay
       6  ??zclWriteAttrData?relay
       6  ??zclWriteAttrDataUsingCB?relay
       6  ??zcl_BuildAnalogData?relay
       6  ??zcl_DeviceOperational?relay
       6  ??zcl_Init?relay
       6  ??zcl_SendCommand?relay
       6  ??zcl_SendConfigReportCmd?relay
       6  ??zcl_SendConfigReportRspCmd?relay
       6  ??zcl_SendDefaultRspCmd?relay
       6  ??zcl_SendRead?relay
       6  ??zcl_SendReadReportCfgCmd?relay
       6  ??zcl_SendReadReportCfgRspCmd?relay
       6  ??zcl_SendReadRsp?relay
       6  ??zcl_SendReportCmd?relay
       6  ??zcl_SendWriteRequest?relay
       6  ??zcl_SendWriteRsp?relay
       6  ??zcl_event_loop?relay
       6  ??zcl_getRawAFMsg?relay
       6  ??zcl_registerAttrList?relay
       6  ??zcl_registerClusterOptionList?relay
       6  ??zcl_registerForMsg?relay
       6  ??zcl_registerPlugin?relay
       6  ??zcl_registerReadWriteCB?relay
       6  ??zcl_registerValidateAttrData?relay
       2  attrList
       2  clusterOptionList
       2  plugins
       2  rawAFMsg
      38  zclAnalogDataType
      74  zclAuthorizeRead
      74  zclAuthorizeWrite
     286  zclBuildHdr
      46  zclCalcHdrSize
      56  zclCmdTable
     281  zclFindAttrRec
      54  zclFindAttrRecsList
     181  zclFindClusterOption
      81  zclFindPlugin
     124  zclGetAttrDataLength
     121  zclGetAttrDataLengthUsingCB
      48  zclGetAuthorizeCB
      65  zclGetClusterOption
     167  zclGetDataTypeLength
      46  zclGetReadWriteCB
     403  zclParseHdr
     792  zclParseInConfigReportCmd
     335  zclParseInConfigReportRspCmd
      89  zclParseInDefaultRspCmd
     187  zclParseInReadCmd
     279  zclParseInReadReportCfgCmd
     813  zclParseInReadReportCfgRspCmd
     583  zclParseInReadRspCmd
     522  zclParseInReportCmd
     522  zclParseInWriteCmd
     341  zclParseInWriteRspCmd
     621  zclProcessInReadCmd
     930  zclProcessInWriteCmd
    1827  zclProcessInWriteUndividedCmd
    1658  zclProcessMessageMSG
     130  zclReadAttrData
     116  zclReadAttrDataUsingCB
     350  zclRevertWriteUndividedCmd
     252  zclSendMsg
     680  zclSerializeData
      73  zclSetSecurityOption
     212  zclWriteAttrData
     153  zclWriteAttrDataUsingCB
     187  zcl_BuildAnalogData
     171  zcl_DeviceOperational
      46  zcl_Init
       1  zcl_RegisteredMsgTaskID
     619  zcl_SendCommand
     824  zcl_SendConfigReportCmd
     512  zcl_SendConfigReportRspCmd
     206  zcl_SendDefaultRspCmd
     403  zcl_SendRead
     431  zcl_SendReadReportCfgCmd
     876  zcl_SendReadReportCfgRspCmd
     739  zcl_SendReadRsp
     546  zcl_SendReportCmd
     551  zcl_SendWriteRequest
     480  zcl_SendWriteRsp
       1  zcl_SeqNum
       1  zcl_TaskID
       1  zcl_TransID
       2  zcl_ValidateAttrDataCB
     166  zcl_event_loop
      19  zcl_getRawAFMsg
     194  zcl_registerAttrList
     172  zcl_registerClusterOptionList
      32  zcl_registerForMsg
     187  zcl_registerPlugin
      71  zcl_registerReadWriteCB
      21  zcl_registerValidateAttrData

 
 21 007 bytes in segment BANKED_CODE
    360 bytes in segment BANK_RELAYS
     56 bytes in segment CODE_C
      1 byte  in segment XDATA_I
      1 byte  in segment XDATA_ID
     13 bytes in segment XDATA_Z
 
 21 424 bytes of CODE  memory
     14 bytes of XDATA memory

Errors: none
Warnings: none

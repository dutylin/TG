///////////////////////////////////////////////////////////////////////////////
//                                                                            /
// IAR C/C++ Compiler V8.20.2.41139 for 8051            13/Jun/2013  13:50:30 /
// Copyright 2004-2013 IAR Systems AB.                                        /
//                                                                            /
//    Core               =  plain                                             /
//    Code model         =  banked                                            /
//    Data model         =  large                                             /
//    Calling convention =  xdata reentrant                                   /
//    Constant location  =  data_rom                                          /
//    Dptr setup         =  1,16                                              /
//                                                                            /
//    Source file        =  C:\Users\PedroZ\Documents\GitHub\TG\Components\st /
//                          ack\zcl\zcl.c                                     /
//    Command line       =  -f C:\Users\PedroZ\Documents\GitHub\TG\Projects\S /
//                          tack\SE\SampleApp\CC2530DB\..\..\..\Tools\CC2530D /
//                          B\f8wCoord.cfg (-DCPU32MHZ -DROOT=__near_func     /
//                          -DMAC_CFG_APP_PENDING_QUEUE=TRUE                  /
//                          -DMAC_CFG_TX_DATA_MAX=5 -DMAC_CFG_TX_MAX=8        /
//                          -DMAC_CFG_RX_MAX=5 -DZDO_COORDINATOR -DRTR_NWK)   /
//                          -f C:\Users\PedroZ\Documents\GitHub\TG\Projects\S /
//                          tack\SE\SampleApp\CC2530DB\..\..\..\Tools\CC2530D /
//                          B\f8wConfig.cfg (-DZIGBEEPRO -DSECURE=0           /
//                          -DZG_SECURE_DYNAMIC=0 -DREFLECTOR                 /
//                          -DDEFAULT_CHANLIST=0x00000800                     /
//                          -DZDAPP_CONFIG_PAN_ID=0xFFFF                      /
//                          -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_M /
//                          ASK=0x007F -DBEACON_REQUEST_DELAY=100             /
//                          -DBEACON_REQ_DELAY_MASK=0x00FF                    /
//                          -DLINK_STATUS_JITTER_MASK=0x007F                  /
//                          -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_P /
//                          OLLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7           /
//                          -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3   /
//                          -DNWK_MAX_DATA_RETRIES=2                          /
//                          -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9        /
//                          -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40          /
//                          -DNWK_MAX_BINDING_ENTRIES=4                       /
//                          -DMAX_BINDING_CLUSTER_IDS=4                       /
//                          "-DDEFAULT_KEY={0x01, 0x03, 0x05, 0x07, 0x09,     /
//                          0x0B, 0x0D, 0x0F, 0x00, 0x02, 0x04, 0x06, 0x08,   /
//                          0x0A, 0x0C, 0x0D}" -DMAC_MAX_FRAME_SIZE=116       /
//                          -DZDNWKMGR_MIN_TRANSMISSIONS=20 "-DCONST=const    /
//                          __code" -DGENERIC=__generic                       /
//                          -DRFD_RCVC_ALWAYS_ON=FALSE -DPOLL_RATE=1000       /
//                          -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100   /
//                          -DREJOIN_POLL_RATE=440) -f                        /
//                          C:\Users\PedroZ\Documents\GitHub\TG\Projects\Stac /
//                          k\SE\SampleApp\CC2530DB\..\..\..\Tools\CC2530DB\f /
//                          8wZCL.cfg (-DZCL_READ -DZCL_WRITE -DZCL_BASIC     /
//                          -DZCL_IDENTIFY -DZCL_ON_OFF -DZCL_KEY_ESTABLISH   /
//                          -DZCL_KEY_ESTABLISHMENT_KEY_GENERATE_TIMEOUT=4    /
//                          -DZCL_KEY_ESTABLISHMENT_MAC_GENERATE_TIMEOUT=10   /
//                          -DZCL_KEY_ESTABLISHMENT_EKEY_GENERATE_TIMEOUT=10  /
//                          -DZCL_LOAD_CONTROL -DZCL_SIMPLE_METERING          /
//                          -DZCL_PRICING -DZCL_MESSAGE -DZCL_TUNNELING       /
//                          -DZCL_TOU) -DZCL_DEVICE_MGMT                      /
//                          C:\Users\PedroZ\Documents\GitHub\TG\Components\st /
//                          ack\zcl\zcl.c -D TC_LINKKEY_JOIN -D ZTOOL_P1 -D   /
//                          MT_TASK -D MT_APP_FUNC -D MT_SYS_FUNC -D          /
//                          LCD_SUPPORTED -D INT_HEAP_LEN=2450 -D NV_INIT -D  /
//                          xNV_RESTORE -D ZCL_REPORT -D INTER_PAN -D         /
//                          ZDSECMGR_TC_DEVICE_MAX=16 -D TEST_CERT_DATA -lC   /
//                          "C:\Users\PedroZ\Documents\GitHub\TG\Projects\Sta /
//                          ck\SE\SampleApp\CC2530DB\ESP -                    /
//                          Coordinator\List\" -lA "C:\Users\PedroZ\Documents /
//                          \GitHub\TG\Projects\Stack\SE\SampleApp\CC2530DB\E /
//                          SP - Coordinator\List\" --diag_suppress           /
//                          Pe001,Pa010 -o "C:\Users\PedroZ\Documents\GitHub\ /
//                          TG\Projects\Stack\SE\SampleApp\CC2530DB\ESP -     /
//                          Coordinator\Obj\" -e --no_cse --no_unroll         /
//                          --no_inline --no_code_motion --no_tbaa --debug    /
//                          --core=plain --dptr=16,1 --data_model=large       /
//                          --code_model=banked --calling_convention=xdata_re /
//                          entrant --place_constants=data_rom                /
//                          --nr_virtual_regs 16 -I                           /
//                          C:\Users\PedroZ\Documents\GitHub\TG\Projects\Stac /
//                          k\SE\SampleApp\CC2530DB\ -I                       /
//                          C:\Users\PedroZ\Documents\GitHub\TG\Projects\Stac /
//                          k\SE\SampleApp\CC2530DB\..\Source\ -I             /
//                          C:\Users\PedroZ\Documents\GitHub\TG\Projects\Stac /
//                          k\SE\SampleApp\CC2530DB\..\..\Source\ -I          /
//                          C:\Users\PedroZ\Documents\GitHub\TG\Projects\Stac /
//                          k\SE\SampleApp\CC2530DB\..\..\..\ZMain\TI2530DB\  /
//                          -I C:\Users\PedroZ\Documents\GitHub\TG\Projects\S /
//                          tack\SE\SampleApp\CC2530DB\..\..\..\..\..\Compone /
//                          nts\hal\include\ -I C:\Users\PedroZ\Documents\Git /
//                          Hub\TG\Projects\Stack\SE\SampleApp\CC2530DB\..\.. /
//                          \..\..\..\Components\hal\target\CC2530EB\ -I      /
//                          C:\Users\PedroZ\Documents\GitHub\TG\Projects\Stac /
//                          k\SE\SampleApp\CC2530DB\..\..\..\..\..\Components /
//                          \mac\include\ -I C:\Users\PedroZ\Documents\GitHub /
//                          \TG\Projects\Stack\SE\SampleApp\CC2530DB\..\..\.. /
//                          \..\..\Components\mac\high_level\ -I              /
//                          C:\Users\PedroZ\Documents\GitHub\TG\Projects\Stac /
//                          k\SE\SampleApp\CC2530DB\..\..\..\..\..\Components /
//                          \mac\low_level\srf04\ -I                          /
//                          C:\Users\PedroZ\Documents\GitHub\TG\Projects\Stac /
//                          k\SE\SampleApp\CC2530DB\..\..\..\..\..\Components /
//                          \mac\low_level\srf04\single_chip\ -I              /
//                          C:\Users\PedroZ\Documents\GitHub\TG\Projects\Stac /
//                          k\SE\SampleApp\CC2530DB\..\..\..\..\..\Components /
//                          \mt\ -I C:\Users\PedroZ\Documents\GitHub\TG\Proje /
//                          cts\Stack\SE\SampleApp\CC2530DB\..\..\..\..\..\Co /
//                          mponents\osal\include\ -I                         /
//                          C:\Users\PedroZ\Documents\GitHub\TG\Projects\Stac /
//                          k\SE\SampleApp\CC2530DB\..\..\..\..\..\Components /
//                          \services\saddr\ -I C:\Users\PedroZ\Documents\Git /
//                          Hub\TG\Projects\Stack\SE\SampleApp\CC2530DB\..\.. /
//                          \..\..\..\Components\services\sdata\ -I           /
//                          C:\Users\PedroZ\Documents\GitHub\TG\Projects\Stac /
//                          k\SE\SampleApp\CC2530DB\..\..\..\..\..\Components /
//                          \stack\af\ -I C:\Users\PedroZ\Documents\GitHub\TG /
//                          \Projects\Stack\SE\SampleApp\CC2530DB\..\..\..\.. /
//                          \..\Components\stack\nwk\ -I                      /
//                          C:\Users\PedroZ\Documents\GitHub\TG\Projects\Stac /
//                          k\SE\SampleApp\CC2530DB\..\..\..\..\..\Components /
//                          \stack\sapi\ -I C:\Users\PedroZ\Documents\GitHub\ /
//                          TG\Projects\Stack\SE\SampleApp\CC2530DB\..\..\..\ /
//                          ..\..\Components\stack\sec\ -I                    /
//                          C:\Users\PedroZ\Documents\GitHub\TG\Projects\Stac /
//                          k\SE\SampleApp\CC2530DB\..\..\..\..\..\Components /
//                          \stack\sys\ -I C:\Users\PedroZ\Documents\GitHub\T /
//                          G\Projects\Stack\SE\SampleApp\CC2530DB\..\..\..\. /
//                          .\..\Components\stack\zcl\ -I                     /
//                          C:\Users\PedroZ\Documents\GitHub\TG\Projects\Stac /
//                          k\SE\SampleApp\CC2530DB\..\..\..\..\..\Components /
//                          \stack\zdo\ -I C:\Users\PedroZ\Documents\GitHub\T /
//                          G\Projects\Stack\SE\SampleApp\CC2530DB\..\..\..\. /
//                          .\..\Components\zmac\ -I                          /
//                          C:\Users\PedroZ\Documents\GitHub\TG\Projects\Stac /
//                          k\SE\SampleApp\CC2530DB\..\..\..\..\..\Components /
//                          \zmac\f8w\ -On --require_prototypes               /
//    List file          =  C:\Users\PedroZ\Documents\GitHub\TG\Projects\Stac /
//                          k\SE\SampleApp\CC2530DB\ESP -                     /
//                          Coordinator\List\zcl.s51                          /
//                                                                            /
//                                                                            /
///////////////////////////////////////////////////////////////////////////////

        NAME zcl

        RTMODEL "__SystemLibrary", "CLib"
        RTMODEL "__calling_convention", "xdata_reentrant"
        RTMODEL "__code_model", "banked"
        RTMODEL "__core", "plain"
        RTMODEL "__data_model", "large"
        RTMODEL "__dptr_size", "16"
        RTMODEL "__extended_stack", "disabled"
        RTMODEL "__location_for_constants", "data"
        RTMODEL "__number_of_dptrs", "1"
        RTMODEL "__rt_version", "1"

        RSEG DOVERLAY:DATA:NOROOT(0)
        RSEG IOVERLAY:IDATA:NOROOT(0)
        RSEG ISTACK:IDATA:NOROOT(0)
        RSEG PSTACK:XDATA:NOROOT(0)
        RSEG XSTACK:XDATA:NOROOT(0)

        EXTERN ?ALLOC_XSTACK8
        EXTERN ?BANKED_ENTER_XDATA
        EXTERN ?BANKED_LEAVE_XDATA
        EXTERN ?BDISPATCH
        EXTERN ?BRET
        EXTERN ?CALL_IND
        EXTERN ?DEALLOC_XSTACK8
        EXTERN ?L_MOV_X
        EXTERN ?MOVE_LONG8_XDATA_CODE
        EXTERN ?MOVE_LONG8_XDATA_XDATA
        EXTERN ?PUSH_XSTACK8_X_FOUR
        EXTERN ?PUSH_XSTACK8_X_TWO
        EXTERN ?PUSH_XSTACK_I_ONE
        EXTERN ?PUSH_XSTACK_I_THREE
        EXTERN ?PUSH_XSTACK_I_TWO
        EXTERN ?S_SHL
        EXTERN ?UC_SWITCH_SPARSE
        EXTERN ?UL_SHR
        EXTERN ?US_DIV_MOD
        EXTERN ?US_SHR
        EXTERN ?V0
        EXTERN ?XSP
        EXTERN ?XSTACK_DISP0_8
        EXTERN ?XSTORE_R2345
        EXTERN __INIT_XDATA_I
        EXTERN __INIT_XDATA_Z

        PUBLIC ??zclAnalogDataType?relay
        FUNCTION ??zclAnalogDataType?relay,0203H
        FUNCTION ??zclAuthorizeRead?relay,0203H
        FUNCTION ??zclAuthorizeWrite?relay,0203H
        FUNCTION ??zclBuildHdr?relay,0203H
        FUNCTION ??zclCalcHdrSize?relay,0203H
        PUBLIC ??zclFindAttrRec?relay
        FUNCTION ??zclFindAttrRec?relay,0203H
        FUNCTION ??zclFindAttrRecsList?relay,0203H
        FUNCTION ??zclFindClusterOption?relay,0203H
        FUNCTION ??zclFindPlugin?relay,0203H
        PUBLIC ??zclGetAttrDataLength?relay
        FUNCTION ??zclGetAttrDataLength?relay,0203H
        FUNCTION ??zclGetAttrDataLengthUsingCB?relay,0203H
        FUNCTION ??zclGetAuthorizeCB?relay,0203H
        FUNCTION ??zclGetClusterOption?relay,0203H
        PUBLIC ??zclGetDataTypeLength?relay
        FUNCTION ??zclGetDataTypeLength?relay,0203H
        FUNCTION ??zclGetReadWriteCB?relay,0203H
        PUBLIC ??zclParseHdr?relay
        FUNCTION ??zclParseHdr?relay,0203H
        PUBLIC ??zclParseInConfigReportCmd?relay
        FUNCTION ??zclParseInConfigReportCmd?relay,0203H
        FUNCTION ??zclParseInConfigReportRspCmd?relay,0203H
        FUNCTION ??zclParseInDefaultRspCmd?relay,0203H
        PUBLIC ??zclParseInReadCmd?relay
        FUNCTION ??zclParseInReadCmd?relay,0203H
        PUBLIC ??zclParseInReadReportCfgCmd?relay
        FUNCTION ??zclParseInReadReportCfgCmd?relay,0203H
        FUNCTION ??zclParseInReadReportCfgRspCmd?relay,0203H
        FUNCTION ??zclParseInReadRspCmd?relay,0203H
        PUBLIC ??zclParseInReportCmd?relay
        FUNCTION ??zclParseInReportCmd?relay,0203H
        PUBLIC ??zclParseInWriteCmd?relay
        FUNCTION ??zclParseInWriteCmd?relay,0203H
        FUNCTION ??zclParseInWriteRspCmd?relay,0203H
        FUNCTION ??zclProcessInReadCmd?relay,0203H
        FUNCTION ??zclProcessInWriteCmd?relay,0203H
        FUNCTION ??zclProcessInWriteUndividedCmd?relay,0203H
        PUBLIC ??zclProcessMessageMSG?relay
        FUNCTION ??zclProcessMessageMSG?relay,0203H
        PUBLIC ??zclReadAttrData?relay
        FUNCTION ??zclReadAttrData?relay,0203H
        FUNCTION ??zclReadAttrDataUsingCB?relay,0203H
        FUNCTION ??zclRevertWriteUndividedCmd?relay,0203H
        FUNCTION ??zclSendMsg?relay,0203H
        PUBLIC ??zclSerializeData?relay
        FUNCTION ??zclSerializeData?relay,0203H
        FUNCTION ??zclSetSecurityOption?relay,0203H
        FUNCTION ??zclWriteAttrData?relay,0203H
        FUNCTION ??zclWriteAttrDataUsingCB?relay,0203H
        FUNCTION ??zcl_BuildAnalogData?relay,0203H
        FUNCTION ??zcl_DeviceOperational?relay,0203H
        PUBLIC ??zcl_Init?relay
        FUNCTION ??zcl_Init?relay,0203H
        PUBLIC ??zcl_SendCommand?relay
        FUNCTION ??zcl_SendCommand?relay,0203H
        PUBLIC ??zcl_SendConfigReportCmd?relay
        FUNCTION ??zcl_SendConfigReportCmd?relay,0203H
        PUBLIC ??zcl_SendConfigReportRspCmd?relay
        FUNCTION ??zcl_SendConfigReportRspCmd?relay,0203H
        PUBLIC ??zcl_SendDefaultRspCmd?relay
        FUNCTION ??zcl_SendDefaultRspCmd?relay,0203H
        PUBLIC ??zcl_SendRead?relay
        FUNCTION ??zcl_SendRead?relay,0203H
        PUBLIC ??zcl_SendReadReportCfgCmd?relay
        FUNCTION ??zcl_SendReadReportCfgCmd?relay,0203H
        PUBLIC ??zcl_SendReadReportCfgRspCmd?relay
        FUNCTION ??zcl_SendReadReportCfgRspCmd?relay,0203H
        PUBLIC ??zcl_SendReadRsp?relay
        FUNCTION ??zcl_SendReadRsp?relay,0203H
        PUBLIC ??zcl_SendReportCmd?relay
        FUNCTION ??zcl_SendReportCmd?relay,0203H
        PUBLIC ??zcl_SendWriteRequest?relay
        FUNCTION ??zcl_SendWriteRequest?relay,0203H
        PUBLIC ??zcl_SendWriteRsp?relay
        FUNCTION ??zcl_SendWriteRsp?relay,0203H
        PUBLIC ??zcl_event_loop?relay
        FUNCTION ??zcl_event_loop?relay,0203H
        PUBLIC ??zcl_getRawAFMsg?relay
        FUNCTION ??zcl_getRawAFMsg?relay,0203H
        PUBLIC ??zcl_registerAttrList?relay
        FUNCTION ??zcl_registerAttrList?relay,0203H
        PUBLIC ??zcl_registerClusterOptionList?relay
        FUNCTION ??zcl_registerClusterOptionList?relay,0203H
        PUBLIC ??zcl_registerForMsg?relay
        FUNCTION ??zcl_registerForMsg?relay,0203H
        PUBLIC ??zcl_registerPlugin?relay
        FUNCTION ??zcl_registerPlugin?relay,0203H
        PUBLIC ??zcl_registerReadWriteCB?relay
        FUNCTION ??zcl_registerReadWriteCB?relay,0203H
        PUBLIC ??zcl_registerValidateAttrData?relay
        FUNCTION ??zcl_registerValidateAttrData?relay,0203H
        PUBLIC zclAnalogDataType
        FUNCTION zclAnalogDataType,080203H
        ARGFRAME XSTACK, 28, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME ISTACK, 2, STACK
        FUNCTION zclAuthorizeRead,021203H
        ARGFRAME XSTACK, 28, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME XSTACK, 16, STACK
        FUNCTION zclAuthorizeWrite,021203H
        ARGFRAME XSTACK, 20, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME XSTACK, 16, STACK
        FUNCTION zclBuildHdr,0203H
        ARGFRAME XSTACK, 34, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME ISTACK, 3, STACK
        FUNCTION zclCalcHdrSize,0203H
        ARGFRAME XSTACK, 34, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME ISTACK, 2, STACK
        PUBLIC zclFindAttrRec
        FUNCTION zclFindAttrRec,021203H
        ARGFRAME XSTACK, 40, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME XSTACK, 16, STACK
        FUNCTION zclFindAttrRecsList,0203H
        ARGFRAME XSTACK, 16, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME ISTACK, 2, STACK
        FUNCTION zclFindClusterOption,0203H
        ARGFRAME XSTACK, 14, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME XSTACK, 9, STACK
        FUNCTION zclFindPlugin,0203H
        ARGFRAME XSTACK, 39, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME XSTACK, 9, STACK
        PUBLIC zclGetAttrDataLength
        FUNCTION zclGetAttrDataLength,021203H
        ARGFRAME XSTACK, 38, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME XSTACK, 11, STACK
        FUNCTION zclGetAttrDataLengthUsingCB,021203H
        ARGFRAME XSTACK, 38, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME XSTACK, 22, STACK
        FUNCTION zclGetAuthorizeCB,021203H
        ARGFRAME XSTACK, 16, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME XSTACK, 10, STACK
        FUNCTION zclGetClusterOption,021203H
        ARGFRAME XSTACK, 39, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME XSTACK, 14, STACK
        PUBLIC zclGetDataTypeLength
        FUNCTION zclGetDataTypeLength,0203H
        ARGFRAME XSTACK, 28, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCTION zclGetReadWriteCB,021203H
        ARGFRAME XSTACK, 20, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME XSTACK, 10, STACK
        PUBLIC zclParseHdr
        FUNCTION zclParseHdr,021203H
        ARGFRAME XSTACK, 39, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME ISTACK, 1, STACK
        LOCFRAME XSTACK, 12, STACK
        PUBLIC zclParseInConfigReportCmd
        FUNCTION zclParseInConfigReportCmd,021603H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME ISTACK, 1, STACK
        LOCFRAME XSTACK, 25, STACK
        FUNCTION zclParseInConfigReportRspCmd,021603H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME ISTACK, 1, STACK
        LOCFRAME XSTACK, 16, STACK
        FUNCTION zclParseInDefaultRspCmd,021603H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME ISTACK, 1, STACK
        LOCFRAME XSTACK, 14, STACK
        PUBLIC zclParseInReadCmd
        FUNCTION zclParseInReadCmd,021603H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME ISTACK, 1, STACK
        LOCFRAME XSTACK, 14, STACK
        PUBLIC zclParseInReadReportCfgCmd
        FUNCTION zclParseInReadReportCfgCmd,021603H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME ISTACK, 1, STACK
        LOCFRAME XSTACK, 16, STACK
        FUNCTION zclParseInReadReportCfgRspCmd,021603H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME ISTACK, 1, STACK
        LOCFRAME XSTACK, 24, STACK
        FUNCTION zclParseInReadRspCmd,021603H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME ISTACK, 1, STACK
        LOCFRAME XSTACK, 29, STACK
        PUBLIC zclParseInReportCmd
        FUNCTION zclParseInReportCmd,021603H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME ISTACK, 1, STACK
        LOCFRAME XSTACK, 29, STACK
        PUBLIC zclParseInWriteCmd
        FUNCTION zclParseInWriteCmd,021603H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME ISTACK, 1, STACK
        LOCFRAME XSTACK, 29, STACK
        FUNCTION zclParseInWriteRspCmd,021603H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME ISTACK, 1, STACK
        LOCFRAME XSTACK, 16, STACK
        FUNCTION zclProcessInReadCmd,021603H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME ISTACK, 1, STACK
        LOCFRAME XSTACK, 33, STACK
        FUNCTION zclProcessInWriteCmd,021603H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME ISTACK, 1, STACK
        LOCFRAME XSTACK, 33, STACK
        FUNCTION zclProcessInWriteUndividedCmd,021603H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME ISTACK, 1, STACK
        LOCFRAME XSTACK, 43, STACK
        PUBLIC zclProcessMessageMSG
        FUNCTION zclProcessMessageMSG,021203H
        ARGFRAME XSTACK, 14, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME ISTACK, 2, STACK
        LOCFRAME XSTACK, 46, STACK
        PUBLIC zclReadAttrData
        FUNCTION zclReadAttrData,021203H
        ARGFRAME XSTACK, 40, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME XSTACK, 21, STACK
        FUNCTION zclReadAttrDataUsingCB,021203H
        ARGFRAME XSTACK, 42, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME XSTACK, 24, STACK
        FUNCTION zclRevertWriteUndividedCmd,021203H
        ARGFRAME XSTACK, 40, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME XSTACK, 33, STACK
        FUNCTION zclSendMsg,021603H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME ISTACK, 1, STACK
        LOCFRAME XSTACK, 12, STACK
        PUBLIC zclSerializeData
        FUNCTION zclSerializeData,0a1203H
        ARGFRAME XSTACK, 28, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME ISTACK, 1, STACK
        LOCFRAME XSTACK, 23, STACK
        FUNCTION zclSetSecurityOption,021203H
        ARGFRAME XSTACK, 39, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME XSTACK, 14, STACK
        FUNCTION zclWriteAttrData,021203H
        ARGFRAME XSTACK, 40, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME XSTACK, 23, STACK
        FUNCTION zclWriteAttrDataUsingCB,021203H
        ARGFRAME XSTACK, 40, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME XSTACK, 22, STACK
        FUNCTION zcl_BuildAnalogData,0a1203H
        ARGFRAME XSTACK, 25, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME ISTACK, 1, STACK
        LOCFRAME XSTACK, 11, STACK
        FUNCTION zcl_DeviceOperational,021203H
        ARGFRAME XSTACK, 41, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME XSTACK, 27, STACK
        PUBLIC zcl_Init
        FUNCTION zcl_Init,0203H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME ISTACK, 2, STACK
        PUBLIC zcl_RegisteredMsgTaskID
        PUBLIC zcl_SendCommand
        FUNCTION zcl_SendCommand,021203H
        ARGFRAME XSTACK, 39, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME ISTACK, 1, STACK
        LOCFRAME XSTACK, 43, STACK
        PUBLIC zcl_SendConfigReportCmd
        FUNCTION zcl_SendConfigReportCmd,021203H
        ARGFRAME XSTACK, 5, STACK
        LOCFRAME ISTACK, 1, STACK
        LOCFRAME XSTACK, 39, STACK
        PUBLIC zcl_SendConfigReportRspCmd
        FUNCTION zcl_SendConfigReportRspCmd,021203H
        ARGFRAME XSTACK, 5, STACK
        LOCFRAME ISTACK, 1, STACK
        LOCFRAME XSTACK, 37, STACK
        PUBLIC zcl_SendDefaultRspCmd
        FUNCTION zcl_SendDefaultRspCmd,021203H
        ARGFRAME XSTACK, 46, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME ISTACK, 1, STACK
        LOCFRAME XSTACK, 33, STACK
        PUBLIC zcl_SendRead
        FUNCTION zcl_SendRead,021203H
        ARGFRAME XSTACK, 5, STACK
        LOCFRAME ISTACK, 1, STACK
        LOCFRAME XSTACK, 37, STACK
        PUBLIC zcl_SendReadReportCfgCmd
        FUNCTION zcl_SendReadReportCfgCmd,021203H
        ARGFRAME XSTACK, 5, STACK
        LOCFRAME ISTACK, 1, STACK
        LOCFRAME XSTACK, 37, STACK
        PUBLIC zcl_SendReadReportCfgRspCmd
        FUNCTION zcl_SendReadReportCfgRspCmd,021203H
        ARGFRAME XSTACK, 5, STACK
        LOCFRAME ISTACK, 1, STACK
        LOCFRAME XSTACK, 39, STACK
        PUBLIC zcl_SendReadRsp
        FUNCTION zcl_SendReadRsp,021203H
        ARGFRAME XSTACK, 33, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME ISTACK, 1, STACK
        LOCFRAME XSTACK, 39, STACK
        PUBLIC zcl_SendReportCmd
        FUNCTION zcl_SendReportCmd,021203H
        ARGFRAME XSTACK, 5, STACK
        LOCFRAME ISTACK, 1, STACK
        LOCFRAME XSTACK, 39, STACK
        PUBLIC zcl_SendWriteRequest
        FUNCTION zcl_SendWriteRequest,021203H
        ARGFRAME XSTACK, 6, STACK
        LOCFRAME ISTACK, 1, STACK
        LOCFRAME XSTACK, 39, STACK
        PUBLIC zcl_SendWriteRsp
        FUNCTION zcl_SendWriteRsp,021203H
        ARGFRAME XSTACK, 43, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME ISTACK, 1, STACK
        LOCFRAME XSTACK, 37, STACK
        PUBLIC zcl_SeqNum
        PUBLIC zcl_TaskID
        PUBLIC zcl_ValidateAttrDataCB
        PUBLIC zcl_event_loop
        FUNCTION zcl_event_loop,021203H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME XSTACK, 14, STACK
        PUBLIC zcl_getRawAFMsg
        FUNCTION zcl_getRawAFMsg,0203H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME ISTACK, 2, STACK
        PUBLIC zcl_registerAttrList
        FUNCTION zcl_registerAttrList,021203H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME ISTACK, 1, STACK
        LOCFRAME XSTACK, 16, STACK
        PUBLIC zcl_registerClusterOptionList
        FUNCTION zcl_registerClusterOptionList,021203H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME ISTACK, 1, STACK
        LOCFRAME XSTACK, 16, STACK
        PUBLIC zcl_registerForMsg
        FUNCTION zcl_registerForMsg,0203H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME ISTACK, 2, STACK
        PUBLIC zcl_registerPlugin
        FUNCTION zcl_registerPlugin,021203H
        ARGFRAME XSTACK, 2, STACK
        LOCFRAME XSTACK, 18, STACK
        PUBLIC zcl_registerReadWriteCB
        FUNCTION zcl_registerReadWriteCB,021203H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME XSTACK, 14, STACK
        PUBLIC zcl_registerValidateAttrData
        FUNCTION zcl_registerValidateAttrData,0203H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME ISTACK, 2, STACK
        
          CFI Names cfiNames0
          CFI StackFrame CFA_SP SP IDATA
          CFI StackFrame CFA_PSP16 PSP16 XDATA
          CFI StackFrame CFA_XSP16 XSP16 XDATA
          CFI StaticOverlayFrame CFA_IOVERLAY IOVERLAY
          CFI StaticOverlayFrame CFA_DOVERLAY DOVERLAY
          CFI Resource `PSW.CY`:1, `B.BR0`:1, `B.BR1`:1, `B.BR2`:1, `B.BR3`:1
          CFI Resource `B.BR4`:1, `B.BR5`:1, `B.BR6`:1, `B.BR7`:1, `VB.BR8`:1
          CFI Resource `VB.BR9`:1, `VB.BR10`:1, `VB.BR11`:1, `VB.BR12`:1
          CFI Resource `VB.BR13`:1, `VB.BR14`:1, `VB.BR15`:1, VB:8, B:8, A:8
          CFI Resource PSW:8, DPL0:8, DPH0:8, R0:8, R1:8, R2:8, R3:8, R4:8, R5:8
          CFI Resource R6:8, R7:8, V0:8, V1:8, V2:8, V3:8, V4:8, V5:8, V6:8, V7:8
          CFI Resource V8:8, V9:8, V10:8, V11:8, V12:8, V13:8, V14:8, V15:8, SP:8
          CFI Resource PSPH:8, PSPL:8, PSP16:16, XSPH:8, XSPL:8, XSP16:16
          CFI VirtualResource ?RET:24
          CFI Resource ?BRET_EXT:8
          CFI VirtualResource ?RET_HIGH:8, ?RET_LOW:8
          CFI ResourceParts PSP16 PSPH, PSPL
          CFI ResourceParts XSP16 XSPH, XSPL
          CFI ResourceParts ?RET ?BRET_EXT, ?RET_HIGH, ?RET_LOW
          CFI EndNames cfiNames0
        
          CFI Common cfiCommon0 Using cfiNames0
          CFI CodeAlign 1
          CFI DataAlign -1
          CFI ReturnAddress ?RET CODE
          CFI CFA_DOVERLAY Used
          CFI CFA_IOVERLAY Used
          CFI CFA_SP SP+-3
          CFI CFA_PSP16 PSP16+0
          CFI CFA_XSP16 XSP16+0
          CFI `PSW.CY` SameValue
          CFI `B.BR0` SameValue
          CFI `B.BR1` SameValue
          CFI `B.BR2` SameValue
          CFI `B.BR3` SameValue
          CFI `B.BR4` SameValue
          CFI `B.BR5` SameValue
          CFI `B.BR6` SameValue
          CFI `B.BR7` SameValue
          CFI `VB.BR8` SameValue
          CFI `VB.BR9` SameValue
          CFI `VB.BR10` SameValue
          CFI `VB.BR11` SameValue
          CFI `VB.BR12` SameValue
          CFI `VB.BR13` SameValue
          CFI `VB.BR14` SameValue
          CFI `VB.BR15` SameValue
          CFI VB SameValue
          CFI B Undefined
          CFI A Undefined
          CFI PSW SameValue
          CFI DPL0 SameValue
          CFI DPH0 SameValue
          CFI R0 Undefined
          CFI R1 Undefined
          CFI R2 Undefined
          CFI R3 Undefined
          CFI R4 Undefined
          CFI R5 Undefined
          CFI R6 SameValue
          CFI R7 SameValue
          CFI V0 SameValue
          CFI V1 SameValue
          CFI V2 SameValue
          CFI V3 SameValue
          CFI V4 SameValue
          CFI V5 SameValue
          CFI V6 SameValue
          CFI V7 SameValue
          CFI V8 SameValue
          CFI V9 SameValue
          CFI V10 SameValue
          CFI V11 SameValue
          CFI V12 SameValue
          CFI V13 SameValue
          CFI V14 SameValue
          CFI V15 SameValue
          CFI PSPH Undefined
          CFI PSPL Undefined
          CFI XSPH Undefined
          CFI XSPL Undefined
          CFI ?RET Concat
          CFI ?BRET_EXT Frame(CFA_SP, 3)
          CFI ?RET_HIGH Frame(CFA_SP, 2)
          CFI ?RET_LOW Frame(CFA_SP, 1)
          CFI EndCommon cfiCommon0
        
AF_DataRequest      SYMBOL "AF_DataRequest"
??AF_DataRequest?relay SYMBOL "?relay", AF_DataRequest
StubAPS_InterPan    SYMBOL "StubAPS_InterPan"
??StubAPS_InterPan?relay SYMBOL "?relay", StubAPS_InterPan
afFindEndPointDesc  SYMBOL "afFindEndPointDesc"
??afFindEndPointDesc?relay SYMBOL "?relay", afFindEndPointDesc
osal_buffer_uint32  SYMBOL "osal_buffer_uint32"
??osal_buffer_uint32?relay SYMBOL "?relay", osal_buffer_uint32
osal_build_uint32   SYMBOL "osal_build_uint32"
??osal_build_uint32?relay SYMBOL "?relay", osal_build_uint32
osal_mem_alloc      SYMBOL "osal_mem_alloc"
??osal_mem_alloc?relay SYMBOL "?relay", osal_mem_alloc
osal_mem_free       SYMBOL "osal_mem_free"
??osal_mem_free?relay SYMBOL "?relay", osal_mem_free
osal_memcpy         SYMBOL "osal_memcpy"
??osal_memcpy?relay SYMBOL "?relay", osal_memcpy
osal_memset         SYMBOL "osal_memset"
??osal_memset?relay SYMBOL "?relay", osal_memset
osal_msg_allocate   SYMBOL "osal_msg_allocate"
??osal_msg_allocate?relay SYMBOL "?relay", osal_msg_allocate
osal_msg_deallocate SYMBOL "osal_msg_deallocate"
??osal_msg_deallocate?relay SYMBOL "?relay", osal_msg_deallocate
osal_msg_receive    SYMBOL "osal_msg_receive"
??osal_msg_receive?relay SYMBOL "?relay", osal_msg_receive
osal_msg_send       SYMBOL "osal_msg_send"
??osal_msg_send?relay SYMBOL "?relay", osal_msg_send
zclAnalogDataType   SYMBOL "zclAnalogDataType"
??zclAnalogDataType?relay SYMBOL "?relay", zclAnalogDataType
zclFindAttrRec      SYMBOL "zclFindAttrRec"
??zclFindAttrRec?relay SYMBOL "?relay", zclFindAttrRec
zclGetAttrDataLength SYMBOL "zclGetAttrDataLength"
??zclGetAttrDataLength?relay SYMBOL "?relay", zclGetAttrDataLength
zclGetDataTypeLength SYMBOL "zclGetDataTypeLength"
??zclGetDataTypeLength?relay SYMBOL "?relay", zclGetDataTypeLength
zclParseHdr         SYMBOL "zclParseHdr"
??zclParseHdr?relay SYMBOL "?relay", zclParseHdr
zclParseInConfigReportCmd SYMBOL "zclParseInConfigReportCmd"
??zclParseInConfigReportCmd?relay SYMBOL "?relay", zclParseInConfigReportCmd
zclParseInReadCmd   SYMBOL "zclParseInReadCmd"
??zclParseInReadCmd?relay SYMBOL "?relay", zclParseInReadCmd
zclParseInReadReportCfgCmd SYMBOL "zclParseInReadReportCfgCmd"
??zclParseInReadReportCfgCmd?relay SYMBOL "?relay", zclParseInReadReportCfgCmd
zclParseInReportCmd SYMBOL "zclParseInReportCmd"
??zclParseInReportCmd?relay SYMBOL "?relay", zclParseInReportCmd
zclParseInWriteCmd  SYMBOL "zclParseInWriteCmd"
??zclParseInWriteCmd?relay SYMBOL "?relay", zclParseInWriteCmd
zclProcessMessageMSG SYMBOL "zclProcessMessageMSG"
??zclProcessMessageMSG?relay SYMBOL "?relay", zclProcessMessageMSG
zclReadAttrData     SYMBOL "zclReadAttrData"
??zclReadAttrData?relay SYMBOL "?relay", zclReadAttrData
zclSerializeData    SYMBOL "zclSerializeData"
??zclSerializeData?relay SYMBOL "?relay", zclSerializeData
zcl_Init            SYMBOL "zcl_Init"
??zcl_Init?relay    SYMBOL "?relay", zcl_Init
zcl_SendCommand     SYMBOL "zcl_SendCommand"
??zcl_SendCommand?relay SYMBOL "?relay", zcl_SendCommand
zcl_SendConfigReportCmd SYMBOL "zcl_SendConfigReportCmd"
??zcl_SendConfigReportCmd?relay SYMBOL "?relay", zcl_SendConfigReportCmd
zcl_SendConfigReportRspCmd SYMBOL "zcl_SendConfigReportRspCmd"
??zcl_SendConfigReportRspCmd?relay SYMBOL "?relay", zcl_SendConfigReportRspCmd
zcl_SendDefaultRspCmd SYMBOL "zcl_SendDefaultRspCmd"
??zcl_SendDefaultRspCmd?relay SYMBOL "?relay", zcl_SendDefaultRspCmd
zcl_SendRead        SYMBOL "zcl_SendRead"
??zcl_SendRead?relay SYMBOL "?relay", zcl_SendRead
zcl_SendReadReportCfgCmd SYMBOL "zcl_SendReadReportCfgCmd"
??zcl_SendReadReportCfgCmd?relay SYMBOL "?relay", zcl_SendReadReportCfgCmd
zcl_SendReadReportCfgRspCmd SYMBOL "zcl_SendReadReportCfgRspCmd"
??zcl_SendReadReportCfgRspCmd?relay SYMBOL "?relay", zcl_SendReadReportCfgRspCmd
zcl_SendReadRsp     SYMBOL "zcl_SendReadRsp"
??zcl_SendReadRsp?relay SYMBOL "?relay", zcl_SendReadRsp
zcl_SendReportCmd   SYMBOL "zcl_SendReportCmd"
??zcl_SendReportCmd?relay SYMBOL "?relay", zcl_SendReportCmd
zcl_SendWriteRequest SYMBOL "zcl_SendWriteRequest"
??zcl_SendWriteRequest?relay SYMBOL "?relay", zcl_SendWriteRequest
zcl_SendWriteRsp    SYMBOL "zcl_SendWriteRsp"
??zcl_SendWriteRsp?relay SYMBOL "?relay", zcl_SendWriteRsp
zcl_event_loop      SYMBOL "zcl_event_loop"
??zcl_event_loop?relay SYMBOL "?relay", zcl_event_loop
zcl_getRawAFMsg     SYMBOL "zcl_getRawAFMsg"
??zcl_getRawAFMsg?relay SYMBOL "?relay", zcl_getRawAFMsg
zcl_registerAttrList SYMBOL "zcl_registerAttrList"
??zcl_registerAttrList?relay SYMBOL "?relay", zcl_registerAttrList
zcl_registerClusterOptionList SYMBOL "zcl_registerClusterOptionList"
??zcl_registerClusterOptionList?relay SYMBOL "?relay", zcl_registerClusterOptionList
zcl_registerForMsg  SYMBOL "zcl_registerForMsg"
??zcl_registerForMsg?relay SYMBOL "?relay", zcl_registerForMsg
zcl_registerPlugin  SYMBOL "zcl_registerPlugin"
??zcl_registerPlugin?relay SYMBOL "?relay", zcl_registerPlugin
zcl_registerReadWriteCB SYMBOL "zcl_registerReadWriteCB"
??zcl_registerReadWriteCB?relay SYMBOL "?relay", zcl_registerReadWriteCB
zcl_registerValidateAttrData SYMBOL "zcl_registerValidateAttrData"
??zcl_registerValidateAttrData?relay SYMBOL "?relay", zcl_registerValidateAttrData

        EXTERN ??AF_DataRequest?relay
        FUNCTION ??AF_DataRequest?relay,00H
        EXTERN ??StubAPS_InterPan?relay
        FUNCTION ??StubAPS_InterPan?relay,00H
        EXTERN ??afFindEndPointDesc?relay
        FUNCTION ??afFindEndPointDesc?relay,00H
        EXTERN ??osal_buffer_uint32?relay
        FUNCTION ??osal_buffer_uint32?relay,00H
        EXTERN ??osal_build_uint32?relay
        FUNCTION ??osal_build_uint32?relay,00H
        EXTERN ??osal_mem_alloc?relay
        FUNCTION ??osal_mem_alloc?relay,00H
        EXTERN ??osal_mem_free?relay
        FUNCTION ??osal_mem_free?relay,00H
        EXTERN ??osal_memcpy?relay
        FUNCTION ??osal_memcpy?relay,00H
        EXTERN ??osal_memset?relay
        FUNCTION ??osal_memset?relay,00H
        EXTERN ??osal_msg_allocate?relay
        FUNCTION ??osal_msg_allocate?relay,00H
        EXTERN ??osal_msg_deallocate?relay
        FUNCTION ??osal_msg_deallocate?relay,00H
        EXTERN ??osal_msg_receive?relay
        FUNCTION ??osal_msg_receive?relay,00H
        EXTERN ??osal_msg_send?relay
        FUNCTION ??osal_msg_send?relay,00H
        EXTERN AF_DataRequest
        FUNCTION AF_DataRequest,0202H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 43, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN StubAPS_InterPan
        FUNCTION StubAPS_InterPan,0202H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 39, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN afFindEndPointDesc
        FUNCTION afFindEndPointDesc,0202H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 39, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN osal_buffer_uint32
        FUNCTION osal_buffer_uint32,0202H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 23, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN osal_build_uint32
        FUNCTION osal_build_uint32,0202H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 11, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN osal_mem_alloc
        FUNCTION osal_mem_alloc,0202H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 38, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN osal_mem_free
        FUNCTION osal_mem_free,0202H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 39, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN osal_memcpy
        FUNCTION osal_memcpy,0202H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 37, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN osal_memset
        FUNCTION osal_memset,0202H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 34, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN osal_msg_allocate
        FUNCTION osal_msg_allocate,0202H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 12, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN osal_msg_deallocate
        FUNCTION osal_msg_deallocate,0202H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 14, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN osal_msg_receive
        FUNCTION osal_msg_receive,0202H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 14, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN osal_msg_send
        FUNCTION osal_msg_send,0202H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 14, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC

// C:\Users\PedroZ\Documents\GitHub\TG\Components\stack\zcl\zcl.c
//    1 /**************************************************************************************************
//    2   Filename:       zcl.c
//    3   Revised:        $Date: 2012-01-30 10:40:08 -0800 (Mon, 30 Jan 2012) $
//    4   Revision:       $Revision: 29096 $
//    5 
//    6   Description:    This file contains the Zigbee Cluster Library Foundation functions.
//    7 
//    8 
//    9   Copyright 2006-2012 Texas Instruments Incorporated. All rights reserved.
//   10 
//   11   IMPORTANT: Your use of this Software is limited to those specific rights
//   12   granted under the terms of a software license agreement between the user
//   13   who downloaded the software, his/her employer (which must be your employer)
//   14   and Texas Instruments Incorporated (the "License").  You may not use this
//   15   Software unless you agree to abide by the terms of the License. The License
//   16   limits your use, and you acknowledge, that the Software may not be modified,
//   17   copied or distributed unless embedded on a Texas Instruments microcontroller
//   18   or used solely and exclusively in conjunction with a Texas Instruments radio
//   19   frequency transceiver, which is integrated into your product.  Other than for
//   20   the foregoing purpose, you may not use, reproduce, copy, prepare derivative
//   21   works of, modify, distribute, perform, display or sell this Software and/or
//   22   its documentation for any purpose.
//   23 
//   24   YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
//   25   PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
//   26   INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
//   27   NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
//   28   TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
//   29   NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
//   30   LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
//   31   INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
//   32   OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
//   33   OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
//   34   (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
//   35 
//   36   Should you have any questions regarding your right to use this Software,
//   37   contact Texas Instruments Incorporated at www.TI.com.
//   38 **************************************************************************************************/
//   39 
//   40 /*********************************************************************
//   41  * INCLUDES
//   42  */
//   43 #include "ZComDef.h"
//   44 #include "OSAL.h"
//   45 #include "OSAL_Tasks.h"
//   46 #include "AF.h"
//   47 #include "ZDConfig.h"
//   48 
//   49 #include "zcl.h"
//   50 #include "zcl_general.h"
//   51 
//   52 #if defined ( INTER_PAN )
//   53   #include "stub_aps.h"
//   54 #endif
//   55 
//   56 /*********************************************************************
//   57  * MACROS
//   58  */
//   59 /*** Frame Control ***/
//   60 #define zcl_FCType( a )               ( (a) & ZCL_FRAME_CONTROL_TYPE )
//   61 #define zcl_FCManuSpecific( a )       ( (a) & ZCL_FRAME_CONTROL_MANU_SPECIFIC )
//   62 #define zcl_FCDirection( a )          ( (a) & ZCL_FRAME_CONTROL_DIRECTION )
//   63 #define zcl_FCDisableDefaultRsp( a )  ( (a) & ZCL_FRAME_CONTROL_DISABLE_DEFAULT_RSP )
//   64 
//   65 /*** Attribute Access Control ***/
//   66 #define zcl_AccessCtrlRead( a )       ( (a) & ACCESS_CONTROL_READ )
//   67 #define zcl_AccessCtrlWrite( a )      ( (a) & ACCESS_CONTROL_WRITE )
//   68 #define zcl_AccessCtrlCmd( a )        ( (a) & ACCESS_CONTROL_CMD )
//   69 #define zcl_AccessCtrlAuthRead( a )   ( (a) & ACCESS_CONTROL_AUTH_READ )
//   70 #define zcl_AccessCtrlAuthWrite( a )  ( (a) & ACCESS_CONTROL_AUTH_WRITE )
//   71 
//   72 #define zclParseCmd( a, b )           zclCmdTable[(a)].pfnParseInProfile( (b) )
//   73 #define zclProcessCmd( a, b )         zclCmdTable[(a)].pfnProcessInProfile( (b) )
//   74 
//   75 #define zcl_DefaultRspCmd( zclHdr )   ( zcl_ProfileCmd( (zclHdr).fc.type )     && \ 
//   76                                         (zclHdr).fc.manuSpecific == 0          && \ 
//   77                                         (zclHdr).commandID == ZCL_CMD_DEFAULT_RSP )
//   78 
//   79 // Commands that have corresponding responses
//   80 #define CMD_HAS_RSP( cmd )            ( (cmd) == ZCL_CMD_READ            || \ 
//   81                                         (cmd) == ZCL_CMD_WRITE           || \ 
//   82                                         (cmd) == ZCL_CMD_WRITE_UNDIVIDED || \ 
//   83                                         (cmd) == ZCL_CMD_CONFIG_REPORT   || \ 
//   84                                         (cmd) == ZCL_CMD_READ_REPORT_CFG || \ 
//   85                                         (cmd) == ZCL_CMD_DISCOVER        || \ 
//   86                                         (cmd) == ZCL_CMD_DEFAULT_RSP ) // exception
//   87 
//   88 /*********************************************************************
//   89  * CONSTANTS
//   90  */
//   91 
//   92 /*********************************************************************
//   93  * TYPEDEFS
//   94  */
//   95 typedef struct zclLibPlugin
//   96 {
//   97   struct zclLibPlugin *next;
//   98   uint16              startClusterID;    // starting cluster ID
//   99   uint16              endClusterID;      // ending cluster ID
//  100   zclInHdlr_t         pfnIncomingHdlr;    // function to handle incoming message
//  101 } zclLibPlugin_t;
//  102 
//  103 // Attribute record list item
//  104 typedef struct zclAttrRecsList
//  105 {
//  106   struct zclAttrRecsList *next;
//  107   uint8                  endpoint;      // Used to link it into the endpoint descriptor
//  108   zclReadWriteCB_t       pfnReadWriteCB;// Read or Write attribute value callback function
//  109   zclAuthorizeCB_t       pfnAuthorizeCB;// Authorize Read or Write operation
//  110   uint8                  numAttributes; // Number of the following records
//  111   CONST zclAttrRec_t     *attrs;        // attribute records
//  112 } zclAttrRecsList;
//  113 
//  114 // Cluster option list item
//  115 typedef struct zclClusterOptionList
//  116 {
//  117   struct zclClusterOptionList *next;
//  118   uint8                       endpoint;   // Used to link it into the endpoint descriptor
//  119   uint8                       numOptions; // Number of the following records
//  120   zclOptionRec_t              *options;   // option records
//  121 } zclClusterOptionList;
//  122 
//  123 typedef void *(*zclParseInProfileCmd_t)( zclParseCmd_t *pCmd );
//  124 typedef uint8 (*zclProcessInProfileCmd_t)( zclIncoming_t *pInMsg );
//  125 
//  126 typedef struct
//  127 {
//  128   zclParseInProfileCmd_t   pfnParseInProfile;
//  129   zclProcessInProfileCmd_t pfnProcessInProfile;
//  130 } zclCmdItems_t;
//  131 
//  132 
//  133 /*********************************************************************
//  134  * GLOBAL VARIABLES
//  135  */

        RSEG XDATA_Z:XDATA:NOROOT(0)
        DATA8
//  136 uint8 zcl_TaskID;
zcl_TaskID:
        DS 1
        REQUIRE __INIT_XDATA_Z
//  137 
//  138 // The task Id of the Application where the unprocessed Foundation
//  139 // Command/Response messages will be sent to.

        RSEG XDATA_I:XDATA:NOROOT(0)
//  140 uint8 zcl_RegisteredMsgTaskID = TASK_NO_TASK;
zcl_RegisteredMsgTaskID:
        DATA8
        DS 1
        REQUIRE `?<Initializer for zcl_RegisteredMsgTaskID>`
        REQUIRE __INIT_XDATA_I
//  141 
//  142 // The Application should register its attribute data validation function

        RSEG XDATA_Z:XDATA:NOROOT(0)
        DATA16
//  143 zclValidateAttrData_t zcl_ValidateAttrDataCB = NULL;
zcl_ValidateAttrDataCB:
        DS 2
        REQUIRE __INIT_XDATA_Z
//  144 
//  145 // ZCL Sequence number

        RSEG XDATA_Z:XDATA:NOROOT(0)
        DATA8
//  146 uint8 zcl_SeqNum = 0x00;
zcl_SeqNum:
        DS 1
        REQUIRE __INIT_XDATA_Z
//  147 
//  148 /*********************************************************************
//  149  * EXTERNAL VARIABLES
//  150  */
//  151 
//  152 /*********************************************************************
//  153  * EXTERNAL FUNCTIONS
//  154  */
//  155 
//  156 /*********************************************************************
//  157  * LOCAL VARIABLES
//  158  */

        RSEG XDATA_Z:XDATA:NOROOT(0)
        DATA16
//  159 static zclLibPlugin_t *plugins;
plugins:
        DS 2
        REQUIRE __INIT_XDATA_Z

        RSEG XDATA_Z:XDATA:NOROOT(0)
        DATA16
//  160 static zclAttrRecsList *attrList;
attrList:
        DS 2
        REQUIRE __INIT_XDATA_Z

        RSEG XDATA_Z:XDATA:NOROOT(0)
        DATA16
//  161 static zclClusterOptionList *clusterOptionList;
clusterOptionList:
        DS 2
        REQUIRE __INIT_XDATA_Z

        RSEG XDATA_Z:XDATA:NOROOT(0)
        DATA8
//  162 static uint8 zcl_TransID = 0;  // This is the unique message ID (counter)
zcl_TransID:
        DS 1
        REQUIRE __INIT_XDATA_Z
//  163 

        RSEG XDATA_Z:XDATA:NOROOT(0)
        DATA16
//  164 static afIncomingMSGPacket_t *rawAFMsg = NULL;
rawAFMsg:
        DS 2
        REQUIRE __INIT_XDATA_Z
//  165 
//  166 /*********************************************************************
//  167  * LOCAL FUNCTIONS
//  168  */
//  169 void zclProcessMessageMSG( afIncomingMSGPacket_t *pkt );  // Not static for ZNP build.
//  170 static uint8 *zclBuildHdr( zclFrameHdr_t *hdr, uint8 *pData );
//  171 static uint8 zclCalcHdrSize( zclFrameHdr_t *hdr );
//  172 static zclLibPlugin_t *zclFindPlugin( uint16 clusterID, uint16 profileID );
//  173 static zclAttrRecsList *zclFindAttrRecsList( uint8 endpoint );
//  174 static zclOptionRec_t *zclFindClusterOption( uint8 endpoint, uint16 clusterID );
//  175 static uint8 zclGetClusterOption( uint8 endpoint, uint16 clusterID );
//  176 static void zclSetSecurityOption( uint8 endpoint, uint16 clusterID, uint8 enable );
//  177 
//  178 static uint8 zcl_DeviceOperational( uint8 srcEP, uint16 clusterID, uint8 frameType, uint8 cmd, uint16 profileID );
//  179 
//  180 #if defined ( ZCL_READ ) || defined ( ZCL_WRITE )
//  181 static zclReadWriteCB_t zclGetReadWriteCB( uint8 endpoint );
//  182 static zclAuthorizeCB_t zclGetAuthorizeCB( uint8 endpoint );
//  183 #endif // ZCL_READ || ZCL_WRITE
//  184 
//  185 #ifdef ZCL_READ
//  186 static uint16 zclGetAttrDataLengthUsingCB( uint8 endpoint, uint16 clusterID, uint16 attrId );
//  187 static ZStatus_t zclReadAttrDataUsingCB( uint8 endpoint, uint16 clusterId, uint16 attrId,
//  188                                          uint8 *pAttrData, uint16 *pDataLen );
//  189 static ZStatus_t zclAuthorizeRead( uint8 endpoint, afAddrType_t *srcAddr, zclAttrRec_t *pAttr );
//  190 static void *zclParseInReadRspCmd( zclParseCmd_t *pCmd );
//  191 static uint8 zclProcessInReadCmd( zclIncoming_t *pInMsg );
//  192 #endif // ZCL_READ
//  193 
//  194 #ifdef ZCL_WRITE
//  195 static ZStatus_t zclWriteAttrData( uint8 endpoint, afAddrType_t *srcAddr,
//  196                                    zclAttrRec_t *pAttr, zclWriteRec_t *pWriteRec );
//  197 static ZStatus_t zclWriteAttrDataUsingCB( uint8 endpoint, afAddrType_t *srcAddr,
//  198                                           zclAttrRec_t *pAttr, uint8 *pAttrData );
//  199 static ZStatus_t zclAuthorizeWrite( uint8 endpoint, afAddrType_t *srcAddr, zclAttrRec_t *pAttr );
//  200 static void *zclParseInWriteRspCmd( zclParseCmd_t *pCmd );
//  201 static uint8 zclProcessInWriteCmd( zclIncoming_t *pInMsg );
//  202 static uint8 zclProcessInWriteUndividedCmd( zclIncoming_t *pInMsg );
//  203 #endif // ZCL_WRITE
//  204 
//  205 #ifdef ZCL_REPORT
//  206 static void *zclParseInConfigReportRspCmd( zclParseCmd_t *pCmd );
//  207 static void *zclParseInReadReportCfgRspCmd( zclParseCmd_t *pCmd );
//  208 #endif // ZCL_REPORT
//  209 
//  210 static void *zclParseInDefaultRspCmd( zclParseCmd_t *pCmd );
//  211 
//  212 #ifdef ZCL_DISCOVER
//  213 static uint8 zclFindNextAttrRec( uint8 endpoint, uint16 clusterID, uint16 *attrId, zclAttrRec_t *pAttr );
//  214 static void *zclParseInDiscRspCmd( zclParseCmd_t *pCmd );
//  215 static uint8 zclProcessInDiscCmd( zclIncoming_t *pInMsg );
//  216 #endif // ZCL_DISCOVER
//  217 
//  218 static uint8 zclSendMsg( zclIncoming_t *pInMsg );
//  219 
//  220 /*********************************************************************
//  221  * Parse Profile Command Function Table
//  222  */

        RSEG CODE_C:CODE:REORDER:NOROOT(0)
        DATA8
//  223 static CONST zclCmdItems_t zclCmdTable[] =
zclCmdTable:
        DATA16
        DW ??zclParseInReadCmd?relay
        DW ??zclProcessInReadCmd?relay
        DW ??zclParseInReadRspCmd?relay
        DW ??zclSendMsg?relay
        DW ??zclParseInWriteCmd?relay
        DW ??zclProcessInWriteCmd?relay
        DW ??zclParseInWriteCmd?relay
        DW ??zclProcessInWriteUndividedCmd?relay
        DW ??zclParseInWriteRspCmd?relay
        DW ??zclSendMsg?relay
        DW ??zclParseInWriteCmd?relay
        DW ??zclProcessInWriteCmd?relay
        DW ??zclParseInConfigReportCmd?relay
        DW ??zclSendMsg?relay
        DW ??zclParseInConfigReportRspCmd?relay
        DW ??zclSendMsg?relay
        DW ??zclParseInReadReportCfgCmd?relay
        DW ??zclSendMsg?relay
        DW ??zclParseInReadReportCfgRspCmd?relay
        DW ??zclSendMsg?relay
        DW ??zclParseInReportCmd?relay
        DW ??zclSendMsg?relay
        DW ??zclParseInDefaultRspCmd?relay
        DW ??zclSendMsg?relay
        DW 0H
        DW 0H
        DW 0H
        DW 0H
//  224 {
//  225 #ifdef ZCL_READ
//  226   /* ZCL_CMD_READ */                { zclParseInReadCmd,             zclProcessInReadCmd             },
//  227   /* ZCL_CMD_READ_RSP */            { zclParseInReadRspCmd,          zclSendMsg                      },
//  228 #else
//  229   /* ZCL_CMD_READ */                { NULL,                          NULL                            },
//  230   /* ZCL_CMD_READ_RSP */            { NULL,                          NULL                            },
//  231 #endif // ZCL_READ
//  232 
//  233 #ifdef ZCL_WRITE
//  234   /* ZCL_CMD_WRITE */               { zclParseInWriteCmd,            zclProcessInWriteCmd            },
//  235   /* ZCL_CMD_WRITE_UNDIVIDED */     { zclParseInWriteCmd,            zclProcessInWriteUndividedCmd   },
//  236   /* ZCL_CMD_WRITE_RSP */           { zclParseInWriteRspCmd,         zclSendMsg                      },
//  237   /* ZCL_CMD_WRITE_NO_RSP */        { zclParseInWriteCmd,            zclProcessInWriteCmd            },
//  238 #else
//  239   /* ZCL_CMD_WRITE */               { NULL,                          NULL                            },
//  240   /* ZCL_CMD_WRITE_UNDIVIDED */     { NULL,                          NULL                            },
//  241   /* ZCL_CMD_WRITE_RSP */           { NULL,                          NULL                            },
//  242   /* ZCL_CMD_WRITE_NO_RSP */        { NULL,                          NULL                            },
//  243 #endif // ZCL_WRITE
//  244 
//  245 #ifdef ZCL_REPORT
//  246   /* ZCL_CMD_CONFIG_REPORT */       { zclParseInConfigReportCmd,     zclSendMsg                      },
//  247   /* ZCL_CMD_CONFIG_REPORT_RSP */   { zclParseInConfigReportRspCmd,  zclSendMsg                      },
//  248   /* ZCL_CMD_READ_REPORT_CFG */     { zclParseInReadReportCfgCmd,    zclSendMsg                      },
//  249   /* ZCL_CMD_READ_REPORT_CFG_RSP */ { zclParseInReadReportCfgRspCmd, zclSendMsg                      },
//  250   /* ZCL_CMD_REPORT */              { zclParseInReportCmd,           zclSendMsg                      },
//  251 #else
//  252   /* ZCL_CMD_CONFIG_REPORT */       { NULL,                          NULL                            },
//  253   /* ZCL_CMD_CONFIG_REPORT_RSP */   { NULL,                          NULL                            },
//  254   /* ZCL_CMD_READ_REPORT_CFG */     { NULL,                          NULL                            },
//  255   /* ZCL_CMD_READ_REPORT_CFG_RSP */ { NULL,                          NULL                            },
//  256   /* ZCL_CMD_REPORT */              { NULL,                          NULL                            },
//  257 #endif // ZCL_REPORT
//  258 
//  259   /* ZCL_CMD_DEFAULT_RSP */         { zclParseInDefaultRspCmd,       zclSendMsg                      },
//  260 
//  261 #ifdef ZCL_DISCOVER
//  262   /* ZCL_CMD_DISCOVER */            { zclParseInDiscCmd,             zclProcessInDiscCmd             },
//  263   /* ZCL_CMD_DISCOVER_RSP */        { zclParseInDiscRspCmd,          zclSendMsg                      }
//  264 #else
//  265   /* ZCL_CMD_DISCOVER */            { NULL,                          NULL                            },
//  266   /* ZCL_CMD_DISCOVER_RSP */        { NULL,                          NULL                            }
//  267 #endif // ZCL_DISCOVER
//  268 };
//  269 
//  270 /*********************************************************************
//  271  * PUBLIC FUNCTIONS
//  272  *********************************************************************/
//  273 
//  274 /*********************************************************************
//  275  * @fn          zcl_Init
//  276  *
//  277  * @brief       Initialization function for the zcl layer.
//  278  *
//  279  * @param       task_id - ZCL task id
//  280  *
//  281  * @return      none
//  282  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  283 void zcl_Init( uint8 task_id )
zcl_Init:
          CFI Block cfiBlock0 Using cfiCommon0
          CFI Function zcl_Init
        CODE
//  284 {
        PUSH    DPL
          CFI DPL0 Frame(CFA_SP, 4)
          CFI CFA_SP SP+-4
        PUSH    DPH
          CFI DPH0 Frame(CFA_SP, 5)
          CFI CFA_SP SP+-5
        ; Saved register size: 2
        ; Auto size: 0
//  285   zcl_TaskID = task_id;
        MOV     A,R1
        MOV     DPTR,#zcl_TaskID
        MOVX    @DPTR,A
//  286 
//  287   plugins = (zclLibPlugin_t  *)NULL;
        MOV     DPTR,#plugins
        MOV     A,#0x0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
//  288   attrList = (zclAttrRecsList *)NULL;
        MOV     DPTR,#attrList
        MOV     A,#0x0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
//  289   clusterOptionList = (zclClusterOptionList *)NULL;
        MOV     DPTR,#clusterOptionList
        MOV     A,#0x0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
//  290 }
        POP     DPH
          CFI DPH0 SameValue
          CFI CFA_SP SP+-4
        POP     DPL
          CFI DPL0 SameValue
          CFI CFA_SP SP+-3
        LJMP    ?BRET
          CFI EndBlock cfiBlock0
//  291 
//  292 /*********************************************************************
//  293  * @fn          zcl_event_loop
//  294  *
//  295  * @brief       Event Loop Processor for zcl.
//  296  *
//  297  * @param       task_id - task id
//  298  * @param       events - event bitmap
//  299  *
//  300  * @return      unprocessed events
//  301  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  302 uint16 zcl_event_loop( uint8 task_id, uint16 events )
zcl_event_loop:
          CFI Block cfiBlock1 Using cfiCommon0
          CFI Function zcl_event_loop
        CODE
//  303 {
        FUNCALL zcl_event_loop, osal_msg_receive
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 14, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 14, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL zcl_event_loop, zclProcessMessageMSG
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 14, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 14, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL zcl_event_loop, osal_msg_send
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 14, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 14, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL zcl_event_loop, osal_msg_deallocate
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 14, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 14, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL zcl_event_loop, osal_msg_receive
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 14, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 14, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0xe
        LCALL   ?BANKED_ENTER_XDATA
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V5 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI V4 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-13)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-14)))
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 14)
        ; Saved register size: 14
        ; Auto size: 0
        MOV     ?V0 + 2,R1
        MOV     ?V0 + 0,R2
        MOV     ?V0 + 1,R3
//  304   uint8 *msgPtr;
//  305 
//  306   (void)task_id;  // Intentionally unreferenced parameter
//  307 
//  308   if ( events & SYS_EVENT_MSG )
        MOV     A,?V0 + 0
        ANL     A,#0x0
        MOV     R0,A
        MOV     A,?V0 + 1
        ANL     A,#0x80
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JNZ     $+5
        LJMP    ??zcl_event_loop_0 & 0xFFFF
//  309   {
//  310     msgPtr = osal_msg_receive( zcl_TaskID );
        ; Setup parameters for call to function osal_msg_receive
        MOV     DPTR,#zcl_TaskID
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??osal_msg_receive?relay
        MOV     ?V0 + 4,R2
        MOV     ?V0 + 5,R3
        MOV     R6,?V0 + 4
        MOV     R7,?V0 + 5
//  311     while ( msgPtr != NULL )
??zcl_event_loop_1:
        MOV     A,R6
        ORL     A,R7
        JZ      ??zcl_event_loop_2
//  312     {
//  313       uint8 dealloc = TRUE;
        MOV     ?V0 + 3,#0x1
//  314 
//  315       if ( *msgPtr == AF_INCOMING_MSG_CMD )
        MOV     DPL,R6
        MOV     DPH,R7
        MOVX    A,@DPTR
        XRL     A,#0x1a
        JNZ     ??zcl_event_loop_3
//  316       {
//  317         rawAFMsg = (afIncomingMSGPacket_t *)msgPtr;
        MOV     DPTR,#rawAFMsg
        MOV     A,R6
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R7
        MOVX    @DPTR,A
//  318         zclProcessMessageMSG( rawAFMsg );
        ; Setup parameters for call to function zclProcessMessageMSG
        MOV     DPTR,#rawAFMsg
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        LCALL   ??zclProcessMessageMSG?relay
//  319         rawAFMsg = NULL;
        MOV     DPTR,#rawAFMsg
        MOV     A,#0x0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
        SJMP    ??zcl_event_loop_4
//  320       }
//  321       else if ( zcl_RegisteredMsgTaskID != TASK_NO_TASK )
??zcl_event_loop_3:
        MOV     DPTR,#zcl_RegisteredMsgTaskID
        MOVX    A,@DPTR
        XRL     A,#0xff
        JZ      ??zcl_event_loop_4
//  322       {
//  323         // send it to another task to process.
//  324         osal_msg_send( zcl_RegisteredMsgTaskID, msgPtr );
        ; Setup parameters for call to function osal_msg_send
        MOV     A,R6
        MOV     R2,A
        MOV     A,R7
        MOV     R3,A
        MOV     DPTR,#zcl_RegisteredMsgTaskID
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??osal_msg_send?relay
        MOV     A,R1
//  325         dealloc = FALSE;
        MOV     ?V0 + 3,#0x0
//  326       }
//  327 
//  328       // Release the memory
//  329       if ( dealloc )
??zcl_event_loop_4:
        MOV     A,?V0 + 3
        JZ      ??zcl_event_loop_5
//  330       {
//  331         osal_msg_deallocate( msgPtr );
        ; Setup parameters for call to function osal_msg_deallocate
        MOV     A,R6
        MOV     R2,A
        MOV     A,R7
        MOV     R3,A
        LCALL   ??osal_msg_deallocate?relay
        MOV     A,R1
//  332       }
//  333 
//  334       // Next
//  335       msgPtr = osal_msg_receive( zcl_TaskID );
??zcl_event_loop_5:
        ; Setup parameters for call to function osal_msg_receive
        MOV     DPTR,#zcl_TaskID
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??osal_msg_receive?relay
        MOV     ?V0 + 4,R2
        MOV     ?V0 + 5,R3
        MOV     R6,?V0 + 4
        MOV     R7,?V0 + 5
        SJMP    ??zcl_event_loop_1
//  336     }
//  337 
//  338     // return unprocessed events
//  339     return (events ^ SYS_EVENT_MSG);
??zcl_event_loop_2:
        MOV     A,?V0 + 0
        XRL     A,#0x0
        MOV     R2,A
        MOV     A,?V0 + 1
        XRL     A,#0x80
        MOV     R3,A
        SJMP    ??zcl_event_loop_6
//  340   }
//  341 
//  342   // Discard unknown events
//  343   return 0;
??zcl_event_loop_0:
        MOV     R2,#0x0
        MOV     R3,#0x0
??zcl_event_loop_6:
        MOV     R7,#0x6
        LJMP    ?BANKED_LEAVE_XDATA
          CFI EndBlock cfiBlock1
//  344 }
//  345 
//  346 /*********************************************************************
//  347  * @fn          zcl_getRawAFMsg
//  348  *
//  349  * @brief       Call to get original unprocessed AF message
//  350  *              (not parsed by ZCL).
//  351  *
//  352  *   NOTE:  This function can only be called during a ZCL callback function
//  353  *          and the calling function must NOT change any data in the message.
//  354  *
//  355  * @param       none
//  356  *
//  357  * @return      pointer to original AF message, NULL if not processing
//  358  *              AF message.
//  359  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  360 afIncomingMSGPacket_t *zcl_getRawAFMsg( void )
zcl_getRawAFMsg:
          CFI Block cfiBlock2 Using cfiCommon0
          CFI Function zcl_getRawAFMsg
        CODE
//  361 {
        PUSH    DPL
          CFI DPL0 Frame(CFA_SP, 4)
          CFI CFA_SP SP+-4
        PUSH    DPH
          CFI DPH0 Frame(CFA_SP, 5)
          CFI CFA_SP SP+-5
        ; Saved register size: 2
        ; Auto size: 0
//  362   return ( rawAFMsg );
        MOV     DPTR,#rawAFMsg
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        POP     DPH
          CFI DPH0 SameValue
          CFI CFA_SP SP+-4
        POP     DPL
          CFI DPL0 SameValue
          CFI CFA_SP SP+-3
        LJMP    ?BRET
          CFI EndBlock cfiBlock2
//  363 }
//  364 
//  365 /*********************************************************************
//  366  * @fn          zcl_registerPlugin
//  367  *
//  368  * @brief       Add a Cluster Library handler
//  369  *
//  370  * @param       startClusterID - starting cluster ID
//  371  * @param       endClusterID - ending cluster ID
//  372  * @param       pfnHdlr - function pointer to incoming message handler
//  373  *
//  374  * @return      ZSuccess if OK
//  375  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  376 ZStatus_t zcl_registerPlugin( uint16 startClusterID,
zcl_registerPlugin:
          CFI Block cfiBlock3 Using cfiCommon0
          CFI Function zcl_registerPlugin
        CODE
//  377           uint16 endClusterID, zclInHdlr_t pfnIncomingHdlr )
//  378 {
        FUNCALL zcl_registerPlugin, osal_mem_alloc
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 18, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 18, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0x12
        LCALL   ?BANKED_ENTER_XDATA
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V9 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI V8 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V7 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI V6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI V5 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI V4 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-13)))
          CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-14)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-15)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-16)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-17)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-18)))
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 18)
        ; Saved register size: 18
        ; Auto size: 0
        MOV     ?V0 + 0,R2
        MOV     ?V0 + 1,R3
        MOV     ?V0 + 6,R4
        MOV     ?V0 + 7,R5
        MOV     A,#0x12
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     ?V0 + 2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     ?V0 + 3,A
//  379   zclLibPlugin_t *pNewItem;
//  380   zclLibPlugin_t *pLoop;
//  381 
//  382   // Fill in the new profile list
//  383   pNewItem = osal_mem_alloc( sizeof( zclLibPlugin_t ) );
        ; Setup parameters for call to function osal_mem_alloc
        MOV     R2,#0x8
        MOV     R3,#0x0
        LCALL   ??osal_mem_alloc?relay
        MOV     ?V0 + 8,R2
        MOV     ?V0 + 9,R3
        MOV     R6,?V0 + 8
        MOV     R7,?V0 + 9
//  384   if ( pNewItem == NULL )
        MOV     A,R6
        ORL     A,R7
        JNZ     ??zcl_registerPlugin_0
//  385   {
//  386     return (ZMemError);
        MOV     R1,#0x10
        LJMP    ??zcl_registerPlugin_1 & 0xFFFF
//  387   }
//  388 
//  389   // Fill in the plugin record.
//  390   pNewItem->next = (zclLibPlugin_t *)NULL;
??zcl_registerPlugin_0:
        MOV     DPL,R6
        MOV     DPH,R7
        MOV     A,#0x0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
//  391   pNewItem->startClusterID = startClusterID;
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        INC     DPTR
        MOV     A,?V0 + 0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,?V0 + 1
        MOVX    @DPTR,A
//  392   pNewItem->endClusterID = endClusterID;
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOV     A,?V0 + 6
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,?V0 + 7
        MOVX    @DPTR,A
//  393   pNewItem->pfnIncomingHdlr = pfnIncomingHdlr;
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOV     A,?V0 + 2
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,?V0 + 3
        MOVX    @DPTR,A
//  394 
//  395   // Find spot in list
//  396   if (  plugins == NULL )
        MOV     DPTR,#plugins
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JNZ     ??zcl_registerPlugin_2
//  397   {
//  398     plugins = pNewItem;
        MOV     DPTR,#plugins
        MOV     A,R6
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R7
        MOVX    @DPTR,A
        SJMP    ??zcl_registerPlugin_3
//  399   }
//  400   else
//  401   {
//  402     // Look for end of list
//  403     pLoop = plugins;
??zcl_registerPlugin_2:
        MOV     DPTR,#plugins
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     ?V0 + 4,R0
        MOV     ?V0 + 5,R1
//  404     while ( pLoop->next != NULL )
??zcl_registerPlugin_4:
        MOV     DPL,?V0 + 4
        MOV     DPH,?V0 + 5
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JZ      ??zcl_registerPlugin_5
//  405     {
//  406       pLoop = pLoop->next;
        MOV     DPL,?V0 + 4
        MOV     DPH,?V0 + 5
        MOVX    A,@DPTR
        MOV     ?V0 + 4,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     ?V0 + 5,A
        SJMP    ??zcl_registerPlugin_4
//  407     }
//  408 
//  409     // Put new item at end of list
//  410     pLoop->next = pNewItem;
??zcl_registerPlugin_5:
        MOV     DPL,?V0 + 4
        MOV     DPH,?V0 + 5
        MOV     A,R6
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R7
        MOVX    @DPTR,A
//  411   }
//  412 
//  413   return ( ZSuccess );
??zcl_registerPlugin_3:
        MOV     R1,#0x0
??zcl_registerPlugin_1:
        MOV     R7,#0xa
        LJMP    ?BANKED_LEAVE_XDATA
          CFI EndBlock cfiBlock3
//  414 }
//  415 
//  416 /*********************************************************************
//  417  * @fn          zcl_registerAttrList
//  418  *
//  419  * @brief       Register an Attribute List with ZCL Foundation
//  420  *
//  421  * @param       endpoint - endpoint the attribute list belongs to
//  422  * @param       numAttr - number of attributes in list
//  423  * @param       newAttrList - array of Attribute records.
//  424  *                            NOTE: THE ATTRIBUTE IDs (FOR A CLUSTER) MUST BE IN
//  425  *                            ASCENDING ORDER. OTHERWISE, THE DISCOVERY RESPONSE
//  426  *                            COMMAND WILL NOT HAVE THE RIGHT ATTRIBUTE INFO
//  427  *
//  428  * @return      ZSuccess if OK
//  429  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  430 ZStatus_t zcl_registerAttrList( uint8 endpoint, uint8 numAttr, CONST zclAttrRec_t newAttrList[] )
zcl_registerAttrList:
          CFI Block cfiBlock4 Using cfiCommon0
          CFI Function zcl_registerAttrList
        CODE
//  431 {
        FUNCALL zcl_registerAttrList, osal_mem_alloc
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 16, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 16, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0x10
        LCALL   ?BANKED_ENTER_XDATA
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V7 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI V6 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V5 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI V4 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-13)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-14)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-15)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-16)))
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 16)
        ; Saved register size: 16
        ; Auto size: 0
        MOV     ?V0 + 4,R1
        MOV     ?V0 + 5,R2
        MOV     ?V0 + 0,R4
        MOV     ?V0 + 1,R5
//  432   zclAttrRecsList *pNewItem;
//  433   zclAttrRecsList *pLoop;
//  434 
//  435   // Fill in the new profile list
//  436   pNewItem = osal_mem_alloc( sizeof( zclAttrRecsList ) );
        ; Setup parameters for call to function osal_mem_alloc
        MOV     R2,#0xa
        MOV     R3,#0x0
        LCALL   ??osal_mem_alloc?relay
        MOV     ?V0 + 6,R2
        MOV     ?V0 + 7,R3
        MOV     R6,?V0 + 6
        MOV     R7,?V0 + 7
//  437   if ( pNewItem == NULL )
        MOV     A,R6
        ORL     A,R7
        JNZ     ??zcl_registerAttrList_0
//  438   {
//  439     return (ZMemError);
        MOV     R1,#0x10
        LJMP    ??zcl_registerAttrList_1 & 0xFFFF
//  440   }
//  441 
//  442   pNewItem->next = (zclAttrRecsList *)NULL;
??zcl_registerAttrList_0:
        MOV     DPL,R6
        MOV     DPH,R7
        MOV     A,#0x0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
//  443   pNewItem->endpoint = endpoint;
        MOV     A,?V0 + 4
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        INC     DPTR
        MOV     A,?V0 + 4
        MOVX    @DPTR,A
//  444   pNewItem->pfnReadWriteCB = NULL;
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
//  445   pNewItem->numAttributes = numAttr;
        MOV     A,?V0 + 5
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOV     A,?V0 + 5
        MOVX    @DPTR,A
//  446   pNewItem->attrs = newAttrList;
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOV     A,?V0 + 0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,?V0 + 1
        MOVX    @DPTR,A
//  447 
//  448   // Find spot in list
//  449   if ( attrList == NULL )
        MOV     DPTR,#attrList
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JNZ     ??zcl_registerAttrList_2
//  450   {
//  451     attrList = pNewItem;
        MOV     DPTR,#attrList
        MOV     A,R6
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R7
        MOVX    @DPTR,A
        SJMP    ??zcl_registerAttrList_3
//  452   }
//  453   else
//  454   {
//  455     // Look for end of list
//  456     pLoop = attrList;
??zcl_registerAttrList_2:
        MOV     DPTR,#attrList
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     ?V0 + 2,R0
        MOV     ?V0 + 3,R1
//  457     while ( pLoop->next != NULL )
??zcl_registerAttrList_4:
        MOV     DPL,?V0 + 2
        MOV     DPH,?V0 + 3
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JZ      ??zcl_registerAttrList_5
//  458     {
//  459       pLoop = pLoop->next;
        MOV     DPL,?V0 + 2
        MOV     DPH,?V0 + 3
        MOVX    A,@DPTR
        MOV     ?V0 + 2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     ?V0 + 3,A
        SJMP    ??zcl_registerAttrList_4
//  460     }
//  461 
//  462     // Put new item at end of list
//  463     pLoop->next = pNewItem;
??zcl_registerAttrList_5:
        MOV     A,R6
        MOV     R0,A
        MOV     A,R7
        MOV     R1,A
        MOV     DPL,?V0 + 2
        MOV     DPH,?V0 + 3
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
//  464   }
//  465 
//  466   return ( ZSuccess );
??zcl_registerAttrList_3:
        MOV     R1,#0x0
??zcl_registerAttrList_1:
        MOV     R7,#0x8
        LJMP    ?BANKED_LEAVE_XDATA
          CFI EndBlock cfiBlock4
//  467 }
//  468 
//  469 /*********************************************************************
//  470  * @fn          zcl_registerClusterOptionList
//  471  *
//  472  * @brief       Register a Cluster Option List with ZCL Foundation
//  473  *
//  474  * @param       endpoint - endpoint the option list belongs to
//  475  * @param       numOption - number of options in list
//  476  * @param       optionList - array of cluster option records.
//  477  *
//  478  *              NOTE: This API should be called to enable 'Application
//  479  *                    Link Key' security and/or 'APS ACK' for a specific
//  480  *                    Cluster. The 'Application Link Key' is discarded
//  481  *                    if security isn't enabled on the device.
//  482  *                    The default behavior is 'Network Key' when security
//  483  *                    is enabled and no 'APS ACK' for the ZCL messages.
//  484  *
//  485  * @return      ZSuccess if OK
//  486  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  487 ZStatus_t zcl_registerClusterOptionList( uint8 endpoint, uint8 numOption, zclOptionRec_t optionList[] )
zcl_registerClusterOptionList:
          CFI Block cfiBlock5 Using cfiCommon0
          CFI Function zcl_registerClusterOptionList
        CODE
//  488 {
        FUNCALL zcl_registerClusterOptionList, osal_mem_alloc
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 16, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 16, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0x10
        LCALL   ?BANKED_ENTER_XDATA
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V7 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI V6 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V5 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI V4 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-13)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-14)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-15)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-16)))
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 16)
        ; Saved register size: 16
        ; Auto size: 0
        MOV     ?V0 + 4,R1
        MOV     ?V0 + 5,R2
        MOV     ?V0 + 0,R4
        MOV     ?V0 + 1,R5
//  489   zclClusterOptionList *pNewItem;
//  490   zclClusterOptionList *pLoop;
//  491 
//  492   // Fill in the new profile list
//  493   pNewItem = osal_mem_alloc( sizeof( zclClusterOptionList ) );
        ; Setup parameters for call to function osal_mem_alloc
        MOV     R2,#0x6
        MOV     R3,#0x0
        LCALL   ??osal_mem_alloc?relay
        MOV     ?V0 + 6,R2
        MOV     ?V0 + 7,R3
        MOV     R6,?V0 + 6
        MOV     R7,?V0 + 7
//  494   if ( pNewItem == NULL )
        MOV     A,R6
        ORL     A,R7
        JNZ     ??zcl_registerClusterOptionList_0
//  495   {
//  496     return (ZMemError);
        MOV     R1,#0x10
        LJMP    ??zcl_registerClusterOptionList_1 & 0xFFFF
//  497   }
//  498 
//  499   pNewItem->next = (zclClusterOptionList *)NULL;
??zcl_registerClusterOptionList_0:
        MOV     DPL,R6
        MOV     DPH,R7
        MOV     A,#0x0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
//  500   pNewItem->endpoint = endpoint;
        MOV     A,?V0 + 4
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        INC     DPTR
        MOV     A,?V0 + 4
        MOVX    @DPTR,A
//  501   pNewItem->numOptions = numOption;
        MOV     A,?V0 + 5
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOV     A,?V0 + 5
        MOVX    @DPTR,A
//  502   pNewItem->options = optionList;
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOV     A,?V0 + 0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,?V0 + 1
        MOVX    @DPTR,A
//  503 
//  504   // Find spot in list
//  505   if ( clusterOptionList == NULL )
        MOV     DPTR,#clusterOptionList
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JNZ     ??zcl_registerClusterOptionList_2
//  506   {
//  507     clusterOptionList = pNewItem;
        MOV     DPTR,#clusterOptionList
        MOV     A,R6
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R7
        MOVX    @DPTR,A
        SJMP    ??zcl_registerClusterOptionList_3
//  508   }
//  509   else
//  510   {
//  511     // Look for end of list
//  512     pLoop = clusterOptionList;
??zcl_registerClusterOptionList_2:
        MOV     DPTR,#clusterOptionList
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     ?V0 + 2,R0
        MOV     ?V0 + 3,R1
//  513     while ( pLoop->next != NULL )
??zcl_registerClusterOptionList_4:
        MOV     DPL,?V0 + 2
        MOV     DPH,?V0 + 3
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JZ      ??zcl_registerClusterOptionList_5
//  514     {
//  515       pLoop = pLoop->next;
        MOV     DPL,?V0 + 2
        MOV     DPH,?V0 + 3
        MOVX    A,@DPTR
        MOV     ?V0 + 2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     ?V0 + 3,A
        SJMP    ??zcl_registerClusterOptionList_4
//  516     }
//  517 
//  518     // Put new item at end of list
//  519     pLoop->next = pNewItem;
??zcl_registerClusterOptionList_5:
        MOV     A,R6
        MOV     R0,A
        MOV     A,R7
        MOV     R1,A
        MOV     DPL,?V0 + 2
        MOV     DPH,?V0 + 3
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
//  520   }
//  521 
//  522   return ( ZSuccess );
??zcl_registerClusterOptionList_3:
        MOV     R1,#0x0
??zcl_registerClusterOptionList_1:
        MOV     R7,#0x8
        LJMP    ?BANKED_LEAVE_XDATA
          CFI EndBlock cfiBlock5
//  523 }
//  524 
//  525 /*********************************************************************
//  526  * @fn          zcl_registerValidateAttrData
//  527  *
//  528  * @brief       Add a validation function for attribute data
//  529  *
//  530  * @param       pfnValidateAttrData - function pointer to validate routine
//  531  *
//  532  * @return      ZSuccess if OK
//  533  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  534 ZStatus_t zcl_registerValidateAttrData( zclValidateAttrData_t pfnValidateAttrData )
zcl_registerValidateAttrData:
          CFI Block cfiBlock6 Using cfiCommon0
          CFI Function zcl_registerValidateAttrData
        CODE
//  535 {
        PUSH    DPL
          CFI DPL0 Frame(CFA_SP, 4)
          CFI CFA_SP SP+-4
        PUSH    DPH
          CFI DPH0 Frame(CFA_SP, 5)
          CFI CFA_SP SP+-5
        ; Saved register size: 2
        ; Auto size: 0
//  536   zcl_ValidateAttrDataCB = pfnValidateAttrData;
        MOV     DPTR,#zcl_ValidateAttrDataCB
        MOV     A,R2
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R3
        MOVX    @DPTR,A
//  537 
//  538   return ( ZSuccess );
        MOV     R1,#0x0
        POP     DPH
          CFI DPH0 SameValue
          CFI CFA_SP SP+-4
        POP     DPL
          CFI DPL0 SameValue
          CFI CFA_SP SP+-3
        LJMP    ?BRET
          CFI EndBlock cfiBlock6
//  539 }
//  540 
//  541 /*********************************************************************
//  542  * @fn          zcl_registerReadWriteCB
//  543  *
//  544  * @brief       Register the application's callback function to read/write
//  545  *              attribute data, and authorize read/write operation.
//  546  *
//  547  *              Note: The pfnReadWriteCB callback function is only required
//  548  *                    when the attribute data format is unknown to ZCL. The
//  549  *                    callback function gets called when the pointer 'dataPtr'
//  550  *                    to the attribute value is NULL in the attribute database
//  551  *                    registered with the ZCL.
//  552  *
//  553  *              Note: The pfnAuthorizeCB callback function is only required
//  554  *                    when the Read/Write operation on an attribute requires
//  555  *                    authorization (i.e., attributes with ACCESS_CONTROL_AUTH_READ
//  556  *                    or ACCESS_CONTROL_AUTH_WRITE access permissions).
//  557  *
//  558  * @param       endpoint - application's endpoint
//  559  * @param       pfnReadWriteCB - function pointer to read/write routine
//  560  * @param       pfnAuthorizeCB - function pointer to authorize read/write operation
//  561  *
//  562  * @return      ZSuccess if successful. ZFailure, otherwise.
//  563  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  564 ZStatus_t zcl_registerReadWriteCB( uint8 endpoint, zclReadWriteCB_t pfnReadWriteCB,
zcl_registerReadWriteCB:
          CFI Block cfiBlock7 Using cfiCommon0
          CFI Function zcl_registerReadWriteCB
        CODE
//  565                                    zclAuthorizeCB_t pfnAuthorizeCB )
//  566 {
        FUNCALL zcl_registerReadWriteCB, zclFindAttrRecsList
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 14, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 14, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0xe
        LCALL   ?BANKED_ENTER_XDATA
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V5 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI V4 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-13)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-14)))
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 14)
        ; Saved register size: 14
        ; Auto size: 0
        MOV     ?V0 + 2,R1
        MOV     ?V0 + 0,R2
        MOV     ?V0 + 1,R3
        MOV     A,R4
        MOV     R6,A
        MOV     A,R5
        MOV     R7,A
//  567   zclAttrRecsList *pRec = zclFindAttrRecsList( endpoint );
        ; Setup parameters for call to function zclFindAttrRecsList
        MOV     R1,?V0 + 2
        LCALL   ??zclFindAttrRecsList?relay
        MOV     ?V0 + 4,R2
        MOV     ?V0 + 5,R3
        MOV     R2,?V0 + 4
        MOV     R3,?V0 + 5
//  568 
//  569   if ( pRec != NULL )
        MOV     A,R2
        ORL     A,R3
        JZ      ??zcl_registerReadWriteCB_0
//  570   {
//  571     pRec->pfnReadWriteCB = pfnReadWriteCB;
        MOV     DPL,R2
        MOV     DPH,R3
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOV     A,?V0 + 0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,?V0 + 1
        MOVX    @DPTR,A
//  572     pRec->pfnAuthorizeCB = pfnAuthorizeCB;
        MOV     DPL,R2
        MOV     DPH,R3
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOV     A,R6
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R7
        MOVX    @DPTR,A
//  573 
//  574     return ( ZSuccess );
        MOV     R1,#0x0
        SJMP    ??zcl_registerReadWriteCB_1
//  575   }
//  576 
//  577   return ( ZFailure );
??zcl_registerReadWriteCB_0:
        MOV     R1,#0x1
??zcl_registerReadWriteCB_1:
        MOV     R7,#0x6
        LJMP    ?BANKED_LEAVE_XDATA
          CFI EndBlock cfiBlock7
//  578 }
//  579 
//  580 /*********************************************************************
//  581  * @fn      zcl_registerForMsg
//  582  *
//  583  * @brief   The ZCL is setup to send all incoming Foundation Command/Response
//  584  *          messages that aren't processed to one task (if a task is
//  585  *          registered).
//  586  *
//  587  * @param   taskId - task Id of the Application where commands will be sent to
//  588  *
//  589  * @return  TRUE if task registeration successful, FALSE otherwise
//  590  *********************************************************************/

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  591 uint8 zcl_registerForMsg( uint8 taskId )
zcl_registerForMsg:
          CFI Block cfiBlock8 Using cfiCommon0
          CFI Function zcl_registerForMsg
        CODE
//  592 {
        PUSH    DPL
          CFI DPL0 Frame(CFA_SP, 4)
          CFI CFA_SP SP+-4
        PUSH    DPH
          CFI DPH0 Frame(CFA_SP, 5)
          CFI CFA_SP SP+-5
        ; Saved register size: 2
        ; Auto size: 0
        MOV     A,R1
        MOV     R0,A
//  593   // Allow only the first task
//  594   if ( zcl_RegisteredMsgTaskID == TASK_NO_TASK )
        MOV     DPTR,#zcl_RegisteredMsgTaskID
        MOVX    A,@DPTR
        XRL     A,#0xff
        JNZ     ??zcl_registerForMsg_0
//  595   {
//  596     zcl_RegisteredMsgTaskID = taskId;
        MOV     A,R0
        MOV     DPTR,#zcl_RegisteredMsgTaskID
        MOVX    @DPTR,A
//  597 
//  598     return ( true );
        MOV     R1,#0x1
        SJMP    ??zcl_registerForMsg_1
//  599   }
//  600 
//  601   return ( false );
??zcl_registerForMsg_0:
        MOV     R1,#0x0
??zcl_registerForMsg_1:
        POP     DPH
          CFI DPH0 SameValue
          CFI CFA_SP SP+-4
        POP     DPL
          CFI DPL0 SameValue
          CFI CFA_SP SP+-3
        LJMP    ?BRET
          CFI EndBlock cfiBlock8
//  602 }
//  603 
//  604 /*********************************************************************
//  605  * @fn      zcl_DeviceOperational
//  606  *
//  607  * @brief   Used to see whether or not the device can send or respond
//  608  *          to application level commands.
//  609  *
//  610  * @param   srcEP - source endpoint
//  611  * @param   clusterID - cluster ID
//  612  * @param   frameType - command type
//  613  * @param   cmd - command ID
//  614  *
//  615  * @return  TRUE if device is operational, FALSE otherwise
//  616  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  617 static uint8 zcl_DeviceOperational( uint8 srcEP, uint16 clusterID,
zcl_DeviceOperational:
          CFI Block cfiBlock9 Using cfiCommon0
          CFI Function zcl_DeviceOperational
        CODE
//  618                                     uint8 frameType, uint8 cmd, uint16 profileID )
//  619 {
        FUNCALL zcl_DeviceOperational, zclFindAttrRec
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 27, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 27, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL zcl_DeviceOperational, zclReadAttrData
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 27, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 27, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0x10
        LCALL   ?BANKED_ENTER_XDATA
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V7 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI V6 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V5 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI V4 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-13)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-14)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-15)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-16)))
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 16)
        ; Saved register size: 16
        ; Auto size: 9
        MOV     A,#-0x9
        LCALL   ?ALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 25)
        MOV     ?V0 + 4,R1
        MOV     A,R2
        MOV     R6,A
        MOV     A,R3
        MOV     R7,A
        MOV     ?V0 + 2,R4
        MOV     ?V0 + 3,R5
        MOV     A,#0x19
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     ?V0 + 0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     ?V0 + 1,A
//  620   zclAttrRec_t attrRec;
//  621   uint8 deviceEnabled = DEVICE_ENABLED; // default value
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     A,#0x1
        MOVX    @DPTR,A
//  622 
//  623   (void)profileID;  // Intentionally unreferenced parameter
//  624 
//  625   // If the device is Disabled (DeviceEnabled attribute is set to Disabled), it
//  626   // cannot send or respond to application level commands, other than commands
//  627   // to read or write attributes. Note that the Identify cluster cannot be
//  628   // disabled, and remains functional regardless of this setting.
//  629   if ( zcl_ProfileCmd( frameType ) && cmd <= ZCL_CMD_WRITE_NO_RSP )
        MOV     A,?V0 + 2
        JNZ     ??zcl_DeviceOperational_0
        MOV     A,?V0 + 3
        CLR     C
        SUBB    A,#0x6
        JNC     ??zcl_DeviceOperational_0
//  630   {
//  631     return ( TRUE );
        MOV     R1,#0x1
        SJMP    ??zcl_DeviceOperational_1
//  632   }
//  633 
//  634   if ( clusterID == ZCL_CLUSTER_ID_GEN_IDENTIFY )
??zcl_DeviceOperational_0:
        MOV     A,#0x3
        XRL     A,R6
        JNZ     ??zcl_DeviceOperational_2
        MOV     A,#0x0
        XRL     A,R7
??zcl_DeviceOperational_2:
        JNZ     ??zcl_DeviceOperational_3
//  635   {
//  636     return ( TRUE );
        MOV     R1,#0x1
        SJMP    ??zcl_DeviceOperational_1
//  637   }
//  638 
//  639   // Is device enabled?
//  640   if ( zclFindAttrRec( srcEP, ZCL_CLUSTER_ID_GEN_BASIC,
//  641                        ATTRID_BASIC_DEVICE_ENABLED, &attrRec ) )
??zcl_DeviceOperational_3:
        ; Setup parameters for call to function zclFindAttrRec
        MOV     A,#0x1
        LCALL   ?XSTACK_DISP0_8
        MOV     ?V0 + 6,DPL
        MOV     ?V0 + 7,DPH
        MOV     R0,#?V0 + 6
        LCALL   ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 27)
        MOV     R4,#0x12
        MOV     R5,#0x0
        MOV     R2,#0x0
        MOV     R3,#0x0
        MOV     R1,?V0 + 4
        LCALL   ??zclFindAttrRec?relay
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 25)
        MOV     A,R1
        JZ      ??zcl_DeviceOperational_4
//  642   {
//  643     zclReadAttrData( &deviceEnabled, &attrRec, NULL );
        ; Setup parameters for call to function zclReadAttrData
        CLR     A
        MOV     ?V0 + 6,A
        MOV     ?V0 + 7,A
        MOV     R0,#?V0 + 6
        LCALL   ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 27)
        MOV     A,#0x3
        LCALL   ?XSTACK_DISP0_8
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     A,#0x2
        LCALL   ?XSTACK_DISP0_8
        MOV     R2,DPL
        MOV     R3,DPH
        LCALL   ??zclReadAttrData?relay
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 25)
        MOV     A,R1
//  644   }
//  645 
//  646   return ( deviceEnabled == DEVICE_ENABLED ? TRUE : FALSE );
??zcl_DeviceOperational_4:
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        XRL     A,#0x1
        JNZ     ??zcl_DeviceOperational_5
        MOV     R1,#0x1
        SJMP    ??zcl_DeviceOperational_1
??zcl_DeviceOperational_5:
        MOV     R1,#0x0
??zcl_DeviceOperational_1:
        MOV     A,#0x9
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 16)
        MOV     R7,#0x8
        LJMP    ?BANKED_LEAVE_XDATA
          CFI EndBlock cfiBlock9
//  647 }
//  648 
//  649 /*********************************************************************
//  650  * @fn      zcl_SendCommand
//  651  *
//  652  * @brief   Used to send Profile and Cluster Specific Command messages.
//  653  *
//  654  *          NOTE: The calling application is responsible for incrementing
//  655  *                the Sequence Number.
//  656  *
//  657  * @param   srcEp - source endpoint
//  658  * @param   destAddr - destination address
//  659  * @param   clusterID - cluster ID
//  660  * @param   cmd - command ID
//  661  * @param   specific - whether the command is Cluster Specific
//  662  * @param   direction - client/server direction of the command
//  663  * @param   disableDefaultRsp - disable Default Response command
//  664  * @param   manuCode - manufacturer code for proprietary extensions to a profile
//  665  * @param   seqNumber - identification number for the transaction
//  666  * @param   cmdFormatLen - length of the command to be sent
//  667  * @param   cmdFormat - command to be sent
//  668  *
//  669  * @return  ZSuccess if OK
//  670  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  671 ZStatus_t zcl_SendCommand( uint8 srcEP, afAddrType_t *destAddr,
zcl_SendCommand:
          CFI Block cfiBlock10 Using cfiCommon0
          CFI Function zcl_SendCommand
        CODE
//  672                            uint16 clusterID, uint8 cmd, uint8 specific, uint8 direction,
//  673                            uint8 disableDefaultRsp, uint16 manuCode, uint8 seqNum,
//  674                            uint16 cmdFormatLen, uint8 *cmdFormat )
//  675 {
        FUNCALL zcl_SendCommand, afFindEndPointDesc
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 34, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 34, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL zcl_SendCommand, StubAPS_InterPan
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 34, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 34, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL zcl_SendCommand, zclGetClusterOption
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 34, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 34, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL zcl_SendCommand, osal_memset
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 34, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 34, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL zcl_SendCommand, zcl_DeviceOperational
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 36, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 36, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL zcl_SendCommand, zclCalcHdrSize
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 34, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 34, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL zcl_SendCommand, osal_mem_alloc
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 34, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 34, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL zcl_SendCommand, zclBuildHdr
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 34, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 34, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL zcl_SendCommand, osal_memcpy
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 37, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 37, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL zcl_SendCommand, AF_DataRequest
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 43, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 43, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL zcl_SendCommand, osal_mem_free
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 34, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 34, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0x18
        LCALL   ?BANKED_ENTER_XDATA
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V15 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI V14 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V13 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI V12 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI V11 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI V10 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI V9 load(1, XDATA, add(CFA_XSP16, literal(-13)))
          CFI V8 load(1, XDATA, add(CFA_XSP16, literal(-14)))
          CFI V7 load(1, XDATA, add(CFA_XSP16, literal(-15)))
          CFI V6 load(1, XDATA, add(CFA_XSP16, literal(-16)))
          CFI V5 load(1, XDATA, add(CFA_XSP16, literal(-17)))
          CFI V4 load(1, XDATA, add(CFA_XSP16, literal(-18)))
          CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-19)))
          CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-20)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-21)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-22)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-23)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-24)))
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 24)
        ; Saved register size: 24
        ; Auto size: 10
        MOV     A,#-0xa
        LCALL   ?ALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 34)
        MOV     A,#0x6
        LCALL   ?XSTACK_DISP0_8
        MOV     A,R2
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R3
        MOVX    @DPTR,A
        MOV     ?V0 + 7,R1
        MOV     A,R4
        MOV     R6,A
        MOV     A,R5
        MOV     R7,A
        MOV     A,#0x22
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     ?V0 + 8,A
        MOV     A,#0x24
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     ?V0 + 15,A
        MOV     A,#0x25
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     ?V0 + 14,A
        MOV     A,#0x28
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     ?V0 + 9,A
//  676   endPointDesc_t *epDesc;
//  677   zclFrameHdr_t hdr;
//  678   uint8 *msgBuf;
//  679   uint16 msgLen;
//  680   uint8 *pBuf;
//  681   uint8 options;
//  682   ZStatus_t status;
//  683 
//  684   epDesc = afFindEndPointDesc( srcEP );
        ; Setup parameters for call to function afFindEndPointDesc
        MOV     R1,?V0 + 7
        LCALL   ??afFindEndPointDesc?relay
        MOV     ?V0 + 4,R2
        MOV     ?V0 + 5,R3
        MOV     ?V0 + 10,?V0 + 4
        MOV     ?V0 + 11,?V0 + 5
//  685   if ( epDesc == NULL )
        MOV     A,?V0 + 10
        ORL     A,?V0 + 11
        JNZ     ??zcl_SendCommand_0
//  686   {
//  687     return ( ZInvalidParameter ); // EMBEDDED RETURN
        MOV     R1,#0x2
        LJMP    ??zcl_SendCommand_1 & 0xFFFF
//  688   }
//  689 
//  690 #if defined ( INTER_PAN )
//  691   if ( StubAPS_InterPan( destAddr->panId, destAddr->endPoint ) )
??zcl_SendCommand_0:
        ; Setup parameters for call to function StubAPS_InterPan
        MOV     A,#0x6
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        XCH     A,R0
        ADD     A,#0x9
        MOV     DPL,A
        MOV     A,R0
        ADDC    A,#0x0
        MOV     DPH,A
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,#0x6
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        XCH     A,R0
        ADD     A,#0xa
        MOV     DPL,A
        MOV     A,R0
        ADDC    A,#0x0
        MOV     DPH,A
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        LCALL   ??StubAPS_InterPan?relay
        MOV     A,R1
        JZ      ??zcl_SendCommand_2
//  692   {
//  693     options = AF_TX_OPTIONS_NONE;
        MOV     ?V0 + 2,#0x0
        SJMP    ??zcl_SendCommand_3
//  694   }
//  695   else
//  696 #endif
//  697   {
//  698     options = zclGetClusterOption( srcEP, clusterID );
??zcl_SendCommand_2:
        ; Setup parameters for call to function zclGetClusterOption
        MOV     A,R6
        MOV     R2,A
        MOV     A,R7
        MOV     R3,A
        MOV     R1,?V0 + 7
        LCALL   ??zclGetClusterOption?relay
        MOV     A,R1
        MOV     ?V0 + 2,A
//  699   }
//  700 
//  701   osal_memset( &hdr, 0, sizeof( zclFrameHdr_t ) );
??zcl_SendCommand_3:
        ; Setup parameters for call to function osal_memset
        MOV     R4,#0x6
        MOV     R5,#0x0
        MOV     R1,#0x0
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     R2,DPL
        MOV     R3,DPH
        LCALL   ??osal_memset?relay
//  702 
//  703   // Not Profile wide command (like READ, WRITE)
//  704   if ( specific )
        MOV     A,#0x23
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        JZ      ??zcl_SendCommand_4
//  705   {
//  706     hdr.fc.type = ZCL_FRAME_TYPE_SPECIFIC_CMD;
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        ANL     A,#0xfc
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ANL     A,#0xff
        MOV     R1,A
        MOV     A,R0
        ORL     A,#0x1
        MOV     R0,A
        MOV     A,R1
        ORL     A,#0x0
        MOV     R1,A
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
        SJMP    ??zcl_SendCommand_5
//  707   }
//  708   else
//  709   {
//  710     hdr.fc.type = ZCL_FRAME_TYPE_PROFILE_CMD;
??zcl_SendCommand_4:
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        ANL     A,#0xfc
        MOVX    @DPTR,A
        INC     DPTR
        MOVX    A,@DPTR
        ANL     A,#0xff
        MOVX    @DPTR,A
//  711   }
//  712 
//  713   if ( ( epDesc->simpleDesc == NULL ) ||
//  714        ( zcl_DeviceOperational( srcEP, clusterID, hdr.fc.type,
//  715                                 cmd, epDesc->simpleDesc->AppProfId ) == FALSE ) )
??zcl_SendCommand_5:
        MOV     DPL,?V0 + 10
        MOV     DPH,?V0 + 11
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JZ      ??zcl_SendCommand_6
        ; Setup parameters for call to function zcl_DeviceOperational
        MOV     DPL,?V0 + 10
        MOV     DPH,?V0 + 11
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        INC     DPTR
        LCALL   ?PUSH_XSTACK8_X_TWO
          CFI CFA_XSP16 add(XSP16, 36)
        MOV     R5,?V0 + 8
        MOV     A,#0x2
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ANL     A,#0x3
        MOV     R4,A
        MOV     A,R6
        MOV     R2,A
        MOV     A,R7
        MOV     R3,A
        MOV     R1,?V0 + 7
        LCALL   ??zcl_DeviceOperational?relay
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 34)
        MOV     A,R1
        JNZ     ??zcl_SendCommand_7
//  716   {
//  717     return ( ZFailure ); // EMBEDDED RETURN
??zcl_SendCommand_6:
        MOV     R1,#0x1
        LJMP    ??zcl_SendCommand_1 & 0xFFFF
//  718   }
//  719 
//  720   // Fill in the Maufacturer Code
//  721   if ( manuCode != 0 )
??zcl_SendCommand_7:
        MOV     A,#0x26
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JZ      ??zcl_SendCommand_8
//  722   {
//  723     hdr.fc.manuSpecific = 1;
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        ORL     A,#0x4
        MOVX    @DPTR,A
        INC     DPTR
        MOVX    A,@DPTR
        ORL     A,#0x0
        MOVX    @DPTR,A
//  724     hdr.manuCode = manuCode;
        MOV     A,#0x26
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,#0x2
        LCALL   ?XSTACK_DISP0_8
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
//  725   }
//  726 
//  727   // Set the Command Direction
//  728   if ( direction )
??zcl_SendCommand_8:
        MOV     A,?V0 + 15
        JZ      ??zcl_SendCommand_9
//  729   {
//  730     hdr.fc.direction = ZCL_FRAME_SERVER_CLIENT_DIR;
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        ORL     A,#0x8
        MOVX    @DPTR,A
        INC     DPTR
        MOVX    A,@DPTR
        ORL     A,#0x0
        MOVX    @DPTR,A
        SJMP    ??zcl_SendCommand_10
//  731   }
//  732   else
//  733   {
//  734     hdr.fc.direction = ZCL_FRAME_CLIENT_SERVER_DIR;
??zcl_SendCommand_9:
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        ANL     A,#0xf7
        MOVX    @DPTR,A
        INC     DPTR
        MOVX    A,@DPTR
        ANL     A,#0xff
        MOVX    @DPTR,A
//  735   }
//  736 
//  737   // Set the Disable Default Response field
//  738   if ( disableDefaultRsp )
??zcl_SendCommand_10:
        MOV     A,?V0 + 14
        JZ      ??zcl_SendCommand_11
//  739   {
//  740     hdr.fc.disableDefaultRsp = 1;
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        ORL     A,#0x10
        MOVX    @DPTR,A
        INC     DPTR
        MOVX    A,@DPTR
        ORL     A,#0x0
        MOVX    @DPTR,A
        SJMP    ??zcl_SendCommand_12
//  741   }
//  742   else
//  743   {
//  744     hdr.fc.disableDefaultRsp = 0;
??zcl_SendCommand_11:
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        ANL     A,#0xef
        MOVX    @DPTR,A
        INC     DPTR
        MOVX    A,@DPTR
        ANL     A,#0xff
        MOVX    @DPTR,A
//  745   }
//  746 
//  747   // Fill in the Transaction Sequence Number
//  748   hdr.transSeqNum = seqNum;
??zcl_SendCommand_12:
        MOV     A,?V0 + 9
        MOV     A,#0x4
        LCALL   ?XSTACK_DISP0_8
        MOV     A,?V0 + 9
        MOVX    @DPTR,A
//  749 
//  750   // Fill in the command
//  751   hdr.commandID = cmd;
        MOV     A,?V0 + 8
        MOV     A,#0x5
        LCALL   ?XSTACK_DISP0_8
        MOV     A,?V0 + 8
        MOVX    @DPTR,A
//  752 
//  753   // calculate the needed buffer size
//  754   msgLen = zclCalcHdrSize( &hdr );
        ; Setup parameters for call to function zclCalcHdrSize
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     R2,DPL
        MOV     R3,DPH
        LCALL   ??zclCalcHdrSize?relay
        MOV     A,R1
        MOV     R0,A
        MOV     R1,#0x0
        MOV     ?V0 + 0,R0
        MOV     ?V0 + 1,R1
//  755   msgLen += cmdFormatLen;
        MOV     A,#0x29
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        ADD     A,?V0 + 0
        MOV     ?V0 + 0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,?V0 + 1
        MOV     ?V0 + 1,A
//  756 
//  757   // Allocate the buffer needed
//  758   msgBuf = osal_mem_alloc( msgLen );
        ; Setup parameters for call to function osal_mem_alloc
        MOV     R2,?V0 + 0
        MOV     R3,?V0 + 1
        LCALL   ??osal_mem_alloc?relay
        MOV     ?V0 + 4,R2
        MOV     ?V0 + 5,R3
        MOV     ?V0 + 12,?V0 + 4
        MOV     ?V0 + 13,?V0 + 5
//  759   if ( msgBuf != NULL )
        MOV     A,?V0 + 12
        ORL     A,?V0 + 13
        JNZ     $+5
        LJMP    ??zcl_SendCommand_13 & 0xFFFF
//  760   {
//  761     // Fill in the ZCL Header
//  762     pBuf = zclBuildHdr( &hdr, msgBuf );
        ; Setup parameters for call to function zclBuildHdr
        MOV     R4,?V0 + 12
        MOV     R5,?V0 + 13
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     R2,DPL
        MOV     R3,DPH
        LCALL   ??zclBuildHdr?relay
        MOV     A,#0x8
        LCALL   ?XSTACK_DISP0_8
        MOV     A,R2
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R3
        MOVX    @DPTR,A
//  763 
//  764     // Fill in the command frame
//  765     osal_memcpy( pBuf, cmdFormat, cmdFormatLen );
        ; Setup parameters for call to function osal_memcpy
        MOV     A,#0x2b
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     ?V0 + 4,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     ?V0 + 5,A
        MOV     ?V0 + 6,#0x0
        MOV     R0,#?V0 + 4
        LCALL   ?PUSH_XSTACK_I_THREE
          CFI CFA_XSP16 add(XSP16, 37)
        MOV     A,#0x2c
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R4,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R5,A
        MOV     A,#0xb
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        LCALL   ??osal_memcpy?relay
        MOV     A,#0x3
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 34)
//  766 
//  767     status = AF_DataRequest( destAddr, epDesc, clusterID, msgLen, msgBuf,
//  768                              &zcl_TransID, options, AF_DEFAULT_RADIUS );
        ; Setup parameters for call to function AF_DataRequest
        MOV     ?V0 + 4,#0x1e
        MOV     R0,#?V0 + 4
        LCALL   ?PUSH_XSTACK_I_ONE
          CFI CFA_XSP16 add(XSP16, 35)
        MOV     ?V0 + 4,#zcl_TransID & 0xff
        MOV     ?V0 + 5,#(zcl_TransID >> 8) & 0xff
        MOV     R0,#?V0 + 4
        LCALL   ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 37)
        MOV     R0,#?V0 + 12
        LCALL   ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 39)
        MOV     R0,#?V0 + 0
        LCALL   ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 41)
        MOV     ?V0 + 4,R6
        MOV     ?V0 + 5,R7
        MOV     R0,#?V0 + 4
        LCALL   ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 43)
        MOV     R1,?V0 + 2
        MOV     R4,?V0 + 10
        MOV     R5,?V0 + 11
        MOV     A,#0xf
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        LCALL   ??AF_DataRequest?relay
        MOV     A,#0x9
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 34)
        MOV     A,R1
        MOV     ?V0 + 3,A
//  769     osal_mem_free ( msgBuf );
        ; Setup parameters for call to function osal_mem_free
        MOV     R2,?V0 + 12
        MOV     R3,?V0 + 13
        LCALL   ??osal_mem_free?relay
        SJMP    ??zcl_SendCommand_14
//  770   }
//  771   else
//  772   {
//  773     status = ZMemError;
??zcl_SendCommand_13:
        MOV     ?V0 + 3,#0x10
//  774   }
//  775 
//  776   return ( status );
??zcl_SendCommand_14:
        MOV     R1,?V0 + 3
??zcl_SendCommand_1:
        MOV     A,#0xa
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 24)
        MOV     R7,#0x10
        LJMP    ?BANKED_LEAVE_XDATA
          CFI EndBlock cfiBlock10
//  777 }
//  778 
//  779 #ifdef ZCL_READ
//  780 /*********************************************************************
//  781  * @fn      zcl_SendRead
//  782  *
//  783  * @brief   Send a Read command
//  784  *
//  785  * @param   srcEP - Application's endpoint
//  786  * @param   dstAddr - destination address
//  787  * @param   clusterID - cluster ID
//  788  * @param   readCmd - read command to be sent
//  789  * @param   direction - direction of the command
//  790  * @param   seqNum - transaction sequence number
//  791  *
//  792  * @return  ZSuccess if OK
//  793  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  794 ZStatus_t zcl_SendRead( uint8 srcEP, afAddrType_t *dstAddr,
zcl_SendRead:
          CFI Block cfiBlock11 Using cfiCommon0
          CFI Function zcl_SendRead
        CODE
//  795                         uint16 clusterID, zclReadCmd_t *readCmd,
//  796                         uint8 direction, uint8 disableDefaultRsp, uint8 seqNum)
//  797 {
        FUNCALL zcl_SendRead, osal_mem_alloc
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 26, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 26, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL zcl_SendRead, zcl_SendCommand
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 37, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 37, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL zcl_SendRead, osal_mem_free
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 26, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 26, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0x18
        LCALL   ?BANKED_ENTER_XDATA
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V15 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI V14 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V13 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI V12 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI V11 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI V10 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI V9 load(1, XDATA, add(CFA_XSP16, literal(-13)))
          CFI V8 load(1, XDATA, add(CFA_XSP16, literal(-14)))
          CFI V7 load(1, XDATA, add(CFA_XSP16, literal(-15)))
          CFI V6 load(1, XDATA, add(CFA_XSP16, literal(-16)))
          CFI V5 load(1, XDATA, add(CFA_XSP16, literal(-17)))
          CFI V4 load(1, XDATA, add(CFA_XSP16, literal(-18)))
          CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-19)))
          CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-20)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-21)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-22)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-23)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-24)))
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 24)
        ; Saved register size: 24
        ; Auto size: 2
        MOV     A,#-0x2
        LCALL   ?ALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 26)
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     A,R2
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R3
        MOVX    @DPTR,A
        MOV     ?V0 + 8,R1
        MOV     ?V0 + 14,R4
        MOV     ?V0 + 15,R5
        MOV     A,#0x1a
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     ?V0 + 6,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     ?V0 + 7,A
        MOV     A,#0x1c
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     ?V0 + 13,A
        MOV     A,#0x1d
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     ?V0 + 12,A
        MOV     A,#0x1e
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     ?V0 + 9,A
//  798   uint16 dataLen;
//  799   uint8 *buf;
//  800   uint8 *pBuf;
//  801   ZStatus_t status;
//  802 
//  803   dataLen = readCmd->numAttr * 2; // Attribute ID
        MOV     DPL,?V0 + 6
        MOV     DPH,?V0 + 7
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     R1,#0x0
        MOV     A,R0
        MOV     B,#0x2
        MUL     AB
        XCH     A,R0
        MOV     R2,B
        MOV     B,#0x0
        MUL     AB
        ADD     A,R2
        MOV     R2,A
        MOV     B,#0x2
        MOV     A,R1
        MUL     AB
        ADD     A,R2
        MOV     R1,A
        MOV     A,R0
        MOV     R6,A
        MOV     A,R1
        MOV     R7,A
//  804 
//  805   buf = osal_mem_alloc( dataLen );
        ; Setup parameters for call to function osal_mem_alloc
        MOV     A,R6
        MOV     R2,A
        MOV     A,R7
        MOV     R3,A
        LCALL   ??osal_mem_alloc?relay
        MOV     ?V0 + 10,R2
        MOV     ?V0 + 11,R3
        MOV     ?V0 + 4,?V0 + 10
        MOV     ?V0 + 5,?V0 + 11
//  806   if ( buf != NULL )
        MOV     A,?V0 + 4
        ORL     A,?V0 + 5
        JNZ     $+5
        LJMP    ??zcl_SendRead_0 & 0xFFFF
//  807   {
//  808     uint8 i;
//  809 
//  810     // Load the buffer - serially
//  811     pBuf = buf;
        MOV     ?V0 + 0,?V0 + 4
        MOV     ?V0 + 1,?V0 + 5
//  812     for (i = 0; i < readCmd->numAttr; i++)
        MOV     ?V0 + 3,#0x0
??zcl_SendRead_1:
        MOV     DPL,?V0 + 6
        MOV     DPH,?V0 + 7
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     A,?V0 + 3
        CLR     C
        SUBB    A,R0
        JC      $+5
        LJMP    ??zcl_SendRead_2 & 0xFFFF
//  813     {
//  814       *pBuf++ = LO_UINT16( readCmd->attrID[i] );
        MOV     A,?V0 + 3
        MOV     R0,?V0 + 3
        MOV     R1,#0x0
        MOV     A,R0
        MOV     B,#0x2
        MUL     AB
        XCH     A,R0
        MOV     R2,B
        MOV     B,#0x0
        MUL     AB
        ADD     A,R2
        MOV     R2,A
        MOV     B,#0x2
        MOV     A,R1
        MUL     AB
        ADD     A,R2
        MOV     R1,A
        MOV     A,?V0 + 6
        ADD     A,R0
        MOV     DPL,A
        MOV     A,?V0 + 7
        ADDC    A,R1
        MOV     DPH,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        MOVX    @DPTR,A
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        INC     DPTR
        MOV     ?V0 + 0,DPL
        MOV     ?V0 + 1,DPH
//  815       *pBuf++ = HI_UINT16( readCmd->attrID[i] );
        MOV     A,?V0 + 3
        MOV     R0,?V0 + 3
        MOV     R1,#0x0
        MOV     A,R0
        MOV     B,#0x2
        MUL     AB
        XCH     A,R0
        MOV     R2,B
        MOV     B,#0x0
        MUL     AB
        ADD     A,R2
        MOV     R2,A
        MOV     B,#0x2
        MOV     A,R1
        MUL     AB
        ADD     A,R2
        MOV     R1,A
        MOV     A,?V0 + 6
        ADD     A,R0
        MOV     DPL,A
        MOV     A,?V0 + 7
        ADDC    A,R1
        MOV     DPH,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        CLR     A
        MOV     A,R1
        MOV     R0,A
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        MOVX    @DPTR,A
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        INC     DPTR
        MOV     ?V0 + 0,DPL
        MOV     ?V0 + 1,DPH
//  816     }
        INC     ?V0 + 3
        LJMP    ??zcl_SendRead_1 & 0xFFFF
//  817 
//  818     status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_READ, FALSE,
//  819                               direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
??zcl_SendRead_2:
        ; Setup parameters for call to function zcl_SendCommand
        MOV     R0,#?V0 + 4
        LCALL   ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 28)
        MOV     ?V0 + 10,R6
        MOV     ?V0 + 11,R7
        MOV     R0,#?V0 + 10
        LCALL   ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 30)
        MOV     A,?V0 + 9
        MOV     ?V0 + 10,A
        MOV     R0,#?V0 + 10
        LCALL   ?PUSH_XSTACK_I_ONE
          CFI CFA_XSP16 add(XSP16, 31)
        CLR     A
        MOV     ?V0 + 10,A
        MOV     ?V0 + 11,A
        MOV     R0,#?V0 + 10
        LCALL   ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 33)
        MOV     A,?V0 + 12
        MOV     ?V0 + 10,A
        MOV     R0,#?V0 + 10
        LCALL   ?PUSH_XSTACK_I_ONE
          CFI CFA_XSP16 add(XSP16, 34)
        MOV     A,?V0 + 13
        MOV     ?V0 + 10,A
        MOV     R0,#?V0 + 10
        LCALL   ?PUSH_XSTACK_I_ONE
          CFI CFA_XSP16 add(XSP16, 35)
        MOV     ?V0 + 10,#0x0
        MOV     R0,#?V0 + 10
        LCALL   ?PUSH_XSTACK_I_ONE
          CFI CFA_XSP16 add(XSP16, 36)
        MOV     ?V0 + 10,#0x0
        MOV     R0,#?V0 + 10
        LCALL   ?PUSH_XSTACK_I_ONE
          CFI CFA_XSP16 add(XSP16, 37)
        MOV     R4,?V0 + 14
        MOV     R5,?V0 + 15
        MOV     A,#0xb
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        MOV     R1,?V0 + 8
        LCALL   ??zcl_SendCommand?relay
        MOV     A,#0xb
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 26)
        MOV     A,R1
        MOV     ?V0 + 2,A
//  820     osal_mem_free( buf );
        ; Setup parameters for call to function osal_mem_free
        MOV     R2,?V0 + 4
        MOV     R3,?V0 + 5
        LCALL   ??osal_mem_free?relay
        SJMP    ??zcl_SendRead_3
//  821   }
//  822   else
//  823   {
//  824     status = ZMemError;
??zcl_SendRead_0:
        MOV     ?V0 + 2,#0x10
//  825   }
//  826 
//  827   return ( status );
??zcl_SendRead_3:
        MOV     R1,?V0 + 2
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 24)
        MOV     R7,#0x10
        LJMP    ?BANKED_LEAVE_XDATA
          CFI EndBlock cfiBlock11
//  828 }
//  829 
//  830 /*********************************************************************
//  831  * @fn      zcl_SendReadRsp
//  832  *
//  833  * @brief   Send a Read Response command.
//  834  *
//  835  * @param   srcEP - Application's endpoint
//  836  * @param   dstAddr - destination address
//  837  * @param   clusterID - cluster ID
//  838  * @param   readRspCmd - read response command to be sent
//  839  * @param   direction - direction of the command
//  840  * @param   seqNum - transaction sequence number
//  841  *
//  842  * @return  ZSuccess if OK
//  843  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  844 ZStatus_t zcl_SendReadRsp( uint8 srcEP, afAddrType_t *dstAddr,
zcl_SendReadRsp:
          CFI Block cfiBlock12 Using cfiCommon0
          CFI Function zcl_SendReadRsp
        CODE
//  845                            uint16 clusterID, zclReadRspCmd_t *readRspCmd,
//  846                            uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
//  847 {
        FUNCALL zcl_SendReadRsp, zclGetAttrDataLength
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 28, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 28, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL zcl_SendReadRsp, zclGetAttrDataLengthUsingCB
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 28, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 28, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL zcl_SendReadRsp, osal_mem_alloc
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 28, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 28, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL zcl_SendReadRsp, zclSerializeData
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 28, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 28, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL zcl_SendReadRsp, zclReadAttrDataUsingCB
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 32, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 32, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL zcl_SendReadRsp, zcl_SendCommand
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 39, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 39, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL zcl_SendReadRsp, osal_mem_free
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 28, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 28, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0x18
        LCALL   ?BANKED_ENTER_XDATA
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V15 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI V14 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V13 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI V12 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI V11 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI V10 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI V9 load(1, XDATA, add(CFA_XSP16, literal(-13)))
          CFI V8 load(1, XDATA, add(CFA_XSP16, literal(-14)))
          CFI V7 load(1, XDATA, add(CFA_XSP16, literal(-15)))
          CFI V6 load(1, XDATA, add(CFA_XSP16, literal(-16)))
          CFI V5 load(1, XDATA, add(CFA_XSP16, literal(-17)))
          CFI V4 load(1, XDATA, add(CFA_XSP16, literal(-18)))
          CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-19)))
          CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-20)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-21)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-22)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-23)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-24)))
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 24)
        ; Saved register size: 24
        ; Auto size: 4
        MOV     A,#-0x4
        LCALL   ?ALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 28)
        MOV     A,#0x2
        LCALL   ?XSTACK_DISP0_8
        MOV     A,R2
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R3
        MOVX    @DPTR,A
        MOV     ?V0 + 6,R1
        MOV     ?V0 + 14,R4
        MOV     ?V0 + 15,R5
        MOV     A,#0x1c
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     ?V0 + 12,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     ?V0 + 13,A
        MOV     A,#0x20
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     ?V0 + 7,A
//  848   uint8 *buf;
//  849   uint16 len = 0;
        MOV     R6,#0x0
        MOV     R7,#0x0
//  850   ZStatus_t status;
//  851 
//  852   // calculate the size of the command
//  853   for ( uint8 i = 0; i < readRspCmd->numAttr; i++ )
        MOV     ?V0 + 2,#0x0
??zcl_SendReadRsp_0:
        MOV     DPL,?V0 + 12
        MOV     DPH,?V0 + 13
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     A,?V0 + 2
        CLR     C
        SUBB    A,R0
        JC      $+5
        LJMP    ??zcl_SendReadRsp_1 & 0xFFFF
//  854   {
//  855     zclReadRspStatus_t *statusRec = &(readRspCmd->attrList[i]);
        MOV     A,?V0 + 2
        MOV     R0,?V0 + 2
        MOV     R1,#0x0
        MOV     A,R0
        MOV     B,#0x6
        MUL     AB
        XCH     A,R0
        MOV     R2,B
        MOV     B,#0x0
        MUL     AB
        ADD     A,R2
        MOV     R2,A
        MOV     B,#0x6
        MOV     A,R1
        MUL     AB
        ADD     A,R2
        MOV     R1,A
        MOV     A,?V0 + 12
        ADD     A,R0
        MOV     DPL,A
        MOV     A,?V0 + 13
        ADDC    A,R1
        MOV     DPH,A
        INC     DPTR
        MOV     ?V0 + 0,DPL
        MOV     ?V0 + 1,DPH
//  856 
//  857     len += 2 + 1; // Attribute ID + Status
        MOV     A,R6
        ADD     A,#0x3
        MOV     R6,A
        MOV     A,R7
        ADDC    A,#0x0
        MOV     R7,A
//  858 
//  859     if ( statusRec->status == ZCL_STATUS_SUCCESS )
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        JNZ     ??zcl_SendReadRsp_2
//  860     {
//  861       len++; // Attribute Data Type length
        MOV     A,R6
        ADD     A,#0x1
        MOV     R6,A
        MOV     A,R7
        ADDC    A,#0x0
        MOV     R7,A
//  862 
//  863       // Attribute Data length
//  864       if ( statusRec->data != NULL )
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JZ      ??zcl_SendReadRsp_3
//  865       {
//  866         len += zclGetAttrDataLength( statusRec->dataType, statusRec->data );
        ; Setup parameters for call to function zclGetAttrDataLength
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??zclGetAttrDataLength?relay
        MOV     ?V0 + 10,R2
        MOV     ?V0 + 11,R3
        MOV     A,R6
        ADD     A,?V0 + 10
        MOV     R6,A
        MOV     A,R7
        ADDC    A,?V0 + 11
        MOV     R7,A
        SJMP    ??zcl_SendReadRsp_2
//  867       }
//  868       else
//  869       {
//  870         len += zclGetAttrDataLengthUsingCB( srcEP, clusterID, statusRec->attrID );
??zcl_SendReadRsp_3:
        ; Setup parameters for call to function zclGetAttrDataLengthUsingCB
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        MOVX    A,@DPTR
        MOV     R4,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R5,A
        MOV     R2,?V0 + 14
        MOV     R3,?V0 + 15
        MOV     R1,?V0 + 6
        LCALL   ??zclGetAttrDataLengthUsingCB?relay
        MOV     ?V0 + 10,R2
        MOV     ?V0 + 11,R3
        MOV     A,R6
        ADD     A,?V0 + 10
        MOV     R6,A
        MOV     A,R7
        ADDC    A,?V0 + 11
        MOV     R7,A
//  871       }
//  872     }
//  873   }
??zcl_SendReadRsp_2:
        INC     ?V0 + 2
        LJMP    ??zcl_SendReadRsp_0 & 0xFFFF
//  874 
//  875   buf = osal_mem_alloc( len );
??zcl_SendReadRsp_1:
        ; Setup parameters for call to function osal_mem_alloc
        MOV     A,R6
        MOV     R2,A
        MOV     A,R7
        MOV     R3,A
        LCALL   ??osal_mem_alloc?relay
        MOV     ?V0 + 0,R2
        MOV     ?V0 + 1,R3
        MOV     ?V0 + 8,?V0 + 0
        MOV     ?V0 + 9,?V0 + 1
//  876   if ( buf != NULL )
        MOV     A,?V0 + 8
        ORL     A,?V0 + 9
        JNZ     $+5
        LJMP    ??zcl_SendReadRsp_4 & 0xFFFF
//  877   {
//  878     // Load the buffer - serially
//  879     uint8 *pBuf = buf;
        MOV     ?V0 + 0,?V0 + 8
        MOV     ?V0 + 1,?V0 + 9
//  880     for ( uint8 i = 0; i < readRspCmd->numAttr; i++ )
        MOV     ?V0 + 4,#0x0
??zcl_SendReadRsp_5:
        MOV     DPL,?V0 + 12
        MOV     DPH,?V0 + 13
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     A,?V0 + 4
        CLR     C
        SUBB    A,R0
        JC      $+5
        LJMP    ??zcl_SendReadRsp_6 & 0xFFFF
//  881     {
//  882       zclReadRspStatus_t *statusRec = &(readRspCmd->attrList[i]);
        MOV     A,?V0 + 4
        MOV     R0,?V0 + 4
        MOV     R1,#0x0
        MOV     A,R0
        MOV     B,#0x6
        MUL     AB
        XCH     A,R0
        MOV     R2,B
        MOV     B,#0x0
        MUL     AB
        ADD     A,R2
        MOV     R2,A
        MOV     B,#0x6
        MOV     A,R1
        MUL     AB
        ADD     A,R2
        MOV     R1,A
        MOV     A,?V0 + 12
        ADD     A,R0
        MOV     DPL,A
        MOV     A,?V0 + 13
        ADDC    A,R1
        MOV     DPH,A
        INC     DPTR
        MOV     ?V0 + 2,DPL
        MOV     ?V0 + 3,DPH
//  883 
//  884       *pBuf++ = LO_UINT16( statusRec->attrID );
        MOV     DPL,?V0 + 2
        MOV     DPH,?V0 + 3
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        MOVX    @DPTR,A
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        INC     DPTR
        MOV     ?V0 + 0,DPL
        MOV     ?V0 + 1,DPH
//  885       *pBuf++ = HI_UINT16( statusRec->attrID );
        MOV     DPL,?V0 + 2
        MOV     DPH,?V0 + 3
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        CLR     A
        MOV     A,R1
        MOV     R0,A
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        MOVX    @DPTR,A
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        INC     DPTR
        MOV     ?V0 + 0,DPL
        MOV     ?V0 + 1,DPH
//  886       *pBuf++ = statusRec->status;
        MOV     DPL,?V0 + 2
        MOV     DPH,?V0 + 3
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        MOVX    @DPTR,A
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        INC     DPTR
        MOV     ?V0 + 0,DPL
        MOV     ?V0 + 1,DPH
//  887 
//  888       if ( statusRec->status == ZCL_STATUS_SUCCESS )
        MOV     DPL,?V0 + 2
        MOV     DPH,?V0 + 3
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        JZ      $+5
        LJMP    ??zcl_SendReadRsp_7 & 0xFFFF
//  889       {
//  890         *pBuf++ = statusRec->dataType;
        MOV     DPL,?V0 + 2
        MOV     DPH,?V0 + 3
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        MOVX    @DPTR,A
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        INC     DPTR
        MOV     ?V0 + 0,DPL
        MOV     ?V0 + 1,DPH
//  891 
//  892         if ( statusRec->data != NULL )
        MOV     DPL,?V0 + 2
        MOV     DPH,?V0 + 3
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JZ      ??zcl_SendReadRsp_8
//  893         {
//  894           // Copy attribute data to the buffer to be sent out
//  895           pBuf = zclSerializeData( statusRec->dataType, statusRec->data, pBuf );
        ; Setup parameters for call to function zclSerializeData
        MOV     R4,?V0 + 0
        MOV     R5,?V0 + 1
        MOV     DPL,?V0 + 2
        MOV     DPH,?V0 + 3
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        MOV     DPL,?V0 + 2
        MOV     DPH,?V0 + 3
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??zclSerializeData?relay
        MOV     ?V0 + 10,R2
        MOV     ?V0 + 11,R3
        MOV     ?V0 + 0,?V0 + 10
        MOV     ?V0 + 1,?V0 + 11
        SJMP    ??zcl_SendReadRsp_7
//  896         }
//  897         else
//  898         {
//  899           uint16 dataLen;
//  900 
//  901           // Read attribute data directly into the buffer to be sent out
//  902           zclReadAttrDataUsingCB( srcEP, clusterID, statusRec->attrID, pBuf, &dataLen );
??zcl_SendReadRsp_8:
        ; Setup parameters for call to function zclReadAttrDataUsingCB
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     ?V0 + 10,DPL
        MOV     ?V0 + 11,DPH
        MOV     R0,#?V0 + 10
        LCALL   ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 30)
        MOV     R0,#?V0 + 0
        LCALL   ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 32)
        MOV     DPL,?V0 + 2
        MOV     DPH,?V0 + 3
        MOVX    A,@DPTR
        MOV     R4,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R5,A
        MOV     R2,?V0 + 14
        MOV     R3,?V0 + 15
        MOV     R1,?V0 + 6
        LCALL   ??zclReadAttrDataUsingCB?relay
        MOV     A,#0x4
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 28)
        MOV     A,R1
//  903           pBuf += dataLen;
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,?V0 + 0
        ADD     A,R0
        MOV     ?V0 + 0,A
        MOV     A,?V0 + 1
        ADDC    A,R1
        MOV     ?V0 + 1,A
//  904         }
//  905       }
//  906     } // for loop
??zcl_SendReadRsp_7:
        INC     ?V0 + 4
        LJMP    ??zcl_SendReadRsp_5 & 0xFFFF
//  907 
//  908     status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_READ_RSP, FALSE,
//  909                               direction, disableDefaultRsp, 0, seqNum, len, buf );
??zcl_SendReadRsp_6:
        ; Setup parameters for call to function zcl_SendCommand
        MOV     R0,#?V0 + 8
        LCALL   ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 30)
        MOV     ?V0 + 2,R6
        MOV     ?V0 + 3,R7
        MOV     R0,#?V0 + 2
        LCALL   ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 32)
        MOV     A,?V0 + 7
        MOV     ?V0 + 2,A
        MOV     R0,#?V0 + 2
        LCALL   ?PUSH_XSTACK_I_ONE
          CFI CFA_XSP16 add(XSP16, 33)
        CLR     A
        MOV     ?V0 + 2,A
        MOV     ?V0 + 3,A
        MOV     R0,#?V0 + 2
        LCALL   ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 35)
        MOV     A,#0x26
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     ?V0 + 2,A
        MOV     R0,#?V0 + 2
        LCALL   ?PUSH_XSTACK_I_ONE
          CFI CFA_XSP16 add(XSP16, 36)
        MOV     A,#0x26
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     ?V0 + 2,A
        MOV     R0,#?V0 + 2
        LCALL   ?PUSH_XSTACK_I_ONE
          CFI CFA_XSP16 add(XSP16, 37)
        MOV     ?V0 + 2,#0x0
        MOV     R0,#?V0 + 2
        LCALL   ?PUSH_XSTACK_I_ONE
          CFI CFA_XSP16 add(XSP16, 38)
        MOV     ?V0 + 2,#0x1
        MOV     R0,#?V0 + 2
        LCALL   ?PUSH_XSTACK_I_ONE
          CFI CFA_XSP16 add(XSP16, 39)
        MOV     R4,?V0 + 14
        MOV     R5,?V0 + 15
        MOV     A,#0xd
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        MOV     R1,?V0 + 6
        LCALL   ??zcl_SendCommand?relay
        MOV     A,#0xb
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 28)
        MOV     A,R1
        MOV     ?V0 + 5,A
//  910     osal_mem_free( buf );
        ; Setup parameters for call to function osal_mem_free
        MOV     R2,?V0 + 8
        MOV     R3,?V0 + 9
        LCALL   ??osal_mem_free?relay
        SJMP    ??zcl_SendReadRsp_9
//  911   }
//  912   else
//  913   {
//  914     status = ZMemError;
??zcl_SendReadRsp_4:
        MOV     ?V0 + 5,#0x10
//  915   }
//  916 
//  917   return ( status );
??zcl_SendReadRsp_9:
        MOV     R1,?V0 + 5
        MOV     A,#0x4
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 24)
        MOV     R7,#0x10
        LJMP    ?BANKED_LEAVE_XDATA
          CFI EndBlock cfiBlock12
//  918 }
//  919 #endif // ZCL_READ
//  920 
//  921 #ifdef ZCL_WRITE
//  922 /*********************************************************************
//  923  * @fn      sendWriteRequest
//  924  *
//  925  * @brief   Send a Write command
//  926  *
//  927  * @param   dstAddr - destination address
//  928  * @param   clusterID - cluster ID
//  929  * @param   writeCmd - write command to be sent
//  930  * @param   cmd - ZCL_CMD_WRITE, ZCL_CMD_WRITE_UNDIVIDED or ZCL_CMD_WRITE_NO_RSP
//  931  * @param   direction - direction of the command
//  932  * @param   seqNum - transaction sequence number
//  933  *
//  934  * @return  ZSuccess if OK
//  935  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  936 ZStatus_t zcl_SendWriteRequest( uint8 srcEP, afAddrType_t *dstAddr, uint16 clusterID,
zcl_SendWriteRequest:
          CFI Block cfiBlock13 Using cfiCommon0
          CFI Function zcl_SendWriteRequest
        CODE
//  937                                 zclWriteCmd_t *writeCmd, uint8 cmd, uint8 direction,
//  938                                 uint8 disableDefaultRsp, uint8 seqNum )
//  939 {
        FUNCALL zcl_SendWriteRequest, zclGetAttrDataLength
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 28, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 28, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL zcl_SendWriteRequest, osal_mem_alloc
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 28, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 28, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL zcl_SendWriteRequest, zclSerializeData
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 28, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 28, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL zcl_SendWriteRequest, zcl_SendCommand
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 39, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 39, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL zcl_SendWriteRequest, osal_mem_free
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 28, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 28, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0x18
        LCALL   ?BANKED_ENTER_XDATA
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V15 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI V14 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V13 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI V12 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI V11 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI V10 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI V9 load(1, XDATA, add(CFA_XSP16, literal(-13)))
          CFI V8 load(1, XDATA, add(CFA_XSP16, literal(-14)))
          CFI V7 load(1, XDATA, add(CFA_XSP16, literal(-15)))
          CFI V6 load(1, XDATA, add(CFA_XSP16, literal(-16)))
          CFI V5 load(1, XDATA, add(CFA_XSP16, literal(-17)))
          CFI V4 load(1, XDATA, add(CFA_XSP16, literal(-18)))
          CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-19)))
          CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-20)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-21)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-22)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-23)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-24)))
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 24)
        ; Saved register size: 24
        ; Auto size: 4
        MOV     A,#-0x4
        LCALL   ?ALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 28)
        MOV     A,#0x2
        LCALL   ?XSTACK_DISP0_8
        MOV     A,R2
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R3
        MOVX    @DPTR,A
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     A,R4
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R5
        MOVX    @DPTR,A
        MOV     ?V0 + 12,R1
        MOV     A,#0x1c
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     ?V0 + 8,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     ?V0 + 9,A
        MOV     A,#0x1f
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     ?V0 + 15,A
        MOV     A,#0x20
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     ?V0 + 14,A
        MOV     A,#0x21
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     ?V0 + 13,A
//  940   uint8 *buf;
//  941   uint16 dataLen = 0;
        MOV     R6,#0x0
        MOV     R7,#0x0
//  942   ZStatus_t status;
//  943 
//  944   for ( uint8 i = 0; i < writeCmd->numAttr; i++ )
        MOV     ?V0 + 4,#0x0
??zcl_SendWriteRequest_0:
        MOV     DPL,?V0 + 8
        MOV     DPH,?V0 + 9
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     A,?V0 + 4
        CLR     C
        SUBB    A,R0
        JNC     ??zcl_SendWriteRequest_1
//  945   {
//  946     zclWriteRec_t *statusRec = &(writeCmd->attrList[i]);
        MOV     A,?V0 + 4
        MOV     R0,?V0 + 4
        MOV     R1,#0x0
        MOV     A,R0
        MOV     B,#0x5
        MUL     AB
        XCH     A,R0
        MOV     R2,B
        MOV     B,#0x0
        MUL     AB
        ADD     A,R2
        MOV     R2,A
        MOV     B,#0x5
        MOV     A,R1
        MUL     AB
        ADD     A,R2
        MOV     R1,A
        MOV     A,?V0 + 8
        ADD     A,R0
        MOV     DPL,A
        MOV     A,?V0 + 9
        ADDC    A,R1
        MOV     DPH,A
        INC     DPTR
        MOV     ?V0 + 0,DPL
        MOV     ?V0 + 1,DPH
//  947 
//  948     dataLen += 2 + 1; // Attribute ID + Attribute Type
        MOV     A,R6
        ADD     A,#0x3
        MOV     R6,A
        MOV     A,R7
        ADDC    A,#0x0
        MOV     R7,A
//  949 
//  950     // Attribute Data
//  951     dataLen += zclGetAttrDataLength( statusRec->dataType, statusRec->attrData );
        ; Setup parameters for call to function zclGetAttrDataLength
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??zclGetAttrDataLength?relay
        MOV     ?V0 + 2,R2
        MOV     ?V0 + 3,R3
        MOV     A,R6
        ADD     A,?V0 + 2
        MOV     R6,A
        MOV     A,R7
        ADDC    A,?V0 + 3
        MOV     R7,A
//  952   }
        INC     ?V0 + 4
        SJMP    ??zcl_SendWriteRequest_0
//  953 
//  954   buf = osal_mem_alloc( dataLen );
??zcl_SendWriteRequest_1:
        ; Setup parameters for call to function osal_mem_alloc
        MOV     A,R6
        MOV     R2,A
        MOV     A,R7
        MOV     R3,A
        LCALL   ??osal_mem_alloc?relay
        MOV     ?V0 + 0,R2
        MOV     ?V0 + 1,R3
        MOV     ?V0 + 6,?V0 + 0
        MOV     ?V0 + 7,?V0 + 1
//  955   if ( buf != NULL )
        MOV     A,?V0 + 6
        ORL     A,?V0 + 7
        JNZ     $+5
        LJMP    ??zcl_SendWriteRequest_2 & 0xFFFF
//  956   {
//  957     // Load the buffer - serially
//  958     uint8 *pBuf = buf;
        MOV     ?V0 + 0,?V0 + 6
        MOV     ?V0 + 1,?V0 + 7
//  959     for ( uint8 i = 0; i < writeCmd->numAttr; i++ )
        MOV     ?V0 + 4,#0x0
??zcl_SendWriteRequest_3:
        MOV     DPL,?V0 + 8
        MOV     DPH,?V0 + 9
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     A,?V0 + 4
        CLR     C
        SUBB    A,R0
        JC      $+5
        LJMP    ??zcl_SendWriteRequest_4 & 0xFFFF
//  960     {
//  961       zclWriteRec_t *statusRec = &(writeCmd->attrList[i]);
        MOV     A,?V0 + 4
        MOV     R0,?V0 + 4
        MOV     R1,#0x0
        MOV     A,R0
        MOV     B,#0x5
        MUL     AB
        XCH     A,R0
        MOV     R2,B
        MOV     B,#0x0
        MUL     AB
        ADD     A,R2
        MOV     R2,A
        MOV     B,#0x5
        MOV     A,R1
        MUL     AB
        ADD     A,R2
        MOV     R1,A
        MOV     A,?V0 + 8
        ADD     A,R0
        MOV     DPL,A
        MOV     A,?V0 + 9
        ADDC    A,R1
        MOV     DPH,A
        INC     DPTR
        MOV     ?V0 + 2,DPL
        MOV     ?V0 + 3,DPH
//  962 
//  963       *pBuf++ = LO_UINT16( statusRec->attrID );
        MOV     DPL,?V0 + 2
        MOV     DPH,?V0 + 3
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        MOVX    @DPTR,A
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        INC     DPTR
        MOV     ?V0 + 0,DPL
        MOV     ?V0 + 1,DPH
//  964       *pBuf++ = HI_UINT16( statusRec->attrID );
        MOV     DPL,?V0 + 2
        MOV     DPH,?V0 + 3
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        CLR     A
        MOV     A,R1
        MOV     R0,A
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        MOVX    @DPTR,A
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        INC     DPTR
        MOV     ?V0 + 0,DPL
        MOV     ?V0 + 1,DPH
//  965       *pBuf++ = statusRec->dataType;
        MOV     DPL,?V0 + 2
        MOV     DPH,?V0 + 3
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        MOVX    @DPTR,A
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        INC     DPTR
        MOV     ?V0 + 0,DPL
        MOV     ?V0 + 1,DPH
//  966 
//  967       pBuf = zclSerializeData( statusRec->dataType, statusRec->attrData, pBuf );
        ; Setup parameters for call to function zclSerializeData
        MOV     R4,?V0 + 0
        MOV     R5,?V0 + 1
        MOV     DPL,?V0 + 2
        MOV     DPH,?V0 + 3
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        MOV     DPL,?V0 + 2
        MOV     DPH,?V0 + 3
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??zclSerializeData?relay
        MOV     ?V0 + 10,R2
        MOV     ?V0 + 11,R3
        MOV     ?V0 + 0,?V0 + 10
        MOV     ?V0 + 1,?V0 + 11
//  968     }
        INC     ?V0 + 4
        LJMP    ??zcl_SendWriteRequest_3 & 0xFFFF
//  969 
//  970     status = zcl_SendCommand( srcEP, dstAddr, clusterID, cmd, FALSE,
//  971                               direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
??zcl_SendWriteRequest_4:
        ; Setup parameters for call to function zcl_SendCommand
        MOV     R0,#?V0 + 6
        LCALL   ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 30)
        MOV     ?V0 + 2,R6
        MOV     ?V0 + 3,R7
        MOV     R0,#?V0 + 2
        LCALL   ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 32)
        MOV     A,?V0 + 13
        MOV     ?V0 + 2,A
        MOV     R0,#?V0 + 2
        LCALL   ?PUSH_XSTACK_I_ONE
          CFI CFA_XSP16 add(XSP16, 33)
        CLR     A
        MOV     ?V0 + 2,A
        MOV     ?V0 + 3,A
        MOV     R0,#?V0 + 2
        LCALL   ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 35)
        MOV     A,?V0 + 14
        MOV     ?V0 + 2,A
        MOV     R0,#?V0 + 2
        LCALL   ?PUSH_XSTACK_I_ONE
          CFI CFA_XSP16 add(XSP16, 36)
        MOV     A,?V0 + 15
        MOV     ?V0 + 2,A
        MOV     R0,#?V0 + 2
        LCALL   ?PUSH_XSTACK_I_ONE
          CFI CFA_XSP16 add(XSP16, 37)
        MOV     ?V0 + 2,#0x0
        MOV     R0,#?V0 + 2
        LCALL   ?PUSH_XSTACK_I_ONE
          CFI CFA_XSP16 add(XSP16, 38)
        MOV     A,#0x28
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     ?V0 + 2,A
        MOV     R0,#?V0 + 2
        LCALL   ?PUSH_XSTACK_I_ONE
          CFI CFA_XSP16 add(XSP16, 39)
        MOV     A,#0xb
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R4,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R5,A
        MOV     A,#0xd
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        MOV     R1,?V0 + 12
        LCALL   ??zcl_SendCommand?relay
        MOV     A,#0xb
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 28)
        MOV     A,R1
        MOV     ?V0 + 5,A
//  972     osal_mem_free( buf );
        ; Setup parameters for call to function osal_mem_free
        MOV     R2,?V0 + 6
        MOV     R3,?V0 + 7
        LCALL   ??osal_mem_free?relay
        SJMP    ??zcl_SendWriteRequest_5
//  973   }
//  974   else
//  975   {
//  976     status = ZMemError;
??zcl_SendWriteRequest_2:
        MOV     ?V0 + 5,#0x10
//  977   }
//  978 
//  979   return ( status);
??zcl_SendWriteRequest_5:
        MOV     R1,?V0 + 5
        MOV     A,#0x4
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 24)
        MOV     R7,#0x10
        LJMP    ?BANKED_LEAVE_XDATA
          CFI EndBlock cfiBlock13
//  980 }
//  981 
//  982 /*********************************************************************
//  983  * @fn      zcl_SendWriteRsp
//  984  *
//  985  * @brief   Send a Write Response command
//  986  *
//  987  * @param   dstAddr - destination address
//  988  * @param   clusterID - cluster ID
//  989  * @param   wrtieRspCmd - write response command to be sent
//  990  * @param   direction - direction of the command
//  991  * @param   seqNum - transaction sequence number
//  992  *
//  993  * @return  ZSuccess if OK
//  994  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  995 ZStatus_t zcl_SendWriteRsp( uint8 srcEP, afAddrType_t *dstAddr,
zcl_SendWriteRsp:
          CFI Block cfiBlock14 Using cfiCommon0
          CFI Function zcl_SendWriteRsp
        CODE
//  996                             uint16 clusterID, zclWriteRspCmd_t *writeRspCmd,
//  997                             uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
//  998 {
        FUNCALL zcl_SendWriteRsp, osal_mem_alloc
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 26, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 26, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL zcl_SendWriteRsp, zcl_SendCommand
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 37, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 37, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL zcl_SendWriteRsp, osal_mem_free
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 26, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 26, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0x18
        LCALL   ?BANKED_ENTER_XDATA
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V15 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI V14 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V13 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI V12 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI V11 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI V10 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI V9 load(1, XDATA, add(CFA_XSP16, literal(-13)))
          CFI V8 load(1, XDATA, add(CFA_XSP16, literal(-14)))
          CFI V7 load(1, XDATA, add(CFA_XSP16, literal(-15)))
          CFI V6 load(1, XDATA, add(CFA_XSP16, literal(-16)))
          CFI V5 load(1, XDATA, add(CFA_XSP16, literal(-17)))
          CFI V4 load(1, XDATA, add(CFA_XSP16, literal(-18)))
          CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-19)))
          CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-20)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-21)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-22)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-23)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-24)))
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 24)
        ; Saved register size: 24
        ; Auto size: 2
        MOV     A,#-0x2
        LCALL   ?ALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 26)
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     A,R2
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R3
        MOVX    @DPTR,A
        MOV     ?V0 + 5,R1
        MOV     ?V0 + 14,R4
        MOV     ?V0 + 15,R5
        MOV     A,#0x1a
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     ?V0 + 2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     ?V0 + 3,A
        MOV     A,#0x1c
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     ?V0 + 12,A
        MOV     A,#0x1d
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     ?V0 + 9,A
        MOV     A,#0x1e
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     ?V0 + 8,A
//  999   uint16 dataLen;
// 1000   uint8 *buf;
// 1001   ZStatus_t status;
// 1002 
// 1003   dataLen = writeRspCmd->numAttr * ( 1 + 2 ); // status + attribute id
        MOV     DPL,?V0 + 2
        MOV     DPH,?V0 + 3
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     R1,#0x0
        MOV     A,R0
        MOV     B,#0x3
        MUL     AB
        XCH     A,R0
        MOV     R2,B
        MOV     B,#0x0
        MUL     AB
        ADD     A,R2
        MOV     R2,A
        MOV     B,#0x3
        MOV     A,R1
        MUL     AB
        ADD     A,R2
        MOV     R1,A
        MOV     A,R0
        MOV     R6,A
        MOV     A,R1
        MOV     R7,A
// 1004 
// 1005   buf = osal_mem_alloc( dataLen );
        ; Setup parameters for call to function osal_mem_alloc
        MOV     A,R6
        MOV     R2,A
        MOV     A,R7
        MOV     R3,A
        LCALL   ??osal_mem_alloc?relay
        MOV     ?V0 + 0,R2
        MOV     ?V0 + 1,R3
        MOV     ?V0 + 6,?V0 + 0
        MOV     ?V0 + 7,?V0 + 1
// 1006   if ( buf != NULL )
        MOV     A,?V0 + 6
        ORL     A,?V0 + 7
        JNZ     $+5
        LJMP    ??zcl_SendWriteRsp_0 & 0xFFFF
// 1007   {
// 1008     // Load the buffer - serially
// 1009     uint8 *pBuf = buf;
        MOV     ?V0 + 0,?V0 + 6
        MOV     ?V0 + 1,?V0 + 7
// 1010     for ( uint8 i = 0; i < writeRspCmd->numAttr; i++ )
        MOV     R2,#0x0
??zcl_SendWriteRsp_1:
        MOV     DPL,?V0 + 2
        MOV     DPH,?V0 + 3
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     A,R2
        CLR     C
        SUBB    A,R0
        JC      $+5
        LJMP    ??zcl_SendWriteRsp_2 & 0xFFFF
// 1011     {
// 1012       *pBuf++ = writeRspCmd->attrList[i].status;
        MOV     A,R2
        MOV     R0,A
        MOV     R1,#0x0
        MOV     A,R0
        MOV     B,#0x3
        MUL     AB
        XCH     A,R0
        MOV     R3,B
        MOV     B,#0x0
        MUL     AB
        ADD     A,R3
        MOV     R3,A
        MOV     B,#0x3
        MOV     A,R1
        MUL     AB
        ADD     A,R3
        MOV     R1,A
        MOV     A,?V0 + 2
        ADD     A,R0
        MOV     DPL,A
        MOV     A,?V0 + 3
        ADDC    A,R1
        MOV     DPH,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        MOVX    @DPTR,A
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        INC     DPTR
        MOV     ?V0 + 0,DPL
        MOV     ?V0 + 1,DPH
// 1013       *pBuf++ = LO_UINT16( writeRspCmd->attrList[i].attrID );
        MOV     A,R2
        MOV     R0,A
        MOV     R1,#0x0
        MOV     A,R0
        MOV     B,#0x3
        MUL     AB
        XCH     A,R0
        MOV     R3,B
        MOV     B,#0x0
        MUL     AB
        ADD     A,R3
        MOV     R3,A
        MOV     B,#0x3
        MOV     A,R1
        MUL     AB
        ADD     A,R3
        MOV     R1,A
        MOV     A,?V0 + 2
        ADD     A,R0
        MOV     DPL,A
        MOV     A,?V0 + 3
        ADDC    A,R1
        MOV     DPH,A
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        MOVX    @DPTR,A
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        INC     DPTR
        MOV     ?V0 + 0,DPL
        MOV     ?V0 + 1,DPH
// 1014       *pBuf++ = HI_UINT16( writeRspCmd->attrList[i].attrID );
        MOV     A,R2
        MOV     R0,A
        MOV     R1,#0x0
        MOV     A,R0
        MOV     B,#0x3
        MUL     AB
        XCH     A,R0
        MOV     R3,B
        MOV     B,#0x0
        MUL     AB
        ADD     A,R3
        MOV     R3,A
        MOV     B,#0x3
        MOV     A,R1
        MUL     AB
        ADD     A,R3
        MOV     R1,A
        MOV     A,?V0 + 2
        ADD     A,R0
        MOV     DPL,A
        MOV     A,?V0 + 3
        ADDC    A,R1
        MOV     DPH,A
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        CLR     A
        MOV     A,R1
        MOV     R0,A
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        MOVX    @DPTR,A
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        INC     DPTR
        MOV     ?V0 + 0,DPL
        MOV     ?V0 + 1,DPH
// 1015     }
        INC     R2
        LJMP    ??zcl_SendWriteRsp_1 & 0xFFFF
// 1016 
// 1017     // If there's only a single status record and its status field is set to
// 1018     // SUCCESS then omit the attribute ID field.
// 1019     if ( writeRspCmd->numAttr == 1 && writeRspCmd->attrList[0].status == ZCL_STATUS_SUCCESS )
??zcl_SendWriteRsp_2:
        MOV     DPL,?V0 + 2
        MOV     DPH,?V0 + 3
        MOVX    A,@DPTR
        XRL     A,#0x1
        JNZ     ??zcl_SendWriteRsp_3
        MOV     DPL,?V0 + 2
        MOV     DPH,?V0 + 3
        INC     DPTR
        MOVX    A,@DPTR
        JNZ     ??zcl_SendWriteRsp_3
// 1020     {
// 1021       dataLen = 1;
        MOV     R6,#0x1
        MOV     R7,#0x0
// 1022     }
// 1023 
// 1024     status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_WRITE_RSP, FALSE,
// 1025                               direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
??zcl_SendWriteRsp_3:
        ; Setup parameters for call to function zcl_SendCommand
        MOV     R0,#?V0 + 6
        LCALL   ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 28)
        MOV     ?V0 + 10,R6
        MOV     ?V0 + 11,R7
        MOV     R0,#?V0 + 10
        LCALL   ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 30)
        MOV     A,?V0 + 8
        MOV     ?V0 + 10,A
        MOV     R0,#?V0 + 10
        LCALL   ?PUSH_XSTACK_I_ONE
          CFI CFA_XSP16 add(XSP16, 31)
        CLR     A
        MOV     ?V0 + 10,A
        MOV     ?V0 + 11,A
        MOV     R0,#?V0 + 10
        LCALL   ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 33)
        MOV     A,?V0 + 9
        MOV     ?V0 + 10,A
        MOV     R0,#?V0 + 10
        LCALL   ?PUSH_XSTACK_I_ONE
          CFI CFA_XSP16 add(XSP16, 34)
        MOV     A,?V0 + 12
        MOV     ?V0 + 10,A
        MOV     R0,#?V0 + 10
        LCALL   ?PUSH_XSTACK_I_ONE
          CFI CFA_XSP16 add(XSP16, 35)
        MOV     ?V0 + 10,#0x0
        MOV     R0,#?V0 + 10
        LCALL   ?PUSH_XSTACK_I_ONE
          CFI CFA_XSP16 add(XSP16, 36)
        MOV     ?V0 + 10,#0x4
        MOV     R0,#?V0 + 10
        LCALL   ?PUSH_XSTACK_I_ONE
          CFI CFA_XSP16 add(XSP16, 37)
        MOV     R4,?V0 + 14
        MOV     R5,?V0 + 15
        MOV     A,#0xb
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        MOV     R1,?V0 + 5
        LCALL   ??zcl_SendCommand?relay
        MOV     A,#0xb
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 26)
        MOV     A,R1
        MOV     ?V0 + 4,A
// 1026     osal_mem_free( buf );
        ; Setup parameters for call to function osal_mem_free
        MOV     R2,?V0 + 6
        MOV     R3,?V0 + 7
        LCALL   ??osal_mem_free?relay
        SJMP    ??zcl_SendWriteRsp_4
// 1027   }
// 1028   else
// 1029   {
// 1030     status = ZMemError;
??zcl_SendWriteRsp_0:
        MOV     ?V0 + 4,#0x10
// 1031   }
// 1032 
// 1033   return ( status );
??zcl_SendWriteRsp_4:
        MOV     R1,?V0 + 4
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 24)
        MOV     R7,#0x10
        LJMP    ?BANKED_LEAVE_XDATA
          CFI EndBlock cfiBlock14
// 1034 }
// 1035 #endif // ZCL_WRITE
// 1036 
// 1037 #ifdef ZCL_REPORT
// 1038 /*********************************************************************
// 1039  * @fn      zcl_SendConfigReportCmd
// 1040  *
// 1041  * @brief   Send a Configure Reporting command
// 1042  *
// 1043  * @param   dstAddr - destination address
// 1044  * @param   clusterID - cluster ID
// 1045  * @param   cfgReportCmd - configure reporting command to be sent
// 1046  * @param   direction - direction of the command
// 1047  * @param   seqNum - transaction sequence number
// 1048  *
// 1049  * @return  ZSuccess if OK
// 1050  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 1051 ZStatus_t zcl_SendConfigReportCmd( uint8 srcEP, afAddrType_t *dstAddr,
zcl_SendConfigReportCmd:
          CFI Block cfiBlock15 Using cfiCommon0
          CFI Function zcl_SendConfigReportCmd
        CODE
// 1052                           uint16 clusterID, zclCfgReportCmd_t *cfgReportCmd,
// 1053                           uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
// 1054 {
        FUNCALL zcl_SendConfigReportCmd, zclAnalogDataType
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 28, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 28, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL zcl_SendConfigReportCmd, zclGetDataTypeLength
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 28, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 28, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL zcl_SendConfigReportCmd, osal_mem_alloc
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 28, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 28, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL zcl_SendConfigReportCmd, zclAnalogDataType
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 28, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 28, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL zcl_SendConfigReportCmd, zclSerializeData
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 28, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 28, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL zcl_SendConfigReportCmd, zcl_SendCommand
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 39, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 39, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL zcl_SendConfigReportCmd, osal_mem_free
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 28, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 28, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0x18
        LCALL   ?BANKED_ENTER_XDATA
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V15 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI V14 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V13 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI V12 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI V11 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI V10 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI V9 load(1, XDATA, add(CFA_XSP16, literal(-13)))
          CFI V8 load(1, XDATA, add(CFA_XSP16, literal(-14)))
          CFI V7 load(1, XDATA, add(CFA_XSP16, literal(-15)))
          CFI V6 load(1, XDATA, add(CFA_XSP16, literal(-16)))
          CFI V5 load(1, XDATA, add(CFA_XSP16, literal(-17)))
          CFI V4 load(1, XDATA, add(CFA_XSP16, literal(-18)))
          CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-19)))
          CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-20)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-21)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-22)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-23)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-24)))
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 24)
        ; Saved register size: 24
        ; Auto size: 4
        MOV     A,#-0x4
        LCALL   ?ALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 28)
        MOV     A,#0x2
        LCALL   ?XSTACK_DISP0_8
        MOV     A,R2
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R3
        MOVX    @DPTR,A
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     A,R4
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R5
        MOVX    @DPTR,A
        MOV     ?V0 + 12,R1
        MOV     A,#0x1c
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     ?V0 + 8,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     ?V0 + 9,A
        MOV     A,#0x1e
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     ?V0 + 15,A
        MOV     A,#0x1f
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     ?V0 + 14,A
        MOV     A,#0x20
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     ?V0 + 13,A
// 1055   uint8 *buf;
// 1056   uint16 dataLen = 0;
        MOV     ?V0 + 0,#0x0
        MOV     ?V0 + 1,#0x0
// 1057   ZStatus_t status;
// 1058 
// 1059   // Find out the data length
// 1060   for ( uint8 i = 0; i < cfgReportCmd->numAttr; i++ )
        MOV     ?V0 + 2,#0x0
??zcl_SendConfigReportCmd_0:
        MOV     DPL,?V0 + 8
        MOV     DPH,?V0 + 9
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     A,?V0 + 2
        CLR     C
        SUBB    A,R0
        JC      $+5
        LJMP    ??zcl_SendConfigReportCmd_1 & 0xFFFF
// 1061   {
// 1062     zclCfgReportRec_t *reportRec = &(cfgReportCmd->attrList[i]);
        MOV     A,?V0 + 2
        MOV     R0,?V0 + 2
        MOV     R1,#0x0
        MOV     A,R0
        MOV     B,#0xc
        MUL     AB
        XCH     A,R0
        MOV     R2,B
        MOV     B,#0x0
        MUL     AB
        ADD     A,R2
        MOV     R2,A
        MOV     B,#0xc
        MOV     A,R1
        MUL     AB
        ADD     A,R2
        MOV     R1,A
        MOV     A,?V0 + 8
        ADD     A,R0
        MOV     DPL,A
        MOV     A,?V0 + 9
        ADDC    A,R1
        MOV     DPH,A
        INC     DPTR
        MOV     R6,DPL
        MOV     R7,DPH
// 1063 
// 1064     dataLen += 1 + 2; // Direction + Attribute ID
        MOV     A,?V0 + 0
        ADD     A,#0x3
        MOV     ?V0 + 0,A
        MOV     A,?V0 + 1
        ADDC    A,#0x0
        MOV     ?V0 + 1,A
// 1065 
// 1066     if ( reportRec->direction == ZCL_SEND_ATTR_REPORTS )
        MOV     DPL,R6
        MOV     DPH,R7
        MOVX    A,@DPTR
        JNZ     ??zcl_SendConfigReportCmd_2
// 1067     {
// 1068       dataLen += 1 + 2 + 2; // Data Type + Min + Max Reporting Intervals
        MOV     A,?V0 + 0
        ADD     A,#0x5
        MOV     ?V0 + 0,A
        MOV     A,?V0 + 1
        ADDC    A,#0x0
        MOV     ?V0 + 1,A
// 1069 
// 1070       // Find out the size of the Reportable Change field (for Analog data types)
// 1071       if ( zclAnalogDataType( reportRec->dataType ) )
        ; Setup parameters for call to function zclAnalogDataType
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??zclAnalogDataType?relay
        MOV     A,R1
        JZ      ??zcl_SendConfigReportCmd_3
// 1072       {
// 1073         dataLen += zclGetDataTypeLength( reportRec->dataType );
        ; Setup parameters for call to function zclGetDataTypeLength
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??zclGetDataTypeLength?relay
        MOV     A,R1
        MOV     R0,A
        MOV     R1,#0x0
        MOV     A,?V0 + 0
        ADD     A,R0
        MOV     ?V0 + 0,A
        MOV     A,?V0 + 1
        ADDC    A,R1
        MOV     ?V0 + 1,A
        SJMP    ??zcl_SendConfigReportCmd_3
// 1074       }
// 1075     }
// 1076     else
// 1077     {
// 1078       dataLen += 2; // Timeout Period
??zcl_SendConfigReportCmd_2:
        MOV     A,?V0 + 0
        ADD     A,#0x2
        MOV     ?V0 + 0,A
        MOV     A,?V0 + 1
        ADDC    A,#0x0
        MOV     ?V0 + 1,A
// 1079     }
// 1080   }
??zcl_SendConfigReportCmd_3:
        INC     ?V0 + 2
        LJMP    ??zcl_SendConfigReportCmd_0 & 0xFFFF
// 1081 
// 1082   buf = osal_mem_alloc( dataLen );
??zcl_SendConfigReportCmd_1:
        ; Setup parameters for call to function osal_mem_alloc
        MOV     R2,?V0 + 0
        MOV     R3,?V0 + 1
        LCALL   ??osal_mem_alloc?relay
        MOV     ?V0 + 2,R2
        MOV     ?V0 + 3,R3
        MOV     ?V0 + 6,?V0 + 2
        MOV     ?V0 + 7,?V0 + 3
// 1083   if ( buf != NULL )
        MOV     A,?V0 + 6
        ORL     A,?V0 + 7
        JNZ     $+5
        LJMP    ??zcl_SendConfigReportCmd_4 & 0xFFFF
// 1084   {
// 1085     // Load the buffer - serially
// 1086     uint8 *pBuf = buf;
        MOV     R6,?V0 + 6
        MOV     R7,?V0 + 7
// 1087     for ( uint8 i = 0; i < cfgReportCmd->numAttr; i++ )
        MOV     ?V0 + 4,#0x0
??zcl_SendConfigReportCmd_5:
        MOV     DPL,?V0 + 8
        MOV     DPH,?V0 + 9
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     A,?V0 + 4
        CLR     C
        SUBB    A,R0
        JC      $+5
        LJMP    ??zcl_SendConfigReportCmd_6 & 0xFFFF
// 1088     {
// 1089       zclCfgReportRec_t *reportRec = &(cfgReportCmd->attrList[i]);
        MOV     A,?V0 + 4
        MOV     R0,?V0 + 4
        MOV     R1,#0x0
        MOV     A,R0
        MOV     B,#0xc
        MUL     AB
        XCH     A,R0
        MOV     R2,B
        MOV     B,#0x0
        MUL     AB
        ADD     A,R2
        MOV     R2,A
        MOV     B,#0xc
        MOV     A,R1
        MUL     AB
        ADD     A,R2
        MOV     R1,A
        MOV     A,?V0 + 8
        ADD     A,R0
        MOV     DPL,A
        MOV     A,?V0 + 9
        ADDC    A,R1
        MOV     DPH,A
        INC     DPTR
        MOV     ?V0 + 2,DPL
        MOV     ?V0 + 3,DPH
// 1090 
// 1091       *pBuf++ = reportRec->direction;
        MOV     DPL,?V0 + 2
        MOV     DPH,?V0 + 3
        MOVX    A,@DPTR
        MOV     DPL,R6
        MOV     DPH,R7
        MOVX    @DPTR,A
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        MOV     R6,DPL
        MOV     R7,DPH
// 1092       *pBuf++ = LO_UINT16( reportRec->attrID );
        MOV     DPL,?V0 + 2
        MOV     DPH,?V0 + 3
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        MOV     DPL,R6
        MOV     DPH,R7
        MOVX    @DPTR,A
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        MOV     R6,DPL
        MOV     R7,DPH
// 1093       *pBuf++ = HI_UINT16( reportRec->attrID );
        MOV     DPL,?V0 + 2
        MOV     DPH,?V0 + 3
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        CLR     A
        MOV     A,R1
        MOV     R0,A
        MOV     DPL,R6
        MOV     DPH,R7
        MOVX    @DPTR,A
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        MOV     R6,DPL
        MOV     R7,DPH
// 1094 
// 1095       if ( reportRec->direction == ZCL_SEND_ATTR_REPORTS )
        MOV     DPL,?V0 + 2
        MOV     DPH,?V0 + 3
        MOVX    A,@DPTR
        JZ      $+5
        LJMP    ??zcl_SendConfigReportCmd_7 & 0xFFFF
// 1096       {
// 1097         *pBuf++ = reportRec->dataType;
        MOV     DPL,?V0 + 2
        MOV     DPH,?V0 + 3
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPL,R6
        MOV     DPH,R7
        MOVX    @DPTR,A
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        MOV     R6,DPL
        MOV     R7,DPH
// 1098         *pBuf++ = LO_UINT16( reportRec->minReportInt );
        MOV     DPL,?V0 + 2
        MOV     DPH,?V0 + 3
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        MOV     DPL,R6
        MOV     DPH,R7
        MOVX    @DPTR,A
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        MOV     R6,DPL
        MOV     R7,DPH
// 1099         *pBuf++ = HI_UINT16( reportRec->minReportInt );
        MOV     DPL,?V0 + 2
        MOV     DPH,?V0 + 3
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        CLR     A
        MOV     A,R1
        MOV     R0,A
        MOV     DPL,R6
        MOV     DPH,R7
        MOVX    @DPTR,A
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        MOV     R6,DPL
        MOV     R7,DPH
// 1100         *pBuf++ = LO_UINT16( reportRec->maxReportInt );
        MOV     DPL,?V0 + 2
        MOV     DPH,?V0 + 3
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        MOV     DPL,R6
        MOV     DPH,R7
        MOVX    @DPTR,A
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        MOV     R6,DPL
        MOV     R7,DPH
// 1101         *pBuf++ = HI_UINT16( reportRec->maxReportInt );
        MOV     DPL,?V0 + 2
        MOV     DPH,?V0 + 3
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        CLR     A
        MOV     A,R1
        MOV     R0,A
        MOV     DPL,R6
        MOV     DPH,R7
        MOVX    @DPTR,A
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        MOV     R6,DPL
        MOV     R7,DPH
// 1102 
// 1103         if ( zclAnalogDataType( reportRec->dataType ) )
        ; Setup parameters for call to function zclAnalogDataType
        MOV     DPL,?V0 + 2
        MOV     DPH,?V0 + 3
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??zclAnalogDataType?relay
        MOV     A,R1
        JZ      ??zcl_SendConfigReportCmd_8
// 1104         {
// 1105           pBuf = zclSerializeData( reportRec->dataType, reportRec->reportableChange, pBuf );
        ; Setup parameters for call to function zclSerializeData
        MOV     A,R6
        MOV     R4,A
        MOV     A,R7
        MOV     R5,A
        MOV     DPL,?V0 + 2
        MOV     DPH,?V0 + 3
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        MOV     DPL,?V0 + 2
        MOV     DPH,?V0 + 3
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??zclSerializeData?relay
        MOV     ?V0 + 10,R2
        MOV     ?V0 + 11,R3
        MOV     R6,?V0 + 10
        MOV     R7,?V0 + 11
        SJMP    ??zcl_SendConfigReportCmd_8
// 1106         }
// 1107       }
// 1108       else
// 1109       {
// 1110         *pBuf++ = LO_UINT16( reportRec->timeoutPeriod );
??zcl_SendConfigReportCmd_7:
        MOV     DPL,?V0 + 2
        MOV     DPH,?V0 + 3
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        MOV     DPL,R6
        MOV     DPH,R7
        MOVX    @DPTR,A
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        MOV     R6,DPL
        MOV     R7,DPH
// 1111         *pBuf++ = HI_UINT16( reportRec->timeoutPeriod );
        MOV     DPL,?V0 + 2
        MOV     DPH,?V0 + 3
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        CLR     A
        MOV     A,R1
        MOV     R0,A
        MOV     DPL,R6
        MOV     DPH,R7
        MOVX    @DPTR,A
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        MOV     R6,DPL
        MOV     R7,DPH
// 1112       }
// 1113     } // for loop
??zcl_SendConfigReportCmd_8:
        INC     ?V0 + 4
        LJMP    ??zcl_SendConfigReportCmd_5 & 0xFFFF
// 1114 
// 1115     status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_CONFIG_REPORT, FALSE,
// 1116                               direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
??zcl_SendConfigReportCmd_6:
        ; Setup parameters for call to function zcl_SendCommand
        MOV     R0,#?V0 + 6
        LCALL   ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 30)
        MOV     R0,#?V0 + 0
        LCALL   ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 32)
        MOV     A,?V0 + 13
        MOV     ?V0 + 2,A
        MOV     R0,#?V0 + 2
        LCALL   ?PUSH_XSTACK_I_ONE
          CFI CFA_XSP16 add(XSP16, 33)
        CLR     A
        MOV     ?V0 + 2,A
        MOV     ?V0 + 3,A
        MOV     R0,#?V0 + 2
        LCALL   ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 35)
        MOV     A,?V0 + 14
        MOV     ?V0 + 2,A
        MOV     R0,#?V0 + 2
        LCALL   ?PUSH_XSTACK_I_ONE
          CFI CFA_XSP16 add(XSP16, 36)
        MOV     A,?V0 + 15
        MOV     ?V0 + 2,A
        MOV     R0,#?V0 + 2
        LCALL   ?PUSH_XSTACK_I_ONE
          CFI CFA_XSP16 add(XSP16, 37)
        MOV     ?V0 + 2,#0x0
        MOV     R0,#?V0 + 2
        LCALL   ?PUSH_XSTACK_I_ONE
          CFI CFA_XSP16 add(XSP16, 38)
        MOV     ?V0 + 2,#0x6
        MOV     R0,#?V0 + 2
        LCALL   ?PUSH_XSTACK_I_ONE
          CFI CFA_XSP16 add(XSP16, 39)
        MOV     A,#0xb
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R4,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R5,A
        MOV     A,#0xd
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        MOV     R1,?V0 + 12
        LCALL   ??zcl_SendCommand?relay
        MOV     A,#0xb
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 28)
        MOV     A,R1
        MOV     ?V0 + 5,A
// 1117     osal_mem_free( buf );
        ; Setup parameters for call to function osal_mem_free
        MOV     R2,?V0 + 6
        MOV     R3,?V0 + 7
        LCALL   ??osal_mem_free?relay
        SJMP    ??zcl_SendConfigReportCmd_9
// 1118   }
// 1119   else
// 1120   {
// 1121     status = ZMemError;
??zcl_SendConfigReportCmd_4:
        MOV     ?V0 + 5,#0x10
// 1122   }
// 1123 
// 1124   return ( status );
??zcl_SendConfigReportCmd_9:
        MOV     R1,?V0 + 5
        MOV     A,#0x4
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 24)
        MOV     R7,#0x10
        LJMP    ?BANKED_LEAVE_XDATA
          CFI EndBlock cfiBlock15
// 1125 }
// 1126 
// 1127 /*********************************************************************
// 1128  * @fn      zcl_SendConfigReportRspCmd
// 1129  *
// 1130  * @brief   Send a Configure Reporting Response command
// 1131  *
// 1132  * @param   dstAddr - destination address
// 1133  * @param   clusterID - cluster ID
// 1134  * @param   cfgReportRspCmd - configure reporting response command to be sent
// 1135  * @param   direction - direction of the command
// 1136  * @param   seqNum - transaction sequence number
// 1137  *
// 1138  * @return  ZSuccess if OK
// 1139  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 1140 ZStatus_t zcl_SendConfigReportRspCmd( uint8 srcEP, afAddrType_t *dstAddr,
zcl_SendConfigReportRspCmd:
          CFI Block cfiBlock16 Using cfiCommon0
          CFI Function zcl_SendConfigReportRspCmd
        CODE
// 1141                     uint16 clusterID, zclCfgReportRspCmd_t *cfgReportRspCmd,
// 1142                     uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
// 1143 {
        FUNCALL zcl_SendConfigReportRspCmd, osal_mem_alloc
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 26, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 26, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL zcl_SendConfigReportRspCmd, zcl_SendCommand
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 37, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 37, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL zcl_SendConfigReportRspCmd, osal_mem_free
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 26, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 26, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0x18
        LCALL   ?BANKED_ENTER_XDATA
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V15 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI V14 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V13 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI V12 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI V11 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI V10 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI V9 load(1, XDATA, add(CFA_XSP16, literal(-13)))
          CFI V8 load(1, XDATA, add(CFA_XSP16, literal(-14)))
          CFI V7 load(1, XDATA, add(CFA_XSP16, literal(-15)))
          CFI V6 load(1, XDATA, add(CFA_XSP16, literal(-16)))
          CFI V5 load(1, XDATA, add(CFA_XSP16, literal(-17)))
          CFI V4 load(1, XDATA, add(CFA_XSP16, literal(-18)))
          CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-19)))
          CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-20)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-21)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-22)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-23)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-24)))
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 24)
        ; Saved register size: 24
        ; Auto size: 2
        MOV     A,#-0x2
        LCALL   ?ALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 26)
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     A,R2
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R3
        MOVX    @DPTR,A
        MOV     ?V0 + 5,R1
        MOV     ?V0 + 14,R4
        MOV     ?V0 + 15,R5
        MOV     A,#0x1a
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     ?V0 + 2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     ?V0 + 3,A
        MOV     A,#0x1c
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     ?V0 + 12,A
        MOV     A,#0x1d
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     ?V0 + 9,A
        MOV     A,#0x1e
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     ?V0 + 8,A
// 1144   uint16 dataLen;
// 1145   uint8 *buf;
// 1146   ZStatus_t status;
// 1147 
// 1148   // Atrribute list (Status, Direction and Attribute ID)
// 1149   dataLen = cfgReportRspCmd->numAttr * ( 1 + 1 + 2 );
        MOV     DPL,?V0 + 2
        MOV     DPH,?V0 + 3
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     R1,#0x0
        MOV     A,R0
        MOV     B,#0x4
        MUL     AB
        XCH     A,R0
        MOV     R2,B
        MOV     B,#0x0
        MUL     AB
        ADD     A,R2
        MOV     R2,A
        MOV     B,#0x4
        MOV     A,R1
        MUL     AB
        ADD     A,R2
        MOV     R1,A
        MOV     ?V0 + 0,R0
        MOV     ?V0 + 1,R1
// 1150 
// 1151   buf = osal_mem_alloc( dataLen );
        ; Setup parameters for call to function osal_mem_alloc
        MOV     R2,?V0 + 0
        MOV     R3,?V0 + 1
        LCALL   ??osal_mem_alloc?relay
        MOV     ?V0 + 10,R2
        MOV     ?V0 + 11,R3
        MOV     ?V0 + 6,?V0 + 10
        MOV     ?V0 + 7,?V0 + 11
// 1152   if ( buf != NULL )
        MOV     A,?V0 + 6
        ORL     A,?V0 + 7
        JNZ     $+5
        LJMP    ??zcl_SendConfigReportRspCmd_0 & 0xFFFF
// 1153   {
// 1154     // Load the buffer - serially
// 1155     uint8 *pBuf = buf;
        MOV     R6,?V0 + 6
        MOV     R7,?V0 + 7
// 1156     for ( uint8 i = 0; i < cfgReportRspCmd->numAttr; i++ )
        MOV     R2,#0x0
??zcl_SendConfigReportRspCmd_1:
        MOV     DPL,?V0 + 2
        MOV     DPH,?V0 + 3
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     A,R2
        CLR     C
        SUBB    A,R0
        JC      $+5
        LJMP    ??zcl_SendConfigReportRspCmd_2 & 0xFFFF
// 1157     {
// 1158       *pBuf++ = cfgReportRspCmd->attrList[i].status;
        MOV     A,R2
        MOV     R0,A
        MOV     R1,#0x0
        MOV     A,R0
        MOV     B,#0x4
        MUL     AB
        XCH     A,R0
        MOV     R3,B
        MOV     B,#0x0
        MUL     AB
        ADD     A,R3
        MOV     R3,A
        MOV     B,#0x4
        MOV     A,R1
        MUL     AB
        ADD     A,R3
        MOV     R1,A
        MOV     A,?V0 + 2
        ADD     A,R0
        MOV     DPL,A
        MOV     A,?V0 + 3
        ADDC    A,R1
        MOV     DPH,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPL,R6
        MOV     DPH,R7
        MOVX    @DPTR,A
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        MOV     R6,DPL
        MOV     R7,DPH
// 1159       *pBuf++ = cfgReportRspCmd->attrList[i].direction;
        MOV     A,R2
        MOV     R0,A
        MOV     R1,#0x0
        MOV     A,R0
        MOV     B,#0x4
        MUL     AB
        XCH     A,R0
        MOV     R3,B
        MOV     B,#0x0
        MUL     AB
        ADD     A,R3
        MOV     R3,A
        MOV     B,#0x4
        MOV     A,R1
        MUL     AB
        ADD     A,R3
        MOV     R1,A
        MOV     A,?V0 + 2
        ADD     A,R0
        MOV     DPL,A
        MOV     A,?V0 + 3
        ADDC    A,R1
        MOV     DPH,A
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPL,R6
        MOV     DPH,R7
        MOVX    @DPTR,A
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        MOV     R6,DPL
        MOV     R7,DPH
// 1160       *pBuf++ = LO_UINT16( cfgReportRspCmd->attrList[i].attrID );
        MOV     A,R2
        MOV     R0,A
        MOV     R1,#0x0
        MOV     A,R0
        MOV     B,#0x4
        MUL     AB
        XCH     A,R0
        MOV     R3,B
        MOV     B,#0x0
        MUL     AB
        ADD     A,R3
        MOV     R3,A
        MOV     B,#0x4
        MOV     A,R1
        MUL     AB
        ADD     A,R3
        MOV     R1,A
        MOV     A,?V0 + 2
        ADD     A,R0
        MOV     DPL,A
        MOV     A,?V0 + 3
        ADDC    A,R1
        MOV     DPH,A
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        MOV     DPL,R6
        MOV     DPH,R7
        MOVX    @DPTR,A
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        MOV     R6,DPL
        MOV     R7,DPH
// 1161       *pBuf++ = HI_UINT16( cfgReportRspCmd->attrList[i].attrID );
        MOV     A,R2
        MOV     R0,A
        MOV     R1,#0x0
        MOV     A,R0
        MOV     B,#0x4
        MUL     AB
        XCH     A,R0
        MOV     R3,B
        MOV     B,#0x0
        MUL     AB
        ADD     A,R3
        MOV     R3,A
        MOV     B,#0x4
        MOV     A,R1
        MUL     AB
        ADD     A,R3
        MOV     R1,A
        MOV     A,?V0 + 2
        ADD     A,R0
        MOV     DPL,A
        MOV     A,?V0 + 3
        ADDC    A,R1
        MOV     DPH,A
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        CLR     A
        MOV     A,R1
        MOV     R0,A
        MOV     DPL,R6
        MOV     DPH,R7
        MOVX    @DPTR,A
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        MOV     R6,DPL
        MOV     R7,DPH
// 1162     }
        INC     R2
        LJMP    ??zcl_SendConfigReportRspCmd_1 & 0xFFFF
// 1163 
// 1164     // If there's only a single status record and its status field is set to
// 1165     // SUCCESS then omit the attribute ID field.
// 1166     if ( cfgReportRspCmd->numAttr == 1 && cfgReportRspCmd->attrList[0].status == ZCL_STATUS_SUCCESS )
??zcl_SendConfigReportRspCmd_2:
        MOV     DPL,?V0 + 2
        MOV     DPH,?V0 + 3
        MOVX    A,@DPTR
        XRL     A,#0x1
        JNZ     ??zcl_SendConfigReportRspCmd_3
        MOV     DPL,?V0 + 2
        MOV     DPH,?V0 + 3
        INC     DPTR
        MOVX    A,@DPTR
        JNZ     ??zcl_SendConfigReportRspCmd_3
// 1167     {
// 1168       dataLen = 1;
        MOV     ?V0 + 0,#0x1
        MOV     ?V0 + 1,#0x0
// 1169     }
// 1170 
// 1171     status = zcl_SendCommand( srcEP, dstAddr, clusterID,
// 1172                               ZCL_CMD_CONFIG_REPORT_RSP, FALSE, direction,
// 1173                               disableDefaultRsp, 0, seqNum, dataLen, buf );
??zcl_SendConfigReportRspCmd_3:
        ; Setup parameters for call to function zcl_SendCommand
        MOV     R0,#?V0 + 6
        LCALL   ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 28)
        MOV     R0,#?V0 + 0
        LCALL   ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 30)
        MOV     A,?V0 + 8
        MOV     ?V0 + 10,A
        MOV     R0,#?V0 + 10
        LCALL   ?PUSH_XSTACK_I_ONE
          CFI CFA_XSP16 add(XSP16, 31)
        CLR     A
        MOV     ?V0 + 10,A
        MOV     ?V0 + 11,A
        MOV     R0,#?V0 + 10
        LCALL   ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 33)
        MOV     A,?V0 + 9
        MOV     ?V0 + 10,A
        MOV     R0,#?V0 + 10
        LCALL   ?PUSH_XSTACK_I_ONE
          CFI CFA_XSP16 add(XSP16, 34)
        MOV     A,?V0 + 12
        MOV     ?V0 + 10,A
        MOV     R0,#?V0 + 10
        LCALL   ?PUSH_XSTACK_I_ONE
          CFI CFA_XSP16 add(XSP16, 35)
        MOV     ?V0 + 10,#0x0
        MOV     R0,#?V0 + 10
        LCALL   ?PUSH_XSTACK_I_ONE
          CFI CFA_XSP16 add(XSP16, 36)
        MOV     ?V0 + 10,#0x7
        MOV     R0,#?V0 + 10
        LCALL   ?PUSH_XSTACK_I_ONE
          CFI CFA_XSP16 add(XSP16, 37)
        MOV     R4,?V0 + 14
        MOV     R5,?V0 + 15
        MOV     A,#0xb
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        MOV     R1,?V0 + 5
        LCALL   ??zcl_SendCommand?relay
        MOV     A,#0xb
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 26)
        MOV     A,R1
        MOV     ?V0 + 4,A
// 1174     osal_mem_free( buf );
        ; Setup parameters for call to function osal_mem_free
        MOV     R2,?V0 + 6
        MOV     R3,?V0 + 7
        LCALL   ??osal_mem_free?relay
        SJMP    ??zcl_SendConfigReportRspCmd_4
// 1175   }
// 1176   else
// 1177   {
// 1178     status = ZMemError;
??zcl_SendConfigReportRspCmd_0:
        MOV     ?V0 + 4,#0x10
// 1179   }
// 1180 
// 1181   return ( status );
??zcl_SendConfigReportRspCmd_4:
        MOV     R1,?V0 + 4
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 24)
        MOV     R7,#0x10
        LJMP    ?BANKED_LEAVE_XDATA
          CFI EndBlock cfiBlock16
// 1182 }
// 1183 
// 1184 /*********************************************************************
// 1185  * @fn      zcl_SendReadReportCfgCmd
// 1186  *
// 1187  * @brief   Send a Read Reporting Configuration command
// 1188  *
// 1189  * @param   dstAddr - destination address
// 1190  * @param   clusterID - cluster ID
// 1191  * @param   readReportCfgCmd - read reporting configuration command to be sent
// 1192  * @param   direction - direction of the command
// 1193  * @param   seqNum - transaction sequence number
// 1194  *
// 1195  * @return  ZSuccess if OK
// 1196  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 1197 ZStatus_t zcl_SendReadReportCfgCmd( uint8 srcEP, afAddrType_t *dstAddr,
zcl_SendReadReportCfgCmd:
          CFI Block cfiBlock17 Using cfiCommon0
          CFI Function zcl_SendReadReportCfgCmd
        CODE
// 1198                   uint16 clusterID, zclReadReportCfgCmd_t *readReportCfgCmd,
// 1199                   uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
// 1200 {
        FUNCALL zcl_SendReadReportCfgCmd, osal_mem_alloc
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 26, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 26, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL zcl_SendReadReportCfgCmd, zcl_SendCommand
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 37, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 37, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL zcl_SendReadReportCfgCmd, osal_mem_free
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 26, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 26, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0x18
        LCALL   ?BANKED_ENTER_XDATA
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V15 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI V14 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V13 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI V12 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI V11 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI V10 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI V9 load(1, XDATA, add(CFA_XSP16, literal(-13)))
          CFI V8 load(1, XDATA, add(CFA_XSP16, literal(-14)))
          CFI V7 load(1, XDATA, add(CFA_XSP16, literal(-15)))
          CFI V6 load(1, XDATA, add(CFA_XSP16, literal(-16)))
          CFI V5 load(1, XDATA, add(CFA_XSP16, literal(-17)))
          CFI V4 load(1, XDATA, add(CFA_XSP16, literal(-18)))
          CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-19)))
          CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-20)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-21)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-22)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-23)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-24)))
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 24)
        ; Saved register size: 24
        ; Auto size: 2
        MOV     A,#-0x2
        LCALL   ?ALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 26)
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     A,R2
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R3
        MOVX    @DPTR,A
        MOV     ?V0 + 5,R1
        MOV     ?V0 + 14,R4
        MOV     ?V0 + 15,R5
        MOV     A,#0x1a
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     ?V0 + 2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     ?V0 + 3,A
        MOV     A,#0x1c
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     ?V0 + 12,A
        MOV     A,#0x1d
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     ?V0 + 9,A
        MOV     A,#0x1e
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     ?V0 + 8,A
// 1201   uint16 dataLen;
// 1202   uint8 *buf;
// 1203   ZStatus_t status;
// 1204 
// 1205   dataLen = readReportCfgCmd->numAttr * ( 1 + 2 ); // Direction + Atrribute ID
        MOV     DPL,?V0 + 2
        MOV     DPH,?V0 + 3
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     R1,#0x0
        MOV     A,R0
        MOV     B,#0x3
        MUL     AB
        XCH     A,R0
        MOV     R2,B
        MOV     B,#0x0
        MUL     AB
        ADD     A,R2
        MOV     R2,A
        MOV     B,#0x3
        MOV     A,R1
        MUL     AB
        ADD     A,R2
        MOV     R1,A
        MOV     ?V0 + 0,R0
        MOV     ?V0 + 1,R1
// 1206 
// 1207   buf = osal_mem_alloc( dataLen );
        ; Setup parameters for call to function osal_mem_alloc
        MOV     R2,?V0 + 0
        MOV     R3,?V0 + 1
        LCALL   ??osal_mem_alloc?relay
        MOV     ?V0 + 10,R2
        MOV     ?V0 + 11,R3
        MOV     ?V0 + 6,?V0 + 10
        MOV     ?V0 + 7,?V0 + 11
// 1208   if ( buf != NULL )
        MOV     A,?V0 + 6
        ORL     A,?V0 + 7
        JNZ     $+5
        LJMP    ??zcl_SendReadReportCfgCmd_0 & 0xFFFF
// 1209   {
// 1210     // Load the buffer - serially
// 1211     uint8 *pBuf = buf;
        MOV     R6,?V0 + 6
        MOV     R7,?V0 + 7
// 1212     for ( uint8 i = 0; i < readReportCfgCmd->numAttr; i++ )
        MOV     R2,#0x0
??zcl_SendReadReportCfgCmd_1:
        MOV     DPL,?V0 + 2
        MOV     DPH,?V0 + 3
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     A,R2
        CLR     C
        SUBB    A,R0
        JC      $+5
        LJMP    ??zcl_SendReadReportCfgCmd_2 & 0xFFFF
// 1213     {
// 1214       *pBuf++ = readReportCfgCmd->attrList[i].direction;
        MOV     A,R2
        MOV     R0,A
        MOV     R1,#0x0
        MOV     A,R0
        MOV     B,#0x3
        MUL     AB
        XCH     A,R0
        MOV     R3,B
        MOV     B,#0x0
        MUL     AB
        ADD     A,R3
        MOV     R3,A
        MOV     B,#0x3
        MOV     A,R1
        MUL     AB
        ADD     A,R3
        MOV     R1,A
        MOV     A,?V0 + 2
        ADD     A,R0
        MOV     DPL,A
        MOV     A,?V0 + 3
        ADDC    A,R1
        MOV     DPH,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPL,R6
        MOV     DPH,R7
        MOVX    @DPTR,A
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        MOV     R6,DPL
        MOV     R7,DPH
// 1215       *pBuf++ = LO_UINT16( readReportCfgCmd->attrList[i].attrID );
        MOV     A,R2
        MOV     R0,A
        MOV     R1,#0x0
        MOV     A,R0
        MOV     B,#0x3
        MUL     AB
        XCH     A,R0
        MOV     R3,B
        MOV     B,#0x0
        MUL     AB
        ADD     A,R3
        MOV     R3,A
        MOV     B,#0x3
        MOV     A,R1
        MUL     AB
        ADD     A,R3
        MOV     R1,A
        MOV     A,?V0 + 2
        ADD     A,R0
        MOV     DPL,A
        MOV     A,?V0 + 3
        ADDC    A,R1
        MOV     DPH,A
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        MOV     DPL,R6
        MOV     DPH,R7
        MOVX    @DPTR,A
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        MOV     R6,DPL
        MOV     R7,DPH
// 1216       *pBuf++ = HI_UINT16( readReportCfgCmd->attrList[i].attrID );
        MOV     A,R2
        MOV     R0,A
        MOV     R1,#0x0
        MOV     A,R0
        MOV     B,#0x3
        MUL     AB
        XCH     A,R0
        MOV     R3,B
        MOV     B,#0x0
        MUL     AB
        ADD     A,R3
        MOV     R3,A
        MOV     B,#0x3
        MOV     A,R1
        MUL     AB
        ADD     A,R3
        MOV     R1,A
        MOV     A,?V0 + 2
        ADD     A,R0
        MOV     DPL,A
        MOV     A,?V0 + 3
        ADDC    A,R1
        MOV     DPH,A
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        CLR     A
        MOV     A,R1
        MOV     R0,A
        MOV     DPL,R6
        MOV     DPH,R7
        MOVX    @DPTR,A
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        MOV     R6,DPL
        MOV     R7,DPH
// 1217     }
        INC     R2
        LJMP    ??zcl_SendReadReportCfgCmd_1 & 0xFFFF
// 1218 
// 1219     status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_READ_REPORT_CFG, FALSE,
// 1220                               direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
??zcl_SendReadReportCfgCmd_2:
        ; Setup parameters for call to function zcl_SendCommand
        MOV     R0,#?V0 + 6
        LCALL   ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 28)
        MOV     R0,#?V0 + 0
        LCALL   ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 30)
        MOV     A,?V0 + 8
        MOV     ?V0 + 10,A
        MOV     R0,#?V0 + 10
        LCALL   ?PUSH_XSTACK_I_ONE
          CFI CFA_XSP16 add(XSP16, 31)
        CLR     A
        MOV     ?V0 + 10,A
        MOV     ?V0 + 11,A
        MOV     R0,#?V0 + 10
        LCALL   ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 33)
        MOV     A,?V0 + 9
        MOV     ?V0 + 10,A
        MOV     R0,#?V0 + 10
        LCALL   ?PUSH_XSTACK_I_ONE
          CFI CFA_XSP16 add(XSP16, 34)
        MOV     A,?V0 + 12
        MOV     ?V0 + 10,A
        MOV     R0,#?V0 + 10
        LCALL   ?PUSH_XSTACK_I_ONE
          CFI CFA_XSP16 add(XSP16, 35)
        MOV     ?V0 + 10,#0x0
        MOV     R0,#?V0 + 10
        LCALL   ?PUSH_XSTACK_I_ONE
          CFI CFA_XSP16 add(XSP16, 36)
        MOV     ?V0 + 10,#0x8
        MOV     R0,#?V0 + 10
        LCALL   ?PUSH_XSTACK_I_ONE
          CFI CFA_XSP16 add(XSP16, 37)
        MOV     R4,?V0 + 14
        MOV     R5,?V0 + 15
        MOV     A,#0xb
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        MOV     R1,?V0 + 5
        LCALL   ??zcl_SendCommand?relay
        MOV     A,#0xb
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 26)
        MOV     A,R1
        MOV     ?V0 + 4,A
// 1221     osal_mem_free( buf );
        ; Setup parameters for call to function osal_mem_free
        MOV     R2,?V0 + 6
        MOV     R3,?V0 + 7
        LCALL   ??osal_mem_free?relay
        SJMP    ??zcl_SendReadReportCfgCmd_3
// 1222   }
// 1223   else
// 1224   {
// 1225     status = ZMemError;
??zcl_SendReadReportCfgCmd_0:
        MOV     ?V0 + 4,#0x10
// 1226   }
// 1227 
// 1228   return ( status );
??zcl_SendReadReportCfgCmd_3:
        MOV     R1,?V0 + 4
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 24)
        MOV     R7,#0x10
        LJMP    ?BANKED_LEAVE_XDATA
          CFI EndBlock cfiBlock17
// 1229 }
// 1230 
// 1231 /*********************************************************************
// 1232  * @fn      zcl_SendReadReportCfgRspCmd
// 1233  *
// 1234  * @brief   Send a Read Reporting Configuration Response command
// 1235  *
// 1236  * @param   dstAddr - destination address
// 1237  * @param   clusterID - cluster ID
// 1238  * @param   readReportCfgRspCmd - read reporting configuration response command to be sent
// 1239  * @param   direction - direction of the command
// 1240  * @param   seqNum - transaction sequence number
// 1241  *
// 1242  * @return  ZSuccess if OK
// 1243  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 1244 ZStatus_t zcl_SendReadReportCfgRspCmd( uint8 srcEP, afAddrType_t *dstAddr,
zcl_SendReadReportCfgRspCmd:
          CFI Block cfiBlock18 Using cfiCommon0
          CFI Function zcl_SendReadReportCfgRspCmd
        CODE
// 1245              uint16 clusterID, zclReadReportCfgRspCmd_t *readReportCfgRspCmd,
// 1246              uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
// 1247 {
        FUNCALL zcl_SendReadReportCfgRspCmd, zclAnalogDataType
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 28, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 28, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL zcl_SendReadReportCfgRspCmd, zclGetDataTypeLength
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 28, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 28, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL zcl_SendReadReportCfgRspCmd, osal_mem_alloc
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 28, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 28, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL zcl_SendReadReportCfgRspCmd, zclAnalogDataType
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 28, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 28, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL zcl_SendReadReportCfgRspCmd, zclSerializeData
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 28, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 28, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL zcl_SendReadReportCfgRspCmd, zcl_SendCommand
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 39, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 39, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL zcl_SendReadReportCfgRspCmd, osal_mem_free
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 28, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 28, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0x18
        LCALL   ?BANKED_ENTER_XDATA
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V15 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI V14 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V13 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI V12 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI V11 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI V10 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI V9 load(1, XDATA, add(CFA_XSP16, literal(-13)))
          CFI V8 load(1, XDATA, add(CFA_XSP16, literal(-14)))
          CFI V7 load(1, XDATA, add(CFA_XSP16, literal(-15)))
          CFI V6 load(1, XDATA, add(CFA_XSP16, literal(-16)))
          CFI V5 load(1, XDATA, add(CFA_XSP16, literal(-17)))
          CFI V4 load(1, XDATA, add(CFA_XSP16, literal(-18)))
          CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-19)))
          CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-20)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-21)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-22)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-23)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-24)))
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 24)
        ; Saved register size: 24
        ; Auto size: 4
        MOV     A,#-0x4
        LCALL   ?ALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 28)
        MOV     A,#0x2
        LCALL   ?XSTACK_DISP0_8
        MOV     A,R2
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R3
        MOVX    @DPTR,A
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     A,R4
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R5
        MOVX    @DPTR,A
        MOV     ?V0 + 12,R1
        MOV     A,#0x1c
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     ?V0 + 8,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     ?V0 + 9,A
        MOV     A,#0x1e
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     ?V0 + 15,A
        MOV     A,#0x1f
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     ?V0 + 14,A
        MOV     A,#0x20
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     ?V0 + 13,A
// 1248   uint8 *buf;
// 1249   uint16 dataLen = 0;
        MOV     ?V0 + 2,#0x0
        MOV     ?V0 + 3,#0x0
// 1250   ZStatus_t status;
// 1251 
// 1252   // Find out the data length
// 1253   for ( uint8 i = 0; i < readReportCfgRspCmd->numAttr; i++ )
        MOV     ?V0 + 0,#0x0
??zcl_SendReadReportCfgRspCmd_0:
        MOV     DPL,?V0 + 8
        MOV     DPH,?V0 + 9
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     A,?V0 + 0
        CLR     C
        SUBB    A,R0
        JC      $+5
        LJMP    ??zcl_SendReadReportCfgRspCmd_1 & 0xFFFF
// 1254   {
// 1255     zclReportCfgRspRec_t *reportRspRec = &(readReportCfgRspCmd->attrList[i]);
        MOV     A,?V0 + 0
        MOV     R0,?V0 + 0
        MOV     R1,#0x0
        MOV     A,R0
        MOV     B,#0xd
        MUL     AB
        XCH     A,R0
        MOV     R2,B
        MOV     B,#0x0
        MUL     AB
        ADD     A,R2
        MOV     R2,A
        MOV     B,#0xd
        MOV     A,R1
        MUL     AB
        ADD     A,R2
        MOV     R1,A
        MOV     A,?V0 + 8
        ADD     A,R0
        MOV     DPL,A
        MOV     A,?V0 + 9
        ADDC    A,R1
        MOV     DPH,A
        INC     DPTR
        MOV     R6,DPL
        MOV     R7,DPH
// 1256 
// 1257     dataLen += 1 + 1 + 2 ; // Status, Direction and Atrribute ID
        MOV     A,?V0 + 2
        ADD     A,#0x4
        MOV     ?V0 + 2,A
        MOV     A,?V0 + 3
        ADDC    A,#0x0
        MOV     ?V0 + 3,A
// 1258 
// 1259     if ( reportRspRec->status == ZCL_STATUS_SUCCESS )
        MOV     DPL,R6
        MOV     DPH,R7
        MOVX    A,@DPTR
        JNZ     ??zcl_SendReadReportCfgRspCmd_2
// 1260     {
// 1261       if ( reportRspRec->direction == ZCL_SEND_ATTR_REPORTS )
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        MOVX    A,@DPTR
        JNZ     ??zcl_SendReadReportCfgRspCmd_3
// 1262       {
// 1263         dataLen += 1 + 2 + 2; // Data Type + Min + Max Reporting Intervals
        MOV     A,?V0 + 2
        ADD     A,#0x5
        MOV     ?V0 + 2,A
        MOV     A,?V0 + 3
        ADDC    A,#0x0
        MOV     ?V0 + 3,A
// 1264 
// 1265         // Find out the size of the Reportable Change field (for Analog data types)
// 1266         if ( zclAnalogDataType( reportRspRec->dataType ) )
        ; Setup parameters for call to function zclAnalogDataType
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??zclAnalogDataType?relay
        MOV     A,R1
        JZ      ??zcl_SendReadReportCfgRspCmd_2
// 1267         {
// 1268           dataLen += zclGetDataTypeLength( reportRspRec->dataType );
        ; Setup parameters for call to function zclGetDataTypeLength
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??zclGetDataTypeLength?relay
        MOV     A,R1
        MOV     R0,A
        MOV     R1,#0x0
        MOV     A,?V0 + 2
        ADD     A,R0
        MOV     ?V0 + 2,A
        MOV     A,?V0 + 3
        ADDC    A,R1
        MOV     ?V0 + 3,A
        SJMP    ??zcl_SendReadReportCfgRspCmd_2
// 1269         }
// 1270       }
// 1271       else
// 1272       {
// 1273         dataLen += 2; // Timeout Period
??zcl_SendReadReportCfgRspCmd_3:
        MOV     A,?V0 + 2
        ADD     A,#0x2
        MOV     ?V0 + 2,A
        MOV     A,?V0 + 3
        ADDC    A,#0x0
        MOV     ?V0 + 3,A
// 1274       }
// 1275     }
// 1276   }
??zcl_SendReadReportCfgRspCmd_2:
        INC     ?V0 + 0
        LJMP    ??zcl_SendReadReportCfgRspCmd_0 & 0xFFFF
// 1277 
// 1278   buf = osal_mem_alloc( dataLen );
??zcl_SendReadReportCfgRspCmd_1:
        ; Setup parameters for call to function osal_mem_alloc
        MOV     R2,?V0 + 2
        MOV     R3,?V0 + 3
        LCALL   ??osal_mem_alloc?relay
        MOV     ?V0 + 0,R2
        MOV     ?V0 + 1,R3
        MOV     ?V0 + 4,?V0 + 0
        MOV     ?V0 + 5,?V0 + 1
// 1279   if ( buf != NULL )
        MOV     A,?V0 + 4
        ORL     A,?V0 + 5
        JNZ     $+5
        LJMP    ??zcl_SendReadReportCfgRspCmd_4 & 0xFFFF
// 1280   {
// 1281     // Load the buffer - serially
// 1282     uint8 *pBuf = buf;
        MOV     R6,?V0 + 4
        MOV     R7,?V0 + 5
// 1283     for ( uint8 i = 0; i < readReportCfgRspCmd->numAttr; i++ )
        MOV     ?V0 + 6,#0x0
??zcl_SendReadReportCfgRspCmd_5:
        MOV     DPL,?V0 + 8
        MOV     DPH,?V0 + 9
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     A,?V0 + 6
        CLR     C
        SUBB    A,R0
        JC      $+5
        LJMP    ??zcl_SendReadReportCfgRspCmd_6 & 0xFFFF
// 1284     {
// 1285       zclReportCfgRspRec_t *reportRspRec = &(readReportCfgRspCmd->attrList[i]);
        MOV     A,?V0 + 6
        MOV     R0,?V0 + 6
        MOV     R1,#0x0
        MOV     A,R0
        MOV     B,#0xd
        MUL     AB
        XCH     A,R0
        MOV     R2,B
        MOV     B,#0x0
        MUL     AB
        ADD     A,R2
        MOV     R2,A
        MOV     B,#0xd
        MOV     A,R1
        MUL     AB
        ADD     A,R2
        MOV     R1,A
        MOV     A,?V0 + 8
        ADD     A,R0
        MOV     DPL,A
        MOV     A,?V0 + 9
        ADDC    A,R1
        MOV     DPH,A
        INC     DPTR
        MOV     ?V0 + 0,DPL
        MOV     ?V0 + 1,DPH
// 1286 
// 1287       *pBuf++ = reportRspRec->status;
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        MOVX    A,@DPTR
        MOV     DPL,R6
        MOV     DPH,R7
        MOVX    @DPTR,A
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        MOV     R6,DPL
        MOV     R7,DPH
// 1288       *pBuf++ = reportRspRec->direction;
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPL,R6
        MOV     DPH,R7
        MOVX    @DPTR,A
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        MOV     R6,DPL
        MOV     R7,DPH
// 1289       *pBuf++ = LO_UINT16( reportRspRec->attrID );
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        MOV     DPL,R6
        MOV     DPH,R7
        MOVX    @DPTR,A
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        MOV     R6,DPL
        MOV     R7,DPH
// 1290       *pBuf++ = HI_UINT16( reportRspRec->attrID );
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        CLR     A
        MOV     A,R1
        MOV     R0,A
        MOV     DPL,R6
        MOV     DPH,R7
        MOVX    @DPTR,A
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        MOV     R6,DPL
        MOV     R7,DPH
// 1291 
// 1292       if ( reportRspRec->status == ZCL_STATUS_SUCCESS )
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        MOVX    A,@DPTR
        JZ      $+5
        LJMP    ??zcl_SendReadReportCfgRspCmd_7 & 0xFFFF
// 1293       {
// 1294         if ( reportRspRec->direction == ZCL_SEND_ATTR_REPORTS )
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        INC     DPTR
        MOVX    A,@DPTR
        JZ      $+5
        LJMP    ??zcl_SendReadReportCfgRspCmd_8 & 0xFFFF
// 1295         {
// 1296           *pBuf++ = reportRspRec->dataType;
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPL,R6
        MOV     DPH,R7
        MOVX    @DPTR,A
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        MOV     R6,DPL
        MOV     R7,DPH
// 1297           *pBuf++ = LO_UINT16( reportRspRec->minReportInt );
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        MOV     DPL,R6
        MOV     DPH,R7
        MOVX    @DPTR,A
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        MOV     R6,DPL
        MOV     R7,DPH
// 1298           *pBuf++ = HI_UINT16( reportRspRec->minReportInt );
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        CLR     A
        MOV     A,R1
        MOV     R0,A
        MOV     DPL,R6
        MOV     DPH,R7
        MOVX    @DPTR,A
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        MOV     R6,DPL
        MOV     R7,DPH
// 1299           *pBuf++ = LO_UINT16( reportRspRec->maxReportInt );
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        MOV     DPL,R6
        MOV     DPH,R7
        MOVX    @DPTR,A
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        MOV     R6,DPL
        MOV     R7,DPH
// 1300           *pBuf++ = HI_UINT16( reportRspRec->maxReportInt );
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        CLR     A
        MOV     A,R1
        MOV     R0,A
        MOV     DPL,R6
        MOV     DPH,R7
        MOVX    @DPTR,A
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        MOV     R6,DPL
        MOV     R7,DPH
// 1301 
// 1302           if ( zclAnalogDataType( reportRspRec->dataType ) )
        ; Setup parameters for call to function zclAnalogDataType
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??zclAnalogDataType?relay
        MOV     A,R1
        JZ      ??zcl_SendReadReportCfgRspCmd_7
// 1303           {
// 1304             pBuf = zclSerializeData( reportRspRec->dataType,
// 1305                                      reportRspRec->reportableChange, pBuf );
        ; Setup parameters for call to function zclSerializeData
        MOV     A,R6
        MOV     R4,A
        MOV     A,R7
        MOV     R5,A
        MOV     A,?V0 + 0
        ADD     A,#0xb
        MOV     DPL,A
        MOV     A,?V0 + 1
        ADDC    A,#0x0
        MOV     DPH,A
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??zclSerializeData?relay
        MOV     ?V0 + 10,R2
        MOV     ?V0 + 11,R3
        MOV     R6,?V0 + 10
        MOV     R7,?V0 + 11
        SJMP    ??zcl_SendReadReportCfgRspCmd_7
// 1306           }
// 1307         }
// 1308         else
// 1309         {
// 1310           *pBuf++ = LO_UINT16( reportRspRec->timeoutPeriod );
??zcl_SendReadReportCfgRspCmd_8:
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        MOV     DPL,R6
        MOV     DPH,R7
        MOVX    @DPTR,A
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        MOV     R6,DPL
        MOV     R7,DPH
// 1311           *pBuf++ = HI_UINT16( reportRspRec->timeoutPeriod );
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        CLR     A
        MOV     A,R1
        MOV     R0,A
        MOV     DPL,R6
        MOV     DPH,R7
        MOVX    @DPTR,A
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        MOV     R6,DPL
        MOV     R7,DPH
// 1312         }
// 1313       }
// 1314     }
??zcl_SendReadReportCfgRspCmd_7:
        INC     ?V0 + 6
        LJMP    ??zcl_SendReadReportCfgRspCmd_5 & 0xFFFF
// 1315 
// 1316     status = zcl_SendCommand( srcEP, dstAddr, clusterID,
// 1317                               ZCL_CMD_READ_REPORT_CFG_RSP, FALSE,
// 1318                               direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
??zcl_SendReadReportCfgRspCmd_6:
        ; Setup parameters for call to function zcl_SendCommand
        MOV     R0,#?V0 + 4
        LCALL   ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 30)
        MOV     R0,#?V0 + 2
        LCALL   ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 32)
        MOV     A,?V0 + 13
        MOV     ?V0 + 0,A
        MOV     R0,#?V0 + 0
        LCALL   ?PUSH_XSTACK_I_ONE
          CFI CFA_XSP16 add(XSP16, 33)
        CLR     A
        MOV     ?V0 + 0,A
        MOV     ?V0 + 1,A
        MOV     R0,#?V0 + 0
        LCALL   ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 35)
        MOV     A,?V0 + 14
        MOV     ?V0 + 0,A
        MOV     R0,#?V0 + 0
        LCALL   ?PUSH_XSTACK_I_ONE
          CFI CFA_XSP16 add(XSP16, 36)
        MOV     A,?V0 + 15
        MOV     ?V0 + 0,A
        MOV     R0,#?V0 + 0
        LCALL   ?PUSH_XSTACK_I_ONE
          CFI CFA_XSP16 add(XSP16, 37)
        MOV     ?V0 + 0,#0x0
        MOV     R0,#?V0 + 0
        LCALL   ?PUSH_XSTACK_I_ONE
          CFI CFA_XSP16 add(XSP16, 38)
        MOV     ?V0 + 0,#0x9
        MOV     R0,#?V0 + 0
        LCALL   ?PUSH_XSTACK_I_ONE
          CFI CFA_XSP16 add(XSP16, 39)
        MOV     A,#0xb
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R4,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R5,A
        MOV     A,#0xd
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        MOV     R1,?V0 + 12
        LCALL   ??zcl_SendCommand?relay
        MOV     A,#0xb
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 28)
        MOV     A,R1
        MOV     ?V0 + 7,A
// 1319     osal_mem_free( buf );
        ; Setup parameters for call to function osal_mem_free
        MOV     R2,?V0 + 4
        MOV     R3,?V0 + 5
        LCALL   ??osal_mem_free?relay
        SJMP    ??zcl_SendReadReportCfgRspCmd_9
// 1320   }
// 1321   else
// 1322   {
// 1323     status = ZMemError;
??zcl_SendReadReportCfgRspCmd_4:
        MOV     ?V0 + 7,#0x10
// 1324   }
// 1325 
// 1326   return ( status );
??zcl_SendReadReportCfgRspCmd_9:
        MOV     R1,?V0 + 7
        MOV     A,#0x4
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 24)
        MOV     R7,#0x10
        LJMP    ?BANKED_LEAVE_XDATA
          CFI EndBlock cfiBlock18
// 1327 }
// 1328 
// 1329 /*********************************************************************
// 1330  * @fn      zcl_SendReportCmd
// 1331  *
// 1332  * @brief   Send a Report command
// 1333  *
// 1334  * @param   dstAddr - destination address
// 1335  * @param   clusterID - cluster ID
// 1336  * @param   reportCmd - report command to be sent
// 1337  * @param   direction - direction of the command
// 1338  * @param   seqNum - transaction sequence number
// 1339  *
// 1340  * @return  ZSuccess if OK
// 1341  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 1342 ZStatus_t zcl_SendReportCmd( uint8 srcEP, afAddrType_t *dstAddr,
zcl_SendReportCmd:
          CFI Block cfiBlock19 Using cfiCommon0
          CFI Function zcl_SendReportCmd
        CODE
// 1343                              uint16 clusterID, zclReportCmd_t *reportCmd,
// 1344                              uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
// 1345 {
        FUNCALL zcl_SendReportCmd, zclGetAttrDataLength
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 28, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 28, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL zcl_SendReportCmd, osal_mem_alloc
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 28, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 28, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL zcl_SendReportCmd, zclSerializeData
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 28, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 28, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL zcl_SendReportCmd, zcl_SendCommand
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 39, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 39, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL zcl_SendReportCmd, osal_mem_free
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 28, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 28, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0x18
        LCALL   ?BANKED_ENTER_XDATA
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V15 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI V14 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V13 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI V12 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI V11 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI V10 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI V9 load(1, XDATA, add(CFA_XSP16, literal(-13)))
          CFI V8 load(1, XDATA, add(CFA_XSP16, literal(-14)))
          CFI V7 load(1, XDATA, add(CFA_XSP16, literal(-15)))
          CFI V6 load(1, XDATA, add(CFA_XSP16, literal(-16)))
          CFI V5 load(1, XDATA, add(CFA_XSP16, literal(-17)))
          CFI V4 load(1, XDATA, add(CFA_XSP16, literal(-18)))
          CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-19)))
          CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-20)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-21)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-22)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-23)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-24)))
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 24)
        ; Saved register size: 24
        ; Auto size: 4
        MOV     A,#-0x4
        LCALL   ?ALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 28)
        MOV     A,#0x2
        LCALL   ?XSTACK_DISP0_8
        MOV     A,R2
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R3
        MOVX    @DPTR,A
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     A,R4
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R5
        MOVX    @DPTR,A
        MOV     ?V0 + 12,R1
        MOV     A,#0x1c
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     ?V0 + 8,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     ?V0 + 9,A
        MOV     A,#0x1e
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     ?V0 + 15,A
        MOV     A,#0x1f
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     ?V0 + 14,A
        MOV     A,#0x20
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     ?V0 + 13,A
// 1346   uint16 dataLen = 0;
        MOV     R6,#0x0
        MOV     R7,#0x0
// 1347   uint8 *buf;
// 1348   ZStatus_t status;
// 1349 
// 1350   // calculate the size of the command
// 1351   for ( uint8 i = 0; i < reportCmd->numAttr; i++ )
        MOV     ?V0 + 4,#0x0
??zcl_SendReportCmd_0:
        MOV     DPL,?V0 + 8
        MOV     DPH,?V0 + 9
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     A,?V0 + 4
        CLR     C
        SUBB    A,R0
        JNC     ??zcl_SendReportCmd_1
// 1352   {
// 1353     zclReport_t *reportRec = &(reportCmd->attrList[i]);
        MOV     A,?V0 + 4
        MOV     R0,?V0 + 4
        MOV     R1,#0x0
        MOV     A,R0
        MOV     B,#0x5
        MUL     AB
        XCH     A,R0
        MOV     R2,B
        MOV     B,#0x0
        MUL     AB
        ADD     A,R2
        MOV     R2,A
        MOV     B,#0x5
        MOV     A,R1
        MUL     AB
        ADD     A,R2
        MOV     R1,A
        MOV     A,?V0 + 8
        ADD     A,R0
        MOV     DPL,A
        MOV     A,?V0 + 9
        ADDC    A,R1
        MOV     DPH,A
        INC     DPTR
        MOV     ?V0 + 0,DPL
        MOV     ?V0 + 1,DPH
// 1354 
// 1355     dataLen += 2 + 1; // Attribute ID + data type
        MOV     A,R6
        ADD     A,#0x3
        MOV     R6,A
        MOV     A,R7
        ADDC    A,#0x0
        MOV     R7,A
// 1356 
// 1357     // Attribute Data
// 1358     dataLen += zclGetAttrDataLength( reportRec->dataType, reportRec->attrData );
        ; Setup parameters for call to function zclGetAttrDataLength
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??zclGetAttrDataLength?relay
        MOV     ?V0 + 2,R2
        MOV     ?V0 + 3,R3
        MOV     A,R6
        ADD     A,?V0 + 2
        MOV     R6,A
        MOV     A,R7
        ADDC    A,?V0 + 3
        MOV     R7,A
// 1359   }
        INC     ?V0 + 4
        SJMP    ??zcl_SendReportCmd_0
// 1360 
// 1361   buf = osal_mem_alloc( dataLen );
??zcl_SendReportCmd_1:
        ; Setup parameters for call to function osal_mem_alloc
        MOV     A,R6
        MOV     R2,A
        MOV     A,R7
        MOV     R3,A
        LCALL   ??osal_mem_alloc?relay
        MOV     ?V0 + 0,R2
        MOV     ?V0 + 1,R3
        MOV     ?V0 + 6,?V0 + 0
        MOV     ?V0 + 7,?V0 + 1
// 1362   if ( buf != NULL )
        MOV     A,?V0 + 6
        ORL     A,?V0 + 7
        JNZ     $+5
        LJMP    ??zcl_SendReportCmd_2 & 0xFFFF
// 1363   {
// 1364     // Load the buffer - serially
// 1365     uint8 *pBuf = buf;
        MOV     ?V0 + 0,?V0 + 6
        MOV     ?V0 + 1,?V0 + 7
// 1366     for ( uint8 i = 0; i < reportCmd->numAttr; i++ )
        MOV     ?V0 + 4,#0x0
??zcl_SendReportCmd_3:
        MOV     DPL,?V0 + 8
        MOV     DPH,?V0 + 9
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     A,?V0 + 4
        CLR     C
        SUBB    A,R0
        JC      $+5
        LJMP    ??zcl_SendReportCmd_4 & 0xFFFF
// 1367     {
// 1368       zclReport_t *reportRec = &(reportCmd->attrList[i]);
        MOV     A,?V0 + 4
        MOV     R0,?V0 + 4
        MOV     R1,#0x0
        MOV     A,R0
        MOV     B,#0x5
        MUL     AB
        XCH     A,R0
        MOV     R2,B
        MOV     B,#0x0
        MUL     AB
        ADD     A,R2
        MOV     R2,A
        MOV     B,#0x5
        MOV     A,R1
        MUL     AB
        ADD     A,R2
        MOV     R1,A
        MOV     A,?V0 + 8
        ADD     A,R0
        MOV     DPL,A
        MOV     A,?V0 + 9
        ADDC    A,R1
        MOV     DPH,A
        INC     DPTR
        MOV     ?V0 + 2,DPL
        MOV     ?V0 + 3,DPH
// 1369 
// 1370       *pBuf++ = LO_UINT16( reportRec->attrID );
        MOV     DPL,?V0 + 2
        MOV     DPH,?V0 + 3
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        MOVX    @DPTR,A
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        INC     DPTR
        MOV     ?V0 + 0,DPL
        MOV     ?V0 + 1,DPH
// 1371       *pBuf++ = HI_UINT16( reportRec->attrID );
        MOV     DPL,?V0 + 2
        MOV     DPH,?V0 + 3
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        CLR     A
        MOV     A,R1
        MOV     R0,A
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        MOVX    @DPTR,A
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        INC     DPTR
        MOV     ?V0 + 0,DPL
        MOV     ?V0 + 1,DPH
// 1372       *pBuf++ = reportRec->dataType;
        MOV     DPL,?V0 + 2
        MOV     DPH,?V0 + 3
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        MOVX    @DPTR,A
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        INC     DPTR
        MOV     ?V0 + 0,DPL
        MOV     ?V0 + 1,DPH
// 1373 
// 1374       pBuf = zclSerializeData( reportRec->dataType, reportRec->attrData, pBuf );
        ; Setup parameters for call to function zclSerializeData
        MOV     R4,?V0 + 0
        MOV     R5,?V0 + 1
        MOV     DPL,?V0 + 2
        MOV     DPH,?V0 + 3
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        MOV     DPL,?V0 + 2
        MOV     DPH,?V0 + 3
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??zclSerializeData?relay
        MOV     ?V0 + 10,R2
        MOV     ?V0 + 11,R3
        MOV     ?V0 + 0,?V0 + 10
        MOV     ?V0 + 1,?V0 + 11
// 1375     }
        INC     ?V0 + 4
        LJMP    ??zcl_SendReportCmd_3 & 0xFFFF
// 1376 
// 1377     status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_REPORT, FALSE,
// 1378                               direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
??zcl_SendReportCmd_4:
        ; Setup parameters for call to function zcl_SendCommand
        MOV     R0,#?V0 + 6
        LCALL   ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 30)
        MOV     ?V0 + 2,R6
        MOV     ?V0 + 3,R7
        MOV     R0,#?V0 + 2
        LCALL   ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 32)
        MOV     A,?V0 + 13
        MOV     ?V0 + 2,A
        MOV     R0,#?V0 + 2
        LCALL   ?PUSH_XSTACK_I_ONE
          CFI CFA_XSP16 add(XSP16, 33)
        CLR     A
        MOV     ?V0 + 2,A
        MOV     ?V0 + 3,A
        MOV     R0,#?V0 + 2
        LCALL   ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 35)
        MOV     A,?V0 + 14
        MOV     ?V0 + 2,A
        MOV     R0,#?V0 + 2
        LCALL   ?PUSH_XSTACK_I_ONE
          CFI CFA_XSP16 add(XSP16, 36)
        MOV     A,?V0 + 15
        MOV     ?V0 + 2,A
        MOV     R0,#?V0 + 2
        LCALL   ?PUSH_XSTACK_I_ONE
          CFI CFA_XSP16 add(XSP16, 37)
        MOV     ?V0 + 2,#0x0
        MOV     R0,#?V0 + 2
        LCALL   ?PUSH_XSTACK_I_ONE
          CFI CFA_XSP16 add(XSP16, 38)
        MOV     ?V0 + 2,#0xa
        MOV     R0,#?V0 + 2
        LCALL   ?PUSH_XSTACK_I_ONE
          CFI CFA_XSP16 add(XSP16, 39)
        MOV     A,#0xb
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R4,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R5,A
        MOV     A,#0xd
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        MOV     R1,?V0 + 12
        LCALL   ??zcl_SendCommand?relay
        MOV     A,#0xb
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 28)
        MOV     A,R1
        MOV     ?V0 + 5,A
// 1379     osal_mem_free( buf );
        ; Setup parameters for call to function osal_mem_free
        MOV     R2,?V0 + 6
        MOV     R3,?V0 + 7
        LCALL   ??osal_mem_free?relay
        SJMP    ??zcl_SendReportCmd_5
// 1380   }
// 1381   else
// 1382   {
// 1383     status = ZMemError;
??zcl_SendReportCmd_2:
        MOV     ?V0 + 5,#0x10
// 1384   }
// 1385 
// 1386   return ( status );
??zcl_SendReportCmd_5:
        MOV     R1,?V0 + 5
        MOV     A,#0x4
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 24)
        MOV     R7,#0x10
        LJMP    ?BANKED_LEAVE_XDATA
          CFI EndBlock cfiBlock19
// 1387 }
// 1388 #endif // ZCL_REPORT
// 1389 
// 1390 /*********************************************************************
// 1391  * @fn      zcl_SendDefaultRspCmd
// 1392  *
// 1393  * @brief   Send a Default Response command
// 1394  *
// 1395  *          Note: The manufacturer code field should be set if this
// 1396  *          command is being sent in response to a manufacturer specific
// 1397  *          command.
// 1398  *
// 1399  * @param   dstAddr - destination address
// 1400  * @param   clusterID - cluster ID
// 1401  * @param   defaultRspCmd - default response command to be sent
// 1402  * @param   direction - direction of the command
// 1403  * @param   manuCode - manufacturer code for proprietary extensions to a profile
// 1404  * @param   seqNum - transaction sequence number
// 1405  *
// 1406  * @return  ZSuccess if OK
// 1407  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 1408 ZStatus_t zcl_SendDefaultRspCmd( uint8 srcEP, afAddrType_t *dstAddr, uint16 clusterID,
zcl_SendDefaultRspCmd:
          CFI Block cfiBlock20 Using cfiCommon0
          CFI Function zcl_SendDefaultRspCmd
        CODE
// 1409                                  zclDefaultRspCmd_t *defaultRspCmd, uint8 direction,
// 1410                                  uint8 disableDefaultRsp, uint16 manuCode, uint8 seqNum )
// 1411 {
        FUNCALL zcl_SendDefaultRspCmd, zcl_SendCommand
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 33, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 33, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0x14
        LCALL   ?BANKED_ENTER_XDATA
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V11 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI V10 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V9 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI V8 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI V7 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI V6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI V5 load(1, XDATA, add(CFA_XSP16, literal(-13)))
          CFI V4 load(1, XDATA, add(CFA_XSP16, literal(-14)))
          CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-15)))
          CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-16)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-17)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-18)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-19)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-20)))
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 20)
        ; Saved register size: 20
        ; Auto size: 2
        MOV     A,#-0x2
        LCALL   ?ALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 22)
        MOV     ?V0 + 5,R1
        MOV     ?V0 + 10,R2
        MOV     ?V0 + 11,R3
        MOV     ?V0 + 6,R4
        MOV     ?V0 + 7,R5
        MOV     A,#0x16
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     ?V0 + 0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     ?V0 + 1,A
        MOV     A,#0x18
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     ?V0 + 2,A
        MOV     A,#0x19
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     ?V0 + 3,A
        MOV     A,#0x1a
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R6,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R7,A
        MOV     A,#0x1c
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     ?V0 + 4,A
// 1412   uint8 buf[2]; // Command ID and Status;
// 1413 
// 1414   // Load the buffer - serially
// 1415   buf[0] = defaultRspCmd->commandID;
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        MOVX    A,@DPTR
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    @DPTR,A
// 1416   buf[1] = defaultRspCmd->statusCode;
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        INC     DPTR
        MOVX    A,@DPTR
        PUSH    A
          CFI CFA_SP SP+-1
        MOV     A,#0x1
        LCALL   ?XSTACK_DISP0_8
        POP     A
          CFI CFA_SP SP+0
        MOVX    @DPTR,A
// 1417 
// 1418   return ( zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_DEFAULT_RSP, FALSE,
// 1419                             direction, disableDefaultRsp, manuCode, seqNum, 2, buf ) );
        ; Setup parameters for call to function zcl_SendCommand
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     ?V0 + 8,DPL
        MOV     ?V0 + 9,DPH
        MOV     R0,#?V0 + 8
        LCALL   ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 24)
        MOV     ?V0 + 8,#0x2
        MOV     ?V0 + 9,#0x0
        MOV     R0,#?V0 + 8
        LCALL   ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 26)
        MOV     A,?V0 + 4
        MOV     ?V0 + 8,A
        MOV     R0,#?V0 + 8
        LCALL   ?PUSH_XSTACK_I_ONE
          CFI CFA_XSP16 add(XSP16, 27)
        MOV     ?V0 + 8,R6
        MOV     ?V0 + 9,R7
        MOV     R0,#?V0 + 8
        LCALL   ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 29)
        MOV     A,?V0 + 3
        MOV     ?V0 + 8,A
        MOV     R0,#?V0 + 8
        LCALL   ?PUSH_XSTACK_I_ONE
          CFI CFA_XSP16 add(XSP16, 30)
        MOV     A,?V0 + 2
        MOV     ?V0 + 8,A
        MOV     R0,#?V0 + 8
        LCALL   ?PUSH_XSTACK_I_ONE
          CFI CFA_XSP16 add(XSP16, 31)
        MOV     ?V0 + 8,#0x0
        MOV     R0,#?V0 + 8
        LCALL   ?PUSH_XSTACK_I_ONE
          CFI CFA_XSP16 add(XSP16, 32)
        MOV     ?V0 + 8,#0xb
        MOV     R0,#?V0 + 8
        LCALL   ?PUSH_XSTACK_I_ONE
          CFI CFA_XSP16 add(XSP16, 33)
        MOV     R4,?V0 + 6
        MOV     R5,?V0 + 7
        MOV     R2,?V0 + 10
        MOV     R3,?V0 + 11
        MOV     R1,?V0 + 5
        LCALL   ??zcl_SendCommand?relay
        MOV     A,#0xb
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 22)
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 20)
        MOV     R7,#0xc
        LJMP    ?BANKED_LEAVE_XDATA
          CFI EndBlock cfiBlock20
// 1420 }
// 1421 
// 1422 #ifdef ZCL_DISCOVER
// 1423 /*********************************************************************
// 1424  * @fn      zcl_SendDiscoverCmd
// 1425  *
// 1426  * @brief   Send a Discover command
// 1427  *
// 1428  * @param   dstAddr - destination address
// 1429  * @param   clusterID - cluster ID
// 1430  * @param   discoverCmd - discover command to be sent
// 1431  * @param   direction - direction of the command
// 1432  * @param   seqNum - transaction sequence number
// 1433  *
// 1434  * @return  ZSuccess if OK
// 1435  */
// 1436 ZStatus_t zcl_SendDiscoverCmd( uint8 srcEP, afAddrType_t *dstAddr,
// 1437                             uint16 clusterID, zclDiscoverCmd_t *discoverCmd,
// 1438                             uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
// 1439 {
// 1440   uint16 dataLen = 2 + 1; // Start Attribute ID and Max Attribute IDs
// 1441   uint8 *buf;
// 1442   ZStatus_t status;
// 1443 
// 1444   buf = osal_mem_alloc( dataLen );
// 1445   if ( buf != NULL )
// 1446   {
// 1447     // Load the buffer - serially
// 1448     uint8 *pBuf = buf;
// 1449     *pBuf++ = LO_UINT16(discoverCmd->startAttr);
// 1450     *pBuf++ = HI_UINT16(discoverCmd->startAttr);
// 1451     *pBuf++ = discoverCmd->maxAttrIDs;
// 1452 
// 1453     status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_DISCOVER, FALSE,
// 1454                               direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
// 1455     osal_mem_free( buf );
// 1456   }
// 1457   else
// 1458   {
// 1459     status = ZMemError;
// 1460   }
// 1461 
// 1462   return ( status );
// 1463 }
// 1464 
// 1465 /*********************************************************************
// 1466  * @fn      zcl_SendDiscoverRspCmd
// 1467  *
// 1468  * @brief   Send a Discover Response command
// 1469  *
// 1470  * @param   dstAddr - destination address
// 1471  * @param   clusterID - cluster ID
// 1472  * @param   reportRspCmd - report response command to be sent
// 1473  * @param   direction - direction of the command
// 1474  * @param   seqNum - transaction sequence number
// 1475  *
// 1476  * @return  ZSuccess if OK
// 1477  */
// 1478 ZStatus_t zcl_SendDiscoverRspCmd( uint8 srcEP, afAddrType_t *dstAddr,
// 1479                       uint16 clusterID, zclDiscoverRspCmd_t *discoverRspCmd,
// 1480                       uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
// 1481 {
// 1482   uint16 dataLen = 1; // Discovery complete
// 1483   uint8 *buf;
// 1484   ZStatus_t status;
// 1485 
// 1486   // calculate the size of the command
// 1487   dataLen += discoverRspCmd->numAttr * (2 + 1); // Attribute ID and Data Type
// 1488 
// 1489   buf = osal_mem_alloc( dataLen );
// 1490   if ( buf != NULL )
// 1491   {
// 1492     // Load the buffer - serially
// 1493     uint8 *pBuf = buf;
// 1494     *pBuf++ = discoverRspCmd->discComplete;
// 1495     for ( uint8 i = 0; i < discoverRspCmd->numAttr; i++ )
// 1496     {
// 1497       *pBuf++ = LO_UINT16(discoverRspCmd->attrList[i].attrID);
// 1498       *pBuf++ = HI_UINT16(discoverRspCmd->attrList[i].attrID);
// 1499       *pBuf++ = discoverRspCmd->attrList[i].dataType;
// 1500     }
// 1501 
// 1502     status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_DISCOVER_RSP, FALSE,
// 1503                               direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
// 1504     osal_mem_free( buf );
// 1505   }
// 1506   else
// 1507   {
// 1508     status = ZMemError;
// 1509   }
// 1510 
// 1511   return ( status );
// 1512 }
// 1513 #endif // ZCL_DISCOVER
// 1514 
// 1515 /*********************************************************************
// 1516  * PRIVATE FUNCTIONS
// 1517  *********************************************************************/
// 1518 
// 1519 /*********************************************************************
// 1520  * @fn      zclProcessMessageMSG
// 1521  *
// 1522  * @brief   Data message processor callback.  This function processes
// 1523  *          any incoming data - probably from other devices.  So, based
// 1524  *          on cluster ID, perform the intended action.
// 1525  *
// 1526  * @param   pkt - incoming message
// 1527  *
// 1528  * @return  none
// 1529  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 1530 void zclProcessMessageMSG( afIncomingMSGPacket_t *pkt )
zclProcessMessageMSG:
          CFI Block cfiBlock21 Using cfiCommon0
          CFI Function zclProcessMessageMSG
        CODE
// 1531 {
        FUNCALL zclProcessMessageMSG, zclParseHdr
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 39, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 39, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL zclProcessMessageMSG, afFindEndPointDesc
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 39, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 39, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL zclProcessMessageMSG, zcl_DeviceOperational
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 41, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 41, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL zclProcessMessageMSG, StubAPS_InterPan
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 39, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 39, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL zclProcessMessageMSG, zclGetClusterOption
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 39, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 39, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL zclProcessMessageMSG, zclFindPlugin
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 39, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 39, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL zclProcessMessageMSG, zclSetSecurityOption
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 39, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 39, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL zclProcessMessageMSG, zcl_SendDefaultRspCmd
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 46, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 46, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL zclProcessMessageMSG, zclSetSecurityOption
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 39, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 39, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL zclProcessMessageMSG, osal_mem_free
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 39, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 39, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL zclProcessMessageMSG, zcl_SendDefaultRspCmd
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 46, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 46, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0x12
        LCALL   ?BANKED_ENTER_XDATA
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V9 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI V8 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V7 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI V6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI V5 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI V4 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-13)))
          CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-14)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-15)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-16)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-17)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-18)))
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 18)
        ; Saved register size: 18
        ; Auto size: 21
        MOV     A,#-0x15
        LCALL   ?ALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 39)
        MOV     ?V0 + 0,R2
        MOV     ?V0 + 1,R3
// 1532   endPointDesc_t *epDesc;
// 1533   zclIncoming_t inMsg;
// 1534   zclLibPlugin_t *pInPlugin;
// 1535   zclDefaultRspCmd_t defautlRspCmd;
// 1536   uint8 options;
// 1537   uint8 securityEnable;
// 1538   uint8 interPanMsg;
// 1539   ZStatus_t status = ZFailure;
        MOV     R6,#0x1
// 1540 
// 1541   if ( pkt->cmd.DataLength == 0 )
        MOV     A,?V0 + 0
        ADD     A,#0x20
        MOV     DPL,A
        MOV     A,?V0 + 1
        ADDC    A,#0x0
        MOV     DPH,A
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JNZ     $+5
        LJMP    ??zclProcessMessageMSG_0 & 0xFFFF
// 1542   {
// 1543     return;   // Error, ignore the message
// 1544   }
// 1545 
// 1546   // Initialize
// 1547   inMsg.msg = pkt;
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     A,?V0 + 0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,?V0 + 1
        MOVX    @DPTR,A
// 1548   inMsg.attrCmd = NULL;
        MOV     A,#0xc
        LCALL   ?XSTACK_DISP0_8
        MOV     A,#0x0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
// 1549   inMsg.pData = NULL;
        MOV     A,#0x8
        LCALL   ?XSTACK_DISP0_8
        MOV     A,#0x0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
// 1550   inMsg.pDataLen = 0;
        MOV     A,#0xa
        LCALL   ?XSTACK_DISP0_8
        MOV     A,#0x0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
// 1551 
// 1552   inMsg.pData = zclParseHdr( &(inMsg.hdr), pkt->cmd.Data );
        ; Setup parameters for call to function zclParseHdr
        MOV     A,?V0 + 0
        ADD     A,#0x22
        MOV     DPL,A
        MOV     A,?V0 + 1
        ADDC    A,#0x0
        MOV     DPH,A
        MOVX    A,@DPTR
        MOV     R4,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R5,A
        MOV     A,#0x2
        LCALL   ?XSTACK_DISP0_8
        MOV     R2,DPL
        MOV     R3,DPH
        LCALL   ??zclParseHdr?relay
        MOV     A,#0x8
        LCALL   ?XSTACK_DISP0_8
        MOV     A,R2
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R3
        MOVX    @DPTR,A
// 1553   inMsg.pDataLen = pkt->cmd.DataLength;
        MOV     A,?V0 + 0
        ADD     A,#0x20
        MOV     DPL,A
        MOV     A,?V0 + 1
        ADDC    A,#0x0
        MOV     DPH,A
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,#0xa
        LCALL   ?XSTACK_DISP0_8
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
// 1554   inMsg.pDataLen -= (uint16)(inMsg.pData - pkt->cmd.Data);
        MOV     A,#0xa
        LCALL   ?XSTACK_DISP0_8
        PUSH    DPL
          CFI CFA_SP SP+-1
        PUSH    DPH
          CFI CFA_SP SP+-2
        MOV     A,#0x8
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        POP     DPH
          CFI CFA_SP SP+-1
        POP     DPL
          CFI CFA_SP SP+0
        MOVX    A,@DPTR
        CLR     C
        SUBB    A,R0
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        SUBB    A,R1
        MOV     R1,A
        MOV     A,?V0 + 0
        ADD     A,#0x22
        MOV     DPL,A
        MOV     A,?V0 + 1
        ADDC    A,#0x0
        MOV     DPH,A
        MOVX    A,@DPTR
        ADD     A,R0
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,R1
        MOV     R1,A
        MOV     A,#0xa
        LCALL   ?XSTACK_DISP0_8
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
// 1555 
// 1556   // Find the wanted endpoint
// 1557   epDesc = afFindEndPointDesc( pkt->endPoint );
        ; Setup parameters for call to function afFindEndPointDesc
        MOV     A,?V0 + 0
        ADD     A,#0x14
        MOV     DPL,A
        MOV     A,?V0 + 1
        ADDC    A,#0x0
        MOV     DPH,A
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??afFindEndPointDesc?relay
        MOV     ?V0 + 8,R2
        MOV     ?V0 + 9,R3
        MOV     ?V0 + 6,?V0 + 8
        MOV     ?V0 + 7,?V0 + 9
// 1558   if ( epDesc == NULL )
        MOV     A,?V0 + 6
        ORL     A,?V0 + 7
        JNZ     $+5
        LJMP    ??zclProcessMessageMSG_0 & 0xFFFF
// 1559   {
// 1560     return;   // Error, ignore the message
// 1561   }
// 1562 
// 1563   if ( ( epDesc->simpleDesc == NULL ) ||
// 1564        ( zcl_DeviceOperational( pkt->endPoint, pkt->clusterId, inMsg.hdr.fc.type,
// 1565                                 inMsg.hdr.commandID, epDesc->simpleDesc->AppProfId ) == FALSE ) )
        MOV     DPL,?V0 + 6
        MOV     DPH,?V0 + 7
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JZ      ??zclProcessMessageMSG_1
        ; Setup parameters for call to function zcl_DeviceOperational
        MOV     DPL,?V0 + 6
        MOV     DPH,?V0 + 7
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        INC     DPTR
        LCALL   ?PUSH_XSTACK8_X_TWO
          CFI CFA_XSP16 add(XSP16, 41)
        MOV     A,#0x9
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R5,A
        MOV     A,#0x4
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ANL     A,#0x3
        MOV     R4,A
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        MOV     A,?V0 + 0
        ADD     A,#0x14
        MOV     DPL,A
        MOV     A,?V0 + 1
        ADDC    A,#0x0
        MOV     DPH,A
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??zcl_DeviceOperational?relay
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 39)
        MOV     A,R1
        JNZ     ??zclProcessMessageMSG_2
// 1566   {
// 1567     return; // Error, ignore the message
??zclProcessMessageMSG_1:
        LJMP    ??zclProcessMessageMSG_0 & 0xFFFF
// 1568   }
// 1569 
// 1570 #if defined ( INTER_PAN )
// 1571   if ( StubAPS_InterPan( pkt->srcAddr.panId, pkt->srcAddr.endPoint ) )
??zclProcessMessageMSG_2:
        ; Setup parameters for call to function StubAPS_InterPan
        MOV     A,?V0 + 0
        ADD     A,#0xf
        MOV     DPL,A
        MOV     A,?V0 + 1
        ADDC    A,#0x0
        MOV     DPH,A
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,?V0 + 0
        ADD     A,#0x10
        MOV     DPL,A
        MOV     A,?V0 + 1
        ADDC    A,#0x0
        MOV     DPH,A
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        LCALL   ??StubAPS_InterPan?relay
        MOV     A,R1
        JZ      ??zclProcessMessageMSG_3
// 1572   {
// 1573     // No foundation command is supported thru Inter-PAN communication.
// 1574     // But the Smart Light cluster uses a different Frame Control format
// 1575     // for it's Inter-PAN messages, where the messages could be confused
// 1576     // with the foundation commands.
// 1577     if ( !ZCL_CLUSTER_ID_SL( pkt->clusterId ) && zcl_ProfileCmd( inMsg.hdr.fc.type ) )
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        XRL     A,#0x0
        JNZ     ??zclProcessMessageMSG_4
        INC     DPTR
        MOVX    A,@DPTR
        XRL     A,#0x10
??zclProcessMessageMSG_4:
        JZ      ??zclProcessMessageMSG_5
        MOV     A,#0x2
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        ANL     A,#0x3
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ANL     A,#0x0
        MOV     R1,A
        MOV     A,R0
        JNZ     $+5
        LJMP    ??zclProcessMessageMSG_0 & 0xFFFF
// 1578     {
// 1579       return;
// 1580     }
// 1581 
// 1582     interPanMsg = TRUE;
??zclProcessMessageMSG_5:
        MOV     R7,#0x1
// 1583     options = AF_TX_OPTIONS_NONE;
        MOV     ?V0 + 2,#0x0
        SJMP    ??zclProcessMessageMSG_6
// 1584   }
// 1585   else
// 1586 #endif
// 1587   {
// 1588     interPanMsg = FALSE;
??zclProcessMessageMSG_3:
        MOV     R7,#0x0
// 1589     options = zclGetClusterOption( pkt->endPoint, pkt->clusterId );
        ; Setup parameters for call to function zclGetClusterOption
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        MOV     A,?V0 + 0
        ADD     A,#0x14
        MOV     DPL,A
        MOV     A,?V0 + 1
        ADDC    A,#0x0
        MOV     DPH,A
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??zclGetClusterOption?relay
        MOV     A,R1
        MOV     ?V0 + 2,A
// 1590   }
// 1591 
// 1592   // Find the appropriate plugin
// 1593   pInPlugin = zclFindPlugin( pkt->clusterId, epDesc->simpleDesc->AppProfId );
??zclProcessMessageMSG_6:
        ; Setup parameters for call to function zclFindPlugin
        MOV     DPL,?V0 + 6
        MOV     DPH,?V0 + 7
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R4,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R5,A
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        LCALL   ??zclFindPlugin?relay
        MOV     ?V0 + 8,R2
        MOV     ?V0 + 9,R3
        MOV     ?V0 + 4,?V0 + 8
        MOV     ?V0 + 5,?V0 + 9
// 1594 
// 1595   // Local and remote Security options must match except for Default Response command
// 1596   if ( ( pInPlugin != NULL ) && !zcl_DefaultRspCmd( inMsg.hdr ) )
        MOV     A,?V0 + 4
        ORL     A,?V0 + 5
        JNZ     $+5
        LJMP    ??zclProcessMessageMSG_7 & 0xFFFF
        MOV     A,#0x2
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        ANL     A,#0x7
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ANL     A,#0x0
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JNZ     ??zclProcessMessageMSG_8
        MOV     A,#0x7
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        XRL     A,#0xb
        JNZ     $+5
        LJMP    ??zclProcessMessageMSG_7 & 0xFFFF
// 1597   {
// 1598     securityEnable = ( options & AF_EN_SECURITY ) ? TRUE : FALSE;
??zclProcessMessageMSG_8:
        MOV     A,?V0 + 2
        MOV     C,0xE0 /* A   */.6
        JNC     ??zclProcessMessageMSG_9
        SETB    B.0
        SJMP    ??zclProcessMessageMSG_10
??zclProcessMessageMSG_9:
        CLR     B.0
??zclProcessMessageMSG_10:
        MOV     C,B.0
        CLR     A
        RLC     A
        MOV     ?V0 + 3,A
// 1599     if ( pkt->SecurityUse != securityEnable )
        MOV     A,?V0 + 0
        ADD     A,#0x19
        MOV     DPL,A
        MOV     A,?V0 + 1
        ADDC    A,#0x0
        MOV     DPH,A
        MOVX    A,@DPTR
        XRL     A,?V0 + 3
        JNZ     $+5
        LJMP    ??zclProcessMessageMSG_7 & 0xFFFF
// 1600     {
// 1601       if ( UNICAST_MSG( inMsg.msg ) )
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        XCH     A,R0
        ADD     A,#0x15
        MOV     DPL,A
        MOV     A,R0
        ADDC    A,#0x0
        MOV     DPH,A
        MOVX    A,@DPTR
        JZ      $+5
        LJMP    ??zclProcessMessageMSG_0 & 0xFFFF
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JZ      $+5
        LJMP    ??zclProcessMessageMSG_0 & 0xFFFF
// 1602       {
// 1603         // Send a Default Response command back with no Application Link Key security
// 1604         if ( securityEnable )
        MOV     A,?V0 + 3
        JZ      ??zclProcessMessageMSG_11
// 1605         {
// 1606           zclSetSecurityOption( pkt->endPoint, pkt->clusterId, FALSE );
        ; Setup parameters for call to function zclSetSecurityOption
        MOV     R4,#0x0
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        MOV     A,?V0 + 0
        ADD     A,#0x14
        MOV     DPL,A
        MOV     A,?V0 + 1
        ADDC    A,#0x0
        MOV     DPH,A
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??zclSetSecurityOption?relay
// 1607         }
// 1608 
// 1609         defautlRspCmd.statusCode = status;
??zclProcessMessageMSG_11:
        MOV     A,R6
        PUSH    A
          CFI CFA_SP SP+-1
        MOV     A,#0xf
        LCALL   ?XSTACK_DISP0_8
        POP     A
          CFI CFA_SP SP+0
        MOVX    @DPTR,A
// 1610         defautlRspCmd.commandID = inMsg.hdr.commandID;
        MOV     A,#0x7
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        PUSH    A
          CFI CFA_SP SP+-1
        MOV     A,#0xe
        LCALL   ?XSTACK_DISP0_8
        POP     A
          CFI CFA_SP SP+0
        MOVX    @DPTR,A
// 1611         zcl_SendDefaultRspCmd( inMsg.msg->endPoint, &(inMsg.msg->srcAddr),
// 1612                                inMsg.msg->clusterId, &defautlRspCmd,
// 1613                                ZCL_FRAME_SERVER_CLIENT_DIR, true,
// 1614                                inMsg.hdr.manuCode, inMsg.hdr.transSeqNum );
        ; Setup parameters for call to function zcl_SendDefaultRspCmd
        MOV     A,#0x6
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     ?V0 + 8,A
        MOV     R0,#?V0 + 8
        LCALL   ?PUSH_XSTACK_I_ONE
          CFI CFA_XSP16 add(XSP16, 40)
        MOV     A,#0x5
        LCALL   ?XSTACK_DISP0_8
        LCALL   ?PUSH_XSTACK8_X_TWO
          CFI CFA_XSP16 add(XSP16, 42)
        MOV     ?V0 + 8,#0x1
        MOV     R0,#?V0 + 8
        LCALL   ?PUSH_XSTACK_I_ONE
          CFI CFA_XSP16 add(XSP16, 43)
        MOV     ?V0 + 8,#0x1
        MOV     R0,#?V0 + 8
        LCALL   ?PUSH_XSTACK_I_ONE
          CFI CFA_XSP16 add(XSP16, 44)
        MOV     A,#0x13
        LCALL   ?XSTACK_DISP0_8
        MOV     ?V0 + 8,DPL
        MOV     ?V0 + 9,DPH
        MOV     R0,#?V0 + 8
        LCALL   ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 46)
        MOV     A,#0x7
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R4,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R5,A
        MOV     A,#0x7
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        ADD     A,#0x6
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R3,A
        MOV     A,#0x7
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        XCH     A,R0
        ADD     A,#0x14
        MOV     DPL,A
        MOV     A,R0
        ADDC    A,#0x0
        MOV     DPH,A
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??zcl_SendDefaultRspCmd?relay
        MOV     A,#0x7
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 39)
        MOV     A,R1
// 1615         if ( securityEnable )
        MOV     A,?V0 + 3
        JZ      ??zclProcessMessageMSG_12
// 1616         {
// 1617           zclSetSecurityOption( pkt->endPoint, pkt->clusterId, TRUE );
        ; Setup parameters for call to function zclSetSecurityOption
        MOV     R4,#0x1
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        MOV     A,?V0 + 0
        ADD     A,#0x14
        MOV     DPL,A
        MOV     A,?V0 + 1
        ADDC    A,#0x0
        MOV     DPH,A
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??zclSetSecurityOption?relay
// 1618         }
// 1619       }
// 1620 
// 1621       return;   // Error, ignore the message
??zclProcessMessageMSG_12:
        LJMP    ??zclProcessMessageMSG_0 & 0xFFFF
// 1622     }
// 1623   }
// 1624 
// 1625   // Is this a foundation type message
// 1626   if ( !interPanMsg && zcl_ProfileCmd( inMsg.hdr.fc.type ) )
??zclProcessMessageMSG_7:
        MOV     A,R7
        JZ      $+5
        LJMP    ??zclProcessMessageMSG_13 & 0xFFFF
        MOV     A,#0x2
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        ANL     A,#0x3
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ANL     A,#0x0
        MOV     R1,A
        MOV     A,R0
        JZ      $+5
        LJMP    ??zclProcessMessageMSG_13 & 0xFFFF
// 1627   {
// 1628     if ( inMsg.hdr.fc.manuSpecific )
        MOV     A,#0x2
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        RRC     A
        RRC     A
        ANL     A,#0x3f
        MOV     R0,A
        MOV     R1,#0x0
        ANL     A,#0x1
        MOV     R0,A
        MOV     A,R1
        ANL     A,#0x0
        MOV     R1,A
        MOV     A,R0
        MOV     C,0xE0 /* A   */.0
        JNC     ??zclProcessMessageMSG_14
// 1629     {
// 1630       // We don't support any manufacturer specific command
// 1631       status = ZCL_STATUS_UNSUP_MANU_GENERAL_COMMAND;
        MOV     R6,#-0x7c
        LJMP    ??zclProcessMessageMSG_15 & 0xFFFF
// 1632     }
// 1633     else if ( ( inMsg.hdr.commandID <= ZCL_CMD_MAX ) &&
// 1634               ( zclCmdTable[inMsg.hdr.commandID].pfnParseInProfile != NULL ) )
??zclProcessMessageMSG_14:
        MOV     A,#0x7
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        CLR     C
        SUBB    A,#0xe
        JC      $+5
        LJMP    ??zclProcessMessageMSG_16 & 0xFFFF
        MOV     A,#0x7
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     R1,#0x0
        MOV     A,R0
        MOV     B,#0x4
        MUL     AB
        XCH     A,R0
        MOV     R2,B
        MOV     B,#0x0
        MUL     AB
        ADD     A,R2
        MOV     R2,A
        MOV     B,#0x4
        MOV     A,R1
        MUL     AB
        ADD     A,R2
        MOV     R1,A
        MOV     A,#zclCmdTable & 0xff
        ADD     A,R0
        MOV     DPL,A
        MOV     A,#(zclCmdTable >> 8) & 0xff
        ADDC    A,R1
        MOV     DPH,A
        CLR     A
        MOVC    A,@A+DPTR
        MOV     R0,A
        MOV     A,#0x1
        MOVC    A,@A+DPTR
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JNZ     $+5
        LJMP    ??zclProcessMessageMSG_16 & 0xFFFF
// 1635     {
// 1636       zclParseCmd_t parseCmd;
// 1637 
// 1638       parseCmd.endpoint = pkt->endPoint;
        MOV     A,?V0 + 0
        ADD     A,#0x14
        MOV     DPL,A
        MOV     A,?V0 + 1
        ADDC    A,#0x0
        MOV     DPH,A
        MOVX    A,@DPTR
        PUSH    A
          CFI CFA_SP SP+-1
        MOV     A,#0x10
        LCALL   ?XSTACK_DISP0_8
        POP     A
          CFI CFA_SP SP+0
        MOVX    @DPTR,A
// 1639       parseCmd.dataLen = inMsg.pDataLen;
        MOV     A,#0xa
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,#0x11
        LCALL   ?XSTACK_DISP0_8
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
// 1640       parseCmd.pData = inMsg.pData;
        MOV     A,#0x8
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,#0x13
        LCALL   ?XSTACK_DISP0_8
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
// 1641 
// 1642       // Parse the command, remember that the return value is a pointer to allocated memory
// 1643       inMsg.attrCmd = zclParseCmd( inMsg.hdr.commandID, &parseCmd );
        ; Setup parameters for indirect call
        MOV     A,#0x10
        LCALL   ?XSTACK_DISP0_8
        MOV     R2,DPL
        MOV     R3,DPH
        MOV     A,#0x7
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     R1,#0x0
        MOV     A,R0
        MOV     B,#0x4
        MUL     AB
        XCH     A,R0
        MOV     R4,B
        MOV     B,#0x0
        MUL     AB
        ADD     A,R4
        MOV     R4,A
        MOV     B,#0x4
        MOV     A,R1
        MUL     AB
        ADD     A,R4
        MOV     R1,A
        MOV     A,#zclCmdTable & 0xff
        ADD     A,R0
        MOV     DPL,A
        MOV     A,#(zclCmdTable >> 8) & 0xff
        ADDC    A,R1
        MOV     DPH,A
        CLR     A
        MOVC    A,@A+DPTR
        PUSH    A
        MOV     A,#0x1
        MOVC    A,@A+DPTR
        MOV     DPH,A
        POP     DPL
        LCALL   ?CALL_IND
        MOV     A,#0xc
        LCALL   ?XSTACK_DISP0_8
        MOV     A,R2
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R3
        MOVX    @DPTR,A
// 1644       if ( (inMsg.attrCmd != NULL) && (zclCmdTable[inMsg.hdr.commandID].pfnProcessInProfile != NULL) )
        MOV     A,#0xc
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JZ      ??zclProcessMessageMSG_17
        MOV     A,#0x7
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     R1,#0x0
        MOV     A,R0
        MOV     B,#0x4
        MUL     AB
        XCH     A,R0
        MOV     R2,B
        MOV     B,#0x0
        MUL     AB
        ADD     A,R2
        MOV     R2,A
        MOV     B,#0x4
        MOV     A,R1
        MUL     AB
        ADD     A,R2
        MOV     R1,A
        MOV     A,#(zclCmdTable + 2) & 0xff
        ADD     A,R0
        MOV     DPL,A
        MOV     A,#((zclCmdTable + 2) >> 8) & 0xff
        ADDC    A,R1
        MOV     DPH,A
        CLR     A
        MOVC    A,@A+DPTR
        MOV     R0,A
        MOV     A,#0x1
        MOVC    A,@A+DPTR
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JZ      ??zclProcessMessageMSG_17
// 1645       {
// 1646         // Process the command
// 1647         if ( zclProcessCmd( inMsg.hdr.commandID, &inMsg ) == FALSE )
        ; Setup parameters for indirect call
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     R2,DPL
        MOV     R3,DPH
        MOV     A,#0x7
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     R1,#0x0
        MOV     A,R0
        MOV     B,#0x4
        MUL     AB
        XCH     A,R0
        MOV     R4,B
        MOV     B,#0x0
        MUL     AB
        ADD     A,R4
        MOV     R4,A
        MOV     B,#0x4
        MOV     A,R1
        MUL     AB
        ADD     A,R4
        MOV     R1,A
        MOV     A,#(zclCmdTable + 2) & 0xff
        ADD     A,R0
        MOV     DPL,A
        MOV     A,#((zclCmdTable + 2) >> 8) & 0xff
        ADDC    A,R1
        MOV     DPH,A
        CLR     A
        MOVC    A,@A+DPTR
        PUSH    A
        MOV     A,#0x1
        MOVC    A,@A+DPTR
        MOV     DPH,A
        POP     DPL
        LCALL   ?CALL_IND
        MOV     A,R1
// 1648         {
// 1649           // Couldn't find attribute in the table.
// 1650         }
// 1651       }
// 1652 
// 1653       // Free the buffer
// 1654       if ( inMsg.attrCmd )
??zclProcessMessageMSG_17:
        MOV     A,#0xc
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JZ      ??zclProcessMessageMSG_18
// 1655       {
// 1656         osal_mem_free( inMsg.attrCmd );
        ; Setup parameters for call to function osal_mem_free
        MOV     A,#0xc
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        LCALL   ??osal_mem_free?relay
// 1657       }
// 1658 
// 1659       if ( CMD_HAS_RSP( inMsg.hdr.commandID ) )
??zclProcessMessageMSG_18:
        MOV     A,#0x7
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        JZ      ??zclProcessMessageMSG_19
        MOV     A,#0x7
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        XRL     A,#0x2
        JZ      ??zclProcessMessageMSG_19
        MOV     A,#0x7
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        XRL     A,#0x3
        JZ      ??zclProcessMessageMSG_19
        MOV     A,#0x7
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        XRL     A,#0x6
        JZ      ??zclProcessMessageMSG_19
        MOV     A,#0x7
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        XRL     A,#0x8
        JZ      ??zclProcessMessageMSG_19
        MOV     A,#0x7
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        XRL     A,#0xc
        JZ      ??zclProcessMessageMSG_19
        MOV     A,#0x7
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        XRL     A,#0xb
        JNZ     ??zclProcessMessageMSG_20
// 1660       {
// 1661         return; // We're done
??zclProcessMessageMSG_19:
        LJMP    ??zclProcessMessageMSG_0 & 0xFFFF
// 1662       }
// 1663 
// 1664       status = ZSuccess;
??zclProcessMessageMSG_20:
        MOV     R6,#0x0
        SJMP    ??zclProcessMessageMSG_15
// 1665     }
// 1666     else
// 1667     {
// 1668       // Unsupported message
// 1669       status = ZCL_STATUS_UNSUP_GENERAL_COMMAND;
??zclProcessMessageMSG_16:
        MOV     R6,#-0x7e
        SJMP    ??zclProcessMessageMSG_15
// 1670     }
// 1671   }
// 1672   else  // Not a foundation type message, so it must be specific to the cluster ID.
// 1673   {
// 1674     if ( pInPlugin && pInPlugin->pfnIncomingHdlr )
??zclProcessMessageMSG_13:
        MOV     A,?V0 + 4
        ORL     A,?V0 + 5
        JZ      ??zclProcessMessageMSG_21
        MOV     DPL,?V0 + 4
        MOV     DPH,?V0 + 5
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JZ      ??zclProcessMessageMSG_21
// 1675     {
// 1676       // The return value of the plugin function will be
// 1677       //  ZSuccess - Supported and need default response
// 1678       //  ZFailure - Unsupported
// 1679       //  ZCL_STATUS_CMD_HAS_RSP - Supported and do not need default rsp
// 1680       //  ZCL_STATUS_INVALID_FIELD - Supported, but the incoming msg is wrong formatted
// 1681       //  ZCL_STATUS_INVALID_VALUE - Supported, but the request not achievable by the h/w
// 1682       //  ZCL_STATUS_SOFTWARE_FAILURE - Supported but ZStack memory allocation fails
// 1683       status = pInPlugin->pfnIncomingHdlr( &inMsg );
        ; Setup parameters for indirect call
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     R2,DPL
        MOV     R3,DPH
        MOV     DPL,?V0 + 4
        MOV     DPH,?V0 + 5
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        LCALL   ?CALL_IND
        MOV     A,R1
        MOV     R6,A
// 1684       if ( status == ZCL_STATUS_CMD_HAS_RSP || ( interPanMsg && status == ZSuccess ) )
        MOV     A,#-0x1
        XRL     A,R6
        JZ      ??zclProcessMessageMSG_22
        MOV     A,R7
        JZ      ??zclProcessMessageMSG_21
        MOV     A,R6
        JNZ     ??zclProcessMessageMSG_21
// 1685       {
// 1686         return; // We're done
??zclProcessMessageMSG_22:
        LJMP    ??zclProcessMessageMSG_0 & 0xFFFF
// 1687       }
// 1688     }
// 1689 
// 1690     if ( status == ZFailure )
??zclProcessMessageMSG_21:
        MOV     A,#0x1
        XRL     A,R6
        JNZ     ??zclProcessMessageMSG_15
// 1691     {
// 1692       // Unsupported message
// 1693       if ( inMsg.hdr.fc.manuSpecific )
        MOV     A,#0x2
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        RRC     A
        RRC     A
        ANL     A,#0x3f
        MOV     R0,A
        MOV     R1,#0x0
        ANL     A,#0x1
        MOV     R0,A
        MOV     A,R1
        ANL     A,#0x0
        MOV     R1,A
        MOV     A,R0
        MOV     C,0xE0 /* A   */.0
        JNC     ??zclProcessMessageMSG_23
// 1694       {
// 1695         status = ZCL_STATUS_UNSUP_MANU_CLUSTER_COMMAND;
        MOV     R6,#-0x7d
        SJMP    ??zclProcessMessageMSG_15
// 1696       }
// 1697       else
// 1698       {
// 1699         status = ZCL_STATUS_UNSUP_CLUSTER_COMMAND;
??zclProcessMessageMSG_23:
        MOV     R6,#-0x7f
// 1700       }
// 1701     }
// 1702   }
// 1703 
// 1704   if ( UNICAST_MSG( inMsg.msg ) && inMsg.hdr.fc.disableDefaultRsp == 0 )
??zclProcessMessageMSG_15:
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        XCH     A,R0
        ADD     A,#0x15
        MOV     DPL,A
        MOV     A,R0
        ADDC    A,#0x0
        MOV     DPH,A
        MOVX    A,@DPTR
        JZ      $+5
        LJMP    ??zclProcessMessageMSG_0 & 0xFFFF
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JZ      $+5
        LJMP    ??zclProcessMessageMSG_0 & 0xFFFF
        MOV     A,#0x2
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        SWAP    A
        ANL     A,#0xf
        MOV     R0,A
        MOV     R1,#0x0
        ANL     A,#0x1
        MOV     R0,A
        MOV     A,R1
        ANL     A,#0x0
        MOV     R1,A
        MOV     A,R0
        MOV     C,0xE0 /* A   */.0
        JNC     $+5
        LJMP    ??zclProcessMessageMSG_0 & 0xFFFF
// 1705   {
// 1706     // Send a Default Response command back
// 1707     defautlRspCmd.statusCode = status;
        MOV     A,R6
        PUSH    A
          CFI CFA_SP SP+-1
        MOV     A,#0xf
        LCALL   ?XSTACK_DISP0_8
        POP     A
          CFI CFA_SP SP+0
        MOVX    @DPTR,A
// 1708     defautlRspCmd.commandID = inMsg.hdr.commandID;
        MOV     A,#0x7
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        PUSH    A
          CFI CFA_SP SP+-1
        MOV     A,#0xe
        LCALL   ?XSTACK_DISP0_8
        POP     A
          CFI CFA_SP SP+0
        MOVX    @DPTR,A
// 1709     zcl_SendDefaultRspCmd( inMsg.msg->endPoint, &(inMsg.msg->srcAddr),
// 1710                            inMsg.msg->clusterId, &defautlRspCmd,
// 1711                            ZCL_FRAME_SERVER_CLIENT_DIR, true,
// 1712                            inMsg.hdr.manuCode, inMsg.hdr.transSeqNum );
        ; Setup parameters for call to function zcl_SendDefaultRspCmd
        MOV     A,#0x6
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     ?V0 + 8,A
        MOV     R0,#?V0 + 8
        LCALL   ?PUSH_XSTACK_I_ONE
          CFI CFA_XSP16 add(XSP16, 40)
        MOV     A,#0x5
        LCALL   ?XSTACK_DISP0_8
        LCALL   ?PUSH_XSTACK8_X_TWO
          CFI CFA_XSP16 add(XSP16, 42)
        MOV     ?V0 + 8,#0x1
        MOV     R0,#?V0 + 8
        LCALL   ?PUSH_XSTACK_I_ONE
          CFI CFA_XSP16 add(XSP16, 43)
        MOV     ?V0 + 8,#0x1
        MOV     R0,#?V0 + 8
        LCALL   ?PUSH_XSTACK_I_ONE
          CFI CFA_XSP16 add(XSP16, 44)
        MOV     A,#0x13
        LCALL   ?XSTACK_DISP0_8
        MOV     ?V0 + 8,DPL
        MOV     ?V0 + 9,DPH
        MOV     R0,#?V0 + 8
        LCALL   ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 46)
        MOV     A,#0x7
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R4,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R5,A
        MOV     A,#0x7
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        ADD     A,#0x6
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R3,A
        MOV     A,#0x7
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        XCH     A,R0
        ADD     A,#0x14
        MOV     DPL,A
        MOV     A,R0
        ADDC    A,#0x0
        MOV     DPH,A
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??zcl_SendDefaultRspCmd?relay
        MOV     A,#0x7
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 39)
        MOV     A,R1
// 1713   }
// 1714 }
??zclProcessMessageMSG_0:
        MOV     A,#0x15
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 18)
        MOV     R7,#0xa
        LJMP    ?BANKED_LEAVE_XDATA
          CFI EndBlock cfiBlock21
// 1715 
// 1716 /*********************************************************************
// 1717  * @fn      zclParseHdr
// 1718  *
// 1719  * @brief   Parse header of the ZCL format
// 1720  *
// 1721  * @param   hdr - place to put the frame control information
// 1722  * @param   pData - incoming buffer to parse
// 1723  *
// 1724  * @return  pointer past the header
// 1725  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 1726 uint8 *zclParseHdr( zclFrameHdr_t *hdr, uint8 *pData )
zclParseHdr:
          CFI Block cfiBlock22 Using cfiCommon0
          CFI Function zclParseHdr
        CODE
// 1727 {
        FUNCALL zclParseHdr, osal_memset
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 12, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 12, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0xc
        LCALL   ?BANKED_ENTER_XDATA
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 12)
        ; Saved register size: 12
        ; Auto size: 0
        MOV     ?V0 + 0,R2
        MOV     ?V0 + 1,R3
        MOV     A,R4
        MOV     R6,A
        MOV     A,R5
        MOV     R7,A
// 1728   // Clear the header
// 1729   osal_memset( (uint8 *)hdr, 0, sizeof ( zclFrameHdr_t ) );
        ; Setup parameters for call to function osal_memset
        MOV     R4,#0x6
        MOV     R5,#0x0
        MOV     R1,#0x0
        MOV     R2,?V0 + 0
        MOV     R3,?V0 + 1
        LCALL   ??osal_memset?relay
// 1730 
// 1731   // Parse the Frame Control
// 1732   hdr->fc.type = zcl_FCType( *pData );
        MOV     DPL,R6
        MOV     DPH,R7
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     R1,#0x0
        ANL     A,#0x3
        MOV     R0,A
        MOV     A,R1
        ANL     A,#0x0
        MOV     R1,A
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        MOVX    A,@DPTR
        ANL     A,#0xfc
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        ANL     A,#0xff
        MOV     R3,A
        MOV     A,R0
        ANL     A,#0x3
        MOV     R0,A
        MOV     A,R1
        ANL     A,#0x0
        MOV     R1,A
        MOV     A,R2
        ORL     A,R0
        MOV     R0,A
        MOV     A,R3
        ORL     A,R1
        MOV     R1,A
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
// 1733   hdr->fc.manuSpecific = zcl_FCManuSpecific( *pData ) ? 1 : 0;
        MOV     DPL,R6
        MOV     DPH,R7
        MOVX    A,@DPTR
        MOV     C,0xE0 /* A   */.2
        JNC     ??zclParseHdr_0
        SETB    B.0
        SJMP    ??zclParseHdr_1
??zclParseHdr_0:
        CLR     B.0
??zclParseHdr_1:
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        MOVX    A,@DPTR
        ANL     A,#0xfb
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        ANL     A,#0xff
        MOV     R3,A
        MOV     C,B.0
        CLR     A
        RLC     A
        MOV     ?V0 + 2,A
        MOV     ?V0 + 3,#0x0
        MOV     A,#0x2
        MOV     R0,#?V0 + 2
        LCALL   ?S_SHL
        MOV     A,R2
        ORL     A,?V0 + 2
        MOV     R0,A
        MOV     A,R3
        ORL     A,?V0 + 3
        MOV     R1,A
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
// 1734   if ( zcl_FCDirection( *pData ) )
        MOV     DPL,R6
        MOV     DPH,R7
        MOVX    A,@DPTR
        MOV     C,0xE0 /* A   */.3
        JNC     ??zclParseHdr_2
// 1735   {
// 1736     hdr->fc.direction = ZCL_FRAME_SERVER_CLIENT_DIR;
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        MOVX    A,@DPTR
        ORL     A,#0x8
        MOVX    @DPTR,A
        INC     DPTR
        MOVX    A,@DPTR
        ORL     A,#0x0
        MOVX    @DPTR,A
        SJMP    ??zclParseHdr_3
// 1737   }
// 1738   else
// 1739   {
// 1740     hdr->fc.direction = ZCL_FRAME_CLIENT_SERVER_DIR;
??zclParseHdr_2:
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        MOVX    A,@DPTR
        ANL     A,#0xf7
        MOVX    @DPTR,A
        INC     DPTR
        MOVX    A,@DPTR
        ANL     A,#0xff
        MOVX    @DPTR,A
// 1741   }
// 1742 
// 1743   hdr->fc.disableDefaultRsp = zcl_FCDisableDefaultRsp( *pData ) ? 1 : 0;
??zclParseHdr_3:
        MOV     DPL,R6
        MOV     DPH,R7
        MOVX    A,@DPTR
        MOV     C,0xE0 /* A   */.4
        JNC     ??zclParseHdr_4
        SETB    B.0
        SJMP    ??zclParseHdr_5
??zclParseHdr_4:
        CLR     B.0
??zclParseHdr_5:
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        MOVX    A,@DPTR
        ANL     A,#0xef
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        ANL     A,#0xff
        MOV     R3,A
        MOV     C,B.0
        CLR     A
        RLC     A
        MOV     ?V0 + 2,A
        MOV     ?V0 + 3,#0x0
        MOV     A,#0x4
        MOV     R0,#?V0 + 2
        LCALL   ?S_SHL
        MOV     A,R2
        ORL     A,?V0 + 2
        MOV     R0,A
        MOV     A,R3
        ORL     A,?V0 + 3
        MOV     R1,A
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
// 1744   pData++;  // move past the frame control field
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        MOV     R6,DPL
        MOV     R7,DPH
// 1745 
// 1746   // parse the manfacturer code
// 1747   if ( hdr->fc.manuSpecific )
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        RRC     A
        RRC     A
        ANL     A,#0x3f
        MOV     R0,A
        MOV     R1,#0x0
        ANL     A,#0x1
        MOV     R0,A
        MOV     A,R1
        ANL     A,#0x0
        MOV     R1,A
        MOV     A,R0
        MOV     C,0xE0 /* A   */.0
        JNC     ??zclParseHdr_6
// 1748   {
// 1749     hdr->manuCode = BUILD_UINT16( pData[0], pData[1] );
        MOV     DPL,R6
        MOV     DPH,R7
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     R3,#0x0
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     R1,#0x0
        CLR     A
        XCH     A,R0
        MOV     R1,A
        MOV     A,R2
        ADD     A,R0
        MOV     R0,A
        MOV     A,R3
        ADDC    A,R1
        MOV     R1,A
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        INC     DPTR
        INC     DPTR
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
// 1750     pData += 2;
        MOV     A,R6
        ADD     A,#0x2
        MOV     R6,A
        MOV     A,R7
        ADDC    A,#0x0
        MOV     R7,A
// 1751   }
// 1752 
// 1753   // parse the Transaction Sequence Number
// 1754   hdr->transSeqNum = *pData++;
??zclParseHdr_6:
        MOV     DPL,R6
        MOV     DPH,R7
        MOVX    A,@DPTR
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    @DPTR,A
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        MOV     R6,DPL
        MOV     R7,DPH
// 1755 
// 1756   // parse the Cluster's command ID
// 1757   hdr->commandID = *pData++;
        MOV     DPL,R6
        MOV     DPH,R7
        MOVX    A,@DPTR
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    @DPTR,A
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        MOV     R6,DPL
        MOV     R7,DPH
// 1758 
// 1759   // Should point to the frame payload
// 1760   return ( pData );
        MOV     A,DPL
        MOV     R2,DPL
        MOV     A,DPH
        MOV     R3,DPH
        MOV     R7,#0x4
        LJMP    ?BANKED_LEAVE_XDATA
          CFI EndBlock cfiBlock22
// 1761 }
// 1762 
// 1763 /*********************************************************************
// 1764  * @fn      zclBuildHdr
// 1765  *
// 1766  * @brief   Build header of the ZCL format
// 1767  *
// 1768  * @param   hdr - outgoing header information
// 1769  * @param   pData - outgoing header space
// 1770  *
// 1771  * @return  pointer past the header
// 1772  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 1773 static uint8 *zclBuildHdr( zclFrameHdr_t *hdr, uint8 *pData )
zclBuildHdr:
          CFI Block cfiBlock23 Using cfiCommon0
          CFI Function zclBuildHdr
        CODE
// 1774 {
        PUSH    DPL
          CFI DPL0 Frame(CFA_SP, 4)
          CFI CFA_SP SP+-4
        PUSH    DPH
          CFI DPH0 Frame(CFA_SP, 5)
          CFI CFA_SP SP+-5
        ; Saved register size: 2
        ; Auto size: 0
        MOV     A,R2
        MOV     R0,A
        MOV     A,R3
        MOV     R1,A
        MOV     A,R4
        MOV     R2,A
        MOV     A,R5
        MOV     R3,A
// 1775   // Build the Frame Control byte
// 1776   *pData = hdr->fc.type;
        MOV     DPL,R0
        MOV     DPH,R1
        MOVX    A,@DPTR
        MOV     R4,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R5,A
        MOV     A,R4
        ANL     A,#0x3
        MOV     DPL,R2
        MOV     DPH,R3
        MOVX    @DPTR,A
// 1777   *pData |= hdr->fc.manuSpecific << 2;
        MOV     DPL,R0
        MOV     DPH,R1
        MOVX    A,@DPTR
        MOV     R4,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R5,A
        MOV     A,R4
        RRC     A
        RRC     A
        ANL     A,#0x3f
        MOV     R4,A
        MOV     R5,#0x0
        ANL     A,#0x1
        MOV     R4,A
        MOV     A,R5
        ANL     A,#0x0
        MOV     R5,A
        MOV     A,R4
        RLC     A
        RLC     A
        ANL     A,#0xfc
        MOV     R4,A
        MOV     DPL,R2
        MOV     DPH,R3
        MOVX    A,@DPTR
        ORL     A,R4
        MOVX    @DPTR,A
// 1778   *pData |= hdr->fc.direction << 3;
        MOV     DPL,R0
        MOV     DPH,R1
        MOVX    A,@DPTR
        MOV     R4,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R5,A
        MOV     A,R4
        RRC     A
        RRC     A
        RRC     A
        ANL     A,#0x1f
        MOV     R4,A
        MOV     R5,#0x0
        ANL     A,#0x1
        MOV     R4,A
        MOV     A,R5
        ANL     A,#0x0
        MOV     R5,A
        MOV     A,R4
        RLC     A
        RLC     A
        RLC     A
        ANL     A,#0xf8
        MOV     R4,A
        MOV     DPL,R2
        MOV     DPH,R3
        MOVX    A,@DPTR
        ORL     A,R4
        MOVX    @DPTR,A
// 1779   *pData |= hdr->fc.disableDefaultRsp << 4;
        MOV     DPL,R0
        MOV     DPH,R1
        MOVX    A,@DPTR
        MOV     R4,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R5,A
        MOV     A,R4
        SWAP    A
        ANL     A,#0xf
        MOV     R4,A
        MOV     R5,#0x0
        ANL     A,#0x1
        MOV     R4,A
        MOV     A,R5
        ANL     A,#0x0
        MOV     R5,A
        MOV     A,R4
        SWAP    A
        ANL     A,#0xf0
        MOV     R4,A
        MOV     DPL,R2
        MOV     DPH,R3
        MOVX    A,@DPTR
        ORL     A,R4
        MOVX    @DPTR,A
// 1780   pData++;  // move past the frame control field
        MOV     DPL,R2
        MOV     DPH,R3
        INC     DPTR
        MOV     R2,DPL
        MOV     R3,DPH
// 1781 
// 1782   // Add the manfacturer code
// 1783   if ( hdr->fc.manuSpecific )
        MOV     DPL,R0
        MOV     DPH,R1
        MOVX    A,@DPTR
        MOV     R4,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R5,A
        MOV     A,R4
        RRC     A
        RRC     A
        ANL     A,#0x3f
        MOV     R4,A
        MOV     R5,#0x0
        ANL     A,#0x1
        MOV     R4,A
        MOV     A,R5
        ANL     A,#0x0
        MOV     R5,A
        MOV     A,R4
        MOV     C,0xE0 /* A   */.0
        JNC     ??zclBuildHdr_0
// 1784   {
// 1785     *pData++ = LO_UINT16( hdr->manuCode );
        MOV     DPL,R0
        MOV     DPH,R1
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R4,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R5,A
        MOV     A,R4
        MOV     DPL,R2
        MOV     DPH,R3
        MOVX    @DPTR,A
        MOV     DPL,R2
        MOV     DPH,R3
        INC     DPTR
        MOV     R2,DPL
        MOV     R3,DPH
// 1786     *pData++ = HI_UINT16( hdr->manuCode );
        MOV     DPL,R0
        MOV     DPH,R1
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R4,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R5,A
        CLR     A
        MOV     A,R5
        MOV     R4,A
        MOV     DPL,R2
        MOV     DPH,R3
        MOVX    @DPTR,A
        MOV     DPL,R2
        MOV     DPH,R3
        INC     DPTR
        MOV     R2,DPL
        MOV     R3,DPH
// 1787   }
// 1788 
// 1789   // Add the Transaction Sequence Number
// 1790   *pData++ = hdr->transSeqNum;
??zclBuildHdr_0:
        MOV     DPL,R0
        MOV     DPH,R1
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPL,R2
        MOV     DPH,R3
        MOVX    @DPTR,A
        MOV     DPL,R2
        MOV     DPH,R3
        INC     DPTR
        MOV     R2,DPL
        MOV     R3,DPH
// 1791 
// 1792   // Add the Cluster's command ID
// 1793   *pData++ = hdr->commandID;
        MOV     DPL,R0
        MOV     DPH,R1
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPL,R2
        MOV     DPH,R3
        MOVX    @DPTR,A
        MOV     DPL,R2
        MOV     DPH,R3
        INC     DPTR
        MOV     R2,DPL
        MOV     R3,DPH
// 1794 
// 1795   // Should point to the frame payload
// 1796   return ( pData );
        POP     DPH
          CFI DPH0 SameValue
          CFI CFA_SP SP+-4
        POP     DPL
          CFI DPL0 SameValue
          CFI CFA_SP SP+-3
        LJMP    ?BRET
          CFI EndBlock cfiBlock23
// 1797 }
// 1798 
// 1799 /*********************************************************************
// 1800  * @fn      zclCalcHdrSize
// 1801  *
// 1802  * @brief   Calculate the number of bytes needed for an outgoing
// 1803  *          ZCL header.
// 1804  *
// 1805  * @param   hdr - outgoing header information
// 1806  *
// 1807  * @return  returns the number of bytes needed
// 1808  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 1809 static uint8 zclCalcHdrSize( zclFrameHdr_t *hdr )
zclCalcHdrSize:
          CFI Block cfiBlock24 Using cfiCommon0
          CFI Function zclCalcHdrSize
        CODE
// 1810 {
        PUSH    DPL
          CFI DPL0 Frame(CFA_SP, 4)
          CFI CFA_SP SP+-4
        PUSH    DPH
          CFI DPH0 Frame(CFA_SP, 5)
          CFI CFA_SP SP+-5
        ; Saved register size: 2
        ; Auto size: 0
// 1811   uint8 needed = (1 + 1 + 1); // frame control + transaction seq num + cmd ID
        MOV     R1,#0x3
// 1812 
// 1813   // Add the manfacturer code
// 1814   if ( hdr->fc.manuSpecific )
        MOV     DPL,R2
        MOV     DPH,R3
        MOVX    A,@DPTR
        MOV     R4,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R5,A
        MOV     A,R4
        RRC     A
        RRC     A
        ANL     A,#0x3f
        MOV     R4,A
        MOV     R5,#0x0
        ANL     A,#0x1
        MOV     R4,A
        MOV     A,R5
        ANL     A,#0x0
        MOV     R5,A
        MOV     A,R4
        MOV     C,0xE0 /* A   */.0
        JNC     ??zclCalcHdrSize_0
// 1815   {
// 1816     needed += 2;
        MOV     A,#0x2
        ADD     A,R1
        MOV     R1,A
// 1817   }
// 1818 
// 1819   return ( needed );
??zclCalcHdrSize_0:
        POP     DPH
          CFI DPH0 SameValue
          CFI CFA_SP SP+-4
        POP     DPL
          CFI DPL0 SameValue
          CFI CFA_SP SP+-3
        LJMP    ?BRET
          CFI EndBlock cfiBlock24
// 1820 }
// 1821 
// 1822 /*********************************************************************
// 1823  * @fn      zclFindPlugin
// 1824  *
// 1825  * @brief   Find the right plugin for a cluster ID
// 1826  *
// 1827  * @param   clusterID - cluster ID to look for
// 1828  * @param   profileID - profile ID
// 1829  *
// 1830  * @return  pointer to plugin, NULL if not found
// 1831  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 1832 static zclLibPlugin_t *zclFindPlugin( uint16 clusterID, uint16 profileID )
zclFindPlugin:
          CFI Block cfiBlock25 Using cfiCommon0
          CFI Function zclFindPlugin
        CODE
// 1833 {
        MOV     A,#-0x9
        LCALL   ?BANKED_ENTER_XDATA
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 9)
        ; Saved register size: 9
        ; Auto size: 0
        MOV     A,R2
        MOV     R6,A
        MOV     A,R3
        MOV     R7,A
// 1834   (void)profileID;  // Intentionally unreferenced parameter
// 1835 
// 1836   zclLibPlugin_t *pLoop = plugins;
        MOV     DPTR,#plugins
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
// 1837 
// 1838   while ( pLoop != NULL )
??zclFindPlugin_0:
        MOV     A,R0
        ORL     A,R1
        JZ      ??zclFindPlugin_1
// 1839   {
// 1840     if ( ( clusterID >= pLoop->startClusterID ) && ( clusterID <= pLoop->endClusterID ) )
        MOV     DPL,R0
        MOV     DPH,R1
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        CLR     C
        MOV     A,R6
        SUBB    A,R2
        MOV     A,R7
        SUBB    A,R3
        JC      ??zclFindPlugin_2
        MOV     DPL,R0
        MOV     DPH,R1
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        CLR     C
        MOVX    A,@DPTR
        SUBB    A,R6
        INC     DPTR
        MOVX    A,@DPTR
        SUBB    A,R7
        JC      ??zclFindPlugin_2
// 1841     {
// 1842       return ( pLoop );
        MOV     A,R0
        MOV     R2,A
        MOV     A,R1
        MOV     R3,A
        SJMP    ??zclFindPlugin_3
// 1843     }
// 1844 
// 1845     pLoop = pLoop->next;
??zclFindPlugin_2:
        MOV     DPL,R0
        MOV     DPH,R1
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        SJMP    ??zclFindPlugin_0
// 1846   }
// 1847 
// 1848   return ( (zclLibPlugin_t *)NULL );
??zclFindPlugin_1:
        MOV     R2,#0x0
        MOV     R3,#0x0
??zclFindPlugin_3:
        MOV     R7,#0x1
        LJMP    ?BANKED_LEAVE_XDATA
          CFI EndBlock cfiBlock25
// 1849 }
// 1850 
// 1851 /*********************************************************************
// 1852  * @fn      zclFindAttrRecsList
// 1853  *
// 1854  * @brief   Find the right attribute record list for an endpoint
// 1855  *
// 1856  * @param   clusterID - endpointto look for
// 1857  *
// 1858  * @return  pointer to record list, NULL if not found
// 1859  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 1860 static zclAttrRecsList *zclFindAttrRecsList( uint8 endpoint )
zclFindAttrRecsList:
          CFI Block cfiBlock26 Using cfiCommon0
          CFI Function zclFindAttrRecsList
        CODE
// 1861 {
        PUSH    DPL
          CFI DPL0 Frame(CFA_SP, 4)
          CFI CFA_SP SP+-4
        PUSH    DPH
          CFI DPH0 Frame(CFA_SP, 5)
          CFI CFA_SP SP+-5
        ; Saved register size: 2
        ; Auto size: 0
// 1862   zclAttrRecsList *pLoop = attrList;
        MOV     DPTR,#attrList
        MOVX    A,@DPTR
        MOV     R4,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R5,A
// 1863 
// 1864   while ( pLoop != NULL )
??zclFindAttrRecsList_0:
        MOV     A,R4
        ORL     A,R5
        JZ      ??zclFindAttrRecsList_1
// 1865   {
// 1866     if ( pLoop->endpoint == endpoint )
        MOV     DPL,R4
        MOV     DPH,R5
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        XRL     A,R1
        JNZ     ??zclFindAttrRecsList_2
// 1867     {
// 1868       return ( pLoop );
        MOV     A,R4
        MOV     R2,A
        MOV     A,R5
        MOV     R3,A
        SJMP    ??zclFindAttrRecsList_3
// 1869     }
// 1870 
// 1871     pLoop = pLoop->next;
??zclFindAttrRecsList_2:
        MOV     DPL,R4
        MOV     DPH,R5
        MOVX    A,@DPTR
        MOV     R4,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R5,A
        SJMP    ??zclFindAttrRecsList_0
// 1872   }
// 1873 
// 1874   return ( NULL );
??zclFindAttrRecsList_1:
        MOV     R2,#0x0
        MOV     R3,#0x0
??zclFindAttrRecsList_3:
        POP     DPH
          CFI DPH0 SameValue
          CFI CFA_SP SP+-4
        POP     DPL
          CFI DPL0 SameValue
          CFI CFA_SP SP+-3
        LJMP    ?BRET
          CFI EndBlock cfiBlock26
// 1875 }
// 1876 
// 1877 /*********************************************************************
// 1878  * @fn      zclFindAttrRec
// 1879  *
// 1880  * @brief   Find the attribute record that matchs the parameters
// 1881  *
// 1882  * @param   endpoint - Application's endpoint
// 1883  * @param   clusterID - cluster ID
// 1884  * @param   attrId - attribute looking for
// 1885  * @param   pAttr - attribute record to be returned
// 1886  *
// 1887  * @return  TRUE if record found. FALSE, otherwise.
// 1888  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 1889 uint8 zclFindAttrRec( uint8 endpoint, uint16 clusterID, uint16 attrId, zclAttrRec_t *pAttr )
zclFindAttrRec:
          CFI Block cfiBlock27 Using cfiCommon0
          CFI Function zclFindAttrRec
        CODE
// 1890 {
        FUNCALL zclFindAttrRec, zclFindAttrRecsList
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 16, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 16, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0x10
        LCALL   ?BANKED_ENTER_XDATA
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V7 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI V6 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V5 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI V4 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-13)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-14)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-15)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-16)))
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 16)
        ; Saved register size: 16
        ; Auto size: 0
        MOV     ?V0 + 4,R1
        MOV     ?V0 + 0,R2
        MOV     ?V0 + 1,R3
        MOV     ?V0 + 2,R4
        MOV     ?V0 + 3,R5
        MOV     A,#0x10
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R6,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R7,A
// 1891   uint8 x;
// 1892   zclAttrRecsList *pRec = zclFindAttrRecsList( endpoint );
        ; Setup parameters for call to function zclFindAttrRecsList
        MOV     R1,?V0 + 4
        LCALL   ??zclFindAttrRecsList?relay
        MOV     ?V0 + 6,R2
        MOV     ?V0 + 7,R3
        MOV     R2,?V0 + 6
        MOV     R3,?V0 + 7
// 1893 
// 1894   if ( pRec != NULL )
        MOV     A,R2
        ORL     A,R3
        JNZ     $+5
        LJMP    ??zclFindAttrRec_0 & 0xFFFF
// 1895   {
// 1896     for ( x = 0; x < pRec->numAttributes; x++ )
        MOV     ?V0 + 5,#0x0
??zclFindAttrRec_1:
        MOV     DPL,R2
        MOV     DPH,R3
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     A,?V0 + 5
        CLR     C
        SUBB    A,R0
        JC      $+5
        LJMP    ??zclFindAttrRec_0 & 0xFFFF
// 1897     {
// 1898       if ( pRec->attrs[x].clusterID == clusterID && pRec->attrs[x].attr.attrId == attrId )
        MOV     A,?V0 + 5
        MOV     R0,?V0 + 5
        MOV     R1,#0x0
        MOV     A,R0
        MOV     B,#0x8
        MUL     AB
        XCH     A,R0
        MOV     R4,B
        MOV     B,#0x0
        MUL     AB
        ADD     A,R4
        MOV     R4,A
        MOV     B,#0x8
        MOV     A,R1
        MUL     AB
        ADD     A,R4
        MOV     R1,A
        MOV     DPL,R2
        MOV     DPH,R3
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        ADD     A,R0
        MOV     R4,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,R1
        MOV     DPL,R4
        MOV     DPH,A
        CLR     A
        MOVC    A,@A+DPTR
        MOV     R0,A
        MOV     A,#0x1
        MOVC    A,@A+DPTR
        MOV     R1,A
        MOV     A,?V0 + 0
        XRL     A,R0
        JNZ     ??zclFindAttrRec_2
        MOV     A,?V0 + 1
        XRL     A,R1
??zclFindAttrRec_2:
        JZ      $+5
        LJMP    ??zclFindAttrRec_3 & 0xFFFF
        MOV     A,?V0 + 5
        MOV     R0,?V0 + 5
        MOV     R1,#0x0
        MOV     A,R0
        MOV     B,#0x8
        MUL     AB
        XCH     A,R0
        MOV     R4,B
        MOV     B,#0x0
        MUL     AB
        ADD     A,R4
        MOV     R4,A
        MOV     B,#0x8
        MOV     A,R1
        MUL     AB
        ADD     A,R4
        MOV     R1,A
        MOV     DPL,R2
        MOV     DPH,R3
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        ADD     A,R0
        MOV     R4,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,R1
        MOV     DPL,R4
        MOV     DPH,A
        INC     DPTR
        INC     DPTR
        CLR     A
        MOVC    A,@A+DPTR
        MOV     R0,A
        MOV     A,#0x1
        MOVC    A,@A+DPTR
        MOV     R1,A
        MOV     A,?V0 + 2
        XRL     A,R0
        JNZ     ??zclFindAttrRec_4
        MOV     A,?V0 + 3
        XRL     A,R1
??zclFindAttrRec_4:
        JNZ     ??zclFindAttrRec_3
// 1899       {
// 1900         *pAttr = pRec->attrs[x];
        MOV     A,?V0 + 5
        MOV     R0,?V0 + 5
        MOV     R1,#0x0
        MOV     A,R0
        MOV     B,#0x8
        MUL     AB
        XCH     A,R0
        MOV     R4,B
        MOV     B,#0x0
        MUL     AB
        ADD     A,R4
        MOV     R4,A
        MOV     B,#0x8
        MOV     A,R1
        MUL     AB
        ADD     A,R4
        MOV     R1,A
        MOV     DPL,R2
        MOV     DPH,R3
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        ADD     A,R0
        MOV     R4,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,R1
        MOV     DPL,R4
        MOV     DPH,A
        MOV     A,R6
        MOV     R4,A
        MOV     A,R7
        MOV     R5,A
        MOV     A,#0x8
        LCALL   ?MOVE_LONG8_XDATA_CODE
// 1901 
// 1902         return ( TRUE ); // EMBEDDED RETURN
        MOV     R1,#0x1
        SJMP    ??zclFindAttrRec_5
// 1903       }
// 1904     }
??zclFindAttrRec_3:
        INC     ?V0 + 5
        LJMP    ??zclFindAttrRec_1 & 0xFFFF
// 1905   }
// 1906 
// 1907   return ( FALSE );
??zclFindAttrRec_0:
        MOV     R1,#0x0
??zclFindAttrRec_5:
        MOV     R7,#0x8
        LJMP    ?BANKED_LEAVE_XDATA
          CFI EndBlock cfiBlock27
// 1908 }
// 1909 
// 1910 #if defined ( ZCL_READ ) || defined ( ZCL_WRITE )
// 1911 /*********************************************************************
// 1912  * @fn      zclGetReadWriteCB
// 1913  *
// 1914  * @brief   Get the Read/Write callback function pointer for a given endpoint.
// 1915  *
// 1916  * @param   endpoint - Application's endpoint
// 1917  *
// 1918  * @return  Read/Write CB, NULL if not found
// 1919  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 1920 static zclReadWriteCB_t zclGetReadWriteCB( uint8 endpoint )
zclGetReadWriteCB:
          CFI Block cfiBlock28 Using cfiCommon0
          CFI Function zclGetReadWriteCB
        CODE
// 1921 {
        FUNCALL zclGetReadWriteCB, zclFindAttrRecsList
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 10, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 10, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0xa
        LCALL   ?BANKED_ENTER_XDATA
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 10)
        ; Saved register size: 10
        ; Auto size: 0
        MOV     A,R1
        MOV     R6,A
// 1922   zclAttrRecsList *pRec = zclFindAttrRecsList( endpoint );
        ; Setup parameters for call to function zclFindAttrRecsList
        MOV     R1,A
        LCALL   ??zclFindAttrRecsList?relay
        MOV     ?V0 + 0,R2
        MOV     ?V0 + 1,R3
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
// 1923 
// 1924   if ( pRec != NULL )
        MOV     A,DPL
        ORL     A,DPH
        JZ      ??zclGetReadWriteCB_0
// 1925   {
// 1926     return ( pRec->pfnReadWriteCB );
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        SJMP    ??zclGetReadWriteCB_1
// 1927   }
// 1928 
// 1929   return ( NULL );
??zclGetReadWriteCB_0:
        MOV     R2,#0x0
        MOV     R3,#0x0
??zclGetReadWriteCB_1:
        MOV     R7,#0x2
        LJMP    ?BANKED_LEAVE_XDATA
          CFI EndBlock cfiBlock28
// 1930 }
// 1931 
// 1932 /*********************************************************************
// 1933  * @fn      zclGetAuthorizeCB
// 1934  *
// 1935  * @brief   Get the Read/Write Authorization callback function pointer
// 1936  *          for a given endpoint.
// 1937  *
// 1938  * @param   endpoint - Application's endpoint
// 1939  *
// 1940  * @return  Authorization CB, NULL if not found
// 1941  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 1942 static zclAuthorizeCB_t zclGetAuthorizeCB( uint8 endpoint )
zclGetAuthorizeCB:
          CFI Block cfiBlock29 Using cfiCommon0
          CFI Function zclGetAuthorizeCB
        CODE
// 1943 {
        FUNCALL zclGetAuthorizeCB, zclFindAttrRecsList
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 10, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 10, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0xa
        LCALL   ?BANKED_ENTER_XDATA
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 10)
        ; Saved register size: 10
        ; Auto size: 0
        MOV     A,R1
        MOV     R6,A
// 1944   zclAttrRecsList *pRec = zclFindAttrRecsList( endpoint );
        ; Setup parameters for call to function zclFindAttrRecsList
        MOV     R1,A
        LCALL   ??zclFindAttrRecsList?relay
        MOV     ?V0 + 0,R2
        MOV     ?V0 + 1,R3
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
// 1945 
// 1946   if ( pRec != NULL )
        MOV     A,DPL
        ORL     A,DPH
        JZ      ??zclGetAuthorizeCB_0
// 1947   {
// 1948     return ( pRec->pfnAuthorizeCB );
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        SJMP    ??zclGetAuthorizeCB_1
// 1949   }
// 1950 
// 1951   return ( NULL );
??zclGetAuthorizeCB_0:
        MOV     R2,#0x0
        MOV     R3,#0x0
??zclGetAuthorizeCB_1:
        MOV     R7,#0x2
        LJMP    ?BANKED_LEAVE_XDATA
          CFI EndBlock cfiBlock29
// 1952 }
// 1953 #endif // ZCL_READ || ZCL_WRITE
// 1954 
// 1955 /*********************************************************************
// 1956  * @fn      zclFindClusterOption
// 1957  *
// 1958  * @brief   Find the option record that matchs the cluster id
// 1959  *
// 1960  * @param   endpoint - Application's endpoint
// 1961  * @param   clusterID - cluster ID looking for
// 1962  *
// 1963  * @return  pointer to clutser option, NULL if not found
// 1964  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 1965 static zclOptionRec_t *zclFindClusterOption( uint8 endpoint, uint16 clusterID )
zclFindClusterOption:
          CFI Block cfiBlock30 Using cfiCommon0
          CFI Function zclFindClusterOption
        CODE
// 1966 {
        MOV     A,#-0x9
        LCALL   ?BANKED_ENTER_XDATA
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 9)
        ; Saved register size: 9
        ; Auto size: 0
        MOV     A,R1
        MOV     R4,A
        MOV     A,R2
        MOV     R6,A
        MOV     A,R3
        MOV     R7,A
// 1967   zclClusterOptionList *pLoop;
// 1968 
// 1969   pLoop = clusterOptionList;
        MOV     DPTR,#clusterOptionList
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        MOV     A,R2
        MOV     R0,A
        MOV     A,R3
        MOV     R1,A
// 1970   while ( pLoop != NULL )
??zclFindClusterOption_0:
        MOV     A,R0
        ORL     A,R1
        JNZ     $+5
        LJMP    ??zclFindClusterOption_1 & 0xFFFF
// 1971   {
// 1972     if ( pLoop->endpoint == endpoint )
        MOV     DPL,R0
        MOV     DPH,R1
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        XRL     A,R4
        JNZ     ??zclFindClusterOption_2
// 1973     {
// 1974       for ( uint8 x = 0; x < pLoop->numOptions; x++ )
        MOV     ?V0 + 0,#0x0
??zclFindClusterOption_3:
        MOV     DPL,R0
        MOV     DPH,R1
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     A,?V0 + 0
        CLR     C
        SUBB    A,R2
        JNC     ??zclFindClusterOption_2
// 1975       {
// 1976         if ( pLoop->options[x].clusterID == clusterID )
        MOV     A,?V0 + 0
        MOV     R2,?V0 + 0
        MOV     R3,#0x0
        MOV     A,R2
        MOV     B,#0x3
        MUL     AB
        XCH     A,R2
        MOV     R5,B
        MOV     B,#0x0
        MUL     AB
        ADD     A,R5
        MOV     R5,A
        MOV     B,#0x3
        MOV     A,R3
        MUL     AB
        ADD     A,R5
        MOV     R3,A
        MOV     DPL,R0
        MOV     DPH,R1
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        ADD     A,R2
        MOV     R5,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,R3
        MOV     DPL,R5
        MOV     DPH,A
        MOVX    A,@DPTR
        XRL     A,R6
        JNZ     ??zclFindClusterOption_4
        INC     DPTR
        MOVX    A,@DPTR
        XRL     A,R7
??zclFindClusterOption_4:
        JNZ     ??zclFindClusterOption_5
// 1977         {
// 1978           return ( &(pLoop->options[x]) ); // EMBEDDED RETURN
        MOV     A,?V0 + 0
        MOV     R2,?V0 + 0
        MOV     R3,#0x0
        MOV     A,R2
        MOV     B,#0x3
        MUL     AB
        XCH     A,R2
        MOV     R5,B
        MOV     B,#0x0
        MUL     AB
        ADD     A,R5
        MOV     R5,A
        MOV     B,#0x3
        MOV     A,R3
        MUL     AB
        ADD     A,R5
        MOV     R3,A
        MOV     DPL,R0
        MOV     DPH,R1
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        ADD     A,R2
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,R3
        MOV     R3,A
        SJMP    ??zclFindClusterOption_6
// 1979         }
// 1980       }
??zclFindClusterOption_5:
        INC     ?V0 + 0
        SJMP    ??zclFindClusterOption_3
// 1981     }
// 1982 
// 1983     pLoop = pLoop->next;
??zclFindClusterOption_2:
        MOV     DPL,R0
        MOV     DPH,R1
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        LJMP    ??zclFindClusterOption_0 & 0xFFFF
// 1984   }
// 1985 
// 1986   return ( NULL );
??zclFindClusterOption_1:
        MOV     R2,#0x0
        MOV     R3,#0x0
??zclFindClusterOption_6:
        MOV     R7,#0x1
        LJMP    ?BANKED_LEAVE_XDATA
          CFI EndBlock cfiBlock30
// 1987 }
// 1988 
// 1989 /*********************************************************************
// 1990  * @fn      zclGetClusterOption
// 1991  *
// 1992  * @brief   Get the option record that matchs the cluster id
// 1993  *
// 1994  * @param   endpoint - Application's endpoint
// 1995  * @param   clusterID - cluster ID looking for
// 1996  *
// 1997  * @return  clutser option, AF_TX_OPTIONS_NONE if not found
// 1998  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 1999 static uint8 zclGetClusterOption( uint8 endpoint, uint16 clusterID )
zclGetClusterOption:
          CFI Block cfiBlock31 Using cfiCommon0
          CFI Function zclGetClusterOption
        CODE
// 2000 {
        FUNCALL zclGetClusterOption, zclFindClusterOption
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 14, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 14, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0xe
        LCALL   ?BANKED_ENTER_XDATA
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V5 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI V4 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-13)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-14)))
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 14)
        ; Saved register size: 14
        ; Auto size: 0
        MOV     ?V0 + 3,R1
        MOV     A,R2
        MOV     R6,A
        MOV     A,R3
        MOV     R7,A
// 2001   uint8 option;
// 2002   zclOptionRec_t *pOption;
// 2003 
// 2004   pOption = zclFindClusterOption( endpoint, clusterID );
        ; Setup parameters for call to function zclFindClusterOption
        MOV     A,R6
        MOV     R2,A
        MOV     A,R7
        MOV     R3,A
        MOV     R1,?V0 + 3
        LCALL   ??zclFindClusterOption?relay
        MOV     ?V0 + 4,R2
        MOV     ?V0 + 5,R3
        MOV     ?V0 + 0,?V0 + 4
        MOV     ?V0 + 1,?V0 + 5
// 2005   if ( pOption != NULL )
        MOV     A,?V0 + 0
        ORL     A,?V0 + 1
        JZ      ??zclGetClusterOption_0
// 2006   {
// 2007     option = pOption->option;
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     ?V0 + 2,A
// 2008     if ( !ZG_SECURE_ENABLED )
// 2009     {
// 2010       option &= (AF_EN_SECURITY ^ 0xFF); // make sure Application Link Key security is off
        CLR     C
        MOV     A,?V0 + 2
        MOV     0xE0 /* A   */.6,C
        MOV     ?V0 + 2,A
// 2011     }
// 2012 
// 2013     return ( option ); // EMBEDDED RETURN
        MOV     R1,?V0 + 2
        SJMP    ??zclGetClusterOption_1
// 2014   }
// 2015 
// 2016   return ( AF_TX_OPTIONS_NONE );
??zclGetClusterOption_0:
        MOV     R1,#0x0
??zclGetClusterOption_1:
        MOV     R7,#0x6
        LJMP    ?BANKED_LEAVE_XDATA
          CFI EndBlock cfiBlock31
// 2017 }
// 2018 
// 2019 /*********************************************************************
// 2020  * @fn      zclSetSecurityOption
// 2021  *
// 2022  * @brief   Set the security option for the cluster id
// 2023  *
// 2024  * @param   endpoint - Application's endpoint
// 2025  * @param   clusterID - cluster ID looking for
// 2026  * @param   enable - whether to enable (TRUE) or disable (FALSE) security option
// 2027  *
// 2028  * @return  none
// 2029  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 2030 static void zclSetSecurityOption( uint8 endpoint, uint16 clusterID, uint8 enable )
zclSetSecurityOption:
          CFI Block cfiBlock32 Using cfiCommon0
          CFI Function zclSetSecurityOption
        CODE
// 2031 {
        FUNCALL zclSetSecurityOption, zclFindClusterOption
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 14, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 14, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0xe
        LCALL   ?BANKED_ENTER_XDATA
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V5 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI V4 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-13)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-14)))
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 14)
        ; Saved register size: 14
        ; Auto size: 0
        MOV     ?V0 + 2,R1
        MOV     A,R2
        MOV     R6,A
        MOV     A,R3
        MOV     R7,A
        MOV     ?V0 + 3,R4
// 2032   zclOptionRec_t *pOption;
// 2033 
// 2034   pOption = zclFindClusterOption( endpoint, clusterID );
        ; Setup parameters for call to function zclFindClusterOption
        MOV     A,R6
        MOV     R2,A
        MOV     A,R7
        MOV     R3,A
        MOV     R1,?V0 + 2
        LCALL   ??zclFindClusterOption?relay
        MOV     ?V0 + 4,R2
        MOV     ?V0 + 5,R3
        MOV     ?V0 + 0,?V0 + 4
        MOV     ?V0 + 1,?V0 + 5
// 2035   if ( pOption != NULL )
        MOV     A,?V0 + 0
        ORL     A,?V0 + 1
        JZ      ??zclSetSecurityOption_0
// 2036   {
// 2037     if ( enable )
        MOV     A,?V0 + 3
        JZ      ??zclSetSecurityOption_1
// 2038     {
// 2039       pOption->option |= AF_EN_SECURITY;
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        SETB    0xE0 /* A   */.6
        MOVX    @DPTR,A
        SJMP    ??zclSetSecurityOption_0
// 2040     }
// 2041     else
// 2042     {
// 2043       pOption->option &= (AF_EN_SECURITY ^ 0xFF);
??zclSetSecurityOption_1:
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        CLR     0xE0 /* A   */.6
        MOVX    @DPTR,A
// 2044     }
// 2045   }
// 2046 }
??zclSetSecurityOption_0:
        MOV     R7,#0x6
        LJMP    ?BANKED_LEAVE_XDATA
          CFI EndBlock cfiBlock32
// 2047 
// 2048 #ifdef ZCL_DISCOVER
// 2049 /*********************************************************************
// 2050  * @fn      zclFindNextAttrRec
// 2051  *
// 2052  * @brief   Find the attribute (or next) record that matchs the parameters
// 2053  *
// 2054  * @param   endpoint - Application's endpoint
// 2055  * @param   clusterID - cluster ID
// 2056  * @param   attr - attribute looking for
// 2057  *
// 2058  * @return  pointer to attribute record, NULL if not found
// 2059  */
// 2060 static uint8 zclFindNextAttrRec( uint8 endpoint, uint16 clusterID,
// 2061                                  uint16 *attrId, zclAttrRec_t *pAttr )
// 2062 {
// 2063   zclAttrRecsList *pRec = zclFindAttrRecsList( endpoint );
// 2064 
// 2065   if ( pRec != NULL )
// 2066   {
// 2067     for ( uint16 x = 0; x < pRec->numAttributes; x++ )
// 2068     {
// 2069       if ( ( pRec->attrs[x].clusterID == clusterID ) &&
// 2070            ( pRec->attrs[x].attr.attrId >= *attrId ) )
// 2071       {
// 2072         *pAttr = pRec->attrs[x];
// 2073 
// 2074         // Update attribute ID
// 2075         *attrId = pAttr->attr.attrId;
// 2076 
// 2077         return ( TRUE ); // EMBEDDED RETURN
// 2078       }
// 2079     }
// 2080   }
// 2081 
// 2082   return ( FALSE );
// 2083 }
// 2084 #endif // ZCL_DISCOVER
// 2085 
// 2086 /*********************************************************************
// 2087  * @fn      zclSerializeData
// 2088  *
// 2089  * @brief   Builds a buffer from the attribute data to sent out over
// 2090  *          the air.
// 2091  *
// 2092  * @param   dataType - data types defined in zcl.h
// 2093  * @param   attrData - pointer to the attribute data
// 2094  * @param   buf - where to put the serialized data
// 2095  *
// 2096  * @return  pointer to end of destination buffer
// 2097  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 2098 uint8 *zclSerializeData( uint8 dataType, void *attrData, uint8 *buf )
zclSerializeData:
          CFI Block cfiBlock33 Using cfiCommon0
          CFI Function zclSerializeData
        CODE
// 2099 {
        FUNCALL zclSerializeData, osal_buffer_uint32
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 23, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 23, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL zclSerializeData, osal_memcpy
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 22, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 22, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL zclSerializeData, osal_memcpy
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 22, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 22, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL zclSerializeData, osal_memcpy
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 22, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 22, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL zclSerializeData, osal_memcpy
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 22, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 22, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL zclSerializeData, osal_memcpy
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 22, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 22, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL zclSerializeData, osal_memcpy
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 22, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 22, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0x13
        LCALL   ?BANKED_ENTER_XDATA
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V10 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI V9 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V8 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI V7 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI V6 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI V5 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI V4 load(1, XDATA, add(CFA_XSP16, literal(-13)))
          CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-14)))
          CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-15)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-16)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-17)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-18)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-19)))
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 19)
        ; Saved register size: 19
        ; Auto size: 0
        MOV     ?V0 + 10,R1
        MOV     ?V0 + 0,R2
        MOV     ?V0 + 1,R3
        MOV     A,R4
        MOV     R6,A
        MOV     A,R5
        MOV     R7,A
// 2100   uint8 *pStr;
// 2101   uint16 len;
// 2102 
// 2103   switch ( dataType )
        MOV     A,?V0 + 10
        LCALL   ?UC_SWITCH_SPARSE
`?<Jumptable for zclSerializeData>_0`:
        DATA
        DATA8
        DATA
        DATA8
        DATA
        DATA8
        DB        4
        DATA
        DATA8
        DATA
        DATA8
        DATA
        DATA8
        DB        65
        DATA
        DATA8
        DATA
        DATA8
        DB        66
        DATA
        DATA16
        DATA
        DATA16
        DATA
        DATA16
        DW        ??zclSerializeData_0
        DATA
        DATA8
        DATA
        DATA8
        DATA
        DATA8
        DB        67
        DATA
        DATA8
        DATA
        DATA8
        DB        68
        DATA
        DATA16
        DATA
        DATA16
        DATA
        DATA16
        DW        ??zclSerializeData_1
        DATA
        DATA8
        DATA
        DATA8
        DATA
        DATA8
        DB        224
        DATA
        DATA8
        DATA
        DATA8
        DB        226
        DATA
        DATA16
        DATA
        DATA16
        DATA
        DATA16
        DW        ??zclSerializeData_2
        DATA
        DATA8
        DATA
        DATA8
        DATA
        DATA8
        DB        232
        DATA
        DATA8
        DATA
        DATA8
        DB        233
        DATA
        DATA16
        DATA
        DATA16
        DATA
        DATA16
        DW        ??zclSerializeData_3
        DATA
        DATA8
        DATA
        DATA8
        DATA
        DATA8
        DB        26
        DATA
        DATA8
        DATA
        DATA8
        DATA
        DATA8
        DB        8
        DATA
        DATA16
        DATA
        DATA16
        DATA
        DATA16
        DW        ??zclSerializeData_4
        DATA
        DATA8
        DATA
        DATA8
        DATA
        DATA8
        DB        9
        DATA
        DATA16
        DATA
        DATA16
        DATA
        DATA16
        DW        ??zclSerializeData_3
        DATA
        DATA8
        DATA
        DATA8
        DATA
        DATA8
        DB        10
        DATA
        DATA16
        DATA
        DATA16
        DATA
        DATA16
        DW        ??zclSerializeData_5
        DATA
        DATA8
        DATA
        DATA8
        DATA
        DATA8
        DB        11
        DATA
        DATA16
        DATA
        DATA16
        DATA
        DATA16
        DW        ??zclSerializeData_2
        DATA
        DATA8
        DATA
        DATA8
        DATA
        DATA8
        DB        16
        DATA
        DATA16
        DATA
        DATA16
        DATA
        DATA16
        DW        ??zclSerializeData_4
        DATA
        DATA8
        DATA
        DATA8
        DATA
        DATA8
        DB        24
        DATA
        DATA16
        DATA
        DATA16
        DATA
        DATA16
        DW        ??zclSerializeData_4
        DATA
        DATA8
        DATA
        DATA8
        DATA
        DATA8
        DB        25
        DATA
        DATA16
        DATA
        DATA16
        DATA
        DATA16
        DW        ??zclSerializeData_3
        DATA
        DATA8
        DATA
        DATA8
        DATA
        DATA8
        DB        26
        DATA
        DATA16
        DATA
        DATA16
        DATA
        DATA16
        DW        ??zclSerializeData_5
        DATA
        DATA8
        DATA
        DATA8
        DATA
        DATA8
        DB        27
        DATA
        DATA16
        DATA
        DATA16
        DATA
        DATA16
        DW        ??zclSerializeData_2
        DATA
        DATA8
        DATA
        DATA8
        DATA
        DATA8
        DB        32
        DATA
        DATA16
        DATA
        DATA16
        DATA
        DATA16
        DW        ??zclSerializeData_4
        DATA
        DATA8
        DATA
        DATA8
        DATA
        DATA8
        DB        33
        DATA
        DATA16
        DATA
        DATA16
        DATA
        DATA16
        DW        ??zclSerializeData_3
        DATA
        DATA8
        DATA
        DATA8
        DATA
        DATA8
        DB        34
        DATA
        DATA16
        DATA
        DATA16
        DATA
        DATA16
        DW        ??zclSerializeData_5
        DATA
        DATA8
        DATA
        DATA8
        DATA
        DATA8
        DB        35
        DATA
        DATA16
        DATA
        DATA16
        DATA
        DATA16
        DW        ??zclSerializeData_2
        DATA
        DATA8
        DATA
        DATA8
        DATA
        DATA8
        DB        36
        DATA
        DATA16
        DATA
        DATA16
        DATA
        DATA16
        DW        ??zclSerializeData_6
        DATA
        DATA8
        DATA
        DATA8
        DATA
        DATA8
        DB        37
        DATA
        DATA16
        DATA
        DATA16
        DATA
        DATA16
        DW        ??zclSerializeData_7
        DATA
        DATA8
        DATA
        DATA8
        DATA
        DATA8
        DB        40
        DATA
        DATA16
        DATA
        DATA16
        DATA
        DATA16
        DW        ??zclSerializeData_4
        DATA
        DATA8
        DATA
        DATA8
        DATA
        DATA8
        DB        41
        DATA
        DATA16
        DATA
        DATA16
        DATA
        DATA16
        DW        ??zclSerializeData_3
        DATA
        DATA8
        DATA
        DATA8
        DATA
        DATA8
        DB        42
        DATA
        DATA16
        DATA
        DATA16
        DATA
        DATA16
        DW        ??zclSerializeData_5
        DATA
        DATA8
        DATA
        DATA8
        DATA
        DATA8
        DB        43
        DATA
        DATA16
        DATA
        DATA16
        DATA
        DATA16
        DW        ??zclSerializeData_2
        DATA
        DATA8
        DATA
        DATA8
        DATA
        DATA8
        DB        48
        DATA
        DATA16
        DATA
        DATA16
        DATA
        DATA16
        DW        ??zclSerializeData_4
        DATA
        DATA8
        DATA
        DATA8
        DATA
        DATA8
        DB        49
        DATA
        DATA16
        DATA
        DATA16
        DATA
        DATA16
        DW        ??zclSerializeData_3
        DATA
        DATA8
        DATA
        DATA8
        DATA
        DATA8
        DB        56
        DATA
        DATA16
        DATA
        DATA16
        DATA
        DATA16
        DW        ??zclSerializeData_3
        DATA
        DATA8
        DATA
        DATA8
        DATA
        DATA8
        DB        57
        DATA
        DATA16
        DATA
        DATA16
        DATA
        DATA16
        DW        ??zclSerializeData_2
        DATA
        DATA8
        DATA
        DATA8
        DATA
        DATA8
        DB        234
        DATA
        DATA16
        DATA
        DATA16
        DATA
        DATA16
        DW        ??zclSerializeData_2
        DATA
        DATA8
        DATA
        DATA8
        DATA
        DATA8
        DB        240
        DATA
        DATA16
        DATA
        DATA16
        DATA
        DATA16
        DW        ??zclSerializeData_8
        DATA
        DATA8
        DATA
        DATA8
        DATA
        DATA8
        DB        241
        DATA
        DATA16
        DATA
        DATA16
        DATA
        DATA16
        DW        ??zclSerializeData_9
        DATA
        DATA16
        DATA
        DATA16
        DW        ??zclSerializeData_10
        CODE
// 2104   {
// 2105     case ZCL_DATATYPE_DATA8:
// 2106     case ZCL_DATATYPE_BOOLEAN:
// 2107     case ZCL_DATATYPE_BITMAP8:
// 2108     case ZCL_DATATYPE_INT8:
// 2109     case ZCL_DATATYPE_UINT8:
// 2110     case ZCL_DATATYPE_ENUM8:
// 2111       *buf++ = *((uint8 *)attrData);
??zclSerializeData_4:
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        MOVX    A,@DPTR
        MOV     DPL,R6
        MOV     DPH,R7
        MOVX    @DPTR,A
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        MOV     R6,DPL
        MOV     R7,DPH
// 2112        break;
        LJMP    ??zclSerializeData_10 & 0xFFFF
// 2113 
// 2114     case ZCL_DATATYPE_DATA16:
// 2115     case ZCL_DATATYPE_BITMAP16:
// 2116     case ZCL_DATATYPE_UINT16:
// 2117     case ZCL_DATATYPE_INT16:
// 2118     case ZCL_DATATYPE_ENUM16:
// 2119     case ZCL_DATATYPE_SEMI_PREC:
// 2120     case ZCL_DATATYPE_CLUSTER_ID:
// 2121     case ZCL_DATATYPE_ATTR_ID:
// 2122       *buf++ = LO_UINT16( *((uint16*)attrData) );
??zclSerializeData_3:
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        MOV     DPL,R6
        MOV     DPH,R7
        MOVX    @DPTR,A
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        MOV     R6,DPL
        MOV     R7,DPH
// 2123       *buf++ = HI_UINT16( *((uint16*)attrData) );
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        CLR     A
        MOV     A,R1
        MOV     R0,A
        MOV     DPL,R6
        MOV     DPH,R7
        MOVX    @DPTR,A
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        MOV     R6,DPL
        MOV     R7,DPH
// 2124       break;
        LJMP    ??zclSerializeData_10 & 0xFFFF
// 2125 
// 2126     case ZCL_DATATYPE_DATA24:
// 2127     case ZCL_DATATYPE_BITMAP24:
// 2128     case ZCL_DATATYPE_UINT24:
// 2129     case ZCL_DATATYPE_INT24:
// 2130       *buf++ = BREAK_UINT32( *((uint32*)attrData), 0 );
??zclSerializeData_5:
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        MOV     R0,#?V0 + 4
        LCALL   ?L_MOV_X
        MOV     A,?V0 + 4
        MOV     DPL,R6
        MOV     DPH,R7
        MOV     A,?V0 + 4
        MOVX    @DPTR,A
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        MOV     R6,DPL
        MOV     R7,DPH
// 2131       *buf++ = BREAK_UINT32( *((uint32*)attrData), 1 );
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        MOV     R0,#?V0 + 4
        LCALL   ?L_MOV_X
        CLR     A
        MOV     A,?V0 + 5
        MOV     ?V0 + 4,A
        MOV     A,?V0 + 4
        MOV     DPL,R6
        MOV     DPH,R7
        MOV     A,?V0 + 4
        MOVX    @DPTR,A
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        MOV     R6,DPL
        MOV     R7,DPH
// 2132       *buf++ = BREAK_UINT32( *((uint32*)attrData), 2 );
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        MOV     R0,#?V0 + 4
        LCALL   ?L_MOV_X
        MOV     A,#0x10
        MOV     R0,#?V0 + 4
        LCALL   ?UL_SHR
        MOV     A,?V0 + 4
        MOV     DPL,R6
        MOV     DPH,R7
        MOV     A,?V0 + 4
        MOVX    @DPTR,A
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        MOV     R6,DPL
        MOV     R7,DPH
// 2133       break;
        LJMP    ??zclSerializeData_10 & 0xFFFF
// 2134 
// 2135     case ZCL_DATATYPE_DATA32:
// 2136     case ZCL_DATATYPE_BITMAP32:
// 2137     case ZCL_DATATYPE_UINT32:
// 2138     case ZCL_DATATYPE_INT32:
// 2139     case ZCL_DATATYPE_SINGLE_PREC:
// 2140     case ZCL_DATATYPE_TOD:
// 2141     case ZCL_DATATYPE_DATE:
// 2142     case ZCL_DATATYPE_UTC:
// 2143     case ZCL_DATATYPE_BAC_OID:
// 2144       buf = osal_buffer_uint32( buf, *((uint32*)attrData) );
??zclSerializeData_2:
        ; Setup parameters for call to function osal_buffer_uint32
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        LCALL   ?PUSH_XSTACK8_X_FOUR
          CFI CFA_XSP16 add(XSP16, 23)
        MOV     A,R6
        MOV     R2,A
        MOV     A,R7
        MOV     R3,A
        LCALL   ??osal_buffer_uint32?relay
        MOV     A,#0x4
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 19)
        MOV     ?V0 + 4,R2
        MOV     ?V0 + 5,R3
        MOV     R6,?V0 + 4
        MOV     R7,?V0 + 5
// 2145       break;
        LJMP    ??zclSerializeData_10 & 0xFFFF
// 2146 
// 2147     case ZCL_DATATYPE_UINT40:
// 2148       pStr = (uint8*)attrData;
??zclSerializeData_6:
        MOV     ?V0 + 2,?V0 + 0
        MOV     ?V0 + 3,?V0 + 1
// 2149       buf = osal_memcpy( buf, pStr, 5 );
        ; Setup parameters for call to function osal_memcpy
        MOV     ?V0 + 4,?V0 + 2
        MOV     ?V0 + 5,?V0 + 3
        MOV     ?V0 + 6,#0x0
        MOV     R0,#?V0 + 4
        LCALL   ?PUSH_XSTACK_I_THREE
          CFI CFA_XSP16 add(XSP16, 22)
        MOV     R4,#0x5
        MOV     R5,#0x0
        MOV     A,R6
        MOV     R2,A
        MOV     A,R7
        MOV     R3,A
        LCALL   ??osal_memcpy?relay
        MOV     A,#0x3
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 19)
        MOV     ?V0 + 4,R2
        MOV     ?V0 + 5,R3
        MOV     R6,?V0 + 4
        MOV     R7,?V0 + 5
// 2150       break;
        LJMP    ??zclSerializeData_10 & 0xFFFF
// 2151 
// 2152     case ZCL_DATATYPE_UINT48:
// 2153       pStr = (uint8*)attrData;
??zclSerializeData_7:
        MOV     ?V0 + 2,?V0 + 0
        MOV     ?V0 + 3,?V0 + 1
// 2154       buf = osal_memcpy( buf, pStr, 6 );
        ; Setup parameters for call to function osal_memcpy
        MOV     ?V0 + 4,?V0 + 2
        MOV     ?V0 + 5,?V0 + 3
        MOV     ?V0 + 6,#0x0
        MOV     R0,#?V0 + 4
        LCALL   ?PUSH_XSTACK_I_THREE
          CFI CFA_XSP16 add(XSP16, 22)
        MOV     R4,#0x6
        MOV     R5,#0x0
        MOV     A,R6
        MOV     R2,A
        MOV     A,R7
        MOV     R3,A
        LCALL   ??osal_memcpy?relay
        MOV     A,#0x3
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 19)
        MOV     ?V0 + 4,R2
        MOV     ?V0 + 5,R3
        MOV     R6,?V0 + 4
        MOV     R7,?V0 + 5
// 2155       break;
        LJMP    ??zclSerializeData_10 & 0xFFFF
// 2156 
// 2157     case ZCL_DATATYPE_IEEE_ADDR:
// 2158       pStr = (uint8*)attrData;
??zclSerializeData_8:
        MOV     ?V0 + 2,?V0 + 0
        MOV     ?V0 + 3,?V0 + 1
// 2159       buf = osal_memcpy( buf, pStr, 8 );
        ; Setup parameters for call to function osal_memcpy
        MOV     ?V0 + 4,?V0 + 2
        MOV     ?V0 + 5,?V0 + 3
        MOV     ?V0 + 6,#0x0
        MOV     R0,#?V0 + 4
        LCALL   ?PUSH_XSTACK_I_THREE
          CFI CFA_XSP16 add(XSP16, 22)
        MOV     R4,#0x8
        MOV     R5,#0x0
        MOV     A,R6
        MOV     R2,A
        MOV     A,R7
        MOV     R3,A
        LCALL   ??osal_memcpy?relay
        MOV     A,#0x3
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 19)
        MOV     ?V0 + 4,R2
        MOV     ?V0 + 5,R3
        MOV     R6,?V0 + 4
        MOV     R7,?V0 + 5
// 2160       break;
        LJMP    ??zclSerializeData_10 & 0xFFFF
// 2161 
// 2162     case ZCL_DATATYPE_CHAR_STR:
// 2163     case ZCL_DATATYPE_OCTET_STR:
// 2164       pStr = (uint8*)attrData;
??zclSerializeData_0:
        MOV     ?V0 + 2,?V0 + 0
        MOV     ?V0 + 3,?V0 + 1
// 2165       len = *pStr;
        MOV     DPL,?V0 + 2
        MOV     DPH,?V0 + 3
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     R1,#0x0
        MOV     ?V0 + 8,R0
        MOV     ?V0 + 9,R1
// 2166       buf = osal_memcpy( buf, pStr, len+1 ); // Including length field
        ; Setup parameters for call to function osal_memcpy
        MOV     ?V0 + 4,?V0 + 2
        MOV     ?V0 + 5,?V0 + 3
        MOV     ?V0 + 6,#0x0
        MOV     R0,#?V0 + 4
        LCALL   ?PUSH_XSTACK_I_THREE
          CFI CFA_XSP16 add(XSP16, 22)
        MOV     A,?V0 + 8
        ADD     A,#0x1
        MOV     R4,A
        MOV     A,?V0 + 9
        ADDC    A,#0x0
        MOV     R5,A
        MOV     A,R6
        MOV     R2,A
        MOV     A,R7
        MOV     R3,A
        LCALL   ??osal_memcpy?relay
        MOV     A,#0x3
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 19)
        MOV     ?V0 + 4,R2
        MOV     ?V0 + 5,R3
        MOV     R6,?V0 + 4
        MOV     R7,?V0 + 5
// 2167       break;
        LJMP    ??zclSerializeData_10 & 0xFFFF
// 2168 
// 2169     case ZCL_DATATYPE_LONG_CHAR_STR:
// 2170     case ZCL_DATATYPE_LONG_OCTET_STR:
// 2171       pStr = (uint8*)attrData;
??zclSerializeData_1:
        MOV     ?V0 + 2,?V0 + 0
        MOV     ?V0 + 3,?V0 + 1
// 2172       len = BUILD_UINT16( pStr[0], pStr[1] );
        MOV     DPL,?V0 + 2
        MOV     DPH,?V0 + 3
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     R3,#0x0
        MOV     DPL,?V0 + 2
        MOV     DPH,?V0 + 3
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     R1,#0x0
        CLR     A
        XCH     A,R0
        MOV     R1,A
        MOV     A,R2
        ADD     A,R0
        MOV     R0,A
        MOV     A,R3
        ADDC    A,R1
        MOV     R1,A
        MOV     ?V0 + 8,R0
        MOV     ?V0 + 9,R1
// 2173       buf = osal_memcpy( buf, pStr, len+2 ); // Including length field
        ; Setup parameters for call to function osal_memcpy
        MOV     ?V0 + 4,?V0 + 2
        MOV     ?V0 + 5,?V0 + 3
        MOV     ?V0 + 6,#0x0
        MOV     R0,#?V0 + 4
        LCALL   ?PUSH_XSTACK_I_THREE
          CFI CFA_XSP16 add(XSP16, 22)
        MOV     A,?V0 + 8
        ADD     A,#0x2
        MOV     R4,A
        MOV     A,?V0 + 9
        ADDC    A,#0x0
        MOV     R5,A
        MOV     A,R6
        MOV     R2,A
        MOV     A,R7
        MOV     R3,A
        LCALL   ??osal_memcpy?relay
        MOV     A,#0x3
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 19)
        MOV     ?V0 + 4,R2
        MOV     ?V0 + 5,R3
        MOV     R6,?V0 + 4
        MOV     R7,?V0 + 5
// 2174       break;
        SJMP    ??zclSerializeData_10
// 2175 
// 2176     case ZCL_DATATYPE_128_BIT_SEC_KEY:
// 2177       pStr = (uint8*)attrData;
??zclSerializeData_9:
        MOV     ?V0 + 2,?V0 + 0
        MOV     ?V0 + 3,?V0 + 1
// 2178       buf = osal_memcpy( buf, pStr, SEC_KEY_LEN );
        ; Setup parameters for call to function osal_memcpy
        MOV     ?V0 + 4,?V0 + 2
        MOV     ?V0 + 5,?V0 + 3
        MOV     ?V0 + 6,#0x0
        MOV     R0,#?V0 + 4
        LCALL   ?PUSH_XSTACK_I_THREE
          CFI CFA_XSP16 add(XSP16, 22)
        MOV     R4,#0x10
        MOV     R5,#0x0
        MOV     A,R6
        MOV     R2,A
        MOV     A,R7
        MOV     R3,A
        LCALL   ??osal_memcpy?relay
        MOV     A,#0x3
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 19)
        MOV     ?V0 + 4,R2
        MOV     ?V0 + 5,R3
        MOV     R6,?V0 + 4
        MOV     R7,?V0 + 5
// 2179       break;
// 2180 
// 2181     case ZCL_DATATYPE_NO_DATA:
// 2182     case ZCL_DATATYPE_UNKNOWN:
// 2183       // Fall through
// 2184 
// 2185     default:
// 2186       break;
// 2187   }
// 2188 
// 2189   return ( buf );
??zclSerializeData_10:
        MOV     A,R6
        MOV     R2,A
        MOV     A,R7
        MOV     R3,A
        MOV     R7,#0xb
        LJMP    ?BANKED_LEAVE_XDATA
          CFI EndBlock cfiBlock33
// 2190 }
// 2191 
// 2192 #ifdef ZCL_REPORT
// 2193 /*********************************************************************
// 2194  * @fn      zclAnalogDataType
// 2195  *
// 2196  * @brief   Checks to see if Data Type is Analog
// 2197  *
// 2198  * @param   dataType - data type
// 2199  *
// 2200  * @return  TRUE if data type is analog
// 2201  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 2202 uint8 zclAnalogDataType( uint8 dataType )
zclAnalogDataType:
          CFI Block cfiBlock34 Using cfiCommon0
          CFI Function zclAnalogDataType
        CODE
// 2203 {
        PUSH    DPL
          CFI DPL0 Frame(CFA_SP, 4)
          CFI CFA_SP SP+-4
        PUSH    DPH
          CFI DPH0 Frame(CFA_SP, 5)
          CFI CFA_SP SP+-5
        ; Saved register size: 2
        ; Auto size: 0
        MOV     A,R1
        MOV     R0,A
// 2204   uint8 analog;
// 2205 
// 2206   switch ( dataType )
        LCALL   ?UC_SWITCH_SPARSE
`?<Jumptable for zclAnalogDataType>_0`:
        DATA
        DATA8
        DATA
        DATA8
        DATA
        DATA8
        DB        3
        DATA
        DATA8
        DATA
        DATA8
        DATA
        DATA8
        DB        32
        DATA
        DATA8
        DATA
        DATA8
        DB        47
        DATA
        DATA16
        DATA
        DATA16
        DATA
        DATA16
        DW        ??zclAnalogDataType_0
        DATA
        DATA8
        DATA
        DATA8
        DATA
        DATA8
        DB        56
        DATA
        DATA8
        DATA
        DATA8
        DB        58
        DATA
        DATA16
        DATA
        DATA16
        DATA
        DATA16
        DW        ??zclAnalogDataType_0
        DATA
        DATA8
        DATA
        DATA8
        DATA
        DATA8
        DB        224
        DATA
        DATA8
        DATA
        DATA8
        DB        226
        DATA
        DATA16
        DATA
        DATA16
        DATA
        DATA16
        DW        ??zclAnalogDataType_0
        DATA
        DATA8
        DATA
        DATA8
        DATA
        DATA8
        DB        0
        DATA
        DATA16
        DATA
        DATA16
        DW        ??zclAnalogDataType_1
        CODE
// 2207   {
// 2208     case ZCL_DATATYPE_UINT8:
// 2209     case ZCL_DATATYPE_UINT16:
// 2210     case ZCL_DATATYPE_UINT24:
// 2211     case ZCL_DATATYPE_UINT32:
// 2212     case ZCL_DATATYPE_UINT40:
// 2213     case ZCL_DATATYPE_UINT48:
// 2214     case ZCL_DATATYPE_UINT56:
// 2215     case ZCL_DATATYPE_UINT64:
// 2216     case ZCL_DATATYPE_INT8:
// 2217     case ZCL_DATATYPE_INT16:
// 2218     case ZCL_DATATYPE_INT24:
// 2219     case ZCL_DATATYPE_INT32:
// 2220     case ZCL_DATATYPE_INT40:
// 2221     case ZCL_DATATYPE_INT48:
// 2222     case ZCL_DATATYPE_INT56:
// 2223     case ZCL_DATATYPE_INT64:
// 2224     case ZCL_DATATYPE_SEMI_PREC:
// 2225     case ZCL_DATATYPE_SINGLE_PREC:
// 2226     case ZCL_DATATYPE_DOUBLE_PREC:
// 2227     case ZCL_DATATYPE_TOD:
// 2228     case ZCL_DATATYPE_DATE:
// 2229     case ZCL_DATATYPE_UTC:
// 2230       analog = TRUE;
??zclAnalogDataType_0:
        MOV     R1,#0x1
// 2231       break;
        SJMP    ??zclAnalogDataType_2
// 2232 
// 2233     default:
// 2234       analog = FALSE;
??zclAnalogDataType_1:
        MOV     R1,#0x0
// 2235       break;
// 2236   }
// 2237 
// 2238   return ( analog );
??zclAnalogDataType_2:
        POP     DPH
          CFI DPH0 SameValue
          CFI CFA_SP SP+-4
        POP     DPL
          CFI DPL0 SameValue
          CFI CFA_SP SP+-3
        LJMP    ?BRET
          CFI EndBlock cfiBlock34
// 2239 }
// 2240 
// 2241 /*********************************************************************
// 2242  * @fn      zcl_BuildAnalogData
// 2243  *
// 2244  * @brief   Build an analog arribute out of sequential bytes.
// 2245  *
// 2246  * @param   dataType - type of data
// 2247  * @param   pData - pointer to data
// 2248  * @param   pBuf - where to put the data
// 2249  *
// 2250  * @return  none
// 2251  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 2252 static void zcl_BuildAnalogData( uint8 dataType, uint8 *pData, uint8 *pBuf)
zcl_BuildAnalogData:
          CFI Block cfiBlock35 Using cfiCommon0
          CFI Function zcl_BuildAnalogData
        CODE
// 2253 {
        FUNCALL zcl_BuildAnalogData, osal_build_uint32
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 11, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 11, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL zcl_BuildAnalogData, osal_build_uint32
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 11, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 11, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0xb
        LCALL   ?BANKED_ENTER_XDATA
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 11)
        ; Saved register size: 11
        ; Auto size: 0
        MOV     ?V0 + 2,R1
        MOV     ?V0 + 0,R2
        MOV     ?V0 + 1,R3
        MOV     A,R4
        MOV     R6,A
        MOV     A,R5
        MOV     R7,A
// 2254   switch ( dataType )
        MOV     A,?V0 + 2
        LCALL   ?UC_SWITCH_SPARSE
`?<Jumptable for zcl_BuildAnalogData>_0`:
        DATA
        DATA8
        DATA
        DATA8
        DATA
        DATA8
        DB        3
        DATA
        DATA8
        DATA
        DATA8
        DATA
        DATA8
        DB        36
        DATA
        DATA8
        DATA
        DATA8
        DB        39
        DATA
        DATA16
        DATA
        DATA16
        DATA
        DATA16
        DW        ??zcl_BuildAnalogData_0
        DATA
        DATA8
        DATA
        DATA8
        DATA
        DATA8
        DB        44
        DATA
        DATA8
        DATA
        DATA8
        DB        47
        DATA
        DATA16
        DATA
        DATA16
        DATA
        DATA16
        DW        ??zcl_BuildAnalogData_0
        DATA
        DATA8
        DATA
        DATA8
        DATA
        DATA8
        DB        224
        DATA
        DATA8
        DATA
        DATA8
        DB        226
        DATA
        DATA16
        DATA
        DATA16
        DATA
        DATA16
        DW        ??zcl_BuildAnalogData_1
        DATA
        DATA8
        DATA
        DATA8
        DATA
        DATA8
        DB        11
        DATA
        DATA8
        DATA
        DATA8
        DATA
        DATA8
        DB        32
        DATA
        DATA16
        DATA
        DATA16
        DATA
        DATA16
        DW        ??zcl_BuildAnalogData_2
        DATA
        DATA8
        DATA
        DATA8
        DATA
        DATA8
        DB        33
        DATA
        DATA16
        DATA
        DATA16
        DATA
        DATA16
        DW        ??zcl_BuildAnalogData_3
        DATA
        DATA8
        DATA
        DATA8
        DATA
        DATA8
        DB        34
        DATA
        DATA16
        DATA
        DATA16
        DATA
        DATA16
        DW        ??zcl_BuildAnalogData_4
        DATA
        DATA8
        DATA
        DATA8
        DATA
        DATA8
        DB        35
        DATA
        DATA16
        DATA
        DATA16
        DATA
        DATA16
        DW        ??zcl_BuildAnalogData_1
        DATA
        DATA8
        DATA
        DATA8
        DATA
        DATA8
        DB        40
        DATA
        DATA16
        DATA
        DATA16
        DATA
        DATA16
        DW        ??zcl_BuildAnalogData_2
        DATA
        DATA8
        DATA
        DATA8
        DATA
        DATA8
        DB        41
        DATA
        DATA16
        DATA
        DATA16
        DATA
        DATA16
        DW        ??zcl_BuildAnalogData_3
        DATA
        DATA8
        DATA
        DATA8
        DATA
        DATA8
        DB        42
        DATA
        DATA16
        DATA
        DATA16
        DATA
        DATA16
        DW        ??zcl_BuildAnalogData_4
        DATA
        DATA8
        DATA
        DATA8
        DATA
        DATA8
        DB        43
        DATA
        DATA16
        DATA
        DATA16
        DATA
        DATA16
        DW        ??zcl_BuildAnalogData_1
        DATA
        DATA8
        DATA
        DATA8
        DATA
        DATA8
        DB        56
        DATA
        DATA16
        DATA
        DATA16
        DATA
        DATA16
        DW        ??zcl_BuildAnalogData_3
        DATA
        DATA8
        DATA
        DATA8
        DATA
        DATA8
        DB        57
        DATA
        DATA16
        DATA
        DATA16
        DATA
        DATA16
        DW        ??zcl_BuildAnalogData_1
        DATA
        DATA8
        DATA
        DATA8
        DATA
        DATA8
        DB        58
        DATA
        DATA16
        DATA
        DATA16
        DATA
        DATA16
        DW        ??zcl_BuildAnalogData_0
        DATA
        DATA16
        DATA
        DATA16
        DW        ??zcl_BuildAnalogData_5
        CODE
// 2255   {
// 2256     case ZCL_DATATYPE_UINT8:
// 2257     case ZCL_DATATYPE_INT8:
// 2258       *pData = *pBuf;
??zcl_BuildAnalogData_2:
        MOV     DPL,R6
        MOV     DPH,R7
        MOVX    A,@DPTR
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        MOVX    @DPTR,A
// 2259       break;
        SJMP    ??zcl_BuildAnalogData_6
// 2260 
// 2261     case ZCL_DATATYPE_UINT16:
// 2262     case ZCL_DATATYPE_INT16:
// 2263     case ZCL_DATATYPE_SEMI_PREC:
// 2264       *((uint16*)pData) = BUILD_UINT16( pBuf[0], pBuf[1] );
??zcl_BuildAnalogData_3:
        MOV     DPL,R6
        MOV     DPH,R7
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     R3,#0x0
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     R1,#0x0
        CLR     A
        XCH     A,R0
        MOV     R1,A
        MOV     A,R2
        ADD     A,R0
        MOV     R0,A
        MOV     A,R3
        ADDC    A,R1
        MOV     R1,A
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
// 2265       break;
        SJMP    ??zcl_BuildAnalogData_6
// 2266 
// 2267     case ZCL_DATATYPE_UINT24:
// 2268     case ZCL_DATATYPE_INT24:
// 2269       *((uint32*)pData) = osal_build_uint32( pBuf, 3 );
??zcl_BuildAnalogData_4:
        ; Setup parameters for call to function osal_build_uint32
        MOV     R1,#0x3
        MOV     A,R6
        MOV     R2,A
        MOV     A,R7
        MOV     R3,A
        LCALL   ??osal_build_uint32?relay
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        LCALL   ?XSTORE_R2345
// 2270       break;
        SJMP    ??zcl_BuildAnalogData_6
// 2271 
// 2272     case ZCL_DATATYPE_UINT32:
// 2273     case ZCL_DATATYPE_INT32:
// 2274     case ZCL_DATATYPE_SINGLE_PREC:
// 2275     case ZCL_DATATYPE_TOD:
// 2276     case ZCL_DATATYPE_DATE:
// 2277     case ZCL_DATATYPE_UTC:
// 2278       *((uint32*)pData) = osal_build_uint32( pBuf, 4 );
??zcl_BuildAnalogData_1:
        ; Setup parameters for call to function osal_build_uint32
        MOV     R1,#0x4
        MOV     A,R6
        MOV     R2,A
        MOV     A,R7
        MOV     R3,A
        LCALL   ??osal_build_uint32?relay
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        LCALL   ?XSTORE_R2345
// 2279       break;
        SJMP    ??zcl_BuildAnalogData_6
// 2280 
// 2281     case ZCL_DATATYPE_UINT40:
// 2282     case ZCL_DATATYPE_UINT48:
// 2283     case ZCL_DATATYPE_UINT56:
// 2284     case ZCL_DATATYPE_UINT64:
// 2285     case ZCL_DATATYPE_INT40:
// 2286     case ZCL_DATATYPE_INT48:
// 2287     case ZCL_DATATYPE_INT56:
// 2288     case ZCL_DATATYPE_INT64:
// 2289     case ZCL_DATATYPE_DOUBLE_PREC:
// 2290       *pData = 0;
??zcl_BuildAnalogData_0:
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        MOV     A,#0x0
        MOVX    @DPTR,A
// 2291       break;
        SJMP    ??zcl_BuildAnalogData_6
// 2292 
// 2293     default:
// 2294       *pData = 0;
??zcl_BuildAnalogData_5:
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        MOV     A,#0x0
        MOVX    @DPTR,A
// 2295       break;
// 2296   }
// 2297 }
??zcl_BuildAnalogData_6:
        MOV     R7,#0x3
        LJMP    ?BANKED_LEAVE_XDATA
          CFI EndBlock cfiBlock35
// 2298 #endif // ZCL_REPORT
// 2299 
// 2300 /*********************************************************************
// 2301  * @fn      zclGetDataTypeLength
// 2302  *
// 2303  * @brief   Return the length of the datatype in octet.
// 2304  *
// 2305  *          NOTE: Should not be called for ZCL_DATATYPE_OCTECT_STR or
// 2306  *                ZCL_DATATYPE_CHAR_STR data types.
// 2307  *
// 2308  * @param   dataType - data type
// 2309  *
// 2310  * @return  length of data
// 2311  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 2312 uint8 zclGetDataTypeLength( uint8 dataType )
zclGetDataTypeLength:
          CFI Block cfiBlock36 Using cfiCommon0
          CFI Function zclGetDataTypeLength
        CODE
// 2313 {
        ; Saved register size: 0
        ; Auto size: 0
        MOV     A,R1
        MOV     R0,A
// 2314   uint8 len;
// 2315 
// 2316   switch ( dataType )
        ADD     A,#-0x8
        JZ      ??zclGetDataTypeLength_0
        DEC     A
        JZ      ??zclGetDataTypeLength_1
        DEC     A
        JZ      ??zclGetDataTypeLength_2
        DEC     A
        JZ      ??zclGetDataTypeLength_3
        ADD     A,#-0x5
        JZ      ??zclGetDataTypeLength_0
        ADD     A,#-0x8
        JZ      ??zclGetDataTypeLength_0
        DEC     A
        JZ      ??zclGetDataTypeLength_1
        DEC     A
        JZ      ??zclGetDataTypeLength_2
        DEC     A
        JZ      ??zclGetDataTypeLength_3
        ADD     A,#-0x5
        JZ      ??zclGetDataTypeLength_0
        DEC     A
        JZ      ??zclGetDataTypeLength_1
        DEC     A
        JZ      ??zclGetDataTypeLength_2
        DEC     A
        JZ      ??zclGetDataTypeLength_3
        DEC     A
        JZ      ??zclGetDataTypeLength_4
        DEC     A
        JZ      ??zclGetDataTypeLength_5
        DEC     A
        JZ      ??zclGetDataTypeLength_6
        DEC     A
        JZ      ??zclGetDataTypeLength_7
        DEC     A
        JZ      ??zclGetDataTypeLength_0
        DEC     A
        JZ      ??zclGetDataTypeLength_1
        DEC     A
        JZ      ??zclGetDataTypeLength_2
        DEC     A
        JZ      ??zclGetDataTypeLength_3
        DEC     A
        JZ      ??zclGetDataTypeLength_4
        DEC     A
        JZ      ??zclGetDataTypeLength_5
        DEC     A
        JZ      ??zclGetDataTypeLength_6
        DEC     A
        JZ      ??zclGetDataTypeLength_7
        DEC     A
        JZ      ??zclGetDataTypeLength_0
        DEC     A
        JZ      ??zclGetDataTypeLength_1
        ADD     A,#-0x7
        JZ      ??zclGetDataTypeLength_1
        DEC     A
        JZ      ??zclGetDataTypeLength_3
        DEC     A
        JZ      ??zclGetDataTypeLength_7
        ADD     A,#0x5a
        JZ      ??zclGetDataTypeLength_3
        DEC     A
        JZ      ??zclGetDataTypeLength_3
        DEC     A
        JZ      ??zclGetDataTypeLength_3
        ADD     A,#-0x6
        JZ      ??zclGetDataTypeLength_1
        DEC     A
        JZ      ??zclGetDataTypeLength_1
        DEC     A
        JZ      ??zclGetDataTypeLength_3
        ADD     A,#-0x6
        JZ      ??zclGetDataTypeLength_7
        DEC     A
        JZ      ??zclGetDataTypeLength_8
        SJMP    ??zclGetDataTypeLength_9
// 2317   {
// 2318     case ZCL_DATATYPE_DATA8:
// 2319     case ZCL_DATATYPE_BOOLEAN:
// 2320     case ZCL_DATATYPE_BITMAP8:
// 2321     case ZCL_DATATYPE_INT8:
// 2322     case ZCL_DATATYPE_UINT8:
// 2323     case ZCL_DATATYPE_ENUM8:
// 2324       len = 1;
??zclGetDataTypeLength_0:
        MOV     R1,#0x1
// 2325       break;
        SJMP    ??zclGetDataTypeLength_10
// 2326 
// 2327     case ZCL_DATATYPE_DATA16:
// 2328     case ZCL_DATATYPE_BITMAP16:
// 2329     case ZCL_DATATYPE_UINT16:
// 2330     case ZCL_DATATYPE_INT16:
// 2331     case ZCL_DATATYPE_ENUM16:
// 2332     case ZCL_DATATYPE_SEMI_PREC:
// 2333     case ZCL_DATATYPE_CLUSTER_ID:
// 2334     case ZCL_DATATYPE_ATTR_ID:
// 2335       len = 2;
??zclGetDataTypeLength_1:
        MOV     R1,#0x2
// 2336       break;
        SJMP    ??zclGetDataTypeLength_10
// 2337 
// 2338     case ZCL_DATATYPE_DATA24:
// 2339     case ZCL_DATATYPE_BITMAP24:
// 2340     case ZCL_DATATYPE_UINT24:
// 2341     case ZCL_DATATYPE_INT24:
// 2342       len = 3;
??zclGetDataTypeLength_2:
        MOV     R1,#0x3
// 2343       break;
        SJMP    ??zclGetDataTypeLength_10
// 2344 
// 2345     case ZCL_DATATYPE_DATA32:
// 2346     case ZCL_DATATYPE_BITMAP32:
// 2347     case ZCL_DATATYPE_UINT32:
// 2348     case ZCL_DATATYPE_INT32:
// 2349     case ZCL_DATATYPE_SINGLE_PREC:
// 2350     case ZCL_DATATYPE_TOD:
// 2351     case ZCL_DATATYPE_DATE:
// 2352     case ZCL_DATATYPE_UTC:
// 2353     case ZCL_DATATYPE_BAC_OID:
// 2354       len = 4;
??zclGetDataTypeLength_3:
        MOV     R1,#0x4
// 2355       break;
        SJMP    ??zclGetDataTypeLength_10
// 2356 
// 2357    case ZCL_DATATYPE_UINT40:
// 2358    case ZCL_DATATYPE_INT40:
// 2359        len = 5;
??zclGetDataTypeLength_4:
        MOV     R1,#0x5
// 2360        break;
        SJMP    ??zclGetDataTypeLength_10
// 2361 
// 2362    case ZCL_DATATYPE_UINT48:
// 2363    case ZCL_DATATYPE_INT48:
// 2364        len = 6;
??zclGetDataTypeLength_5:
        MOV     R1,#0x6
// 2365        break;
        SJMP    ??zclGetDataTypeLength_10
// 2366 
// 2367    case ZCL_DATATYPE_UINT56:
// 2368    case ZCL_DATATYPE_INT56:
// 2369        len = 7;
??zclGetDataTypeLength_6:
        MOV     R1,#0x7
// 2370        break;
        SJMP    ??zclGetDataTypeLength_10
// 2371 
// 2372    case ZCL_DATATYPE_DOUBLE_PREC:
// 2373    case ZCL_DATATYPE_IEEE_ADDR:
// 2374    case ZCL_DATATYPE_UINT64:
// 2375    case ZCL_DATATYPE_INT64:
// 2376      len = 8;
??zclGetDataTypeLength_7:
        MOV     R1,#0x8
// 2377      break;
        SJMP    ??zclGetDataTypeLength_10
// 2378 
// 2379     case ZCL_DATATYPE_128_BIT_SEC_KEY:
// 2380      len = SEC_KEY_LEN;
??zclGetDataTypeLength_8:
        MOV     R1,#0x10
// 2381      break;
        SJMP    ??zclGetDataTypeLength_10
// 2382 
// 2383     case ZCL_DATATYPE_NO_DATA:
// 2384     case ZCL_DATATYPE_UNKNOWN:
// 2385       // Fall through
// 2386 
// 2387     default:
// 2388       len = 0;
??zclGetDataTypeLength_9:
        MOV     R1,#0x0
// 2389       break;
// 2390   }
// 2391 
// 2392   return ( len );
??zclGetDataTypeLength_10:
        LJMP    ?BRET
          CFI EndBlock cfiBlock36
// 2393 }
// 2394 
// 2395 /*********************************************************************
// 2396  * @fn      zclGetAttrDataLength
// 2397  *
// 2398  * @brief   Return the length of the attribute.
// 2399  *
// 2400  * @param   dataType - data type
// 2401  * @param   pData - pointer to data
// 2402  *
// 2403  * @return  returns atrribute length
// 2404  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 2405 uint16 zclGetAttrDataLength( uint8 dataType, uint8 *pData )
zclGetAttrDataLength:
          CFI Block cfiBlock37 Using cfiCommon0
          CFI Function zclGetAttrDataLength
        CODE
// 2406 {
        FUNCALL zclGetAttrDataLength, zclGetDataTypeLength
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 11, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 11, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0xb
        LCALL   ?BANKED_ENTER_XDATA
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 11)
        ; Saved register size: 11
        ; Auto size: 0
        MOV     ?V0 + 2,R1
        MOV     A,R2
        MOV     R6,A
        MOV     A,R3
        MOV     R7,A
// 2407   uint16 dataLen = 0;
        MOV     ?V0 + 0,#0x0
        MOV     ?V0 + 1,#0x0
// 2408 
// 2409   if ( dataType == ZCL_DATATYPE_LONG_CHAR_STR || dataType == ZCL_DATATYPE_LONG_OCTET_STR )
        MOV     A,#0x44
        XRL     A,?V0 + 2
        JZ      ??zclGetAttrDataLength_0
        MOV     A,#0x43
        XRL     A,?V0 + 2
        JNZ     ??zclGetAttrDataLength_1
// 2410   {
// 2411     dataLen = BUILD_UINT16( pData[0], pData[1] ) + 2; // long string length + 2 for length field
??zclGetAttrDataLength_0:
        MOV     DPL,R6
        MOV     DPH,R7
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     R3,#0x0
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     R1,#0x0
        CLR     A
        XCH     A,R0
        MOV     R1,A
        MOV     A,R2
        ADD     A,R0
        MOV     R0,A
        MOV     A,R3
        ADDC    A,R1
        MOV     R1,A
        MOV     A,R0
        ADD     A,#0x2
        MOV     R0,A
        MOV     A,R1
        ADDC    A,#0x0
        MOV     R1,A
        MOV     ?V0 + 0,R0
        MOV     ?V0 + 1,R1
        SJMP    ??zclGetAttrDataLength_2
// 2412   }
// 2413   else if ( dataType == ZCL_DATATYPE_CHAR_STR || dataType == ZCL_DATATYPE_OCTET_STR )
??zclGetAttrDataLength_1:
        MOV     A,#0x42
        XRL     A,?V0 + 2
        JZ      ??zclGetAttrDataLength_3
        MOV     A,#0x41
        XRL     A,?V0 + 2
        JNZ     ??zclGetAttrDataLength_4
// 2414   {
// 2415     dataLen = *pData + 1; // string length + 1 for length field
??zclGetAttrDataLength_3:
        MOV     DPL,R6
        MOV     DPH,R7
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     R1,#0x0
        ADD     A,#0x1
        MOV     R0,A
        MOV     A,R1
        ADDC    A,#0x0
        MOV     R1,A
        MOV     ?V0 + 0,R0
        MOV     ?V0 + 1,R1
        SJMP    ??zclGetAttrDataLength_2
// 2416   }
// 2417   else
// 2418   {
// 2419     dataLen = zclGetDataTypeLength( dataType );
??zclGetAttrDataLength_4:
        ; Setup parameters for call to function zclGetDataTypeLength
        MOV     R1,?V0 + 2
        LCALL   ??zclGetDataTypeLength?relay
        MOV     A,R1
        MOV     R0,A
        MOV     R1,#0x0
        MOV     ?V0 + 0,R0
        MOV     ?V0 + 1,R1
// 2420   }
// 2421 
// 2422   return ( dataLen );
??zclGetAttrDataLength_2:
        MOV     R2,?V0 + 0
        MOV     R3,?V0 + 1
        MOV     R7,#0x3
        LJMP    ?BANKED_LEAVE_XDATA
          CFI EndBlock cfiBlock37
// 2423 }
// 2424 
// 2425 /*********************************************************************
// 2426  * @fn      zclReadAttrData
// 2427  *
// 2428  * @brief   Read the attribute's current value into pAttrData.
// 2429  *
// 2430  * @param   pAttrData - where to put attribute data
// 2431  * @param   pAttr - pointer to attribute
// 2432  * @param   pDataLen - where to put attribute data length
// 2433  *
// 2434  * @return Success
// 2435  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 2436 uint8 zclReadAttrData( uint8 *pAttrData, zclAttrRec_t *pAttr, uint16 *pDataLen )
zclReadAttrData:
          CFI Block cfiBlock38 Using cfiCommon0
          CFI Function zclReadAttrData
        CODE
// 2437 {
        FUNCALL zclReadAttrData, zclGetAttrDataLength
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 18, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 18, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL zclReadAttrData, osal_memcpy
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 21, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 21, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0x12
        LCALL   ?BANKED_ENTER_XDATA
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V9 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI V8 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V7 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI V6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI V5 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI V4 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-13)))
          CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-14)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-15)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-16)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-17)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-18)))
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 18)
        ; Saved register size: 18
        ; Auto size: 0
        MOV     ?V0 + 8,R2
        MOV     ?V0 + 9,R3
        MOV     A,R4
        MOV     R6,A
        MOV     A,R5
        MOV     R7,A
        MOV     A,#0x12
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     ?V0 + 0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     ?V0 + 1,A
// 2438   uint16 dataLen;
// 2439 
// 2440   dataLen = zclGetAttrDataLength( pAttr->attr.dataType, (uint8*)(pAttr->attr.dataPtr) );
        ; Setup parameters for call to function zclGetAttrDataLength
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??zclGetAttrDataLength?relay
        MOV     ?V0 + 4,R2
        MOV     ?V0 + 5,R3
        MOV     ?V0 + 2,?V0 + 4
        MOV     ?V0 + 3,?V0 + 5
// 2441   osal_memcpy( pAttrData, pAttr->attr.dataPtr, dataLen );
        ; Setup parameters for call to function osal_memcpy
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     ?V0 + 4,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     ?V0 + 5,A
        MOV     ?V0 + 6,#0x0
        MOV     R0,#?V0 + 4
        LCALL   ?PUSH_XSTACK_I_THREE
          CFI CFA_XSP16 add(XSP16, 21)
        MOV     R4,?V0 + 2
        MOV     R5,?V0 + 3
        MOV     R2,?V0 + 8
        MOV     R3,?V0 + 9
        LCALL   ??osal_memcpy?relay
        MOV     A,#0x3
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 18)
// 2442 
// 2443   if ( pDataLen != NULL )
        MOV     A,?V0 + 0
        ORL     A,?V0 + 1
        JZ      ??zclReadAttrData_0
// 2444   {
// 2445     *pDataLen = dataLen;
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        MOV     A,?V0 + 2
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,?V0 + 3
        MOVX    @DPTR,A
// 2446   }
// 2447 
// 2448   return ( ZCL_STATUS_SUCCESS );
??zclReadAttrData_0:
        MOV     R1,#0x0
        MOV     R7,#0xa
        LJMP    ?BANKED_LEAVE_XDATA
          CFI EndBlock cfiBlock38
// 2449 }
// 2450 
// 2451 #ifdef ZCL_READ
// 2452 /*********************************************************************
// 2453  * @fn      zclGetAttrDataLengthUsingCB
// 2454  *
// 2455  * @brief   Use application's callback to get the length of the attribute's
// 2456  *          current value stored in the database.
// 2457  *
// 2458  * @param   endpoint - application's endpoint
// 2459  * @param   clusterId - cluster that attribute belongs to
// 2460  * @param   attrId - attribute id
// 2461  *
// 2462  * @return  returns attribute length
// 2463  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 2464 static uint16 zclGetAttrDataLengthUsingCB( uint8 endpoint, uint16 clusterId, uint16 attrId )
zclGetAttrDataLengthUsingCB:
          CFI Block cfiBlock39 Using cfiCommon0
          CFI Function zclGetAttrDataLengthUsingCB
        CODE
// 2465 {
        FUNCALL zclGetAttrDataLengthUsingCB, zclGetReadWriteCB
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 18, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 18, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0x10
        LCALL   ?BANKED_ENTER_XDATA
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V7 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI V6 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V5 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI V4 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-13)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-14)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-15)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-16)))
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 16)
        ; Saved register size: 16
        ; Auto size: 2
        MOV     A,#-0x2
        LCALL   ?ALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 18)
        MOV     ?V0 + 4,R1
        MOV     ?V0 + 2,R2
        MOV     ?V0 + 3,R3
        MOV     ?V0 + 0,R4
        MOV     ?V0 + 1,R5
// 2466   uint16 dataLen = 0;
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     A,#0x0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
// 2467   zclReadWriteCB_t pfnReadWriteCB = zclGetReadWriteCB( endpoint );
        ; Setup parameters for call to function zclGetReadWriteCB
        MOV     R1,?V0 + 4
        LCALL   ??zclGetReadWriteCB?relay
        MOV     ?V0 + 6,R2
        MOV     ?V0 + 7,R3
        MOV     R6,?V0 + 6
        MOV     R7,?V0 + 7
// 2468 
// 2469   if ( pfnReadWriteCB != NULL )
        MOV     A,R6
        ORL     A,R7
        JZ      ??zclGetAttrDataLengthUsingCB_0
// 2470   {
// 2471     // Only get the attribute length
// 2472     (*pfnReadWriteCB)( clusterId, attrId, ZCL_OPER_LEN, NULL, &dataLen );
        ; Setup parameters for indirect call
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     ?V0 + 6,DPL
        MOV     ?V0 + 7,DPH
        MOV     R0,#?V0 + 6
        LCALL   ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 20)
        CLR     A
        MOV     ?V0 + 6,A
        MOV     ?V0 + 7,A
        MOV     R0,#?V0 + 6
        LCALL   ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 22)
        MOV     R1,#0x0
        MOV     R4,?V0 + 0
        MOV     R5,?V0 + 1
        MOV     R2,?V0 + 2
        MOV     R3,?V0 + 3
        MOV     DPL,R6
        MOV     DPH,R7
        LCALL   ?CALL_IND
        MOV     A,#0x4
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 18)
        MOV     A,R1
// 2473   }
// 2474 
// 2475   return ( dataLen );
??zclGetAttrDataLengthUsingCB_0:
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 16)
        MOV     R7,#0x8
        LJMP    ?BANKED_LEAVE_XDATA
          CFI EndBlock cfiBlock39
// 2476 }
// 2477 
// 2478 /*********************************************************************
// 2479  * @fn      zclReadAttrDataUsingCB
// 2480  *
// 2481  * @brief   Use application's callback to read the attribute's current
// 2482  *          value stored in the database.
// 2483  *
// 2484  * @param   endpoint - application's endpoint
// 2485  * @param   clusterId - cluster that attribute belongs to
// 2486  * @param   attrId - attribute id
// 2487  * @param   pAttrData - where to put attribute data
// 2488  * @param   pDataLen - where to put attribute data length
// 2489  *
// 2490  * @return  Successful if data was read
// 2491  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 2492 static ZStatus_t zclReadAttrDataUsingCB( uint8 endpoint, uint16 clusterId, uint16 attrId,
zclReadAttrDataUsingCB:
          CFI Block cfiBlock40 Using cfiCommon0
          CFI Function zclReadAttrDataUsingCB
        CODE
// 2493                                          uint8 *pAttrData, uint16 *pDataLen )
// 2494 {
        FUNCALL zclReadAttrDataUsingCB, zclGetReadWriteCB
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 20, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 20, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0x14
        LCALL   ?BANKED_ENTER_XDATA
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V11 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI V10 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V9 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI V8 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI V7 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI V6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI V5 load(1, XDATA, add(CFA_XSP16, literal(-13)))
          CFI V4 load(1, XDATA, add(CFA_XSP16, literal(-14)))
          CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-15)))
          CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-16)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-17)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-18)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-19)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-20)))
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 20)
        ; Saved register size: 20
        ; Auto size: 0
        MOV     ?V0 + 4,R1
        MOV     ?V0 + 2,R2
        MOV     ?V0 + 3,R3
        MOV     ?V0 + 0,R4
        MOV     ?V0 + 1,R5
        MOV     A,#0x14
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     ?V0 + 8,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     ?V0 + 9,A
        MOV     A,#0x16
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     ?V0 + 6,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     ?V0 + 7,A
// 2495   zclReadWriteCB_t pfnReadWriteCB = zclGetReadWriteCB( endpoint );
        ; Setup parameters for call to function zclGetReadWriteCB
        MOV     R1,?V0 + 4
        LCALL   ??zclGetReadWriteCB?relay
        MOV     ?V0 + 10,R2
        MOV     ?V0 + 11,R3
        MOV     R6,?V0 + 10
        MOV     R7,?V0 + 11
// 2496 
// 2497   if ( pDataLen != NULL )
        MOV     A,?V0 + 6
        ORL     A,?V0 + 7
        JZ      ??zclReadAttrDataUsingCB_0
// 2498   {
// 2499     *pDataLen = 0; // Always initialize it to 0
        MOV     DPL,?V0 + 6
        MOV     DPH,?V0 + 7
        MOV     A,#0x0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
// 2500   }
// 2501 
// 2502   if ( pfnReadWriteCB != NULL )
??zclReadAttrDataUsingCB_0:
        MOV     A,R6
        ORL     A,R7
        JZ      ??zclReadAttrDataUsingCB_1
// 2503   {
// 2504     // Read the attribute value and its length
// 2505     return ( (*pfnReadWriteCB)( clusterId, attrId, ZCL_OPER_READ, pAttrData, pDataLen ) );
        ; Setup parameters for indirect call
        MOV     R0,#?V0 + 6
        LCALL   ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 22)
        MOV     R0,#?V0 + 8
        LCALL   ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 24)
        MOV     R1,#0x1
        MOV     R4,?V0 + 0
        MOV     R5,?V0 + 1
        MOV     R2,?V0 + 2
        MOV     R3,?V0 + 3
        MOV     DPL,R6
        MOV     DPH,R7
        LCALL   ?CALL_IND
        MOV     A,#0x4
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 20)
        SJMP    ??zclReadAttrDataUsingCB_2
// 2506   }
// 2507 
// 2508   return ( ZCL_STATUS_SOFTWARE_FAILURE );
??zclReadAttrDataUsingCB_1:
        MOV     R1,#-0x3f
??zclReadAttrDataUsingCB_2:
        MOV     R7,#0xc
        LJMP    ?BANKED_LEAVE_XDATA
          CFI EndBlock cfiBlock40
// 2509 }
// 2510 
// 2511 /*********************************************************************
// 2512  * @fn      zclAuthorizeRead
// 2513  *
// 2514  * @brief   Use application's callback to authorize a Read operation
// 2515  *          on a given attribute.
// 2516  *
// 2517  * @param   endpoint - application's endpoint
// 2518  * @param   srcAddr - source Address
// 2519  * @param   pAttr - pointer to attribute
// 2520  *
// 2521  * @return  ZCL_STATUS_SUCCESS: Operation authorized
// 2522  *          ZCL_STATUS_NOT_AUTHORIZED: Operation not authorized
// 2523  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 2524 static ZStatus_t zclAuthorizeRead( uint8 endpoint, afAddrType_t *srcAddr, zclAttrRec_t *pAttr )
zclAuthorizeRead:
          CFI Block cfiBlock41 Using cfiCommon0
          CFI Function zclAuthorizeRead
        CODE
// 2525 {
        FUNCALL zclAuthorizeRead, zclGetAuthorizeCB
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 16, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 16, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0x10
        LCALL   ?BANKED_ENTER_XDATA
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V7 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI V6 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V5 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI V4 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-13)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-14)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-15)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-16)))
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 16)
        ; Saved register size: 16
        ; Auto size: 0
        MOV     ?V0 + 4,R1
        MOV     ?V0 + 2,R2
        MOV     ?V0 + 3,R3
        MOV     ?V0 + 0,R4
        MOV     ?V0 + 1,R5
// 2526   if ( zcl_AccessCtrlAuthRead( pAttr->attr.accessControl ) )
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     C,0xE0 /* A   */.4
        JNC     ??zclAuthorizeRead_0
// 2527   {
// 2528     zclAuthorizeCB_t pfnAuthorizeCB = zclGetAuthorizeCB( endpoint );
        ; Setup parameters for call to function zclGetAuthorizeCB
        MOV     R1,?V0 + 4
        LCALL   ??zclGetAuthorizeCB?relay
        MOV     ?V0 + 6,R2
        MOV     ?V0 + 7,R3
        MOV     R6,?V0 + 6
        MOV     R7,?V0 + 7
// 2529 
// 2530     if ( pfnAuthorizeCB != NULL )
        MOV     A,R6
        ORL     A,R7
        JZ      ??zclAuthorizeRead_0
// 2531     {
// 2532       return ( (*pfnAuthorizeCB)( srcAddr, pAttr, ZCL_OPER_READ ) );
        ; Setup parameters for indirect call
        MOV     R1,#0x1
        MOV     R4,?V0 + 0
        MOV     R5,?V0 + 1
        MOV     R2,?V0 + 2
        MOV     R3,?V0 + 3
        MOV     DPL,R6
        MOV     DPH,R7
        LCALL   ?CALL_IND
        SJMP    ??zclAuthorizeRead_1
// 2533     }
// 2534   }
// 2535 
// 2536   return ( ZCL_STATUS_SUCCESS );
??zclAuthorizeRead_0:
        MOV     R1,#0x0
??zclAuthorizeRead_1:
        MOV     R7,#0x8
        LJMP    ?BANKED_LEAVE_XDATA
          CFI EndBlock cfiBlock41
// 2537 }
// 2538 #endif // ZCL_READ
// 2539 
// 2540 #ifdef ZCL_WRITE
// 2541 /*********************************************************************
// 2542  * @fn      zclWriteAttrData
// 2543  *
// 2544  * @brief   Write the received data.
// 2545  *
// 2546  * @param   endpoint - application's endpoint
// 2547  * @param   pAttr - where to write data to
// 2548  * @param   pWriteRec - data to be written
// 2549  *
// 2550  * @return  Successful if data was written
// 2551  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 2552 static ZStatus_t zclWriteAttrData( uint8 endpoint, afAddrType_t *srcAddr,
zclWriteAttrData:
          CFI Block cfiBlock42 Using cfiCommon0
          CFI Function zclWriteAttrData
        CODE
// 2553                                    zclAttrRec_t *pAttr, zclWriteRec_t *pWriteRec )
// 2554 {
        FUNCALL zclWriteAttrData, zclAuthorizeWrite
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 20, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 20, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL zclWriteAttrData, zclGetAttrDataLength
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 20, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 20, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL zclWriteAttrData, osal_memcpy
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 23, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 23, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0x14
        LCALL   ?BANKED_ENTER_XDATA
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V11 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI V10 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V9 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI V8 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI V7 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI V6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI V5 load(1, XDATA, add(CFA_XSP16, literal(-13)))
          CFI V4 load(1, XDATA, add(CFA_XSP16, literal(-14)))
          CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-15)))
          CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-16)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-17)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-18)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-19)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-20)))
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 20)
        ; Saved register size: 20
        ; Auto size: 0
        MOV     ?V0 + 3,R1
        MOV     ?V0 + 10,R2
        MOV     ?V0 + 11,R3
        MOV     A,R4
        MOV     R6,A
        MOV     A,R5
        MOV     R7,A
        MOV     A,#0x14
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     ?V0 + 0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     ?V0 + 1,A
// 2555   uint8 status;
// 2556 
// 2557   if ( zcl_AccessCtrlWrite( pAttr->attr.accessControl ) )
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     C,0xE0 /* A   */.1
        JC      $+5
        LJMP    ??zclWriteAttrData_0 & 0xFFFF
// 2558   {
// 2559     status = zclAuthorizeWrite( endpoint, srcAddr, pAttr );
        ; Setup parameters for call to function zclAuthorizeWrite
        MOV     A,R6
        MOV     R4,A
        MOV     A,R7
        MOV     R5,A
        MOV     R2,?V0 + 10
        MOV     R3,?V0 + 11
        MOV     R1,?V0 + 3
        LCALL   ??zclAuthorizeWrite?relay
        MOV     A,R1
        MOV     ?V0 + 2,A
// 2560     if ( status == ZCL_STATUS_SUCCESS )
        MOV     A,?V0 + 2
        JZ      $+5
        LJMP    ??zclWriteAttrData_1 & 0xFFFF
// 2561     {
// 2562       if ( ( zcl_ValidateAttrDataCB == NULL ) || zcl_ValidateAttrDataCB( pAttr, pWriteRec ) )
        MOV     DPTR,#zcl_ValidateAttrDataCB
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JZ      ??zclWriteAttrData_2
        ; Setup parameters for indirect call
        MOV     R4,?V0 + 0
        MOV     R5,?V0 + 1
        MOV     A,R6
        MOV     R2,A
        MOV     A,R7
        MOV     R3,A
        MOV     DPTR,#zcl_ValidateAttrDataCB
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        LCALL   ?CALL_IND
        MOV     A,R1
        JZ      ??zclWriteAttrData_3
// 2563       {
// 2564         // Write the attribute value
// 2565         uint16 len = zclGetAttrDataLength( pAttr->attr.dataType, pWriteRec->attrData );
??zclWriteAttrData_2:
        ; Setup parameters for call to function zclGetAttrDataLength
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??zclGetAttrDataLength?relay
        MOV     ?V0 + 4,R2
        MOV     ?V0 + 5,R3
        MOV     ?V0 + 8,?V0 + 4
        MOV     ?V0 + 9,?V0 + 5
// 2566         osal_memcpy( pAttr->attr.dataPtr, pWriteRec->attrData, len );
        ; Setup parameters for call to function osal_memcpy
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     ?V0 + 4,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     ?V0 + 5,A
        MOV     ?V0 + 6,#0x0
        MOV     R0,#?V0 + 4
        LCALL   ?PUSH_XSTACK_I_THREE
          CFI CFA_XSP16 add(XSP16, 23)
        MOV     R4,?V0 + 8
        MOV     R5,?V0 + 9
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        LCALL   ??osal_memcpy?relay
        MOV     A,#0x3
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 20)
// 2567 
// 2568         status = ZCL_STATUS_SUCCESS;
        MOV     ?V0 + 2,#0x0
        SJMP    ??zclWriteAttrData_1
// 2569       }
// 2570       else
// 2571       {
// 2572         status = ZCL_STATUS_INVALID_VALUE;
??zclWriteAttrData_3:
        MOV     ?V0 + 2,#-0x79
        SJMP    ??zclWriteAttrData_1
// 2573       }
// 2574     }
// 2575   }
// 2576   else
// 2577   {
// 2578     status = ZCL_STATUS_READ_ONLY;
??zclWriteAttrData_0:
        MOV     ?V0 + 2,#-0x78
// 2579   }
// 2580 
// 2581   return ( status );
??zclWriteAttrData_1:
        MOV     R1,?V0 + 2
        MOV     R7,#0xc
        LJMP    ?BANKED_LEAVE_XDATA
          CFI EndBlock cfiBlock42
// 2582 }
// 2583 
// 2584 /*********************************************************************
// 2585  * @fn      zclWriteAttrDataUsingCB
// 2586  *
// 2587  * @brief   Use application's callback to write the attribute's current
// 2588  *          value stored in the database.
// 2589  *
// 2590  * @param   endpoint - application's endpoint
// 2591  * @param   pAttr - where to write data to
// 2592  * @param   pAttrData - data to be written
// 2593  *
// 2594  * @return  Successful if data was written
// 2595  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 2596 static ZStatus_t zclWriteAttrDataUsingCB( uint8 endpoint, afAddrType_t *srcAddr,
zclWriteAttrDataUsingCB:
          CFI Block cfiBlock43 Using cfiCommon0
          CFI Function zclWriteAttrDataUsingCB
        CODE
// 2597                                           zclAttrRec_t *pAttr, uint8 *pAttrData )
// 2598 {
        FUNCALL zclWriteAttrDataUsingCB, zclAuthorizeWrite
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 18, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 18, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL zclWriteAttrDataUsingCB, zclGetReadWriteCB
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 18, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 18, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0x12
        LCALL   ?BANKED_ENTER_XDATA
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V9 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI V8 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V7 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI V6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI V5 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI V4 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-13)))
          CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-14)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-15)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-16)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-17)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-18)))
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 18)
        ; Saved register size: 18
        ; Auto size: 0
        MOV     ?V0 + 1,R1
        MOV     ?V0 + 4,R2
        MOV     ?V0 + 5,R3
        MOV     A,R4
        MOV     R6,A
        MOV     A,R5
        MOV     R7,A
        MOV     A,#0x12
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     ?V0 + 6,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     ?V0 + 7,A
// 2599   uint8 status;
// 2600 
// 2601   if ( zcl_AccessCtrlWrite( pAttr->attr.accessControl ) )
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     C,0xE0 /* A   */.1
        JNC     ??zclWriteAttrDataUsingCB_0
// 2602   {
// 2603     status = zclAuthorizeWrite( endpoint, srcAddr, pAttr );
        ; Setup parameters for call to function zclAuthorizeWrite
        MOV     A,R6
        MOV     R4,A
        MOV     A,R7
        MOV     R5,A
        MOV     R2,?V0 + 4
        MOV     R3,?V0 + 5
        MOV     R1,?V0 + 1
        LCALL   ??zclAuthorizeWrite?relay
        MOV     A,R1
        MOV     ?V0 + 0,A
// 2604     if ( status == ZCL_STATUS_SUCCESS )
        MOV     A,?V0 + 0
        JNZ     ??zclWriteAttrDataUsingCB_1
// 2605     {
// 2606       zclReadWriteCB_t pfnReadWriteCB = zclGetReadWriteCB( endpoint );
        ; Setup parameters for call to function zclGetReadWriteCB
        MOV     R1,?V0 + 1
        LCALL   ??zclGetReadWriteCB?relay
        MOV     ?V0 + 8,R2
        MOV     ?V0 + 9,R3
        MOV     ?V0 + 2,?V0 + 8
        MOV     ?V0 + 3,?V0 + 9
// 2607       if ( pfnReadWriteCB != NULL )
        MOV     A,?V0 + 2
        ORL     A,?V0 + 3
        JZ      ??zclWriteAttrDataUsingCB_2
// 2608       {
// 2609         // Write the attribute value
// 2610         status = (*pfnReadWriteCB)( pAttr->clusterID, pAttr->attr.attrId,
// 2611                                     ZCL_OPER_WRITE, pAttrData, NULL );
        ; Setup parameters for indirect call
        CLR     A
        MOV     ?V0 + 8,A
        MOV     ?V0 + 9,A
        MOV     R0,#?V0 + 8
        LCALL   ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 20)
        MOV     R0,#?V0 + 6
        LCALL   ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 22)
        MOV     R1,#0x2
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R4,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R5,A
        MOV     DPL,R6
        MOV     DPH,R7
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        MOV     DPL,?V0 + 2
        MOV     DPH,?V0 + 3
        LCALL   ?CALL_IND
        MOV     A,#0x4
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 18)
        MOV     A,R1
        MOV     ?V0 + 0,A
        SJMP    ??zclWriteAttrDataUsingCB_1
// 2612       }
// 2613       else
// 2614       {
// 2615         status = ZCL_STATUS_SOFTWARE_FAILURE;
??zclWriteAttrDataUsingCB_2:
        MOV     ?V0 + 0,#-0x3f
        SJMP    ??zclWriteAttrDataUsingCB_1
// 2616       }
// 2617     }
// 2618   }
// 2619   else
// 2620   {
// 2621     status = ZCL_STATUS_READ_ONLY;
??zclWriteAttrDataUsingCB_0:
        MOV     ?V0 + 0,#-0x78
// 2622   }
// 2623 
// 2624   return ( status );
??zclWriteAttrDataUsingCB_1:
        MOV     R1,?V0 + 0
        MOV     R7,#0xa
        LJMP    ?BANKED_LEAVE_XDATA
          CFI EndBlock cfiBlock43
// 2625 }
// 2626 
// 2627 /*********************************************************************
// 2628  * @fn      zclAuthorizeWrite
// 2629  *
// 2630  * @brief   Use application's callback to authorize a Write operation
// 2631  *          on a given attribute.
// 2632  *
// 2633  * @param   endpoint - application's endpoint
// 2634  * @param   srcAddr - source Address
// 2635  * @param   pAttr - pointer to attribute
// 2636  *
// 2637  * @return  ZCL_STATUS_SUCCESS: Operation authorized
// 2638  *          ZCL_STATUS_NOT_AUTHORIZED: Operation not authorized
// 2639  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 2640 static ZStatus_t zclAuthorizeWrite( uint8 endpoint, afAddrType_t *srcAddr, zclAttrRec_t *pAttr )
zclAuthorizeWrite:
          CFI Block cfiBlock44 Using cfiCommon0
          CFI Function zclAuthorizeWrite
        CODE
// 2641 {
        FUNCALL zclAuthorizeWrite, zclGetAuthorizeCB
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 16, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 16, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0x10
        LCALL   ?BANKED_ENTER_XDATA
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V7 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI V6 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V5 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI V4 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-13)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-14)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-15)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-16)))
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 16)
        ; Saved register size: 16
        ; Auto size: 0
        MOV     ?V0 + 4,R1
        MOV     ?V0 + 2,R2
        MOV     ?V0 + 3,R3
        MOV     ?V0 + 0,R4
        MOV     ?V0 + 1,R5
// 2642   if ( zcl_AccessCtrlAuthWrite( pAttr->attr.accessControl ) )
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     C,0xE0 /* A   */.5
        JNC     ??zclAuthorizeWrite_0
// 2643   {
// 2644     zclAuthorizeCB_t pfnAuthorizeCB = zclGetAuthorizeCB( endpoint );
        ; Setup parameters for call to function zclGetAuthorizeCB
        MOV     R1,?V0 + 4
        LCALL   ??zclGetAuthorizeCB?relay
        MOV     ?V0 + 6,R2
        MOV     ?V0 + 7,R3
        MOV     R6,?V0 + 6
        MOV     R7,?V0 + 7
// 2645 
// 2646     if ( pfnAuthorizeCB != NULL )
        MOV     A,R6
        ORL     A,R7
        JZ      ??zclAuthorizeWrite_0
// 2647     {
// 2648       return ( (*pfnAuthorizeCB)( srcAddr, pAttr, ZCL_OPER_WRITE ) );
        ; Setup parameters for indirect call
        MOV     R1,#0x2
        MOV     R4,?V0 + 0
        MOV     R5,?V0 + 1
        MOV     R2,?V0 + 2
        MOV     R3,?V0 + 3
        MOV     DPL,R6
        MOV     DPH,R7
        LCALL   ?CALL_IND
        SJMP    ??zclAuthorizeWrite_1
// 2649     }
// 2650   }
// 2651 
// 2652   return ( ZCL_STATUS_SUCCESS );
??zclAuthorizeWrite_0:
        MOV     R1,#0x0
??zclAuthorizeWrite_1:
        MOV     R7,#0x8
        LJMP    ?BANKED_LEAVE_XDATA
          CFI EndBlock cfiBlock44
// 2653 }
// 2654 #endif // ZCL_WRITE
// 2655 
// 2656 #ifdef ZCL_READ
// 2657 /*********************************************************************
// 2658  * @fn      zclParseInReadCmd
// 2659  *
// 2660  * @brief   Parse the "Profile" Read Commands
// 2661  *
// 2662  *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
// 2663  *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
// 2664  *
// 2665  * @param   pCmd - pointer to incoming data to parse
// 2666  *
// 2667  * @return  pointer to the parsed command structure
// 2668  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 2669 void *zclParseInReadCmd( zclParseCmd_t *pCmd )
zclParseInReadCmd:
          CFI Block cfiBlock45 Using cfiCommon0
          CFI Function zclParseInReadCmd
        CODE
// 2670 {
        FUNCALL zclParseInReadCmd, osal_mem_alloc
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 14, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 14, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0xe
        LCALL   ?BANKED_ENTER_XDATA
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V5 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI V4 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-13)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-14)))
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 14)
        ; Saved register size: 14
        ; Auto size: 0
        MOV     ?V0 + 2,R2
        MOV     ?V0 + 3,R3
// 2671   zclReadCmd_t *readCmd;
// 2672   uint8 *pBuf = pCmd->pData;
        MOV     DPL,?V0 + 2
        MOV     DPH,?V0 + 3
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     ?V0 + 0,R0
        MOV     ?V0 + 1,R1
// 2673 
// 2674   readCmd = (zclReadCmd_t *)osal_mem_alloc( sizeof ( zclReadCmd_t ) + pCmd->dataLen );
        ; Setup parameters for call to function osal_mem_alloc
        MOV     DPL,?V0 + 2
        MOV     DPH,?V0 + 3
        INC     DPTR
        MOVX    A,@DPTR
        ADD     A,#0x1
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R3,A
        LCALL   ??osal_mem_alloc?relay
        MOV     ?V0 + 4,R2
        MOV     ?V0 + 5,R3
        MOV     R6,?V0 + 4
        MOV     R7,?V0 + 5
// 2675   if ( readCmd != NULL )
        MOV     A,R6
        ORL     A,R7
        JZ      ??zclParseInReadCmd_0
// 2676   {
// 2677     readCmd->numAttr = pCmd->dataLen / 2; // Atrribute ID
        MOV     DPL,?V0 + 2
        MOV     DPH,?V0 + 3
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        CLR     C
        RRC     A
        MOV     R1,A
        MOV     A,R0
        RRC     A
        MOV     R0,A
        MOV     DPL,R6
        MOV     DPH,R7
        MOVX    @DPTR,A
// 2678     for ( uint8 i = 0; i < readCmd->numAttr; i++ )
        MOV     R5,#0x0
??zclParseInReadCmd_1:
        MOV     DPL,R6
        MOV     DPH,R7
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     A,R5
        CLR     C
        SUBB    A,R0
        JNC     ??zclParseInReadCmd_0
// 2679     {
// 2680       readCmd->attrID[i] = BUILD_UINT16( pBuf[0], pBuf[1] );
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     R3,#0x0
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     R1,#0x0
        CLR     A
        XCH     A,R0
        MOV     R1,A
        MOV     A,R2
        ADD     A,R0
        MOV     R2,A
        MOV     A,R3
        ADDC    A,R1
        MOV     R3,A
        MOV     A,R5
        MOV     R0,A
        MOV     R1,#0x0
        MOV     A,R0
        MOV     B,#0x2
        MUL     AB
        XCH     A,R0
        MOV     R4,B
        MOV     B,#0x0
        MUL     AB
        ADD     A,R4
        MOV     R4,A
        MOV     B,#0x2
        MOV     A,R1
        MUL     AB
        ADD     A,R4
        MOV     R1,A
        MOV     A,R6
        ADD     A,R0
        MOV     DPL,A
        MOV     A,R7
        ADDC    A,R1
        MOV     DPH,A
        INC     DPTR
        MOV     A,R2
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R3
        MOVX    @DPTR,A
// 2681       pBuf += 2;
        MOV     A,?V0 + 0
        ADD     A,#0x2
        MOV     ?V0 + 0,A
        MOV     A,?V0 + 1
        ADDC    A,#0x0
        MOV     ?V0 + 1,A
// 2682     }
        INC     R5
        SJMP    ??zclParseInReadCmd_1
// 2683   }
// 2684 
// 2685   return ( (void *)readCmd );
??zclParseInReadCmd_0:
        MOV     A,R6
        MOV     R2,A
        MOV     A,R7
        MOV     R3,A
        MOV     R7,#0x6
        LJMP    ?BANKED_LEAVE_XDATA
          CFI EndBlock cfiBlock45
// 2686 }
// 2687 
// 2688 /*********************************************************************
// 2689  * @fn      zclParseInReadRspCmd
// 2690  *
// 2691  * @brief   Parse the "Profile" Read Response Commands
// 2692  *
// 2693  *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
// 2694  *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
// 2695  *
// 2696  * @param   pCmd - pointer to incoming data to parse
// 2697  *
// 2698  * @return  pointer to the parsed command structure
// 2699  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 2700 static void *zclParseInReadRspCmd( zclParseCmd_t *pCmd )
zclParseInReadRspCmd:
          CFI Block cfiBlock46 Using cfiCommon0
          CFI Function zclParseInReadRspCmd
        CODE
// 2701 {
        FUNCALL zclParseInReadRspCmd, zclGetAttrDataLength
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 26, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 26, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL zclParseInReadRspCmd, osal_mem_alloc
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 26, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 26, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL zclParseInReadRspCmd, zclGetAttrDataLength
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 26, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 26, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL zclParseInReadRspCmd, osal_memcpy
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 29, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 29, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0x18
        LCALL   ?BANKED_ENTER_XDATA
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V15 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI V14 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V13 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI V12 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI V11 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI V10 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI V9 load(1, XDATA, add(CFA_XSP16, literal(-13)))
          CFI V8 load(1, XDATA, add(CFA_XSP16, literal(-14)))
          CFI V7 load(1, XDATA, add(CFA_XSP16, literal(-15)))
          CFI V6 load(1, XDATA, add(CFA_XSP16, literal(-16)))
          CFI V5 load(1, XDATA, add(CFA_XSP16, literal(-17)))
          CFI V4 load(1, XDATA, add(CFA_XSP16, literal(-18)))
          CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-19)))
          CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-20)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-21)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-22)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-23)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-24)))
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 24)
        ; Saved register size: 24
        ; Auto size: 2
        MOV     A,#-0x2
        LCALL   ?ALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 26)
        MOV     ?V0 + 14,R2
        MOV     ?V0 + 15,R3
// 2702   zclReadRspCmd_t *readRspCmd;
// 2703   uint8 *pBuf = pCmd->pData;
        MOV     DPL,?V0 + 14
        MOV     DPH,?V0 + 15
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R6,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R7,A
// 2704   uint8 *dataPtr;
// 2705   uint8 numAttr = 0;
        MOV     ?V0 + 7,#0x0
// 2706   uint8 hdrLen;
// 2707   uint16 dataLen = 0;
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     A,#0x0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
// 2708   uint16 attrDataLen;
// 2709 
// 2710   // find out the number of attributes and the length of attribute data
// 2711   while ( pBuf < ( pCmd->pData + pCmd->dataLen ) )
??zclParseInReadRspCmd_0:
        MOV     DPL,?V0 + 14
        MOV     DPH,?V0 + 15
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     DPL,?V0 + 14
        MOV     DPH,?V0 + 15
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        ADD     A,R0
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,R1
        MOV     R1,A
        CLR     C
        MOV     A,R6
        SUBB    A,R0
        MOV     A,R7
        SUBB    A,R1
        JNC     ??zclParseInReadRspCmd_1
// 2712   {
// 2713     uint8 status;
// 2714 
// 2715     numAttr++;
        INC     ?V0 + 7
// 2716     pBuf += 2; // move pass attribute id
        MOV     A,R6
        ADD     A,#0x2
        MOV     R6,A
        MOV     A,R7
        ADDC    A,#0x0
        MOV     R7,A
// 2717 
// 2718     status = *pBuf++;
        MOV     DPL,R6
        MOV     DPH,R7
        MOVX    A,@DPTR
        MOV     ?V0 + 4,A
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        MOV     R6,DPL
        MOV     R7,DPH
// 2719     if ( status == ZCL_STATUS_SUCCESS )
        MOV     A,?V0 + 4
        JNZ     ??zclParseInReadRspCmd_0
// 2720     {
// 2721       uint8 dataType = *pBuf++;
        MOV     DPL,R6
        MOV     DPH,R7
        MOVX    A,@DPTR
        MOV     ?V0 + 5,A
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        MOV     R6,DPL
        MOV     R7,DPH
// 2722 
// 2723       attrDataLen = zclGetAttrDataLength( dataType, pBuf );
        ; Setup parameters for call to function zclGetAttrDataLength
        MOV     A,R6
        MOV     R2,A
        MOV     A,R7
        MOV     R3,A
        MOV     R1,?V0 + 5
        LCALL   ??zclGetAttrDataLength?relay
        MOV     ?V0 + 0,R2
        MOV     ?V0 + 1,R3
        MOV     ?V0 + 2,?V0 + 0
        MOV     ?V0 + 3,?V0 + 1
// 2724       pBuf += attrDataLen; // move pass attribute data
        MOV     A,R6
        ADD     A,?V0 + 2
        MOV     R6,A
        MOV     A,R7
        ADDC    A,?V0 + 3
        MOV     R7,A
// 2725 
// 2726       // add padding if needed
// 2727       if ( PADDING_NEEDED( attrDataLen ) )
        MOV     A,?V0 + 2
        MOV     C,0xE0 /* A   */.0
        JNC     ??zclParseInReadRspCmd_2
// 2728       {
// 2729         attrDataLen++;
        MOV     A,?V0 + 2
        ADD     A,#0x1
        MOV     ?V0 + 2,A
        MOV     A,?V0 + 3
        ADDC    A,#0x0
        MOV     ?V0 + 3,A
// 2730       }
// 2731 
// 2732       dataLen += attrDataLen;
??zclParseInReadRspCmd_2:
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        ADD     A,?V0 + 2
        MOVX    @DPTR,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,?V0 + 3
        MOVX    @DPTR,A
        LJMP    ??zclParseInReadRspCmd_0 & 0xFFFF
// 2733     }
// 2734   }
// 2735 
// 2736   // calculate the length of the response header
// 2737   hdrLen = sizeof( zclReadRspCmd_t ) + ( numAttr * sizeof( zclReadRspStatus_t ) );
??zclParseInReadRspCmd_1:
        MOV     B,#0x6
        MOV     A,?V0 + 7
        MUL     AB
        ADD     A,#0x1
        MOV     ?V0 + 9,A
// 2738 
// 2739   readRspCmd = (zclReadRspCmd_t *)osal_mem_alloc( hdrLen + dataLen );
        ; Setup parameters for call to function osal_mem_alloc
        MOV     ?V0 + 0,?V0 + 9
        MOV     ?V0 + 1,#0x0
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        ADD     A,?V0 + 0
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,?V0 + 1
        MOV     R3,A
        LCALL   ??osal_mem_alloc?relay
        MOV     ?V0 + 0,R2
        MOV     ?V0 + 1,R3
        MOV     ?V0 + 12,?V0 + 0
        MOV     ?V0 + 13,?V0 + 1
// 2740   if ( readRspCmd != NULL )
        MOV     A,?V0 + 12
        ORL     A,?V0 + 13
        JNZ     $+5
        LJMP    ??zclParseInReadRspCmd_3 & 0xFFFF
// 2741   {
// 2742     pBuf = pCmd->pData;
        MOV     DPL,?V0 + 14
        MOV     DPH,?V0 + 15
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        MOV     R6,A
        MOV     A,R1
        MOV     R7,A
// 2743     dataPtr = (uint8 *)( (uint8 *)readRspCmd + hdrLen );
        MOV     ?V0 + 0,?V0 + 9
        MOV     ?V0 + 1,#0x0
        MOV     A,?V0 + 12
        ADD     A,?V0 + 0
        MOV     R0,A
        MOV     A,?V0 + 13
        ADDC    A,?V0 + 1
        MOV     R1,A
        MOV     ?V0 + 10,R0
        MOV     ?V0 + 11,R1
// 2744 
// 2745     readRspCmd->numAttr = numAttr;
        MOV     A,?V0 + 7
        MOV     DPL,?V0 + 12
        MOV     DPH,?V0 + 13
        MOV     A,?V0 + 7
        MOVX    @DPTR,A
// 2746     for ( uint8 i = 0; i < numAttr; i++ )
        MOV     ?V0 + 8,#0x0
??zclParseInReadRspCmd_4:
        MOV     A,?V0 + 8
        CLR     C
        SUBB    A,?V0 + 7
        JC      $+5
        LJMP    ??zclParseInReadRspCmd_3 & 0xFFFF
// 2747     {
// 2748       zclReadRspStatus_t *statusRec = &(readRspCmd->attrList[i]);
        MOV     A,?V0 + 8
        MOV     R0,?V0 + 8
        MOV     R1,#0x0
        MOV     A,R0
        MOV     B,#0x6
        MUL     AB
        XCH     A,R0
        MOV     R2,B
        MOV     B,#0x0
        MUL     AB
        ADD     A,R2
        MOV     R2,A
        MOV     B,#0x6
        MOV     A,R1
        MUL     AB
        ADD     A,R2
        MOV     R1,A
        MOV     A,?V0 + 12
        ADD     A,R0
        MOV     DPL,A
        MOV     A,?V0 + 13
        ADDC    A,R1
        MOV     DPH,A
        INC     DPTR
        MOV     ?V0 + 0,DPL
        MOV     ?V0 + 1,DPH
// 2749 
// 2750       statusRec->attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
        MOV     DPL,R6
        MOV     DPH,R7
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     R3,#0x0
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     R1,#0x0
        CLR     A
        XCH     A,R0
        MOV     R1,A
        MOV     A,R2
        ADD     A,R0
        MOV     R0,A
        MOV     A,R3
        ADDC    A,R1
        MOV     R1,A
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
// 2751       pBuf += 2;
        MOV     A,R6
        ADD     A,#0x2
        MOV     R6,A
        MOV     A,R7
        ADDC    A,#0x0
        MOV     R7,A
// 2752 
// 2753       statusRec->status = *pBuf++;
        MOV     DPL,R6
        MOV     DPH,R7
        MOVX    A,@DPTR
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        INC     DPTR
        INC     DPTR
        MOVX    @DPTR,A
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        MOV     R6,DPL
        MOV     R7,DPH
// 2754       if ( statusRec->status == ZCL_STATUS_SUCCESS )
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        JZ      $+5
        LJMP    ??zclParseInReadRspCmd_5 & 0xFFFF
// 2755       {
// 2756         statusRec->dataType = *pBuf++;
        MOV     DPL,R6
        MOV     DPH,R7
        MOVX    A,@DPTR
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    @DPTR,A
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        MOV     R6,DPL
        MOV     R7,DPH
// 2757 
// 2758         attrDataLen = zclGetAttrDataLength( statusRec->dataType, pBuf );
        ; Setup parameters for call to function zclGetAttrDataLength
        MOV     A,R6
        MOV     R2,A
        MOV     A,R7
        MOV     R3,A
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??zclGetAttrDataLength?relay
        MOV     ?V0 + 4,R2
        MOV     ?V0 + 5,R3
        MOV     ?V0 + 2,?V0 + 4
        MOV     ?V0 + 3,?V0 + 5
// 2759         osal_memcpy( dataPtr, pBuf, attrDataLen);
        ; Setup parameters for call to function osal_memcpy
        MOV     ?V0 + 4,R6
        MOV     ?V0 + 5,R7
        MOV     ?V0 + 6,#0x0
        MOV     R0,#?V0 + 4
        LCALL   ?PUSH_XSTACK_I_THREE
          CFI CFA_XSP16 add(XSP16, 29)
        MOV     R4,?V0 + 2
        MOV     R5,?V0 + 3
        MOV     R2,?V0 + 10
        MOV     R3,?V0 + 11
        LCALL   ??osal_memcpy?relay
        MOV     A,#0x3
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 26)
// 2760         statusRec->data = dataPtr;
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOV     A,?V0 + 10
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,?V0 + 11
        MOVX    @DPTR,A
// 2761 
// 2762         pBuf += attrDataLen; // move pass attribute data
        MOV     A,R6
        ADD     A,?V0 + 2
        MOV     R6,A
        MOV     A,R7
        ADDC    A,?V0 + 3
        MOV     R7,A
// 2763 
// 2764         // advance attribute data pointer
// 2765         if ( PADDING_NEEDED( attrDataLen ) )
        MOV     A,?V0 + 2
        MOV     C,0xE0 /* A   */.0
        JNC     ??zclParseInReadRspCmd_6
// 2766         {
// 2767           attrDataLen++;
        MOV     A,?V0 + 2
        ADD     A,#0x1
        MOV     ?V0 + 2,A
        MOV     A,?V0 + 3
        ADDC    A,#0x0
        MOV     ?V0 + 3,A
// 2768         }
// 2769 
// 2770         dataPtr += attrDataLen;
??zclParseInReadRspCmd_6:
        MOV     A,?V0 + 10
        ADD     A,?V0 + 2
        MOV     ?V0 + 10,A
        MOV     A,?V0 + 11
        ADDC    A,?V0 + 3
        MOV     ?V0 + 11,A
// 2771       }
// 2772     }
??zclParseInReadRspCmd_5:
        INC     ?V0 + 8
        LJMP    ??zclParseInReadRspCmd_4 & 0xFFFF
// 2773   }
// 2774 
// 2775   return ( (void *)readRspCmd );
??zclParseInReadRspCmd_3:
        MOV     R2,?V0 + 12
        MOV     R3,?V0 + 13
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 24)
        MOV     R7,#0x10
        LJMP    ?BANKED_LEAVE_XDATA
          CFI EndBlock cfiBlock46
// 2776 }
// 2777 #endif // ZCL_READ
// 2778 
// 2779 #ifdef ZCL_WRITE
// 2780 /*********************************************************************
// 2781  * @fn      zclParseInWriteCmd
// 2782  *
// 2783  * @brief   Parse the "Profile" Write, Write Undivided and Write No
// 2784  *          Response Commands
// 2785  *
// 2786  *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
// 2787  *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
// 2788  *
// 2789  * @param   pCmd - pointer to incoming data to parse
// 2790  *
// 2791  * @return  pointer to the parsed command structure
// 2792  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 2793 void *zclParseInWriteCmd( zclParseCmd_t *pCmd )
zclParseInWriteCmd:
          CFI Block cfiBlock47 Using cfiCommon0
          CFI Function zclParseInWriteCmd
        CODE
// 2794 {
        FUNCALL zclParseInWriteCmd, zclGetAttrDataLength
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 26, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 26, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL zclParseInWriteCmd, osal_mem_alloc
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 26, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 26, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL zclParseInWriteCmd, zclGetAttrDataLength
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 26, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 26, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL zclParseInWriteCmd, osal_memcpy
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 29, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 29, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0x18
        LCALL   ?BANKED_ENTER_XDATA
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V15 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI V14 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V13 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI V12 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI V11 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI V10 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI V9 load(1, XDATA, add(CFA_XSP16, literal(-13)))
          CFI V8 load(1, XDATA, add(CFA_XSP16, literal(-14)))
          CFI V7 load(1, XDATA, add(CFA_XSP16, literal(-15)))
          CFI V6 load(1, XDATA, add(CFA_XSP16, literal(-16)))
          CFI V5 load(1, XDATA, add(CFA_XSP16, literal(-17)))
          CFI V4 load(1, XDATA, add(CFA_XSP16, literal(-18)))
          CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-19)))
          CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-20)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-21)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-22)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-23)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-24)))
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 24)
        ; Saved register size: 24
        ; Auto size: 2
        MOV     A,#-0x2
        LCALL   ?ALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 26)
        MOV     ?V0 + 14,R2
        MOV     ?V0 + 15,R3
// 2795   zclWriteCmd_t *writeCmd;
// 2796   uint8 *pBuf = pCmd->pData;
        MOV     DPL,?V0 + 14
        MOV     DPH,?V0 + 15
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R6,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R7,A
// 2797   uint16 attrDataLen;
// 2798   uint8 *dataPtr;
// 2799   uint8 numAttr = 0;
        MOV     ?V0 + 7,#0x0
// 2800   uint8 hdrLen;
// 2801   uint16 dataLen = 0;
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     A,#0x0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
// 2802 
// 2803   // find out the number of attributes and the length of attribute data
// 2804   while ( pBuf < ( pCmd->pData + pCmd->dataLen ) )
??zclParseInWriteCmd_0:
        MOV     DPL,?V0 + 14
        MOV     DPH,?V0 + 15
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     DPL,?V0 + 14
        MOV     DPH,?V0 + 15
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        ADD     A,R0
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,R1
        MOV     R1,A
        CLR     C
        MOV     A,R6
        SUBB    A,R0
        MOV     A,R7
        SUBB    A,R1
        JNC     ??zclParseInWriteCmd_1
// 2805   {
// 2806     uint8 dataType;
// 2807 
// 2808     numAttr++;
        INC     ?V0 + 7
// 2809     pBuf += 2; // move pass attribute id
        MOV     A,R6
        ADD     A,#0x2
        MOV     R6,A
        MOV     A,R7
        ADDC    A,#0x0
        MOV     R7,A
// 2810 
// 2811     dataType = *pBuf++;
        MOV     DPL,R6
        MOV     DPH,R7
        MOVX    A,@DPTR
        MOV     ?V0 + 6,A
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        MOV     R6,DPL
        MOV     R7,DPH
// 2812 
// 2813     attrDataLen = zclGetAttrDataLength( dataType, pBuf );
        ; Setup parameters for call to function zclGetAttrDataLength
        MOV     A,R6
        MOV     R2,A
        MOV     A,R7
        MOV     R3,A
        MOV     R1,?V0 + 6
        LCALL   ??zclGetAttrDataLength?relay
        MOV     ?V0 + 4,R2
        MOV     ?V0 + 5,R3
        MOV     ?V0 + 0,?V0 + 4
        MOV     ?V0 + 1,?V0 + 5
// 2814     pBuf += attrDataLen; // move pass attribute data
        MOV     A,R6
        ADD     A,?V0 + 0
        MOV     R6,A
        MOV     A,R7
        ADDC    A,?V0 + 1
        MOV     R7,A
// 2815 
// 2816     // add padding if needed
// 2817     if ( PADDING_NEEDED( attrDataLen ) )
        MOV     A,?V0 + 0
        MOV     C,0xE0 /* A   */.0
        JNC     ??zclParseInWriteCmd_2
// 2818     {
// 2819       attrDataLen++;
        MOV     A,?V0 + 0
        ADD     A,#0x1
        MOV     ?V0 + 0,A
        MOV     A,?V0 + 1
        ADDC    A,#0x0
        MOV     ?V0 + 1,A
// 2820     }
// 2821 
// 2822     dataLen += attrDataLen;
??zclParseInWriteCmd_2:
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        ADD     A,?V0 + 0
        MOVX    @DPTR,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,?V0 + 1
        MOVX    @DPTR,A
        SJMP    ??zclParseInWriteCmd_0
// 2823   }
// 2824 
// 2825   // calculate the length of the response header
// 2826   hdrLen = sizeof( zclWriteCmd_t ) + ( numAttr * sizeof( zclWriteRec_t ) );
??zclParseInWriteCmd_1:
        MOV     B,#0x5
        MOV     A,?V0 + 7
        MUL     AB
        ADD     A,#0x1
        MOV     ?V0 + 9,A
// 2827 
// 2828   writeCmd = (zclWriteCmd_t *)osal_mem_alloc( hdrLen + dataLen );
        ; Setup parameters for call to function osal_mem_alloc
        MOV     ?V0 + 4,?V0 + 9
        MOV     ?V0 + 5,#0x0
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        ADD     A,?V0 + 4
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,?V0 + 5
        MOV     R3,A
        LCALL   ??osal_mem_alloc?relay
        MOV     ?V0 + 4,R2
        MOV     ?V0 + 5,R3
        MOV     ?V0 + 10,?V0 + 4
        MOV     ?V0 + 11,?V0 + 5
// 2829   if ( writeCmd != NULL )
        MOV     A,?V0 + 10
        ORL     A,?V0 + 11
        JNZ     $+5
        LJMP    ??zclParseInWriteCmd_3 & 0xFFFF
// 2830   {
// 2831     pBuf = pCmd->pData;
        MOV     DPL,?V0 + 14
        MOV     DPH,?V0 + 15
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        MOV     R6,A
        MOV     A,R1
        MOV     R7,A
// 2832     dataPtr = (uint8 *)( (uint8 *)writeCmd + hdrLen );
        MOV     ?V0 + 4,?V0 + 9
        MOV     ?V0 + 5,#0x0
        MOV     A,?V0 + 10
        ADD     A,?V0 + 4
        MOV     R0,A
        MOV     A,?V0 + 11
        ADDC    A,?V0 + 5
        MOV     R1,A
        MOV     ?V0 + 2,R0
        MOV     ?V0 + 3,R1
// 2833 
// 2834     writeCmd->numAttr = numAttr;
        MOV     A,?V0 + 7
        MOV     DPL,?V0 + 10
        MOV     DPH,?V0 + 11
        MOV     A,?V0 + 7
        MOVX    @DPTR,A
// 2835     for ( uint8 i = 0; i < numAttr; i++ )
        MOV     ?V0 + 8,#0x0
??zclParseInWriteCmd_4:
        MOV     A,?V0 + 8
        CLR     C
        SUBB    A,?V0 + 7
        JC      $+5
        LJMP    ??zclParseInWriteCmd_3 & 0xFFFF
// 2836     {
// 2837       zclWriteRec_t *statusRec = &(writeCmd->attrList[i]);
        MOV     A,?V0 + 8
        MOV     R0,?V0 + 8
        MOV     R1,#0x0
        MOV     A,R0
        MOV     B,#0x5
        MUL     AB
        XCH     A,R0
        MOV     R2,B
        MOV     B,#0x0
        MUL     AB
        ADD     A,R2
        MOV     R2,A
        MOV     B,#0x5
        MOV     A,R1
        MUL     AB
        ADD     A,R2
        MOV     R1,A
        MOV     A,?V0 + 10
        ADD     A,R0
        MOV     DPL,A
        MOV     A,?V0 + 11
        ADDC    A,R1
        MOV     DPH,A
        INC     DPTR
        MOV     ?V0 + 12,DPL
        MOV     ?V0 + 13,DPH
// 2838 
// 2839       statusRec->attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
        MOV     DPL,R6
        MOV     DPH,R7
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     R3,#0x0
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     R1,#0x0
        CLR     A
        XCH     A,R0
        MOV     R1,A
        MOV     A,R2
        ADD     A,R0
        MOV     R0,A
        MOV     A,R3
        ADDC    A,R1
        MOV     R1,A
        MOV     DPL,?V0 + 12
        MOV     DPH,?V0 + 13
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
// 2840       pBuf += 2;
        MOV     A,R6
        ADD     A,#0x2
        MOV     R6,A
        MOV     A,R7
        ADDC    A,#0x0
        MOV     R7,A
// 2841       statusRec->dataType = *pBuf++;
        MOV     DPL,R6
        MOV     DPH,R7
        MOVX    A,@DPTR
        MOV     DPL,?V0 + 12
        MOV     DPH,?V0 + 13
        INC     DPTR
        INC     DPTR
        MOVX    @DPTR,A
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        MOV     R6,DPL
        MOV     R7,DPH
// 2842 
// 2843       attrDataLen = zclGetAttrDataLength( statusRec->dataType, pBuf );
        ; Setup parameters for call to function zclGetAttrDataLength
        MOV     A,R6
        MOV     R2,A
        MOV     A,R7
        MOV     R3,A
        MOV     DPL,?V0 + 12
        MOV     DPH,?V0 + 13
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??zclGetAttrDataLength?relay
        MOV     ?V0 + 4,R2
        MOV     ?V0 + 5,R3
        MOV     ?V0 + 0,?V0 + 4
        MOV     ?V0 + 1,?V0 + 5
// 2844       osal_memcpy( dataPtr, pBuf, attrDataLen);
        ; Setup parameters for call to function osal_memcpy
        MOV     ?V0 + 4,R6
        MOV     ?V0 + 5,R7
        MOV     ?V0 + 6,#0x0
        MOV     R0,#?V0 + 4
        LCALL   ?PUSH_XSTACK_I_THREE
          CFI CFA_XSP16 add(XSP16, 29)
        MOV     R4,?V0 + 0
        MOV     R5,?V0 + 1
        MOV     R2,?V0 + 2
        MOV     R3,?V0 + 3
        LCALL   ??osal_memcpy?relay
        MOV     A,#0x3
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 26)
// 2845       statusRec->attrData = dataPtr;
        MOV     DPL,?V0 + 12
        MOV     DPH,?V0 + 13
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOV     A,?V0 + 2
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,?V0 + 3
        MOVX    @DPTR,A
// 2846 
// 2847       pBuf += attrDataLen; // move pass attribute data
        MOV     A,R6
        ADD     A,?V0 + 0
        MOV     R6,A
        MOV     A,R7
        ADDC    A,?V0 + 1
        MOV     R7,A
// 2848 
// 2849       // advance attribute data pointer
// 2850       if ( PADDING_NEEDED( attrDataLen ) )
        MOV     A,?V0 + 0
        MOV     C,0xE0 /* A   */.0
        JNC     ??zclParseInWriteCmd_5
// 2851       {
// 2852         attrDataLen++;
        MOV     A,?V0 + 0
        ADD     A,#0x1
        MOV     ?V0 + 0,A
        MOV     A,?V0 + 1
        ADDC    A,#0x0
        MOV     ?V0 + 1,A
// 2853       }
// 2854 
// 2855       dataPtr += attrDataLen;
??zclParseInWriteCmd_5:
        MOV     A,?V0 + 2
        ADD     A,?V0 + 0
        MOV     ?V0 + 2,A
        MOV     A,?V0 + 3
        ADDC    A,?V0 + 1
        MOV     ?V0 + 3,A
// 2856     }
        INC     ?V0 + 8
        LJMP    ??zclParseInWriteCmd_4 & 0xFFFF
// 2857   }
// 2858 
// 2859   return ( (void *)writeCmd );
??zclParseInWriteCmd_3:
        MOV     R2,?V0 + 10
        MOV     R3,?V0 + 11
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 24)
        MOV     R7,#0x10
        LJMP    ?BANKED_LEAVE_XDATA
          CFI EndBlock cfiBlock47
// 2860 }
// 2861 
// 2862 /*********************************************************************
// 2863  * @fn      zclParseInWriteRspCmd
// 2864  *
// 2865  * @brief   Parse the "Profile" Write Response Commands
// 2866  *
// 2867  *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
// 2868  *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
// 2869  *
// 2870  * @param   pCmd - pointer to incoming data to parse
// 2871  *
// 2872  * @return  pointer to the parsed command structure
// 2873  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 2874 static void *zclParseInWriteRspCmd( zclParseCmd_t *pCmd )
zclParseInWriteRspCmd:
          CFI Block cfiBlock48 Using cfiCommon0
          CFI Function zclParseInWriteRspCmd
        CODE
// 2875 {
        FUNCALL zclParseInWriteRspCmd, osal_mem_alloc
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 16, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 16, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0x10
        LCALL   ?BANKED_ENTER_XDATA
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V7 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI V6 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V5 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI V4 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-13)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-14)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-15)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-16)))
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 16)
        ; Saved register size: 16
        ; Auto size: 0
        MOV     ?V0 + 2,R2
        MOV     ?V0 + 3,R3
// 2876   zclWriteRspCmd_t *writeRspCmd;
// 2877   uint8 *pBuf = pCmd->pData;
        MOV     DPL,?V0 + 2
        MOV     DPH,?V0 + 3
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     ?V0 + 0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     ?V0 + 1,A
// 2878   uint8 i = 0;
        MOV     ?V0 + 4,#0x0
// 2879 
// 2880   writeRspCmd = (zclWriteRspCmd_t *)osal_mem_alloc( sizeof ( zclWriteRspCmd_t ) + pCmd->dataLen );
        ; Setup parameters for call to function osal_mem_alloc
        MOV     DPL,?V0 + 2
        MOV     DPH,?V0 + 3
        INC     DPTR
        MOVX    A,@DPTR
        ADD     A,#0x1
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R3,A
        LCALL   ??osal_mem_alloc?relay
        MOV     ?V0 + 6,R2
        MOV     ?V0 + 7,R3
        MOV     R6,?V0 + 6
        MOV     R7,?V0 + 7
// 2881   if ( writeRspCmd != NULL )
        MOV     A,R6
        ORL     A,R7
        JNZ     $+5
        LJMP    ??zclParseInWriteRspCmd_0 & 0xFFFF
// 2882   {
// 2883     if ( pCmd->dataLen == 1 )
        MOV     DPL,?V0 + 2
        MOV     DPH,?V0 + 3
        INC     DPTR
        MOVX    A,@DPTR
        XRL     A,#0x1
        JNZ     ??zclParseInWriteRspCmd_1
        INC     DPTR
        MOVX    A,@DPTR
        XRL     A,#0x0
??zclParseInWriteRspCmd_1:
        JNZ     ??zclParseInWriteRspCmd_2
// 2884     {
// 2885       // special case when all writes were successfull
// 2886       writeRspCmd->attrList[i++].status = *pBuf;
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        MOVX    A,@DPTR
        PUSH    A
          CFI CFA_SP SP+-1
        MOV     A,?V0 + 4
        MOV     R0,?V0 + 4
        MOV     R1,#0x0
        MOV     A,R0
        MOV     B,#0x3
        MUL     AB
        XCH     A,R0
        MOV     R2,B
        MOV     B,#0x0
        MUL     AB
        ADD     A,R2
        MOV     R2,A
        MOV     B,#0x3
        MOV     A,R1
        MUL     AB
        ADD     A,R2
        MOV     R1,A
        MOV     A,R6
        ADD     A,R0
        MOV     DPL,A
        MOV     A,R7
        ADDC    A,R1
        MOV     DPH,A
        INC     DPTR
        POP     A
          CFI CFA_SP SP+0
        MOVX    @DPTR,A
        INC     ?V0 + 4
        LJMP    ??zclParseInWriteRspCmd_3 & 0xFFFF
// 2887     }
// 2888     else
// 2889     {
// 2890       while ( pBuf < ( pCmd->pData + pCmd->dataLen ) )
??zclParseInWriteRspCmd_2:
        MOV     DPL,?V0 + 2
        MOV     DPH,?V0 + 3
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     DPL,?V0 + 2
        MOV     DPH,?V0 + 3
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        ADD     A,R0
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,R1
        MOV     R1,A
        CLR     C
        MOV     A,?V0 + 0
        SUBB    A,R0
        MOV     A,?V0 + 1
        SUBB    A,R1
        JC      $+5
        LJMP    ??zclParseInWriteRspCmd_3 & 0xFFFF
// 2891       {
// 2892         writeRspCmd->attrList[i].status = *pBuf++;
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        MOVX    A,@DPTR
        PUSH    A
          CFI CFA_SP SP+-1
        MOV     A,?V0 + 4
        MOV     R0,?V0 + 4
        MOV     R1,#0x0
        MOV     A,R0
        MOV     B,#0x3
        MUL     AB
        XCH     A,R0
        MOV     R2,B
        MOV     B,#0x0
        MUL     AB
        ADD     A,R2
        MOV     R2,A
        MOV     B,#0x3
        MOV     A,R1
        MUL     AB
        ADD     A,R2
        MOV     R1,A
        MOV     A,R6
        ADD     A,R0
        MOV     DPL,A
        MOV     A,R7
        ADDC    A,R1
        MOV     DPH,A
        INC     DPTR
        POP     A
          CFI CFA_SP SP+0
        MOVX    @DPTR,A
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        INC     DPTR
        MOV     ?V0 + 0,DPL
        MOV     ?V0 + 1,DPH
// 2893         writeRspCmd->attrList[i++].attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     R3,#0x0
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     R1,#0x0
        CLR     A
        XCH     A,R0
        MOV     R1,A
        MOV     A,R2
        ADD     A,R0
        MOV     R2,A
        MOV     A,R3
        ADDC    A,R1
        MOV     R3,A
        MOV     A,?V0 + 4
        MOV     R0,?V0 + 4
        MOV     R1,#0x0
        MOV     A,R0
        MOV     B,#0x3
        MUL     AB
        XCH     A,R0
        MOV     R4,B
        MOV     B,#0x0
        MUL     AB
        ADD     A,R4
        MOV     R4,A
        MOV     B,#0x3
        MOV     A,R1
        MUL     AB
        ADD     A,R4
        MOV     R1,A
        MOV     A,R6
        ADD     A,R0
        MOV     DPL,A
        MOV     A,R7
        ADDC    A,R1
        MOV     DPH,A
        INC     DPTR
        INC     DPTR
        MOV     A,R2
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R3
        MOVX    @DPTR,A
        INC     ?V0 + 4
// 2894         pBuf += 2;
        MOV     A,?V0 + 0
        ADD     A,#0x2
        MOV     ?V0 + 0,A
        MOV     A,?V0 + 1
        ADDC    A,#0x0
        MOV     ?V0 + 1,A
        LJMP    ??zclParseInWriteRspCmd_2 & 0xFFFF
// 2895       }
// 2896     }
// 2897 
// 2898     writeRspCmd->numAttr = i;
??zclParseInWriteRspCmd_3:
        MOV     A,?V0 + 4
        MOV     DPL,R6
        MOV     DPH,R7
        MOV     A,?V0 + 4
        MOVX    @DPTR,A
// 2899   }
// 2900 
// 2901   return ( (void *)writeRspCmd );
??zclParseInWriteRspCmd_0:
        MOV     A,R6
        MOV     R2,A
        MOV     A,R7
        MOV     R3,A
        MOV     R7,#0x8
        LJMP    ?BANKED_LEAVE_XDATA
          CFI EndBlock cfiBlock48
// 2902 }
// 2903 #endif // ZCL_WRITE
// 2904 
// 2905 #ifdef ZCL_REPORT
// 2906 /*********************************************************************
// 2907  * @fn      zclParseInConfigReportCmd
// 2908  *
// 2909  * @brief   Parse the "Profile" Configure Reporting Command
// 2910  *
// 2911  *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
// 2912  *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
// 2913  *
// 2914  * @param   pCmd - pointer to incoming data to parse
// 2915  *
// 2916  * @return  pointer to the parsed command structure
// 2917  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 2918 void *zclParseInConfigReportCmd( zclParseCmd_t *pCmd )
zclParseInConfigReportCmd:
          CFI Block cfiBlock49 Using cfiCommon0
          CFI Function zclParseInConfigReportCmd
        CODE
// 2919 {
        FUNCALL zclParseInConfigReportCmd, zclAnalogDataType
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 25, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 25, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL zclParseInConfigReportCmd, zclGetDataTypeLength
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 25, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 25, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL zclParseInConfigReportCmd, osal_mem_alloc
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 25, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 25, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL zclParseInConfigReportCmd, osal_memset
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 25, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 25, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL zclParseInConfigReportCmd, zclAnalogDataType
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 25, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 25, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL zclParseInConfigReportCmd, zcl_BuildAnalogData
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 25, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 25, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL zclParseInConfigReportCmd, zclGetDataTypeLength
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 25, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 25, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0x17
        LCALL   ?BANKED_ENTER_XDATA
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V14 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI V13 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V12 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI V11 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI V10 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI V9 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI V8 load(1, XDATA, add(CFA_XSP16, literal(-13)))
          CFI V7 load(1, XDATA, add(CFA_XSP16, literal(-14)))
          CFI V6 load(1, XDATA, add(CFA_XSP16, literal(-15)))
          CFI V5 load(1, XDATA, add(CFA_XSP16, literal(-16)))
          CFI V4 load(1, XDATA, add(CFA_XSP16, literal(-17)))
          CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-18)))
          CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-19)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-20)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-21)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-22)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-23)))
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 23)
        ; Saved register size: 23
        ; Auto size: 2
        MOV     A,#-0x2
        LCALL   ?ALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 25)
        MOV     ?V0 + 12,R2
        MOV     ?V0 + 13,R3
// 2920   zclCfgReportCmd_t *cfgReportCmd;
// 2921   uint8 *pBuf = pCmd->pData;
        MOV     DPL,?V0 + 12
        MOV     DPH,?V0 + 13
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R6,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R7,A
// 2922   uint8 *dataPtr;
// 2923   uint8 numAttr = 0;
        MOV     ?V0 + 1,#0x0
// 2924   uint8 dataType;
// 2925   uint8 hdrLen;
// 2926   uint16 dataLen = 0;
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     A,#0x0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
// 2927   uint8 reportChangeLen; // length of Reportable Change field
// 2928 
// 2929   // Calculate the length of the Request command
// 2930   while ( pBuf < ( pCmd->pData + pCmd->dataLen ) )
??zclParseInConfigReportCmd_0:
        MOV     DPL,?V0 + 12
        MOV     DPH,?V0 + 13
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     DPL,?V0 + 12
        MOV     DPH,?V0 + 13
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        ADD     A,R0
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,R1
        MOV     R1,A
        CLR     C
        MOV     A,R6
        SUBB    A,R0
        MOV     A,R7
        SUBB    A,R1
        JC      $+5
        LJMP    ??zclParseInConfigReportCmd_1 & 0xFFFF
// 2931   {
// 2932     uint8 direction;
// 2933 
// 2934     numAttr++;
        INC     ?V0 + 1
// 2935     direction = *pBuf++;
        MOV     DPL,R6
        MOV     DPH,R7
        MOVX    A,@DPTR
        MOV     ?V0 + 4,A
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        MOV     R6,DPL
        MOV     R7,DPH
// 2936     pBuf += 2; // move pass the attribute ID
        MOV     A,DPL
        ADD     A,#0x2
        MOV     R6,A
        MOV     A,DPH
        ADDC    A,#0x0
        MOV     R7,A
// 2937 
// 2938     // Is there a Reportable Change field?
// 2939     if ( direction == ZCL_SEND_ATTR_REPORTS )
        MOV     A,?V0 + 4
        JNZ     ??zclParseInConfigReportCmd_2
// 2940     {
// 2941       dataType = *pBuf++;
        MOV     DPL,R6
        MOV     DPH,R7
        MOVX    A,@DPTR
        MOV     ?V0 + 14,A
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        MOV     R6,DPL
        MOV     R7,DPH
// 2942       pBuf += 4; // move pass the Min and Max Reporting Intervals
        MOV     A,DPL
        ADD     A,#0x4
        MOV     R6,A
        MOV     A,DPH
        ADDC    A,#0x0
        MOV     R7,A
// 2943 
// 2944       // For attributes of 'discrete' data types this field is omitted
// 2945       if ( zclAnalogDataType( dataType ) )
        ; Setup parameters for call to function zclAnalogDataType
        MOV     R1,?V0 + 14
        LCALL   ??zclAnalogDataType?relay
        MOV     A,R1
        JZ      ??zclParseInConfigReportCmd_0
// 2946       {
// 2947         reportChangeLen = zclGetDataTypeLength( dataType );
        ; Setup parameters for call to function zclGetDataTypeLength
        MOV     R1,?V0 + 14
        LCALL   ??zclGetDataTypeLength?relay
        MOV     A,R1
        MOV     ?V0 + 0,A
// 2948         pBuf += reportChangeLen;
        MOV     ?V0 + 2,?V0 + 0
        MOV     ?V0 + 3,#0x0
        MOV     A,R6
        ADD     A,?V0 + 2
        MOV     R6,A
        MOV     A,R7
        ADDC    A,?V0 + 3
        MOV     R7,A
// 2949 
// 2950         // add padding if needed
// 2951         if ( PADDING_NEEDED( reportChangeLen ) )
        MOV     A,?V0 + 0
        MOV     B,#0x2
        DIV     AB
        MOV     A,B
        JZ      ??zclParseInConfigReportCmd_3
// 2952         {
// 2953           reportChangeLen++;
        INC     ?V0 + 0
// 2954         }
// 2955 
// 2956         dataLen += reportChangeLen;
??zclParseInConfigReportCmd_3:
        MOV     ?V0 + 2,?V0 + 0
        MOV     ?V0 + 3,#0x0
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        ADD     A,?V0 + 2
        MOVX    @DPTR,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,?V0 + 3
        MOVX    @DPTR,A
        LJMP    ??zclParseInConfigReportCmd_0 & 0xFFFF
// 2957       }
// 2958     }
// 2959     else
// 2960     {
// 2961       pBuf += 2; // move pass the Timeout Period
??zclParseInConfigReportCmd_2:
        MOV     A,R6
        ADD     A,#0x2
        MOV     R6,A
        MOV     A,R7
        ADDC    A,#0x0
        MOV     R7,A
        LJMP    ??zclParseInConfigReportCmd_0 & 0xFFFF
// 2962     }
// 2963   } // while loop
// 2964 
// 2965   hdrLen = sizeof( zclCfgReportCmd_t ) + ( numAttr * sizeof( zclCfgReportRec_t ) );
??zclParseInConfigReportCmd_1:
        MOV     B,#0xc
        MOV     A,?V0 + 1
        MUL     AB
        ADD     A,#0x1
        MOV     ?V0 + 5,A
// 2966 
// 2967   cfgReportCmd = (zclCfgReportCmd_t *)osal_mem_alloc( hdrLen + dataLen );
        ; Setup parameters for call to function osal_mem_alloc
        MOV     ?V0 + 2,?V0 + 5
        MOV     ?V0 + 3,#0x0
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        ADD     A,?V0 + 2
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,?V0 + 3
        MOV     R3,A
        LCALL   ??osal_mem_alloc?relay
        MOV     ?V0 + 2,R2
        MOV     ?V0 + 3,R3
        MOV     ?V0 + 8,?V0 + 2
        MOV     ?V0 + 9,?V0 + 3
// 2968   if ( cfgReportCmd != NULL )
        MOV     A,?V0 + 8
        ORL     A,?V0 + 9
        JNZ     $+5
        LJMP    ??zclParseInConfigReportCmd_4 & 0xFFFF
// 2969   {
// 2970     pBuf = pCmd->pData;
        MOV     DPL,?V0 + 12
        MOV     DPH,?V0 + 13
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        MOV     R6,A
        MOV     A,R1
        MOV     R7,A
// 2971     dataPtr = (uint8 *)( (uint8 *)cfgReportCmd + hdrLen );
        MOV     ?V0 + 2,?V0 + 5
        MOV     ?V0 + 3,#0x0
        MOV     A,?V0 + 8
        ADD     A,?V0 + 2
        MOV     R0,A
        MOV     A,?V0 + 9
        ADDC    A,?V0 + 3
        MOV     R1,A
        MOV     ?V0 + 6,R0
        MOV     ?V0 + 7,R1
// 2972 
// 2973     cfgReportCmd->numAttr = numAttr;
        MOV     A,?V0 + 1
        MOV     DPL,?V0 + 8
        MOV     DPH,?V0 + 9
        MOV     A,?V0 + 1
        MOVX    @DPTR,A
// 2974     for ( uint8 i = 0; i < numAttr; i++ )
        MOV     ?V0 + 4,#0x0
??zclParseInConfigReportCmd_5:
        MOV     A,?V0 + 4
        CLR     C
        SUBB    A,?V0 + 1
        JC      $+5
        LJMP    ??zclParseInConfigReportCmd_4 & 0xFFFF
// 2975     {
// 2976       zclCfgReportRec_t *reportRec = &(cfgReportCmd->attrList[i]);
        MOV     A,?V0 + 4
        MOV     R0,?V0 + 4
        MOV     R1,#0x0
        MOV     A,R0
        MOV     B,#0xc
        MUL     AB
        XCH     A,R0
        MOV     R2,B
        MOV     B,#0x0
        MUL     AB
        ADD     A,R2
        MOV     R2,A
        MOV     B,#0xc
        MOV     A,R1
        MUL     AB
        ADD     A,R2
        MOV     R1,A
        MOV     A,?V0 + 8
        ADD     A,R0
        MOV     DPL,A
        MOV     A,?V0 + 9
        ADDC    A,R1
        MOV     DPH,A
        INC     DPTR
        MOV     ?V0 + 2,DPL
        MOV     ?V0 + 3,DPH
// 2977 
// 2978       osal_memset( reportRec, 0, sizeof( zclCfgReportRec_t ) );
        ; Setup parameters for call to function osal_memset
        MOV     R4,#0xc
        MOV     R5,#0x0
        MOV     R1,#0x0
        MOV     R2,?V0 + 2
        MOV     R3,?V0 + 3
        LCALL   ??osal_memset?relay
// 2979 
// 2980       reportRec->direction = *pBuf++;
        MOV     DPL,R6
        MOV     DPH,R7
        MOVX    A,@DPTR
        MOV     DPL,?V0 + 2
        MOV     DPH,?V0 + 3
        MOVX    @DPTR,A
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        MOV     R6,DPL
        MOV     R7,DPH
// 2981       reportRec->attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
        MOV     DPL,R6
        MOV     DPH,R7
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     R3,#0x0
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     R1,#0x0
        CLR     A
        XCH     A,R0
        MOV     R1,A
        MOV     A,R2
        ADD     A,R0
        MOV     R0,A
        MOV     A,R3
        ADDC    A,R1
        MOV     R1,A
        MOV     DPL,?V0 + 2
        MOV     DPH,?V0 + 3
        INC     DPTR
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
// 2982       pBuf += 2;
        MOV     A,R6
        ADD     A,#0x2
        MOV     R6,A
        MOV     A,R7
        ADDC    A,#0x0
        MOV     R7,A
// 2983       if ( reportRec->direction == ZCL_SEND_ATTR_REPORTS )
        MOV     DPL,?V0 + 2
        MOV     DPH,?V0 + 3
        MOVX    A,@DPTR
        JZ      $+5
        LJMP    ??zclParseInConfigReportCmd_6 & 0xFFFF
// 2984       {
// 2985         // Attribute to be reported
// 2986         reportRec->dataType = *pBuf++;
        MOV     DPL,R6
        MOV     DPH,R7
        MOVX    A,@DPTR
        MOV     DPL,?V0 + 2
        MOV     DPH,?V0 + 3
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    @DPTR,A
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        MOV     R6,DPL
        MOV     R7,DPH
// 2987         reportRec->minReportInt = BUILD_UINT16( pBuf[0], pBuf[1] );
        MOV     DPL,R6
        MOV     DPH,R7
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     R3,#0x0
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     R1,#0x0
        CLR     A
        XCH     A,R0
        MOV     R1,A
        MOV     A,R2
        ADD     A,R0
        MOV     R0,A
        MOV     A,R3
        ADDC    A,R1
        MOV     R1,A
        MOV     DPL,?V0 + 2
        MOV     DPH,?V0 + 3
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
// 2988         pBuf += 2;
        MOV     A,R6
        ADD     A,#0x2
        MOV     R6,A
        MOV     A,R7
        ADDC    A,#0x0
        MOV     R7,A
// 2989         reportRec->maxReportInt = BUILD_UINT16( pBuf[0], pBuf[1] );
        MOV     DPL,R6
        MOV     DPH,R7
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     R3,#0x0
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     R1,#0x0
        CLR     A
        XCH     A,R0
        MOV     R1,A
        MOV     A,R2
        ADD     A,R0
        MOV     R0,A
        MOV     A,R3
        ADDC    A,R1
        MOV     R1,A
        MOV     DPL,?V0 + 2
        MOV     DPH,?V0 + 3
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
// 2990         pBuf += 2;
        MOV     A,R6
        ADD     A,#0x2
        MOV     R6,A
        MOV     A,R7
        ADDC    A,#0x0
        MOV     R7,A
// 2991 
// 2992         // For attributes of 'discrete' data types this field is omitted
// 2993         if ( zclAnalogDataType( reportRec->dataType ) )
        ; Setup parameters for call to function zclAnalogDataType
        MOV     DPL,?V0 + 2
        MOV     DPH,?V0 + 3
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??zclAnalogDataType?relay
        MOV     A,R1
        JNZ     $+5
        LJMP    ??zclParseInConfigReportCmd_7 & 0xFFFF
// 2994         {
// 2995           zcl_BuildAnalogData( reportRec->dataType, dataPtr, pBuf);
        ; Setup parameters for call to function zcl_BuildAnalogData
        MOV     A,R6
        MOV     R4,A
        MOV     A,R7
        MOV     R5,A
        MOV     R2,?V0 + 6
        MOV     R3,?V0 + 7
        MOV     DPL,?V0 + 2
        MOV     DPH,?V0 + 3
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??zcl_BuildAnalogData?relay
// 2996           reportRec->reportableChange = dataPtr;
        MOV     DPL,?V0 + 2
        MOV     DPH,?V0 + 3
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOV     A,?V0 + 6
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,?V0 + 7
        MOVX    @DPTR,A
// 2997 
// 2998           reportChangeLen = zclGetDataTypeLength( reportRec->dataType );
        ; Setup parameters for call to function zclGetDataTypeLength
        MOV     DPL,?V0 + 2
        MOV     DPH,?V0 + 3
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??zclGetDataTypeLength?relay
        MOV     A,R1
        MOV     ?V0 + 0,A
// 2999           pBuf += reportChangeLen;
        MOV     ?V0 + 10,?V0 + 0
        MOV     ?V0 + 11,#0x0
        MOV     A,R6
        ADD     A,?V0 + 10
        MOV     R6,A
        MOV     A,R7
        ADDC    A,?V0 + 11
        MOV     R7,A
// 3000 
// 3001           // advance attribute data pointer
// 3002           if ( PADDING_NEEDED( reportChangeLen ) )
        MOV     A,?V0 + 0
        MOV     B,#0x2
        DIV     AB
        MOV     A,B
        JZ      ??zclParseInConfigReportCmd_8
// 3003           {
// 3004             reportChangeLen++;
        INC     ?V0 + 0
// 3005           }
// 3006 
// 3007           dataPtr += reportChangeLen;
??zclParseInConfigReportCmd_8:
        MOV     ?V0 + 10,?V0 + 0
        MOV     ?V0 + 11,#0x0
        MOV     A,?V0 + 6
        ADD     A,?V0 + 10
        MOV     ?V0 + 6,A
        MOV     A,?V0 + 7
        ADDC    A,?V0 + 11
        MOV     ?V0 + 7,A
        SJMP    ??zclParseInConfigReportCmd_7
// 3008         }
// 3009       }
// 3010       else
// 3011       {
// 3012         // Attribute reports to be received
// 3013         reportRec->timeoutPeriod = BUILD_UINT16( pBuf[0], pBuf[1] );
??zclParseInConfigReportCmd_6:
        MOV     DPL,R6
        MOV     DPH,R7
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     R3,#0x0
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     R1,#0x0
        CLR     A
        XCH     A,R0
        MOV     R1,A
        MOV     A,R2
        ADD     A,R0
        MOV     R0,A
        MOV     A,R3
        ADDC    A,R1
        MOV     R1,A
        MOV     DPL,?V0 + 2
        MOV     DPH,?V0 + 3
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
// 3014         pBuf += 2;
        MOV     A,R6
        ADD     A,#0x2
        MOV     R6,A
        MOV     A,R7
        ADDC    A,#0x0
        MOV     R7,A
// 3015       }
// 3016     } // while loop
??zclParseInConfigReportCmd_7:
        INC     ?V0 + 4
        LJMP    ??zclParseInConfigReportCmd_5 & 0xFFFF
// 3017   }
// 3018 
// 3019   return ( (void *)cfgReportCmd );
??zclParseInConfigReportCmd_4:
        MOV     R2,?V0 + 8
        MOV     R3,?V0 + 9
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 23)
        MOV     R7,#0xf
        LJMP    ?BANKED_LEAVE_XDATA
          CFI EndBlock cfiBlock49
// 3020 }
// 3021 
// 3022 /*********************************************************************
// 3023  * @fn      zclParseInConfigReportRspCmd
// 3024  *
// 3025  * @brief   Parse the "Profile" Configure Reporting Response Command
// 3026  *
// 3027  *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
// 3028  *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
// 3029  *
// 3030  * @param   pCmd - pointer to incoming data to parse
// 3031  *
// 3032  * @return  pointer to the parsed command structure
// 3033  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 3034 static void *zclParseInConfigReportRspCmd( zclParseCmd_t *pCmd )
zclParseInConfigReportRspCmd:
          CFI Block cfiBlock50 Using cfiCommon0
          CFI Function zclParseInConfigReportRspCmd
        CODE
// 3035 {
        FUNCALL zclParseInConfigReportRspCmd, osal_mem_alloc
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 16, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 16, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0x10
        LCALL   ?BANKED_ENTER_XDATA
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V7 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI V6 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V5 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI V4 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-13)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-14)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-15)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-16)))
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 16)
        ; Saved register size: 16
        ; Auto size: 0
        MOV     ?V0 + 2,R2
        MOV     ?V0 + 3,R3
// 3036   zclCfgReportRspCmd_t *cfgReportRspCmd;
// 3037   uint8 *pBuf = pCmd->pData;
        MOV     DPL,?V0 + 2
        MOV     DPH,?V0 + 3
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R6,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R7,A
// 3038   uint8 numAttr;
// 3039 
// 3040   numAttr = pCmd->dataLen / ( 1 + 1 + 2 ); // Status + Direction + Attribute ID
        MOV     DPL,?V0 + 2
        MOV     DPH,?V0 + 3
        INC     DPTR
        MOVX    A,@DPTR
        MOV     ?V0 + 6,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     ?V0 + 7,A
        MOV     A,#0x2
        MOV     R0,#?V0 + 6
        LCALL   ?US_SHR
        MOV     A,?V0 + 6
        MOV     ?V0 + 4,A
// 3041 
// 3042   cfgReportRspCmd = (zclCfgReportRspCmd_t *)osal_mem_alloc( sizeof( zclCfgReportRspCmd_t )
// 3043                                             + ( numAttr * sizeof( zclCfgReportStatus_t ) ) );
        ; Setup parameters for call to function osal_mem_alloc
        MOV     A,?V0 + 4
        MOV     R0,?V0 + 4
        MOV     R1,#0x0
        MOV     A,R0
        MOV     B,#0x4
        MUL     AB
        XCH     A,R0
        MOV     R2,B
        MOV     B,#0x0
        MUL     AB
        ADD     A,R2
        MOV     R2,A
        MOV     B,#0x4
        MOV     A,R1
        MUL     AB
        ADD     A,R2
        MOV     R1,A
        MOV     A,R0
        ADD     A,#0x1
        MOV     R2,A
        MOV     A,R1
        ADDC    A,#0x0
        MOV     R3,A
        LCALL   ??osal_mem_alloc?relay
        MOV     ?V0 + 6,R2
        MOV     ?V0 + 7,R3
        MOV     ?V0 + 0,?V0 + 6
        MOV     ?V0 + 1,?V0 + 7
// 3044   if ( cfgReportRspCmd != NULL )
        MOV     A,?V0 + 0
        ORL     A,?V0 + 1
        JNZ     $+5
        LJMP    ??zclParseInConfigReportRspCmd_0 & 0xFFFF
// 3045   {
// 3046     cfgReportRspCmd->numAttr = numAttr;
        MOV     A,?V0 + 4
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        MOV     A,?V0 + 4
        MOVX    @DPTR,A
// 3047     for ( uint8 i = 0; i < cfgReportRspCmd->numAttr; i++ )
        MOV     R4,#0x0
??zclParseInConfigReportRspCmd_1:
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     A,R4
        CLR     C
        SUBB    A,R0
        JC      $+5
        LJMP    ??zclParseInConfigReportRspCmd_0 & 0xFFFF
// 3048     {
// 3049       cfgReportRspCmd->attrList[i].status = *pBuf++;
        MOV     DPL,R6
        MOV     DPH,R7
        MOVX    A,@DPTR
        PUSH    A
          CFI CFA_SP SP+-1
        MOV     A,R4
        MOV     R0,A
        MOV     R1,#0x0
        MOV     A,R0
        MOV     B,#0x4
        MUL     AB
        XCH     A,R0
        MOV     R2,B
        MOV     B,#0x0
        MUL     AB
        ADD     A,R2
        MOV     R2,A
        MOV     B,#0x4
        MOV     A,R1
        MUL     AB
        ADD     A,R2
        MOV     R1,A
        MOV     A,?V0 + 0
        ADD     A,R0
        MOV     DPL,A
        MOV     A,?V0 + 1
        ADDC    A,R1
        MOV     DPH,A
        INC     DPTR
        POP     A
          CFI CFA_SP SP+0
        MOVX    @DPTR,A
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        MOV     R6,DPL
        MOV     R7,DPH
// 3050       cfgReportRspCmd->attrList[i].direction = *pBuf++;
        MOV     DPL,R6
        MOV     DPH,R7
        MOVX    A,@DPTR
        PUSH    A
          CFI CFA_SP SP+-1
        MOV     A,R4
        MOV     R0,A
        MOV     R1,#0x0
        MOV     A,R0
        MOV     B,#0x4
        MUL     AB
        XCH     A,R0
        MOV     R2,B
        MOV     B,#0x0
        MUL     AB
        ADD     A,R2
        MOV     R2,A
        MOV     B,#0x4
        MOV     A,R1
        MUL     AB
        ADD     A,R2
        MOV     R1,A
        MOV     A,?V0 + 0
        ADD     A,R0
        MOV     DPL,A
        MOV     A,?V0 + 1
        ADDC    A,R1
        MOV     DPH,A
        INC     DPTR
        INC     DPTR
        POP     A
          CFI CFA_SP SP+0
        MOVX    @DPTR,A
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        MOV     R6,DPL
        MOV     R7,DPH
// 3051       cfgReportRspCmd->attrList[i].attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
        MOV     DPL,R6
        MOV     DPH,R7
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     R3,#0x0
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     R1,#0x0
        CLR     A
        XCH     A,R0
        MOV     R1,A
        MOV     A,R2
        ADD     A,R0
        MOV     R2,A
        MOV     A,R3
        ADDC    A,R1
        MOV     R3,A
        MOV     A,R4
        MOV     R0,A
        MOV     R1,#0x0
        MOV     A,R0
        MOV     B,#0x4
        MUL     AB
        XCH     A,R0
        MOV     R5,B
        MOV     B,#0x0
        MUL     AB
        ADD     A,R5
        MOV     R5,A
        MOV     B,#0x4
        MOV     A,R1
        MUL     AB
        ADD     A,R5
        MOV     R1,A
        MOV     A,?V0 + 0
        ADD     A,R0
        MOV     DPL,A
        MOV     A,?V0 + 1
        ADDC    A,R1
        MOV     DPH,A
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOV     A,R2
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R3
        MOVX    @DPTR,A
// 3052       pBuf += 2;
        MOV     A,R6
        ADD     A,#0x2
        MOV     R6,A
        MOV     A,R7
        ADDC    A,#0x0
        MOV     R7,A
// 3053     }
        INC     R4
        LJMP    ??zclParseInConfigReportRspCmd_1 & 0xFFFF
// 3054   }
// 3055 
// 3056   return ( (void *)cfgReportRspCmd );
??zclParseInConfigReportRspCmd_0:
        MOV     R2,?V0 + 0
        MOV     R3,?V0 + 1
        MOV     R7,#0x8
        LJMP    ?BANKED_LEAVE_XDATA
          CFI EndBlock cfiBlock50
// 3057 }
// 3058 
// 3059 /*********************************************************************
// 3060  * @fn      zclParseInReadReportCfgCmd
// 3061  *
// 3062  * @brief   Parse the "Profile" Read Reporting Configuration Command
// 3063  *
// 3064  *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
// 3065  *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
// 3066  *
// 3067  * @param   pCmd - pointer to incoming data to parse
// 3068  *
// 3069  * @return  pointer to the parsed command structure
// 3070  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 3071 void *zclParseInReadReportCfgCmd( zclParseCmd_t *pCmd )
zclParseInReadReportCfgCmd:
          CFI Block cfiBlock51 Using cfiCommon0
          CFI Function zclParseInReadReportCfgCmd
        CODE
// 3072 {
        FUNCALL zclParseInReadReportCfgCmd, osal_mem_alloc
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 16, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 16, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0x10
        LCALL   ?BANKED_ENTER_XDATA
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V7 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI V6 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V5 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI V4 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-13)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-14)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-15)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-16)))
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 16)
        ; Saved register size: 16
        ; Auto size: 0
        MOV     ?V0 + 2,R2
        MOV     ?V0 + 3,R3
// 3073   zclReadReportCfgCmd_t *readReportCfgCmd;
// 3074   uint8 *pBuf = pCmd->pData;
        MOV     DPL,?V0 + 2
        MOV     DPH,?V0 + 3
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     ?V0 + 0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     ?V0 + 1,A
// 3075   uint8 numAttr;
// 3076 
// 3077   numAttr = pCmd->dataLen / ( 1 + 2 ); // Direction + Attribute ID
        MOV     DPL,?V0 + 2
        MOV     DPH,?V0 + 3
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     R2,#0x3
        MOV     R3,#0x0
        LCALL   ?US_DIV_MOD
        MOV     A,R0
        MOV     ?V0 + 4,A
// 3078 
// 3079   readReportCfgCmd = (zclReadReportCfgCmd_t *)osal_mem_alloc( sizeof( zclReadReportCfgCmd_t )
// 3080                                                   + ( numAttr * sizeof( zclReadReportCfgRec_t ) ) );
        ; Setup parameters for call to function osal_mem_alloc
        MOV     A,?V0 + 4
        MOV     R0,?V0 + 4
        MOV     R1,#0x0
        MOV     A,R0
        MOV     B,#0x3
        MUL     AB
        XCH     A,R0
        MOV     R2,B
        MOV     B,#0x0
        MUL     AB
        ADD     A,R2
        MOV     R2,A
        MOV     B,#0x3
        MOV     A,R1
        MUL     AB
        ADD     A,R2
        MOV     R1,A
        MOV     A,R0
        ADD     A,#0x1
        MOV     R2,A
        MOV     A,R1
        ADDC    A,#0x0
        MOV     R3,A
        LCALL   ??osal_mem_alloc?relay
        MOV     ?V0 + 6,R2
        MOV     ?V0 + 7,R3
        MOV     R6,?V0 + 6
        MOV     R7,?V0 + 7
// 3081   if ( readReportCfgCmd != NULL )
        MOV     A,R6
        ORL     A,R7
        JNZ     $+5
        LJMP    ??zclParseInReadReportCfgCmd_0 & 0xFFFF
// 3082   {
// 3083     readReportCfgCmd->numAttr = numAttr;
        MOV     A,?V0 + 4
        MOV     DPL,R6
        MOV     DPH,R7
        MOV     A,?V0 + 4
        MOVX    @DPTR,A
// 3084     for ( uint8 i = 0; i < readReportCfgCmd->numAttr; i++)
        MOV     R5,#0x0
??zclParseInReadReportCfgCmd_1:
        MOV     DPL,R6
        MOV     DPH,R7
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     A,R5
        CLR     C
        SUBB    A,R0
        JC      $+5
        LJMP    ??zclParseInReadReportCfgCmd_0 & 0xFFFF
// 3085     {
// 3086       readReportCfgCmd->attrList[i].direction = *pBuf++;;
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        MOVX    A,@DPTR
        PUSH    A
          CFI CFA_SP SP+-1
        MOV     A,R5
        MOV     R0,A
        MOV     R1,#0x0
        MOV     A,R0
        MOV     B,#0x3
        MUL     AB
        XCH     A,R0
        MOV     R2,B
        MOV     B,#0x0
        MUL     AB
        ADD     A,R2
        MOV     R2,A
        MOV     B,#0x3
        MOV     A,R1
        MUL     AB
        ADD     A,R2
        MOV     R1,A
        MOV     A,R6
        ADD     A,R0
        MOV     DPL,A
        MOV     A,R7
        ADDC    A,R1
        MOV     DPH,A
        INC     DPTR
        POP     A
          CFI CFA_SP SP+0
        MOVX    @DPTR,A
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        INC     DPTR
        MOV     ?V0 + 0,DPL
        MOV     ?V0 + 1,DPH
// 3087       readReportCfgCmd->attrList[i].attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     R3,#0x0
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     R1,#0x0
        CLR     A
        XCH     A,R0
        MOV     R1,A
        MOV     A,R2
        ADD     A,R0
        MOV     R2,A
        MOV     A,R3
        ADDC    A,R1
        MOV     R3,A
        MOV     A,R5
        MOV     R0,A
        MOV     R1,#0x0
        MOV     A,R0
        MOV     B,#0x3
        MUL     AB
        XCH     A,R0
        MOV     R4,B
        MOV     B,#0x0
        MUL     AB
        ADD     A,R4
        MOV     R4,A
        MOV     B,#0x3
        MOV     A,R1
        MUL     AB
        ADD     A,R4
        MOV     R1,A
        MOV     A,R6
        ADD     A,R0
        MOV     DPL,A
        MOV     A,R7
        ADDC    A,R1
        MOV     DPH,A
        INC     DPTR
        INC     DPTR
        MOV     A,R2
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R3
        MOVX    @DPTR,A
// 3088       pBuf += 2;
        MOV     A,?V0 + 0
        ADD     A,#0x2
        MOV     ?V0 + 0,A
        MOV     A,?V0 + 1
        ADDC    A,#0x0
        MOV     ?V0 + 1,A
// 3089     }
        INC     R5
        LJMP    ??zclParseInReadReportCfgCmd_1 & 0xFFFF
// 3090   }
// 3091 
// 3092   return ( (void *)readReportCfgCmd );
??zclParseInReadReportCfgCmd_0:
        MOV     A,R6
        MOV     R2,A
        MOV     A,R7
        MOV     R3,A
        MOV     R7,#0x8
        LJMP    ?BANKED_LEAVE_XDATA
          CFI EndBlock cfiBlock51
// 3093 }
// 3094 
// 3095 /*********************************************************************
// 3096  * @fn      zclParseInReadReportCfgRspCmd
// 3097  *
// 3098  * @brief   Parse the "Profile" Read Reporting Configuration Response Command
// 3099  *
// 3100  *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
// 3101  *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
// 3102  *
// 3103  * @param   pCmd - pointer to incoming data to parse
// 3104  *
// 3105  * @return  pointer to the parsed command structure
// 3106  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 3107 static void *zclParseInReadReportCfgRspCmd( zclParseCmd_t *pCmd )
zclParseInReadReportCfgRspCmd:
          CFI Block cfiBlock52 Using cfiCommon0
          CFI Function zclParseInReadReportCfgRspCmd
        CODE
// 3108 {
        FUNCALL zclParseInReadReportCfgRspCmd, zclAnalogDataType
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 24, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 24, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL zclParseInReadReportCfgRspCmd, zclGetDataTypeLength
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 24, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 24, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL zclParseInReadReportCfgRspCmd, osal_mem_alloc
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 24, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 24, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL zclParseInReadReportCfgRspCmd, zclAnalogDataType
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 24, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 24, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL zclParseInReadReportCfgRspCmd, zcl_BuildAnalogData
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 24, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 24, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL zclParseInReadReportCfgRspCmd, zclGetDataTypeLength
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 24, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 24, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0x18
        LCALL   ?BANKED_ENTER_XDATA
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V15 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI V14 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V13 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI V12 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI V11 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI V10 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI V9 load(1, XDATA, add(CFA_XSP16, literal(-13)))
          CFI V8 load(1, XDATA, add(CFA_XSP16, literal(-14)))
          CFI V7 load(1, XDATA, add(CFA_XSP16, literal(-15)))
          CFI V6 load(1, XDATA, add(CFA_XSP16, literal(-16)))
          CFI V5 load(1, XDATA, add(CFA_XSP16, literal(-17)))
          CFI V4 load(1, XDATA, add(CFA_XSP16, literal(-18)))
          CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-19)))
          CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-20)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-21)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-22)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-23)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-24)))
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 24)
        ; Saved register size: 24
        ; Auto size: 0
        MOV     ?V0 + 12,R2
        MOV     ?V0 + 13,R3
// 3109   zclReadReportCfgRspCmd_t *readReportCfgRspCmd;
// 3110   uint8 reportChangeLen;
// 3111   uint8 *pBuf = pCmd->pData;
        MOV     DPL,?V0 + 12
        MOV     DPH,?V0 + 13
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R6,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R7,A
// 3112   uint8 *dataPtr;
// 3113   uint8 numAttr = 0;
        MOV     ?V0 + 3,#0x0
// 3114   uint8 hdrLen;
// 3115   uint16 dataLen = 0;
        MOV     ?V0 + 14,#0x0
        MOV     ?V0 + 15,#0x0
// 3116 
// 3117   // Calculate the length of the response command
// 3118   while ( pBuf < ( pCmd->pData + pCmd->dataLen ) )
??zclParseInReadReportCfgRspCmd_0:
        MOV     DPL,?V0 + 12
        MOV     DPH,?V0 + 13
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     DPL,?V0 + 12
        MOV     DPH,?V0 + 13
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        ADD     A,R0
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,R1
        MOV     R1,A
        CLR     C
        MOV     A,R6
        SUBB    A,R0
        MOV     A,R7
        SUBB    A,R1
        JC      $+5
        LJMP    ??zclParseInReadReportCfgRspCmd_1 & 0xFFFF
// 3119   {
// 3120     uint8 status;
// 3121     uint8 direction;
// 3122 
// 3123     numAttr++;
        INC     ?V0 + 3
// 3124     status = *pBuf++;
        MOV     DPL,R6
        MOV     DPH,R7
        MOVX    A,@DPTR
        MOV     ?V0 + 10,A
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        MOV     R6,DPL
        MOV     R7,DPH
// 3125     direction = *pBuf++;
        MOV     DPL,R6
        MOV     DPH,R7
        MOVX    A,@DPTR
        MOV     ?V0 + 11,A
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        MOV     R6,DPL
        MOV     R7,DPH
// 3126     pBuf += 2; // move pass the attribute ID
        MOV     A,DPL
        ADD     A,#0x2
        MOV     R6,A
        MOV     A,DPH
        ADDC    A,#0x0
        MOV     R7,A
// 3127 
// 3128     if ( status == ZCL_STATUS_SUCCESS )
        MOV     A,?V0 + 10
        JNZ     ??zclParseInReadReportCfgRspCmd_0
// 3129     {
// 3130       if ( direction == ZCL_SEND_ATTR_REPORTS )
        MOV     A,?V0 + 11
        JNZ     ??zclParseInReadReportCfgRspCmd_2
// 3131       {
// 3132         uint8 dataType = *pBuf++;
        MOV     DPL,R6
        MOV     DPH,R7
        MOVX    A,@DPTR
        MOV     ?V0 + 4,A
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        MOV     R6,DPL
        MOV     R7,DPH
// 3133         pBuf += 4; // move pass the Min and Max Reporting Intervals
        MOV     A,DPL
        ADD     A,#0x4
        MOV     R6,A
        MOV     A,DPH
        ADDC    A,#0x0
        MOV     R7,A
// 3134 
// 3135         // For attributes of 'discrete' data types this field is omitted
// 3136         if ( zclAnalogDataType( dataType ) )
        ; Setup parameters for call to function zclAnalogDataType
        MOV     R1,?V0 + 4
        LCALL   ??zclAnalogDataType?relay
        MOV     A,R1
        JZ      ??zclParseInReadReportCfgRspCmd_0
// 3137         {
// 3138           reportChangeLen = zclGetDataTypeLength( dataType );
        ; Setup parameters for call to function zclGetDataTypeLength
        MOV     R1,?V0 + 4
        LCALL   ??zclGetDataTypeLength?relay
        MOV     A,R1
        MOV     ?V0 + 2,A
// 3139           pBuf += reportChangeLen;
        MOV     ?V0 + 0,?V0 + 2
        MOV     ?V0 + 1,#0x0
        MOV     A,R6
        ADD     A,?V0 + 0
        MOV     R6,A
        MOV     A,R7
        ADDC    A,?V0 + 1
        MOV     R7,A
// 3140 
// 3141           // add padding if needed
// 3142           if ( PADDING_NEEDED( reportChangeLen ) )
        MOV     A,?V0 + 2
        MOV     B,#0x2
        DIV     AB
        MOV     A,B
        JZ      ??zclParseInReadReportCfgRspCmd_3
// 3143           {
// 3144             reportChangeLen++;
        INC     ?V0 + 2
// 3145           }
// 3146 
// 3147           dataLen += reportChangeLen;
??zclParseInReadReportCfgRspCmd_3:
        MOV     ?V0 + 0,?V0 + 2
        MOV     ?V0 + 1,#0x0
        MOV     A,?V0 + 14
        ADD     A,?V0 + 0
        MOV     ?V0 + 14,A
        MOV     A,?V0 + 15
        ADDC    A,?V0 + 1
        MOV     ?V0 + 15,A
        LJMP    ??zclParseInReadReportCfgRspCmd_0 & 0xFFFF
// 3148         }
// 3149       }
// 3150       else
// 3151       {
// 3152         pBuf += 2; // move pass the Timeout field
??zclParseInReadReportCfgRspCmd_2:
        MOV     A,R6
        ADD     A,#0x2
        MOV     R6,A
        MOV     A,R7
        ADDC    A,#0x0
        MOV     R7,A
        LJMP    ??zclParseInReadReportCfgRspCmd_0 & 0xFFFF
// 3153       }
// 3154     }
// 3155   } // while loop
// 3156 
// 3157   hdrLen = sizeof( zclReadReportCfgRspCmd_t ) + ( numAttr * sizeof( zclReportCfgRspRec_t ) );
??zclParseInReadReportCfgRspCmd_1:
        MOV     B,#0xd
        MOV     A,?V0 + 3
        MUL     AB
        ADD     A,#0x1
        MOV     ?V0 + 5,A
// 3158 
// 3159   readReportCfgRspCmd = (zclReadReportCfgRspCmd_t *)osal_mem_alloc( hdrLen + dataLen );
        ; Setup parameters for call to function osal_mem_alloc
        MOV     ?V0 + 0,?V0 + 5
        MOV     ?V0 + 1,#0x0
        MOV     A,?V0 + 0
        ADD     A,?V0 + 14
        MOV     R2,A
        MOV     A,?V0 + 1
        ADDC    A,?V0 + 15
        MOV     R3,A
        LCALL   ??osal_mem_alloc?relay
        MOV     ?V0 + 0,R2
        MOV     ?V0 + 1,R3
        MOV     ?V0 + 8,?V0 + 0
        MOV     ?V0 + 9,?V0 + 1
// 3160   if ( readReportCfgRspCmd != NULL )
        MOV     A,?V0 + 8
        ORL     A,?V0 + 9
        JNZ     $+5
        LJMP    ??zclParseInReadReportCfgRspCmd_4 & 0xFFFF
// 3161   {
// 3162     pBuf = pCmd->pData;
        MOV     DPL,?V0 + 12
        MOV     DPH,?V0 + 13
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        MOV     R6,A
        MOV     A,R1
        MOV     R7,A
// 3163     dataPtr = (uint8 *)( (uint8 *)readReportCfgRspCmd + hdrLen );
        MOV     ?V0 + 0,?V0 + 5
        MOV     ?V0 + 1,#0x0
        MOV     A,?V0 + 8
        ADD     A,?V0 + 0
        MOV     R0,A
        MOV     A,?V0 + 9
        ADDC    A,?V0 + 1
        MOV     R1,A
        MOV     ?V0 + 6,R0
        MOV     ?V0 + 7,R1
// 3164 
// 3165     readReportCfgRspCmd->numAttr = numAttr;
        MOV     A,?V0 + 3
        MOV     DPL,?V0 + 8
        MOV     DPH,?V0 + 9
        MOV     A,?V0 + 3
        MOVX    @DPTR,A
// 3166     for ( uint8 i = 0; i < numAttr; i++ )
        MOV     ?V0 + 4,#0x0
??zclParseInReadReportCfgRspCmd_5:
        MOV     A,?V0 + 4
        CLR     C
        SUBB    A,?V0 + 3
        JC      $+5
        LJMP    ??zclParseInReadReportCfgRspCmd_4 & 0xFFFF
// 3167     {
// 3168       zclReportCfgRspRec_t *reportRspRec = &(readReportCfgRspCmd->attrList[i]);
        MOV     A,?V0 + 4
        MOV     R0,?V0 + 4
        MOV     R1,#0x0
        MOV     A,R0
        MOV     B,#0xd
        MUL     AB
        XCH     A,R0
        MOV     R2,B
        MOV     B,#0x0
        MUL     AB
        ADD     A,R2
        MOV     R2,A
        MOV     B,#0xd
        MOV     A,R1
        MUL     AB
        ADD     A,R2
        MOV     R1,A
        MOV     A,?V0 + 8
        ADD     A,R0
        MOV     DPL,A
        MOV     A,?V0 + 9
        ADDC    A,R1
        MOV     DPH,A
        INC     DPTR
        MOV     ?V0 + 0,DPL
        MOV     ?V0 + 1,DPH
// 3169 
// 3170       reportRspRec->status = *pBuf++;
        MOV     DPL,R6
        MOV     DPH,R7
        MOVX    A,@DPTR
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        MOVX    @DPTR,A
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        MOV     R6,DPL
        MOV     R7,DPH
// 3171       reportRspRec->direction = *pBuf++;
        MOV     DPL,R6
        MOV     DPH,R7
        MOVX    A,@DPTR
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        INC     DPTR
        MOVX    @DPTR,A
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        MOV     R6,DPL
        MOV     R7,DPH
// 3172       reportRspRec->attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
        MOV     DPL,R6
        MOV     DPH,R7
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     R3,#0x0
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     R1,#0x0
        CLR     A
        XCH     A,R0
        MOV     R1,A
        MOV     A,R2
        ADD     A,R0
        MOV     R0,A
        MOV     A,R3
        ADDC    A,R1
        MOV     R1,A
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        INC     DPTR
        INC     DPTR
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
// 3173       pBuf += 2;
        MOV     A,R6
        ADD     A,#0x2
        MOV     R6,A
        MOV     A,R7
        ADDC    A,#0x0
        MOV     R7,A
// 3174 
// 3175       if ( reportRspRec->status == ZCL_STATUS_SUCCESS )
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        MOVX    A,@DPTR
        JZ      $+5
        LJMP    ??zclParseInReadReportCfgRspCmd_6 & 0xFFFF
// 3176       {
// 3177         if ( reportRspRec->direction == ZCL_SEND_ATTR_REPORTS )
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        INC     DPTR
        MOVX    A,@DPTR
        JZ      $+5
        LJMP    ??zclParseInReadReportCfgRspCmd_7 & 0xFFFF
// 3178         {
// 3179           reportRspRec->dataType = *pBuf++;
        MOV     DPL,R6
        MOV     DPH,R7
        MOVX    A,@DPTR
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    @DPTR,A
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        MOV     R6,DPL
        MOV     R7,DPH
// 3180           reportRspRec->minReportInt = BUILD_UINT16( pBuf[0], pBuf[1] );
        MOV     DPL,R6
        MOV     DPH,R7
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     R3,#0x0
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     R1,#0x0
        CLR     A
        XCH     A,R0
        MOV     R1,A
        MOV     A,R2
        ADD     A,R0
        MOV     R0,A
        MOV     A,R3
        ADDC    A,R1
        MOV     R1,A
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
// 3181           pBuf += 2;
        MOV     A,R6
        ADD     A,#0x2
        MOV     R6,A
        MOV     A,R7
        ADDC    A,#0x0
        MOV     R7,A
// 3182           reportRspRec->maxReportInt = BUILD_UINT16( pBuf[0], pBuf[1] );
        MOV     DPL,R6
        MOV     DPH,R7
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     R3,#0x0
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     R1,#0x0
        CLR     A
        XCH     A,R0
        MOV     R1,A
        MOV     A,R2
        ADD     A,R0
        MOV     R0,A
        MOV     A,R3
        ADDC    A,R1
        MOV     R1,A
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
// 3183           pBuf += 2;
        MOV     A,R6
        ADD     A,#0x2
        MOV     R6,A
        MOV     A,R7
        ADDC    A,#0x0
        MOV     R7,A
// 3184 
// 3185           if ( zclAnalogDataType( reportRspRec->dataType ) )
        ; Setup parameters for call to function zclAnalogDataType
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??zclAnalogDataType?relay
        MOV     A,R1
        JNZ     $+5
        LJMP    ??zclParseInReadReportCfgRspCmd_6 & 0xFFFF
// 3186           {
// 3187             zcl_BuildAnalogData( reportRspRec->dataType, dataPtr, pBuf);
        ; Setup parameters for call to function zcl_BuildAnalogData
        MOV     A,R6
        MOV     R4,A
        MOV     A,R7
        MOV     R5,A
        MOV     R2,?V0 + 6
        MOV     R3,?V0 + 7
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??zcl_BuildAnalogData?relay
// 3188             reportRspRec->reportableChange = dataPtr;
        MOV     A,?V0 + 0
        ADD     A,#0xb
        MOV     DPL,A
        MOV     A,?V0 + 1
        ADDC    A,#0x0
        MOV     DPH,A
        MOV     A,?V0 + 6
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,?V0 + 7
        MOVX    @DPTR,A
// 3189 
// 3190             reportChangeLen = zclGetDataTypeLength( reportRspRec->dataType );
        ; Setup parameters for call to function zclGetDataTypeLength
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??zclGetDataTypeLength?relay
        MOV     A,R1
        MOV     ?V0 + 2,A
// 3191             pBuf += reportChangeLen;
        MOV     ?V0 + 10,?V0 + 2
        MOV     ?V0 + 11,#0x0
        MOV     A,R6
        ADD     A,?V0 + 10
        MOV     R6,A
        MOV     A,R7
        ADDC    A,?V0 + 11
        MOV     R7,A
// 3192 
// 3193             // advance attribute data pointer
// 3194             if ( PADDING_NEEDED( reportChangeLen ) )
        MOV     A,?V0 + 2
        MOV     B,#0x2
        DIV     AB
        MOV     A,B
        JZ      ??zclParseInReadReportCfgRspCmd_8
// 3195             {
// 3196               reportChangeLen++;
        INC     ?V0 + 2
// 3197             }
// 3198 
// 3199             dataPtr += reportChangeLen;
??zclParseInReadReportCfgRspCmd_8:
        MOV     ?V0 + 10,?V0 + 2
        MOV     ?V0 + 11,#0x0
        MOV     A,?V0 + 6
        ADD     A,?V0 + 10
        MOV     ?V0 + 6,A
        MOV     A,?V0 + 7
        ADDC    A,?V0 + 11
        MOV     ?V0 + 7,A
        SJMP    ??zclParseInReadReportCfgRspCmd_6
// 3200           }
// 3201         }
// 3202         else
// 3203         {
// 3204           reportRspRec->timeoutPeriod = BUILD_UINT16( pBuf[0], pBuf[1] );
??zclParseInReadReportCfgRspCmd_7:
        MOV     DPL,R6
        MOV     DPH,R7
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     R3,#0x0
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     R1,#0x0
        CLR     A
        XCH     A,R0
        MOV     R1,A
        MOV     A,R2
        ADD     A,R0
        MOV     R0,A
        MOV     A,R3
        ADDC    A,R1
        MOV     R1,A
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
// 3205           pBuf += 2;
        MOV     A,R6
        ADD     A,#0x2
        MOV     R6,A
        MOV     A,R7
        ADDC    A,#0x0
        MOV     R7,A
// 3206         }
// 3207       }
// 3208     }
??zclParseInReadReportCfgRspCmd_6:
        INC     ?V0 + 4
        LJMP    ??zclParseInReadReportCfgRspCmd_5 & 0xFFFF
// 3209   }
// 3210 
// 3211   return ( (void *)readReportCfgRspCmd );
??zclParseInReadReportCfgRspCmd_4:
        MOV     R2,?V0 + 8
        MOV     R3,?V0 + 9
        MOV     R7,#0x10
        LJMP    ?BANKED_LEAVE_XDATA
          CFI EndBlock cfiBlock52
// 3212 }
// 3213 
// 3214 /*********************************************************************
// 3215  * @fn      zclParseInReportCmd
// 3216  *
// 3217  * @brief   Parse the "Profile" Report Command
// 3218  *
// 3219  *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
// 3220  *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
// 3221  *
// 3222  * @param   pCmd - pointer to incoming data to parse
// 3223  *
// 3224  * @return  pointer to the parsed command structure
// 3225  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 3226 void *zclParseInReportCmd( zclParseCmd_t *pCmd )
zclParseInReportCmd:
          CFI Block cfiBlock53 Using cfiCommon0
          CFI Function zclParseInReportCmd
        CODE
// 3227 {
        FUNCALL zclParseInReportCmd, zclGetAttrDataLength
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 26, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 26, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL zclParseInReportCmd, osal_mem_alloc
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 26, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 26, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL zclParseInReportCmd, zclGetAttrDataLength
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 26, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 26, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL zclParseInReportCmd, osal_memcpy
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 29, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 29, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0x18
        LCALL   ?BANKED_ENTER_XDATA
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V15 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI V14 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V13 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI V12 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI V11 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI V10 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI V9 load(1, XDATA, add(CFA_XSP16, literal(-13)))
          CFI V8 load(1, XDATA, add(CFA_XSP16, literal(-14)))
          CFI V7 load(1, XDATA, add(CFA_XSP16, literal(-15)))
          CFI V6 load(1, XDATA, add(CFA_XSP16, literal(-16)))
          CFI V5 load(1, XDATA, add(CFA_XSP16, literal(-17)))
          CFI V4 load(1, XDATA, add(CFA_XSP16, literal(-18)))
          CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-19)))
          CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-20)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-21)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-22)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-23)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-24)))
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 24)
        ; Saved register size: 24
        ; Auto size: 2
        MOV     A,#-0x2
        LCALL   ?ALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 26)
        MOV     ?V0 + 14,R2
        MOV     ?V0 + 15,R3
// 3228   zclReportCmd_t *reportCmd;
// 3229   uint8 *pBuf = pCmd->pData;
        MOV     DPL,?V0 + 14
        MOV     DPH,?V0 + 15
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R6,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R7,A
// 3230   uint16 attrDataLen;
// 3231   uint8 *dataPtr;
// 3232   uint8 numAttr = 0;
        MOV     ?V0 + 7,#0x0
// 3233   uint8 hdrLen;
// 3234   uint16 dataLen = 0;
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     A,#0x0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
// 3235 
// 3236   // find out the number of attributes and the length of attribute data
// 3237   while ( pBuf < ( pCmd->pData + pCmd->dataLen ) )
??zclParseInReportCmd_0:
        MOV     DPL,?V0 + 14
        MOV     DPH,?V0 + 15
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     DPL,?V0 + 14
        MOV     DPH,?V0 + 15
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        ADD     A,R0
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,R1
        MOV     R1,A
        CLR     C
        MOV     A,R6
        SUBB    A,R0
        MOV     A,R7
        SUBB    A,R1
        JNC     ??zclParseInReportCmd_1
// 3238   {
// 3239     uint8 dataType;
// 3240 
// 3241     numAttr++;
        INC     ?V0 + 7
// 3242     pBuf += 2; // move pass attribute id
        MOV     A,R6
        ADD     A,#0x2
        MOV     R6,A
        MOV     A,R7
        ADDC    A,#0x0
        MOV     R7,A
// 3243 
// 3244     dataType = *pBuf++;
        MOV     DPL,R6
        MOV     DPH,R7
        MOVX    A,@DPTR
        MOV     ?V0 + 6,A
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        MOV     R6,DPL
        MOV     R7,DPH
// 3245 
// 3246     attrDataLen = zclGetAttrDataLength( dataType, pBuf );
        ; Setup parameters for call to function zclGetAttrDataLength
        MOV     A,R6
        MOV     R2,A
        MOV     A,R7
        MOV     R3,A
        MOV     R1,?V0 + 6
        LCALL   ??zclGetAttrDataLength?relay
        MOV     ?V0 + 4,R2
        MOV     ?V0 + 5,R3
        MOV     ?V0 + 0,?V0 + 4
        MOV     ?V0 + 1,?V0 + 5
// 3247     pBuf += attrDataLen; // move pass attribute data
        MOV     A,R6
        ADD     A,?V0 + 0
        MOV     R6,A
        MOV     A,R7
        ADDC    A,?V0 + 1
        MOV     R7,A
// 3248 
// 3249     // add padding if needed
// 3250     if ( PADDING_NEEDED( attrDataLen ) )
        MOV     A,?V0 + 0
        MOV     C,0xE0 /* A   */.0
        JNC     ??zclParseInReportCmd_2
// 3251     {
// 3252       attrDataLen++;
        MOV     A,?V0 + 0
        ADD     A,#0x1
        MOV     ?V0 + 0,A
        MOV     A,?V0 + 1
        ADDC    A,#0x0
        MOV     ?V0 + 1,A
// 3253     }
// 3254 
// 3255     dataLen += attrDataLen;
??zclParseInReportCmd_2:
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        ADD     A,?V0 + 0
        MOVX    @DPTR,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,?V0 + 1
        MOVX    @DPTR,A
        SJMP    ??zclParseInReportCmd_0
// 3256   }
// 3257 
// 3258   hdrLen = sizeof( zclReportCmd_t ) + ( numAttr * sizeof( zclReport_t ) );
??zclParseInReportCmd_1:
        MOV     B,#0x5
        MOV     A,?V0 + 7
        MUL     AB
        ADD     A,#0x1
        MOV     ?V0 + 9,A
// 3259 
// 3260   reportCmd = (zclReportCmd_t *)osal_mem_alloc( hdrLen + dataLen );
        ; Setup parameters for call to function osal_mem_alloc
        MOV     ?V0 + 4,?V0 + 9
        MOV     ?V0 + 5,#0x0
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        ADD     A,?V0 + 4
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,?V0 + 5
        MOV     R3,A
        LCALL   ??osal_mem_alloc?relay
        MOV     ?V0 + 4,R2
        MOV     ?V0 + 5,R3
        MOV     ?V0 + 10,?V0 + 4
        MOV     ?V0 + 11,?V0 + 5
// 3261   if (reportCmd != NULL )
        MOV     A,?V0 + 10
        ORL     A,?V0 + 11
        JNZ     $+5
        LJMP    ??zclParseInReportCmd_3 & 0xFFFF
// 3262   {
// 3263     pBuf = pCmd->pData;
        MOV     DPL,?V0 + 14
        MOV     DPH,?V0 + 15
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        MOV     R6,A
        MOV     A,R1
        MOV     R7,A
// 3264     dataPtr = (uint8 *)( (uint8 *)reportCmd + hdrLen );
        MOV     ?V0 + 4,?V0 + 9
        MOV     ?V0 + 5,#0x0
        MOV     A,?V0 + 10
        ADD     A,?V0 + 4
        MOV     R0,A
        MOV     A,?V0 + 11
        ADDC    A,?V0 + 5
        MOV     R1,A
        MOV     ?V0 + 2,R0
        MOV     ?V0 + 3,R1
// 3265 
// 3266     reportCmd->numAttr = numAttr;
        MOV     A,?V0 + 7
        MOV     DPL,?V0 + 10
        MOV     DPH,?V0 + 11
        MOV     A,?V0 + 7
        MOVX    @DPTR,A
// 3267     for ( uint8 i = 0; i < numAttr; i++ )
        MOV     ?V0 + 8,#0x0
??zclParseInReportCmd_4:
        MOV     A,?V0 + 8
        CLR     C
        SUBB    A,?V0 + 7
        JC      $+5
        LJMP    ??zclParseInReportCmd_3 & 0xFFFF
// 3268     {
// 3269       zclReport_t *reportRec = &(reportCmd->attrList[i]);
        MOV     A,?V0 + 8
        MOV     R0,?V0 + 8
        MOV     R1,#0x0
        MOV     A,R0
        MOV     B,#0x5
        MUL     AB
        XCH     A,R0
        MOV     R2,B
        MOV     B,#0x0
        MUL     AB
        ADD     A,R2
        MOV     R2,A
        MOV     B,#0x5
        MOV     A,R1
        MUL     AB
        ADD     A,R2
        MOV     R1,A
        MOV     A,?V0 + 10
        ADD     A,R0
        MOV     DPL,A
        MOV     A,?V0 + 11
        ADDC    A,R1
        MOV     DPH,A
        INC     DPTR
        MOV     ?V0 + 12,DPL
        MOV     ?V0 + 13,DPH
// 3270 
// 3271       reportRec->attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
        MOV     DPL,R6
        MOV     DPH,R7
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     R3,#0x0
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     R1,#0x0
        CLR     A
        XCH     A,R0
        MOV     R1,A
        MOV     A,R2
        ADD     A,R0
        MOV     R0,A
        MOV     A,R3
        ADDC    A,R1
        MOV     R1,A
        MOV     DPL,?V0 + 12
        MOV     DPH,?V0 + 13
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
// 3272       pBuf += 2;
        MOV     A,R6
        ADD     A,#0x2
        MOV     R6,A
        MOV     A,R7
        ADDC    A,#0x0
        MOV     R7,A
// 3273       reportRec->dataType = *pBuf++;
        MOV     DPL,R6
        MOV     DPH,R7
        MOVX    A,@DPTR
        MOV     DPL,?V0 + 12
        MOV     DPH,?V0 + 13
        INC     DPTR
        INC     DPTR
        MOVX    @DPTR,A
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        MOV     R6,DPL
        MOV     R7,DPH
// 3274 
// 3275       attrDataLen = zclGetAttrDataLength( reportRec->dataType, pBuf );
        ; Setup parameters for call to function zclGetAttrDataLength
        MOV     A,R6
        MOV     R2,A
        MOV     A,R7
        MOV     R3,A
        MOV     DPL,?V0 + 12
        MOV     DPH,?V0 + 13
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??zclGetAttrDataLength?relay
        MOV     ?V0 + 4,R2
        MOV     ?V0 + 5,R3
        MOV     ?V0 + 0,?V0 + 4
        MOV     ?V0 + 1,?V0 + 5
// 3276       osal_memcpy( dataPtr, pBuf, attrDataLen );
        ; Setup parameters for call to function osal_memcpy
        MOV     ?V0 + 4,R6
        MOV     ?V0 + 5,R7
        MOV     ?V0 + 6,#0x0
        MOV     R0,#?V0 + 4
        LCALL   ?PUSH_XSTACK_I_THREE
          CFI CFA_XSP16 add(XSP16, 29)
        MOV     R4,?V0 + 0
        MOV     R5,?V0 + 1
        MOV     R2,?V0 + 2
        MOV     R3,?V0 + 3
        LCALL   ??osal_memcpy?relay
        MOV     A,#0x3
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 26)
// 3277       reportRec->attrData = dataPtr;
        MOV     DPL,?V0 + 12
        MOV     DPH,?V0 + 13
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOV     A,?V0 + 2
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,?V0 + 3
        MOVX    @DPTR,A
// 3278 
// 3279       pBuf += attrDataLen; // move pass attribute data
        MOV     A,R6
        ADD     A,?V0 + 0
        MOV     R6,A
        MOV     A,R7
        ADDC    A,?V0 + 1
        MOV     R7,A
// 3280 
// 3281       // advance attribute data pointer
// 3282       if ( PADDING_NEEDED( attrDataLen ) )
        MOV     A,?V0 + 0
        MOV     C,0xE0 /* A   */.0
        JNC     ??zclParseInReportCmd_5
// 3283       {
// 3284         attrDataLen++;
        MOV     A,?V0 + 0
        ADD     A,#0x1
        MOV     ?V0 + 0,A
        MOV     A,?V0 + 1
        ADDC    A,#0x0
        MOV     ?V0 + 1,A
// 3285       }
// 3286 
// 3287       dataPtr += attrDataLen;
??zclParseInReportCmd_5:
        MOV     A,?V0 + 2
        ADD     A,?V0 + 0
        MOV     ?V0 + 2,A
        MOV     A,?V0 + 3
        ADDC    A,?V0 + 1
        MOV     ?V0 + 3,A
// 3288     }
        INC     ?V0 + 8
        LJMP    ??zclParseInReportCmd_4 & 0xFFFF
// 3289   }
// 3290 
// 3291   return ( (void *)reportCmd );
??zclParseInReportCmd_3:
        MOV     R2,?V0 + 10
        MOV     R3,?V0 + 11
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 24)
        MOV     R7,#0x10
        LJMP    ?BANKED_LEAVE_XDATA
          CFI EndBlock cfiBlock53
// 3292 }
// 3293 #endif // ZCL_REPORT
// 3294 
// 3295 /*********************************************************************
// 3296  * @fn      zclParseInDefaultRspCmd
// 3297  *
// 3298  * @brief   Parse the "Profile" Default Response Command
// 3299  *
// 3300  *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
// 3301  *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
// 3302  *
// 3303  * @param   pCmd - pointer to incoming data to parse
// 3304  *
// 3305  * @return  pointer to the parsed command structure
// 3306  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 3307 static void *zclParseInDefaultRspCmd( zclParseCmd_t *pCmd )
zclParseInDefaultRspCmd:
          CFI Block cfiBlock54 Using cfiCommon0
          CFI Function zclParseInDefaultRspCmd
        CODE
// 3308 {
        FUNCALL zclParseInDefaultRspCmd, osal_mem_alloc
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 14, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 14, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0xe
        LCALL   ?BANKED_ENTER_XDATA
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V5 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI V4 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-13)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-14)))
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 14)
        ; Saved register size: 14
        ; Auto size: 0
        MOV     ?V0 + 2,R2
        MOV     ?V0 + 3,R3
// 3309   zclDefaultRspCmd_t *defaultRspCmd;
// 3310   uint8 *pBuf = pCmd->pData;
        MOV     DPL,?V0 + 2
        MOV     DPH,?V0 + 3
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R6,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R7,A
// 3311 
// 3312   defaultRspCmd = (zclDefaultRspCmd_t *)osal_mem_alloc( sizeof ( zclDefaultRspCmd_t ) );
        ; Setup parameters for call to function osal_mem_alloc
        MOV     R2,#0x2
        MOV     R3,#0x0
        LCALL   ??osal_mem_alloc?relay
        MOV     ?V0 + 4,R2
        MOV     ?V0 + 5,R3
        MOV     ?V0 + 0,?V0 + 4
        MOV     ?V0 + 1,?V0 + 5
// 3313   if ( defaultRspCmd != NULL )
        MOV     A,?V0 + 0
        ORL     A,?V0 + 1
        JZ      ??zclParseInDefaultRspCmd_0
// 3314   {
// 3315     defaultRspCmd->commandID = *pBuf++;
        MOV     DPL,R6
        MOV     DPH,R7
        MOVX    A,@DPTR
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        MOVX    @DPTR,A
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        MOV     R6,DPL
        MOV     R7,DPH
// 3316     defaultRspCmd->statusCode = *pBuf;
        MOV     DPL,R6
        MOV     DPH,R7
        MOVX    A,@DPTR
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        INC     DPTR
        MOVX    @DPTR,A
// 3317   }
// 3318 
// 3319   return ( (void *)defaultRspCmd );
??zclParseInDefaultRspCmd_0:
        MOV     R2,?V0 + 0
        MOV     R3,?V0 + 1
        MOV     R7,#0x6
        LJMP    ?BANKED_LEAVE_XDATA
          CFI EndBlock cfiBlock54
// 3320 }
// 3321 
// 3322 #ifdef ZCL_DISCOVER
// 3323 /*********************************************************************
// 3324  * @fn      zclParseInDiscCmd
// 3325  *
// 3326  * @brief   Parse the "Profile" Discovery Commands
// 3327  *
// 3328  *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
// 3329  *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
// 3330  *
// 3331  * @param   pCmd - pointer to incoming data to parse
// 3332  *
// 3333  * @return  pointer to the parsed command structure
// 3334  */
// 3335 void *zclParseInDiscCmd( zclParseCmd_t *pCmd )
// 3336 {
// 3337   zclDiscoverCmd_t *discoverCmd;
// 3338   uint8 *pBuf = pCmd->pData;
// 3339 
// 3340   discoverCmd = (zclDiscoverCmd_t *)osal_mem_alloc( sizeof ( zclDiscoverCmd_t ) );
// 3341   if ( discoverCmd != NULL )
// 3342   {
// 3343     discoverCmd->startAttr = BUILD_UINT16( pBuf[0], pBuf[1] );
// 3344     pBuf += 2;
// 3345     discoverCmd->maxAttrIDs = *pBuf;
// 3346   }
// 3347 
// 3348   return ( (void *)discoverCmd );
// 3349 }
// 3350 
// 3351 /*********************************************************************
// 3352  * @fn      zclParseInDiscRspCmd
// 3353  *
// 3354  * @brief   Parse the "Profile" Discovery Response Commands
// 3355  *
// 3356  *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
// 3357  *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
// 3358  *
// 3359  * @param   pCmd - pointer to incoming data to parse
// 3360  *
// 3361  * @return  pointer to the parsed command structure
// 3362  */
// 3363 #define ZCLDISCRSPCMD_DATALEN(a)  ((a)-1) // data len - Discovery Complete
// 3364 static void *zclParseInDiscRspCmd( zclParseCmd_t *pCmd )
// 3365 {
// 3366   zclDiscoverRspCmd_t *discoverRspCmd;
// 3367   uint8 *pBuf = pCmd->pData;
// 3368   uint8 numAttr = ZCLDISCRSPCMD_DATALEN(pCmd->dataLen) / ( 2 + 1 ); // Attr ID + Data Type
// 3369 
// 3370   discoverRspCmd = (zclDiscoverRspCmd_t *)osal_mem_alloc( sizeof ( zclDiscoverRspCmd_t )
// 3371                                                  + ( numAttr * sizeof(zclDiscoverInfo_t) ) );
// 3372   if ( discoverRspCmd != NULL )
// 3373   {
// 3374     discoverRspCmd->discComplete = *pBuf++;
// 3375     discoverRspCmd->numAttr = numAttr;
// 3376 
// 3377     for ( uint8 i = 0; i < numAttr; i++ )
// 3378     {
// 3379       discoverRspCmd->attrList[i].attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
// 3380       pBuf += 2;
// 3381       discoverRspCmd->attrList[i].dataType = *pBuf++;;
// 3382     }
// 3383   }
// 3384 
// 3385   return ( (void *)discoverRspCmd );
// 3386 }
// 3387 #endif // ZCL_DISCOVER
// 3388 
// 3389 #ifdef ZCL_READ
// 3390 /*********************************************************************
// 3391  * @fn      zclProcessInReadCmd
// 3392  *
// 3393  * @brief   Process the "Profile" Read Command
// 3394  *
// 3395  * @param   pInMsg - incoming message to process
// 3396  *
// 3397  * @return  TRUE if command processed. FALSE, otherwise.
// 3398  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 3399 static uint8 zclProcessInReadCmd( zclIncoming_t *pInMsg )
zclProcessInReadCmd:
          CFI Block cfiBlock55 Using cfiCommon0
          CFI Function zclProcessInReadCmd
        CODE
// 3400 {
        FUNCALL zclProcessInReadCmd, osal_mem_alloc
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 28, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 28, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL zclProcessInReadCmd, zclFindAttrRec
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 30, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 30, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL zclProcessInReadCmd, zclAuthorizeRead
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 28, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 28, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL zclProcessInReadCmd, zcl_SendReadRsp
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 33, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 33, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL zclProcessInReadCmd, osal_mem_free
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 28, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 28, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0x14
        LCALL   ?BANKED_ENTER_XDATA
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V11 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI V10 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V9 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI V8 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI V7 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI V6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI V5 load(1, XDATA, add(CFA_XSP16, literal(-13)))
          CFI V4 load(1, XDATA, add(CFA_XSP16, literal(-14)))
          CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-15)))
          CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-16)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-17)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-18)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-19)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-20)))
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 20)
        ; Saved register size: 20
        ; Auto size: 8
        MOV     A,#-0x8
        LCALL   ?ALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 28)
        MOV     A,R2
        MOV     R6,A
        MOV     A,R3
        MOV     R7,A
// 3401   zclReadCmd_t *readCmd;
// 3402   zclReadRspCmd_t *readRspCmd;
// 3403   zclAttrRec_t attrRec;
// 3404   uint16 len;
// 3405 
// 3406   readCmd = (zclReadCmd_t *)pInMsg->attrCmd;
        MOV     A,R6
        ADD     A,#0xc
        MOV     DPL,A
        MOV     A,R7
        ADDC    A,#0x0
        MOV     DPH,A
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     ?V0 + 4,R0
        MOV     ?V0 + 5,R1
// 3407 
// 3408   // calculate the length of the response status record
// 3409   len = sizeof( zclReadRspCmd_t ) + (readCmd->numAttr * sizeof( zclReadRspStatus_t ));
        MOV     DPL,?V0 + 4
        MOV     DPH,?V0 + 5
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     R1,#0x0
        MOV     A,R0
        MOV     B,#0x6
        MUL     AB
        XCH     A,R0
        MOV     R2,B
        MOV     B,#0x0
        MUL     AB
        ADD     A,R2
        MOV     R2,A
        MOV     B,#0x6
        MOV     A,R1
        MUL     AB
        ADD     A,R2
        MOV     R1,A
        MOV     A,R0
        ADD     A,#0x1
        MOV     R0,A
        MOV     A,R1
        ADDC    A,#0x0
        MOV     R1,A
        MOV     ?V0 + 6,R0
        MOV     ?V0 + 7,R1
// 3410 
// 3411   readRspCmd = osal_mem_alloc( len );
        ; Setup parameters for call to function osal_mem_alloc
        MOV     R2,?V0 + 6
        MOV     R3,?V0 + 7
        LCALL   ??osal_mem_alloc?relay
        MOV     ?V0 + 0,R2
        MOV     ?V0 + 1,R3
        MOV     ?V0 + 8,?V0 + 0
        MOV     ?V0 + 9,?V0 + 1
// 3412   if ( readRspCmd == NULL )
        MOV     A,?V0 + 8
        ORL     A,?V0 + 9
        JNZ     ??zclProcessInReadCmd_0
// 3413   {
// 3414     return FALSE; // EMBEDDED RETURN
        MOV     R1,#0x0
        LJMP    ??zclProcessInReadCmd_1 & 0xFFFF
// 3415   }
// 3416 
// 3417   readRspCmd->numAttr = readCmd->numAttr;
??zclProcessInReadCmd_0:
        MOV     DPL,?V0 + 4
        MOV     DPH,?V0 + 5
        MOVX    A,@DPTR
        MOV     DPL,?V0 + 8
        MOV     DPH,?V0 + 9
        MOVX    @DPTR,A
// 3418   for ( uint8 i = 0; i < readCmd->numAttr; i++ )
        MOV     ?V0 + 0,#0x0
??zclProcessInReadCmd_2:
        MOV     DPL,?V0 + 4
        MOV     DPH,?V0 + 5
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     A,?V0 + 0
        CLR     C
        SUBB    A,R0
        JC      $+5
        LJMP    ??zclProcessInReadCmd_3 & 0xFFFF
// 3419   {
// 3420     zclReadRspStatus_t *statusRec = &(readRspCmd->attrList[i]);
        MOV     A,?V0 + 0
        MOV     R0,?V0 + 0
        MOV     R1,#0x0
        MOV     A,R0
        MOV     B,#0x6
        MUL     AB
        XCH     A,R0
        MOV     R2,B
        MOV     B,#0x0
        MUL     AB
        ADD     A,R2
        MOV     R2,A
        MOV     B,#0x6
        MOV     A,R1
        MUL     AB
        ADD     A,R2
        MOV     R1,A
        MOV     A,?V0 + 8
        ADD     A,R0
        MOV     DPL,A
        MOV     A,?V0 + 9
        ADDC    A,R1
        MOV     DPH,A
        INC     DPTR
        MOV     ?V0 + 2,DPL
        MOV     ?V0 + 3,DPH
// 3421 
// 3422     statusRec->attrID = readCmd->attrID[i];
        MOV     A,?V0 + 0
        MOV     R0,?V0 + 0
        MOV     R1,#0x0
        MOV     A,R0
        MOV     B,#0x2
        MUL     AB
        XCH     A,R0
        MOV     R2,B
        MOV     B,#0x0
        MUL     AB
        ADD     A,R2
        MOV     R2,A
        MOV     B,#0x2
        MOV     A,R1
        MUL     AB
        ADD     A,R2
        MOV     R1,A
        MOV     A,?V0 + 4
        ADD     A,R0
        MOV     DPL,A
        MOV     A,?V0 + 5
        ADDC    A,R1
        MOV     DPH,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     DPL,?V0 + 2
        MOV     DPH,?V0 + 3
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
// 3423 
// 3424     if ( zclFindAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId,
// 3425                          readCmd->attrID[i], &attrRec ) )
        ; Setup parameters for call to function zclFindAttrRec
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     ?V0 + 10,DPL
        MOV     ?V0 + 11,DPH
        MOV     R0,#?V0 + 10
        LCALL   ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 30)
        MOV     A,?V0 + 0
        MOV     R0,?V0 + 0
        MOV     R1,#0x0
        MOV     A,R0
        MOV     B,#0x2
        MUL     AB
        XCH     A,R0
        MOV     R2,B
        MOV     B,#0x0
        MUL     AB
        ADD     A,R2
        MOV     R2,A
        MOV     B,#0x2
        MOV     A,R1
        MUL     AB
        ADD     A,R2
        MOV     R1,A
        MOV     A,?V0 + 4
        ADD     A,R0
        MOV     DPL,A
        MOV     A,?V0 + 5
        ADDC    A,R1
        MOV     DPH,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R4,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R5,A
        MOV     DPL,R6
        MOV     DPH,R7
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        MOV     DPL,R6
        MOV     DPH,R7
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        XCH     A,R0
        ADD     A,#0x14
        MOV     DPL,A
        MOV     A,R0
        ADDC    A,#0x0
        MOV     DPH,A
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??zclFindAttrRec?relay
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 28)
        MOV     A,R1
        JNZ     $+5
        LJMP    ??zclProcessInReadCmd_4 & 0xFFFF
// 3426     {
// 3427       if ( zcl_AccessCtrlRead( attrRec.attr.accessControl ) )
        MOV     A,#0x5
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     C,0xE0 /* A   */.0
        JNC     ??zclProcessInReadCmd_5
// 3428       {
// 3429         statusRec->status = zclAuthorizeRead( pInMsg->msg->endPoint,
// 3430                                               &(pInMsg->msg->srcAddr), &attrRec );
        ; Setup parameters for call to function zclAuthorizeRead
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     DPL,R6
        MOV     DPH,R7
        MOVX    A,@DPTR
        ADD     A,#0x6
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R3,A
        MOV     DPL,R6
        MOV     DPH,R7
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        XCH     A,R0
        ADD     A,#0x14
        MOV     DPL,A
        MOV     A,R0
        ADDC    A,#0x0
        MOV     DPH,A
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??zclAuthorizeRead?relay
        MOV     A,R1
        MOV     DPL,?V0 + 2
        MOV     DPH,?V0 + 3
        INC     DPTR
        INC     DPTR
        MOVX    @DPTR,A
// 3431         if ( statusRec->status == ZCL_STATUS_SUCCESS )
        MOV     DPL,?V0 + 2
        MOV     DPH,?V0 + 3
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        JNZ     ??zclProcessInReadCmd_6
// 3432         {
// 3433           statusRec->data = attrRec.attr.dataPtr;
        MOV     A,#0x6
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     DPL,?V0 + 2
        MOV     DPH,?V0 + 3
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
// 3434           statusRec->dataType = attrRec.attr.dataType;
        MOV     A,#0x4
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     DPL,?V0 + 2
        MOV     DPH,?V0 + 3
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    @DPTR,A
        SJMP    ??zclProcessInReadCmd_6
// 3435         }
// 3436       }
// 3437       else
// 3438       {
// 3439         statusRec->status = ZCL_STATUS_WRITE_ONLY;
??zclProcessInReadCmd_5:
        MOV     DPL,?V0 + 2
        MOV     DPH,?V0 + 3
        INC     DPTR
        INC     DPTR
        MOV     A,#-0x71
        MOVX    @DPTR,A
        SJMP    ??zclProcessInReadCmd_6
// 3440       }
// 3441     }
// 3442     else
// 3443     {
// 3444       statusRec->status = ZCL_STATUS_UNSUPPORTED_ATTRIBUTE;
??zclProcessInReadCmd_4:
        MOV     DPL,?V0 + 2
        MOV     DPH,?V0 + 3
        INC     DPTR
        INC     DPTR
        MOV     A,#-0x7a
        MOVX    @DPTR,A
// 3445     }
// 3446   }
??zclProcessInReadCmd_6:
        INC     ?V0 + 0
        LJMP    ??zclProcessInReadCmd_2 & 0xFFFF
// 3447 
// 3448   // Build and send Read Response command
// 3449   zcl_SendReadRsp( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr), pInMsg->msg->clusterId,
// 3450                    readRspCmd, ZCL_FRAME_SERVER_CLIENT_DIR,
// 3451                    true, pInMsg->hdr.transSeqNum );
??zclProcessInReadCmd_3:
        ; Setup parameters for call to function zcl_SendReadRsp
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     ?V0 + 0,A
        MOV     R0,#?V0 + 0
        LCALL   ?PUSH_XSTACK_I_ONE
          CFI CFA_XSP16 add(XSP16, 29)
        MOV     ?V0 + 0,#0x1
        MOV     R0,#?V0 + 0
        LCALL   ?PUSH_XSTACK_I_ONE
          CFI CFA_XSP16 add(XSP16, 30)
        MOV     ?V0 + 0,#0x1
        MOV     R0,#?V0 + 0
        LCALL   ?PUSH_XSTACK_I_ONE
          CFI CFA_XSP16 add(XSP16, 31)
        MOV     R0,#?V0 + 8
        LCALL   ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 33)
        MOV     DPL,R6
        MOV     DPH,R7
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R4,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R5,A
        MOV     DPL,R6
        MOV     DPH,R7
        MOVX    A,@DPTR
        ADD     A,#0x6
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R3,A
        MOV     DPL,R6
        MOV     DPH,R7
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        XCH     A,R0
        ADD     A,#0x14
        MOV     DPL,A
        MOV     A,R0
        ADDC    A,#0x0
        MOV     DPH,A
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??zcl_SendReadRsp?relay
        MOV     A,#0x5
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 28)
        MOV     A,R1
// 3452   osal_mem_free( readRspCmd );
        ; Setup parameters for call to function osal_mem_free
        MOV     R2,?V0 + 8
        MOV     R3,?V0 + 9
        LCALL   ??osal_mem_free?relay
// 3453 
// 3454   return TRUE;
        MOV     R1,#0x1
??zclProcessInReadCmd_1:
        MOV     A,#0x8
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 20)
        MOV     R7,#0xc
        LJMP    ?BANKED_LEAVE_XDATA
          CFI EndBlock cfiBlock55
// 3455 }
// 3456 #endif // ZCL_READ
// 3457 
// 3458 #ifdef ZCL_WRITE
// 3459 /*********************************************************************
// 3460  * @fn      processInWriteCmd
// 3461  *
// 3462  * @brief   Process the "Profile" Write and Write No Response Commands
// 3463  *
// 3464  * @param   pInMsg - incoming message to process
// 3465  *
// 3466  * @return  TRUE if command processed. FALSE, otherwise.
// 3467  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 3468 static uint8 zclProcessInWriteCmd( zclIncoming_t *pInMsg )
zclProcessInWriteCmd:
          CFI Block cfiBlock56 Using cfiCommon0
          CFI Function zclProcessInWriteCmd
        CODE
// 3469 {
        FUNCALL zclProcessInWriteCmd, osal_mem_alloc
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 28, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 28, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL zclProcessInWriteCmd, zclFindAttrRec
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 30, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 30, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL zclProcessInWriteCmd, zclWriteAttrData
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 30, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 30, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL zclProcessInWriteCmd, zclWriteAttrDataUsingCB
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 30, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 30, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL zclProcessInWriteCmd, zcl_SendWriteRsp
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 33, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 33, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL zclProcessInWriteCmd, osal_mem_free
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 28, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 28, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0x14
        LCALL   ?BANKED_ENTER_XDATA
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V11 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI V10 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V9 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI V8 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI V7 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI V6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI V5 load(1, XDATA, add(CFA_XSP16, literal(-13)))
          CFI V4 load(1, XDATA, add(CFA_XSP16, literal(-14)))
          CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-15)))
          CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-16)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-17)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-18)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-19)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-20)))
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 20)
        ; Saved register size: 20
        ; Auto size: 8
        MOV     A,#-0x8
        LCALL   ?ALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 28)
        MOV     ?V0 + 0,R2
        MOV     ?V0 + 1,R3
// 3470   zclWriteCmd_t *writeCmd;
// 3471   zclWriteRspCmd_t *writeRspCmd;
// 3472   uint8 sendRsp = FALSE;
        MOV     ?V0 + 2,#0x0
// 3473   uint8 j = 0;
        MOV     R6,#0x0
// 3474 
// 3475   writeCmd = (zclWriteCmd_t *)pInMsg->attrCmd;
        MOV     A,?V0 + 0
        ADD     A,#0xc
        MOV     DPL,A
        MOV     A,?V0 + 1
        ADDC    A,#0x0
        MOV     DPH,A
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     ?V0 + 4,R0
        MOV     ?V0 + 5,R1
// 3476   if ( pInMsg->hdr.commandID == ZCL_CMD_WRITE )
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        XRL     A,#0x2
        JNZ     ??zclProcessInWriteCmd_0
// 3477   {
// 3478     // We need to send a response back - allocate space for it
// 3479     writeRspCmd = (zclWriteRspCmd_t *)osal_mem_alloc( sizeof( zclWriteRspCmd_t )
// 3480             + sizeof( zclWriteRspStatus_t ) * writeCmd->numAttr );
        ; Setup parameters for call to function osal_mem_alloc
        MOV     DPL,?V0 + 4
        MOV     DPH,?V0 + 5
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     R1,#0x0
        MOV     A,R0
        MOV     B,#0x3
        MUL     AB
        XCH     A,R0
        MOV     R2,B
        MOV     B,#0x0
        MUL     AB
        ADD     A,R2
        MOV     R2,A
        MOV     B,#0x3
        MOV     A,R1
        MUL     AB
        ADD     A,R2
        MOV     R1,A
        MOV     A,R0
        ADD     A,#0x1
        MOV     R2,A
        MOV     A,R1
        ADDC    A,#0x0
        MOV     R3,A
        LCALL   ??osal_mem_alloc?relay
        MOV     ?V0 + 6,R2
        MOV     ?V0 + 7,R3
        MOV     ?V0 + 8,?V0 + 6
        MOV     ?V0 + 9,?V0 + 7
// 3481     if ( writeRspCmd == NULL )
        MOV     A,?V0 + 8
        ORL     A,?V0 + 9
        JNZ     ??zclProcessInWriteCmd_1
// 3482     {
// 3483       return FALSE; // EMBEDDED RETURN
        MOV     R1,#0x0
        LJMP    ??zclProcessInWriteCmd_2 & 0xFFFF
// 3484     }
// 3485 
// 3486     sendRsp = TRUE;
??zclProcessInWriteCmd_1:
        MOV     ?V0 + 2,#0x1
// 3487   }
// 3488 
// 3489   for ( uint8 i = 0; i < writeCmd->numAttr; i++ )
??zclProcessInWriteCmd_0:
        MOV     ?V0 + 3,#0x0
??zclProcessInWriteCmd_3:
        MOV     DPL,?V0 + 4
        MOV     DPH,?V0 + 5
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     A,?V0 + 3
        CLR     C
        SUBB    A,R0
        JC      $+5
        LJMP    ??zclProcessInWriteCmd_4 & 0xFFFF
// 3490   {
// 3491     zclAttrRec_t attrRec;
// 3492     zclWriteRec_t *statusRec = &(writeCmd->attrList[i]);
        MOV     A,?V0 + 3
        MOV     R0,?V0 + 3
        MOV     R1,#0x0
        MOV     A,R0
        MOV     B,#0x5
        MUL     AB
        XCH     A,R0
        MOV     R2,B
        MOV     B,#0x0
        MUL     AB
        ADD     A,R2
        MOV     R2,A
        MOV     B,#0x5
        MOV     A,R1
        MUL     AB
        ADD     A,R2
        MOV     R1,A
        MOV     A,?V0 + 4
        ADD     A,R0
        MOV     DPL,A
        MOV     A,?V0 + 5
        ADDC    A,R1
        MOV     DPH,A
        INC     DPTR
        MOV     ?V0 + 6,DPL
        MOV     ?V0 + 7,DPH
// 3493 
// 3494     if ( zclFindAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId,
// 3495                          statusRec->attrID, &attrRec ) )
        ; Setup parameters for call to function zclFindAttrRec
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     ?V0 + 10,DPL
        MOV     ?V0 + 11,DPH
        MOV     R0,#?V0 + 10
        LCALL   ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 30)
        MOV     DPL,?V0 + 6
        MOV     DPH,?V0 + 7
        MOVX    A,@DPTR
        MOV     R4,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R5,A
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        XCH     A,R0
        ADD     A,#0x14
        MOV     DPL,A
        MOV     A,R0
        ADDC    A,#0x0
        MOV     DPH,A
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??zclFindAttrRec?relay
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 28)
        MOV     A,R1
        JNZ     $+5
        LJMP    ??zclProcessInWriteCmd_5 & 0xFFFF
// 3496     {
// 3497       if ( statusRec->dataType == attrRec.attr.dataType )
        MOV     DPL,?V0 + 6
        MOV     DPH,?V0 + 7
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     A,#0x4
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        XRL     A,R0
        JZ      $+5
        LJMP    ??zclProcessInWriteCmd_6 & 0xFFFF
// 3498       {
// 3499         uint8 status;
// 3500 
// 3501         // Write the new attribute value
// 3502         if ( attrRec.attr.dataPtr != NULL )
        MOV     A,#0x6
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JZ      ??zclProcessInWriteCmd_7
// 3503         {
// 3504           status = zclWriteAttrData( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr),
// 3505                                      &attrRec, statusRec );
        ; Setup parameters for call to function zclWriteAttrData
        MOV     R0,#?V0 + 6
        LCALL   ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 30)
        MOV     A,#0x2
        LCALL   ?XSTACK_DISP0_8
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        MOVX    A,@DPTR
        ADD     A,#0x6
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R3,A
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        XCH     A,R0
        ADD     A,#0x14
        MOV     DPL,A
        MOV     A,R0
        ADDC    A,#0x0
        MOV     DPH,A
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??zclWriteAttrData?relay
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 28)
        MOV     A,R1
        MOV     R7,A
        SJMP    ??zclProcessInWriteCmd_8
// 3506         }
// 3507         else // Use CB
// 3508         {
// 3509           status = zclWriteAttrDataUsingCB( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr),
// 3510                                             &attrRec, statusRec->attrData );
??zclProcessInWriteCmd_7:
        ; Setup parameters for call to function zclWriteAttrDataUsingCB
        MOV     DPL,?V0 + 6
        MOV     DPH,?V0 + 7
        INC     DPTR
        INC     DPTR
        INC     DPTR
        LCALL   ?PUSH_XSTACK8_X_TWO
          CFI CFA_XSP16 add(XSP16, 30)
        MOV     A,#0x2
        LCALL   ?XSTACK_DISP0_8
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        MOVX    A,@DPTR
        ADD     A,#0x6
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R3,A
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        XCH     A,R0
        ADD     A,#0x14
        MOV     DPL,A
        MOV     A,R0
        ADDC    A,#0x0
        MOV     DPH,A
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??zclWriteAttrDataUsingCB?relay
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 28)
        MOV     A,R1
        MOV     R7,A
// 3511         }
// 3512 
// 3513         // If successful, a write attribute status record shall NOT be generated
// 3514         if ( sendRsp && status != ZCL_STATUS_SUCCESS )
??zclProcessInWriteCmd_8:
        MOV     A,?V0 + 2
        JNZ     $+5
        LJMP    ??zclProcessInWriteCmd_9 & 0xFFFF
        MOV     A,R7
        JNZ     $+5
        LJMP    ??zclProcessInWriteCmd_9 & 0xFFFF
// 3515         {
// 3516           // Attribute is read only - move on to the next write attribute record
// 3517           writeRspCmd->attrList[j].status = status;
        MOV     A,R7
        PUSH    A
          CFI CFA_SP SP+-1
        MOV     A,R6
        MOV     R0,A
        MOV     R1,#0x0
        MOV     A,R0
        MOV     B,#0x3
        MUL     AB
        XCH     A,R0
        MOV     R2,B
        MOV     B,#0x0
        MUL     AB
        ADD     A,R2
        MOV     R2,A
        MOV     B,#0x3
        MOV     A,R1
        MUL     AB
        ADD     A,R2
        MOV     R1,A
        MOV     A,?V0 + 8
        ADD     A,R0
        MOV     DPL,A
        MOV     A,?V0 + 9
        ADDC    A,R1
        MOV     DPH,A
        INC     DPTR
        POP     A
          CFI CFA_SP SP+0
        MOVX    @DPTR,A
// 3518           writeRspCmd->attrList[j++].attrID = statusRec->attrID;
        MOV     DPL,?V0 + 6
        MOV     DPH,?V0 + 7
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        MOV     A,R6
        MOV     R0,A
        MOV     R1,#0x0
        MOV     A,R0
        MOV     B,#0x3
        MUL     AB
        XCH     A,R0
        MOV     R4,B
        MOV     B,#0x0
        MUL     AB
        ADD     A,R4
        MOV     R4,A
        MOV     B,#0x3
        MOV     A,R1
        MUL     AB
        ADD     A,R4
        MOV     R1,A
        MOV     A,?V0 + 8
        ADD     A,R0
        MOV     DPL,A
        MOV     A,?V0 + 9
        ADDC    A,R1
        MOV     DPH,A
        INC     DPTR
        INC     DPTR
        MOV     A,R2
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R3
        MOVX    @DPTR,A
        INC     R6
        LJMP    ??zclProcessInWriteCmd_9 & 0xFFFF
// 3519         }
// 3520       }
// 3521       else
// 3522       {
// 3523         // Attribute data type is incorrect - move on to the next write attribute record
// 3524         if ( sendRsp )
??zclProcessInWriteCmd_6:
        MOV     A,?V0 + 2
        JNZ     $+5
        LJMP    ??zclProcessInWriteCmd_9 & 0xFFFF
// 3525         {
// 3526           writeRspCmd->attrList[j].status = ZCL_STATUS_INVALID_DATA_TYPE;
        MOV     A,R6
        MOV     R0,A
        MOV     R1,#0x0
        MOV     A,R0
        MOV     B,#0x3
        MUL     AB
        XCH     A,R0
        MOV     R2,B
        MOV     B,#0x0
        MUL     AB
        ADD     A,R2
        MOV     R2,A
        MOV     B,#0x3
        MOV     A,R1
        MUL     AB
        ADD     A,R2
        MOV     R1,A
        MOV     A,?V0 + 8
        ADD     A,R0
        MOV     DPL,A
        MOV     A,?V0 + 9
        ADDC    A,R1
        MOV     DPH,A
        INC     DPTR
        MOV     A,#-0x73
        MOVX    @DPTR,A
// 3527           writeRspCmd->attrList[j++].attrID = statusRec->attrID;
        MOV     DPL,?V0 + 6
        MOV     DPH,?V0 + 7
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        MOV     A,R6
        MOV     R0,A
        MOV     R1,#0x0
        MOV     A,R0
        MOV     B,#0x3
        MUL     AB
        XCH     A,R0
        MOV     R4,B
        MOV     B,#0x0
        MUL     AB
        ADD     A,R4
        MOV     R4,A
        MOV     B,#0x3
        MOV     A,R1
        MUL     AB
        ADD     A,R4
        MOV     R1,A
        MOV     A,?V0 + 8
        ADD     A,R0
        MOV     DPL,A
        MOV     A,?V0 + 9
        ADDC    A,R1
        MOV     DPH,A
        INC     DPTR
        INC     DPTR
        MOV     A,R2
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R3
        MOVX    @DPTR,A
        INC     R6
        SJMP    ??zclProcessInWriteCmd_9
// 3528         }
// 3529       }
// 3530     }
// 3531     else
// 3532     {
// 3533       // Attribute is not supported - move on to the next write attribute record
// 3534       if ( sendRsp )
??zclProcessInWriteCmd_5:
        MOV     A,?V0 + 2
        JZ      ??zclProcessInWriteCmd_9
// 3535       {
// 3536         writeRspCmd->attrList[j].status = ZCL_STATUS_UNSUPPORTED_ATTRIBUTE;
        MOV     A,R6
        MOV     R0,A
        MOV     R1,#0x0
        MOV     A,R0
        MOV     B,#0x3
        MUL     AB
        XCH     A,R0
        MOV     R2,B
        MOV     B,#0x0
        MUL     AB
        ADD     A,R2
        MOV     R2,A
        MOV     B,#0x3
        MOV     A,R1
        MUL     AB
        ADD     A,R2
        MOV     R1,A
        MOV     A,?V0 + 8
        ADD     A,R0
        MOV     DPL,A
        MOV     A,?V0 + 9
        ADDC    A,R1
        MOV     DPH,A
        INC     DPTR
        MOV     A,#-0x7a
        MOVX    @DPTR,A
// 3537         writeRspCmd->attrList[j++].attrID = statusRec->attrID;
        MOV     DPL,?V0 + 6
        MOV     DPH,?V0 + 7
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        MOV     A,R6
        MOV     R0,A
        MOV     R1,#0x0
        MOV     A,R0
        MOV     B,#0x3
        MUL     AB
        XCH     A,R0
        MOV     R4,B
        MOV     B,#0x0
        MUL     AB
        ADD     A,R4
        MOV     R4,A
        MOV     B,#0x3
        MOV     A,R1
        MUL     AB
        ADD     A,R4
        MOV     R1,A
        MOV     A,?V0 + 8
        ADD     A,R0
        MOV     DPL,A
        MOV     A,?V0 + 9
        ADDC    A,R1
        MOV     DPH,A
        INC     DPTR
        INC     DPTR
        MOV     A,R2
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R3
        MOVX    @DPTR,A
        INC     R6
// 3538       }
// 3539     }
// 3540   } // for loop
??zclProcessInWriteCmd_9:
        INC     ?V0 + 3
        LJMP    ??zclProcessInWriteCmd_3 & 0xFFFF
// 3541 
// 3542   if ( sendRsp )
??zclProcessInWriteCmd_4:
        MOV     A,?V0 + 2
        JNZ     $+5
        LJMP    ??zclProcessInWriteCmd_10 & 0xFFFF
// 3543   {
// 3544     writeRspCmd->numAttr = j;
        MOV     A,R6
        MOV     DPL,?V0 + 8
        MOV     DPH,?V0 + 9
        MOVX    @DPTR,A
// 3545     if ( writeRspCmd->numAttr == 0 )
        MOV     DPL,?V0 + 8
        MOV     DPH,?V0 + 9
        MOVX    A,@DPTR
        JNZ     ??zclProcessInWriteCmd_11
// 3546     {
// 3547       // Since all records were written successful, include a single status record
// 3548       // in the resonse command with the status field set to SUCCESS and the
// 3549       // attribute ID field omitted.
// 3550       writeRspCmd->attrList[0].status = ZCL_STATUS_SUCCESS;
        MOV     DPL,?V0 + 8
        MOV     DPH,?V0 + 9
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
// 3551       writeRspCmd->numAttr = 1;
        MOV     DPL,?V0 + 8
        MOV     DPH,?V0 + 9
        MOV     A,#0x1
        MOVX    @DPTR,A
// 3552     }
// 3553 
// 3554     zcl_SendWriteRsp( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr),
// 3555                       pInMsg->msg->clusterId, writeRspCmd, ZCL_FRAME_SERVER_CLIENT_DIR,
// 3556                       true, pInMsg->hdr.transSeqNum );
??zclProcessInWriteCmd_11:
        ; Setup parameters for call to function zcl_SendWriteRsp
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     ?V0 + 3,A
        MOV     R0,#?V0 + 3
        LCALL   ?PUSH_XSTACK_I_ONE
          CFI CFA_XSP16 add(XSP16, 29)
        MOV     ?V0 + 3,#0x1
        MOV     R0,#?V0 + 3
        LCALL   ?PUSH_XSTACK_I_ONE
          CFI CFA_XSP16 add(XSP16, 30)
        MOV     ?V0 + 3,#0x1
        MOV     R0,#?V0 + 3
        LCALL   ?PUSH_XSTACK_I_ONE
          CFI CFA_XSP16 add(XSP16, 31)
        MOV     R0,#?V0 + 8
        LCALL   ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 33)
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R4,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R5,A
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        MOVX    A,@DPTR
        ADD     A,#0x6
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R3,A
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        XCH     A,R0
        ADD     A,#0x14
        MOV     DPL,A
        MOV     A,R0
        ADDC    A,#0x0
        MOV     DPH,A
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??zcl_SendWriteRsp?relay
        MOV     A,#0x5
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 28)
        MOV     A,R1
// 3557     osal_mem_free( writeRspCmd );
        ; Setup parameters for call to function osal_mem_free
        MOV     R2,?V0 + 8
        MOV     R3,?V0 + 9
        LCALL   ??osal_mem_free?relay
// 3558   }
// 3559 
// 3560   return TRUE;
??zclProcessInWriteCmd_10:
        MOV     R1,#0x1
??zclProcessInWriteCmd_2:
        MOV     A,#0x8
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 20)
        MOV     R7,#0xc
        LJMP    ?BANKED_LEAVE_XDATA
          CFI EndBlock cfiBlock56
// 3561 }
// 3562 
// 3563 /*********************************************************************
// 3564  * @fn      zclRevertWriteUndividedCmd
// 3565  *
// 3566  * @brief   Revert the "Profile" Write Undevided Command
// 3567  *
// 3568  * @param   pInMsg - incoming message to process
// 3569  * @param   curWriteRec - old data
// 3570  * @param   numAttr - number of attributes to be reverted
// 3571  *
// 3572  * @return  none
// 3573  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 3574 static void zclRevertWriteUndividedCmd( zclIncoming_t *pInMsg,
zclRevertWriteUndividedCmd:
          CFI Block cfiBlock57 Using cfiCommon0
          CFI Function zclRevertWriteUndividedCmd
        CODE
// 3575                                     zclWriteRec_t *curWriteRec, uint16 numAttr )
// 3576 {
        FUNCALL zclRevertWriteUndividedCmd, zclFindAttrRec
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 32, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 32, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL zclRevertWriteUndividedCmd, zclGetAttrDataLength
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 30, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 30, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL zclRevertWriteUndividedCmd, osal_memcpy
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 33, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 33, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL zclRevertWriteUndividedCmd, zclWriteAttrDataUsingCB
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 32, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 32, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0x16
        LCALL   ?BANKED_ENTER_XDATA
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V13 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI V12 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V11 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI V10 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI V9 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI V8 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI V7 load(1, XDATA, add(CFA_XSP16, literal(-13)))
          CFI V6 load(1, XDATA, add(CFA_XSP16, literal(-14)))
          CFI V5 load(1, XDATA, add(CFA_XSP16, literal(-15)))
          CFI V4 load(1, XDATA, add(CFA_XSP16, literal(-16)))
          CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-17)))
          CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-18)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-19)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-20)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-21)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-22)))
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 22)
        ; Saved register size: 22
        ; Auto size: 8
        MOV     A,#-0x8
        LCALL   ?ALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 30)
        MOV     ?V0 + 8,R2
        MOV     ?V0 + 9,R3
        MOV     ?V0 + 12,R4
        MOV     ?V0 + 13,R5
        MOV     A,#0x1e
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     ?V0 + 10,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     ?V0 + 11,A
// 3577   for ( uint8 i = 0; i < numAttr; i++ )
        MOV     R6,#0x0
??zclRevertWriteUndividedCmd_0:
        MOV     ?V0 + 0,R6
        MOV     ?V0 + 1,#0x0
        CLR     C
        MOV     A,?V0 + 0
        SUBB    A,?V0 + 10
        MOV     A,?V0 + 1
        SUBB    A,?V0 + 11
        JC      $+5
        LJMP    ??zclRevertWriteUndividedCmd_1 & 0xFFFF
// 3578   {
// 3579     zclAttrRec_t attrRec;
// 3580     zclWriteRec_t *statusRec = &(curWriteRec[i]);
        MOV     A,R6
        MOV     R0,A
        MOV     R1,#0x0
        MOV     A,R0
        MOV     B,#0x5
        MUL     AB
        XCH     A,R0
        MOV     R2,B
        MOV     B,#0x0
        MUL     AB
        ADD     A,R2
        MOV     R2,A
        MOV     B,#0x5
        MOV     A,R1
        MUL     AB
        ADD     A,R2
        MOV     R1,A
        MOV     A,?V0 + 12
        ADD     A,R0
        MOV     ?V0 + 0,A
        MOV     A,?V0 + 13
        ADDC    A,R1
        MOV     ?V0 + 1,A
// 3581 
// 3582     if ( !zclFindAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId,
// 3583                           statusRec->attrID, &attrRec ) )
        ; Setup parameters for call to function zclFindAttrRec
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     ?V0 + 2,DPL
        MOV     ?V0 + 3,DPH
        MOV     R0,#?V0 + 2
        LCALL   ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 32)
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        MOVX    A,@DPTR
        MOV     R4,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R5,A
        MOV     DPL,?V0 + 8
        MOV     DPH,?V0 + 9
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        MOV     DPL,?V0 + 8
        MOV     DPH,?V0 + 9
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        XCH     A,R0
        ADD     A,#0x14
        MOV     DPL,A
        MOV     A,R0
        ADDC    A,#0x0
        MOV     DPH,A
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??zclFindAttrRec?relay
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 30)
        MOV     A,R1
        JNZ     $+5
        LJMP    ??zclRevertWriteUndividedCmd_1 & 0xFFFF
// 3584     {
// 3585       break; // should never happen
// 3586     }
// 3587 
// 3588     if ( attrRec.attr.dataPtr != NULL )
        MOV     A,#0x6
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JZ      ??zclRevertWriteUndividedCmd_2
// 3589     {
// 3590       // Just copy the old data back - no need to validate the data
// 3591       uint16 dataLen = zclGetAttrDataLength( attrRec.attr.dataType, statusRec->attrData );
        ; Setup parameters for call to function zclGetAttrDataLength
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        MOV     A,#0x4
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??zclGetAttrDataLength?relay
        MOV     ?V0 + 4,R2
        MOV     ?V0 + 5,R3
        MOV     ?V0 + 2,?V0 + 4
        MOV     ?V0 + 3,?V0 + 5
// 3592       osal_memcpy( attrRec.attr.dataPtr, statusRec->attrData, dataLen );
        ; Setup parameters for call to function osal_memcpy
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     ?V0 + 4,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     ?V0 + 5,A
        MOV     ?V0 + 6,#0x0
        MOV     R0,#?V0 + 4
        LCALL   ?PUSH_XSTACK_I_THREE
          CFI CFA_XSP16 add(XSP16, 33)
        MOV     R4,?V0 + 2
        MOV     R5,?V0 + 3
        MOV     A,#0x9
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        LCALL   ??osal_memcpy?relay
        MOV     A,#0x3
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 30)
        SJMP    ??zclRevertWriteUndividedCmd_3
// 3593     }
// 3594     else // Use CB
// 3595     {
// 3596       // Write the old data back
// 3597       zclWriteAttrDataUsingCB( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr),
// 3598                                &attrRec, statusRec->attrData );
??zclRevertWriteUndividedCmd_2:
        ; Setup parameters for call to function zclWriteAttrDataUsingCB
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        INC     DPTR
        INC     DPTR
        INC     DPTR
        LCALL   ?PUSH_XSTACK8_X_TWO
          CFI CFA_XSP16 add(XSP16, 32)
        MOV     A,#0x2
        LCALL   ?XSTACK_DISP0_8
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     DPL,?V0 + 8
        MOV     DPH,?V0 + 9
        MOVX    A,@DPTR
        ADD     A,#0x6
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R3,A
        MOV     DPL,?V0 + 8
        MOV     DPH,?V0 + 9
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        XCH     A,R0
        ADD     A,#0x14
        MOV     DPL,A
        MOV     A,R0
        ADDC    A,#0x0
        MOV     DPH,A
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??zclWriteAttrDataUsingCB?relay
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 30)
        MOV     A,R1
// 3599     }
// 3600   } // for loop
??zclRevertWriteUndividedCmd_3:
        INC     R6
        LJMP    ??zclRevertWriteUndividedCmd_0 & 0xFFFF
// 3601 }
??zclRevertWriteUndividedCmd_1:
        MOV     A,#0x8
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 22)
        MOV     R7,#0xe
        LJMP    ?BANKED_LEAVE_XDATA
          CFI EndBlock cfiBlock57
// 3602 
// 3603 /*********************************************************************
// 3604  * @fn      zclProcessInWriteUndividedCmd
// 3605  *
// 3606  * @brief   Process the "Profile" Write Undivided Command
// 3607  *
// 3608  * @param   pInMsg - incoming message to process
// 3609  *
// 3610  * @return  TRUE if command processed. FALSE, otherwise.
// 3611  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 3612 static uint8 zclProcessInWriteUndividedCmd( zclIncoming_t *pInMsg )
zclProcessInWriteUndividedCmd:
          CFI Block cfiBlock58 Using cfiCommon0
          CFI Function zclProcessInWriteUndividedCmd
        CODE
// 3613 {
        FUNCALL zclProcessInWriteUndividedCmd, osal_mem_alloc
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 38, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 38, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL zclProcessInWriteUndividedCmd, zclFindAttrRec
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 40, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 40, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL zclProcessInWriteUndividedCmd, zclGetAttrDataLength
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 38, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 38, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL zclProcessInWriteUndividedCmd, zclGetAttrDataLengthUsingCB
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 38, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 38, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL zclProcessInWriteUndividedCmd, osal_mem_alloc
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 38, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 38, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL zclProcessInWriteUndividedCmd, osal_mem_free
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 38, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 38, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL zclProcessInWriteUndividedCmd, zclFindAttrRec
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 40, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 40, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL zclProcessInWriteUndividedCmd, zclReadAttrData
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 40, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 40, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL zclProcessInWriteUndividedCmd, zclWriteAttrData
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 40, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 40, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL zclProcessInWriteUndividedCmd, zclReadAttrDataUsingCB
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 42, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 42, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL zclProcessInWriteUndividedCmd, zclWriteAttrDataUsingCB
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 40, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 40, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL zclProcessInWriteUndividedCmd, zclRevertWriteUndividedCmd
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 40, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 40, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL zclProcessInWriteUndividedCmd, osal_mem_free
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 38, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 38, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL zclProcessInWriteUndividedCmd, zcl_SendWriteRsp
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 43, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 43, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL zclProcessInWriteUndividedCmd, osal_mem_free
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 38, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 38, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0x18
        LCALL   ?BANKED_ENTER_XDATA
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V15 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI V14 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V13 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI V12 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI V11 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI V10 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI V9 load(1, XDATA, add(CFA_XSP16, literal(-13)))
          CFI V8 load(1, XDATA, add(CFA_XSP16, literal(-14)))
          CFI V7 load(1, XDATA, add(CFA_XSP16, literal(-15)))
          CFI V6 load(1, XDATA, add(CFA_XSP16, literal(-16)))
          CFI V5 load(1, XDATA, add(CFA_XSP16, literal(-17)))
          CFI V4 load(1, XDATA, add(CFA_XSP16, literal(-18)))
          CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-19)))
          CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-20)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-21)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-22)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-23)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-24)))
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 24)
        ; Saved register size: 24
        ; Auto size: 14
        MOV     A,#-0xe
        LCALL   ?ALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 38)
        MOV     ?V0 + 2,R2
        MOV     ?V0 + 3,R3
// 3614   zclWriteCmd_t *writeCmd;
// 3615   zclWriteRspCmd_t *writeRspCmd;
// 3616   zclAttrRec_t attrRec;
// 3617   uint16 dataLen;
// 3618   uint16 curLen = 0;
        MOV     A,#0x4
        LCALL   ?XSTACK_DISP0_8
        MOV     A,#0x0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
// 3619   uint8 j = 0;
        MOV     R6,#0x0
// 3620 
// 3621   writeCmd = (zclWriteCmd_t *)pInMsg->attrCmd;
        MOV     A,?V0 + 2
        ADD     A,#0xc
        MOV     DPL,A
        MOV     A,?V0 + 3
        ADDC    A,#0x0
        MOV     DPH,A
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     ?V0 + 14,R0
        MOV     ?V0 + 15,R1
// 3622 
// 3623   // Allocate space for Write Response Command
// 3624   writeRspCmd = (zclWriteRspCmd_t *)osal_mem_alloc( sizeof( zclWriteRspCmd_t )
// 3625                    + sizeof( zclWriteRspStatus_t )* writeCmd->numAttr );
        ; Setup parameters for call to function osal_mem_alloc
        MOV     DPL,?V0 + 14
        MOV     DPH,?V0 + 15
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     R1,#0x0
        MOV     A,R0
        MOV     B,#0x3
        MUL     AB
        XCH     A,R0
        MOV     R2,B
        MOV     B,#0x0
        MUL     AB
        ADD     A,R2
        MOV     R2,A
        MOV     B,#0x3
        MOV     A,R1
        MUL     AB
        ADD     A,R2
        MOV     R1,A
        MOV     A,R0
        ADD     A,#0x1
        MOV     R2,A
        MOV     A,R1
        ADDC    A,#0x0
        MOV     R3,A
        LCALL   ??osal_mem_alloc?relay
        MOV     ?V0 + 4,R2
        MOV     ?V0 + 5,R3
        MOV     ?V0 + 0,?V0 + 4
        MOV     ?V0 + 1,?V0 + 5
// 3626   if ( writeRspCmd == NULL )
        MOV     A,?V0 + 0
        ORL     A,?V0 + 1
        JNZ     ??zclProcessInWriteUndividedCmd_0
// 3627   {
// 3628     return FALSE; // EMBEDDED RETURN
        MOV     R1,#0x0
        LJMP    ??zclProcessInWriteUndividedCmd_1 & 0xFFFF
// 3629   }
// 3630 
// 3631   // If any attribute cannot be written, no attribute values are changed. Hence,
// 3632   // make sure all the attributes are supported and writable
// 3633   for ( uint8 i = 0; i < writeCmd->numAttr; i++ )
??zclProcessInWriteUndividedCmd_0:
        MOV     R7,#0x0
??zclProcessInWriteUndividedCmd_2:
        MOV     DPL,?V0 + 14
        MOV     DPH,?V0 + 15
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     A,R7
        CLR     C
        SUBB    A,R0
        JC      $+5
        LJMP    ??zclProcessInWriteUndividedCmd_3 & 0xFFFF
// 3634   {
// 3635     zclWriteRec_t *statusRec = &(writeCmd->attrList[i]);
        MOV     A,R7
        MOV     R0,A
        MOV     R1,#0x0
        MOV     A,R0
        MOV     B,#0x5
        MUL     AB
        XCH     A,R0
        MOV     R2,B
        MOV     B,#0x0
        MUL     AB
        ADD     A,R2
        MOV     R2,A
        MOV     B,#0x5
        MOV     A,R1
        MUL     AB
        ADD     A,R2
        MOV     R1,A
        MOV     A,?V0 + 14
        ADD     A,R0
        MOV     DPL,A
        MOV     A,?V0 + 15
        ADDC    A,R1
        MOV     DPH,A
        INC     DPTR
        MOV     ?V0 + 4,DPL
        MOV     ?V0 + 5,DPH
// 3636 
// 3637     if ( !zclFindAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId,
// 3638                           statusRec->attrID, &attrRec ) )
        ; Setup parameters for call to function zclFindAttrRec
        MOV     A,#0x6
        LCALL   ?XSTACK_DISP0_8
        MOV     ?V0 + 6,DPL
        MOV     ?V0 + 7,DPH
        MOV     R0,#?V0 + 6
        LCALL   ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 40)
        MOV     DPL,?V0 + 4
        MOV     DPH,?V0 + 5
        MOVX    A,@DPTR
        MOV     R4,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R5,A
        MOV     DPL,?V0 + 2
        MOV     DPH,?V0 + 3
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        MOV     DPL,?V0 + 2
        MOV     DPH,?V0 + 3
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        XCH     A,R0
        ADD     A,#0x14
        MOV     DPL,A
        MOV     A,R0
        ADDC    A,#0x0
        MOV     DPH,A
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??zclFindAttrRec?relay
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 38)
        MOV     A,R1
        JNZ     ??zclProcessInWriteUndividedCmd_4
// 3639     {
// 3640       // Attribute is not supported - stop here
// 3641       writeRspCmd->attrList[j].status = ZCL_STATUS_UNSUPPORTED_ATTRIBUTE;
        MOV     A,R6
        MOV     R0,A
        MOV     R1,#0x0
        MOV     A,R0
        MOV     B,#0x3
        MUL     AB
        XCH     A,R0
        MOV     R2,B
        MOV     B,#0x0
        MUL     AB
        ADD     A,R2
        MOV     R2,A
        MOV     B,#0x3
        MOV     A,R1
        MUL     AB
        ADD     A,R2
        MOV     R1,A
        MOV     A,?V0 + 0
        ADD     A,R0
        MOV     DPL,A
        MOV     A,?V0 + 1
        ADDC    A,R1
        MOV     DPH,A
        INC     DPTR
        MOV     A,#-0x7a
        MOVX    @DPTR,A
// 3642       writeRspCmd->attrList[j++].attrID = statusRec->attrID;
        MOV     DPL,?V0 + 4
        MOV     DPH,?V0 + 5
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        MOV     A,R6
        MOV     R0,A
        MOV     R1,#0x0
        MOV     A,R0
        MOV     B,#0x3
        MUL     AB
        XCH     A,R0
        MOV     R4,B
        MOV     B,#0x0
        MUL     AB
        ADD     A,R4
        MOV     R4,A
        MOV     B,#0x3
        MOV     A,R1
        MUL     AB
        ADD     A,R4
        MOV     R1,A
        MOV     A,?V0 + 0
        ADD     A,R0
        MOV     DPL,A
        MOV     A,?V0 + 1
        ADDC    A,R1
        MOV     DPH,A
        INC     DPTR
        INC     DPTR
        MOV     A,R2
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R3
        MOVX    @DPTR,A
        INC     R6
// 3643       break;
        LJMP    ??zclProcessInWriteUndividedCmd_3 & 0xFFFF
// 3644     }
// 3645 
// 3646     if ( statusRec->dataType != attrRec.attr.dataType )
??zclProcessInWriteUndividedCmd_4:
        MOV     DPL,?V0 + 4
        MOV     DPH,?V0 + 5
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     A,#0xa
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        XRL     A,R0
        JZ      ??zclProcessInWriteUndividedCmd_5
// 3647     {
// 3648       // Attribute data type is incorrect - stope here
// 3649       writeRspCmd->attrList[j].status = ZCL_STATUS_INVALID_DATA_TYPE;
        MOV     A,R6
        MOV     R0,A
        MOV     R1,#0x0
        MOV     A,R0
        MOV     B,#0x3
        MUL     AB
        XCH     A,R0
        MOV     R2,B
        MOV     B,#0x0
        MUL     AB
        ADD     A,R2
        MOV     R2,A
        MOV     B,#0x3
        MOV     A,R1
        MUL     AB
        ADD     A,R2
        MOV     R1,A
        MOV     A,?V0 + 0
        ADD     A,R0
        MOV     DPL,A
        MOV     A,?V0 + 1
        ADDC    A,R1
        MOV     DPH,A
        INC     DPTR
        MOV     A,#-0x73
        MOVX    @DPTR,A
// 3650       writeRspCmd->attrList[j++].attrID = statusRec->attrID;
        MOV     DPL,?V0 + 4
        MOV     DPH,?V0 + 5
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        MOV     A,R6
        MOV     R0,A
        MOV     R1,#0x0
        MOV     A,R0
        MOV     B,#0x3
        MUL     AB
        XCH     A,R0
        MOV     R4,B
        MOV     B,#0x0
        MUL     AB
        ADD     A,R4
        MOV     R4,A
        MOV     B,#0x3
        MOV     A,R1
        MUL     AB
        ADD     A,R4
        MOV     R1,A
        MOV     A,?V0 + 0
        ADD     A,R0
        MOV     DPL,A
        MOV     A,?V0 + 1
        ADDC    A,R1
        MOV     DPH,A
        INC     DPTR
        INC     DPTR
        MOV     A,R2
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R3
        MOVX    @DPTR,A
        INC     R6
// 3651       break;
        LJMP    ??zclProcessInWriteUndividedCmd_3 & 0xFFFF
// 3652     }
// 3653 
// 3654     if ( !zcl_AccessCtrlWrite( attrRec.attr.accessControl ) )
??zclProcessInWriteUndividedCmd_5:
        MOV     A,#0xb
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     C,0xE0 /* A   */.1
        JC      ??zclProcessInWriteUndividedCmd_6
// 3655     {
// 3656       // Attribute is not writable - stop here
// 3657       writeRspCmd->attrList[j].status = ZCL_STATUS_READ_ONLY;
        MOV     A,R6
        MOV     R0,A
        MOV     R1,#0x0
        MOV     A,R0
        MOV     B,#0x3
        MUL     AB
        XCH     A,R0
        MOV     R2,B
        MOV     B,#0x0
        MUL     AB
        ADD     A,R2
        MOV     R2,A
        MOV     B,#0x3
        MOV     A,R1
        MUL     AB
        ADD     A,R2
        MOV     R1,A
        MOV     A,?V0 + 0
        ADD     A,R0
        MOV     DPL,A
        MOV     A,?V0 + 1
        ADDC    A,R1
        MOV     DPH,A
        INC     DPTR
        MOV     A,#-0x78
        MOVX    @DPTR,A
// 3658       writeRspCmd->attrList[j++].attrID = statusRec->attrID;
        MOV     DPL,?V0 + 4
        MOV     DPH,?V0 + 5
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        MOV     A,R6
        MOV     R0,A
        MOV     R1,#0x0
        MOV     A,R0
        MOV     B,#0x3
        MUL     AB
        XCH     A,R0
        MOV     R4,B
        MOV     B,#0x0
        MUL     AB
        ADD     A,R4
        MOV     R4,A
        MOV     B,#0x3
        MOV     A,R1
        MUL     AB
        ADD     A,R4
        MOV     R1,A
        MOV     A,?V0 + 0
        ADD     A,R0
        MOV     DPL,A
        MOV     A,?V0 + 1
        ADDC    A,R1
        MOV     DPH,A
        INC     DPTR
        INC     DPTR
        MOV     A,R2
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R3
        MOVX    @DPTR,A
        INC     R6
// 3659       break;
        LJMP    ??zclProcessInWriteUndividedCmd_3 & 0xFFFF
// 3660     }
// 3661 
// 3662     if ( zcl_AccessCtrlAuthWrite( attrRec.attr.accessControl ) )
??zclProcessInWriteUndividedCmd_6:
        MOV     A,#0xb
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     C,0xE0 /* A   */.5
        JNC     ??zclProcessInWriteUndividedCmd_7
// 3663     {
// 3664       // Not authorized to write - stop here
// 3665       writeRspCmd->attrList[j].status = ZCL_STATUS_NOT_AUTHORIZED;
        MOV     A,R6
        MOV     R0,A
        MOV     R1,#0x0
        MOV     A,R0
        MOV     B,#0x3
        MUL     AB
        XCH     A,R0
        MOV     R2,B
        MOV     B,#0x0
        MUL     AB
        ADD     A,R2
        MOV     R2,A
        MOV     B,#0x3
        MOV     A,R1
        MUL     AB
        ADD     A,R2
        MOV     R1,A
        MOV     A,?V0 + 0
        ADD     A,R0
        MOV     DPL,A
        MOV     A,?V0 + 1
        ADDC    A,R1
        MOV     DPH,A
        INC     DPTR
        MOV     A,#0x7e
        MOVX    @DPTR,A
// 3666       writeRspCmd->attrList[j++].attrID = statusRec->attrID;
        MOV     DPL,?V0 + 4
        MOV     DPH,?V0 + 5
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        MOV     A,R6
        MOV     R0,A
        MOV     R1,#0x0
        MOV     A,R0
        MOV     B,#0x3
        MUL     AB
        XCH     A,R0
        MOV     R4,B
        MOV     B,#0x0
        MUL     AB
        ADD     A,R4
        MOV     R4,A
        MOV     B,#0x3
        MOV     A,R1
        MUL     AB
        ADD     A,R4
        MOV     R1,A
        MOV     A,?V0 + 0
        ADD     A,R0
        MOV     DPL,A
        MOV     A,?V0 + 1
        ADDC    A,R1
        MOV     DPH,A
        INC     DPTR
        INC     DPTR
        MOV     A,R2
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R3
        MOVX    @DPTR,A
        INC     R6
// 3667       break;
        LJMP    ??zclProcessInWriteUndividedCmd_3 & 0xFFFF
// 3668     }
// 3669 
// 3670     // Attribute Data length
// 3671     if ( attrRec.attr.dataPtr != NULL )
??zclProcessInWriteUndividedCmd_7:
        MOV     A,#0xc
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JZ      ??zclProcessInWriteUndividedCmd_8
// 3672     {
// 3673       dataLen = zclGetAttrDataLength( attrRec.attr.dataType, attrRec.attr.dataPtr );
        ; Setup parameters for call to function zclGetAttrDataLength
        MOV     A,#0xc
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        MOV     A,#0xa
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??zclGetAttrDataLength?relay
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     A,R2
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R3
        MOVX    @DPTR,A
        SJMP    ??zclProcessInWriteUndividedCmd_9
// 3674     }
// 3675     else // Use CB
// 3676     {
// 3677       dataLen = zclGetAttrDataLengthUsingCB( pInMsg->msg->endPoint, pInMsg->msg->clusterId,
// 3678                                              statusRec->attrID );
??zclProcessInWriteUndividedCmd_8:
        ; Setup parameters for call to function zclGetAttrDataLengthUsingCB
        MOV     DPL,?V0 + 4
        MOV     DPH,?V0 + 5
        MOVX    A,@DPTR
        MOV     R4,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R5,A
        MOV     DPL,?V0 + 2
        MOV     DPH,?V0 + 3
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        MOV     DPL,?V0 + 2
        MOV     DPH,?V0 + 3
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        XCH     A,R0
        ADD     A,#0x14
        MOV     DPL,A
        MOV     A,R0
        ADDC    A,#0x0
        MOV     DPH,A
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??zclGetAttrDataLengthUsingCB?relay
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     A,R2
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R3
        MOVX    @DPTR,A
// 3679     }
// 3680 
// 3681     // add padding if needed
// 3682     if ( PADDING_NEEDED( dataLen ) )
??zclProcessInWriteUndividedCmd_9:
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        MOV     C,0xE0 /* A   */.0
        JNC     ??zclProcessInWriteUndividedCmd_10
// 3683     {
// 3684       dataLen++;
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        ADD     A,#0x1
        MOVX    @DPTR,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOVX    @DPTR,A
// 3685     }
// 3686 
// 3687     curLen += dataLen;
??zclProcessInWriteUndividedCmd_10:
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,#0x4
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        ADD     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,R1
        MOVX    @DPTR,A
// 3688   } // for loop
        INC     R7
        LJMP    ??zclProcessInWriteUndividedCmd_2 & 0xFFFF
// 3689 
// 3690   writeRspCmd->numAttr = j;
??zclProcessInWriteUndividedCmd_3:
        MOV     A,R6
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        MOVX    @DPTR,A
// 3691   if ( writeRspCmd->numAttr == 0 ) // All attributes can be written
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        MOVX    A,@DPTR
        JZ      $+5
        LJMP    ??zclProcessInWriteUndividedCmd_11 & 0xFFFF
// 3692   {
// 3693     uint8 *curDataPtr;
// 3694     zclWriteRec_t *curWriteRec;
// 3695 
// 3696     // calculate the length of the current data header
// 3697     uint8 hdrLen = j * sizeof( zclWriteRec_t );
        MOV     B,#0x5
        MOV     A,R6
        MUL     AB
        MOV     ?V0 + 5,A
// 3698 
// 3699     // Allocate space to keep a copy of the current data
// 3700     curWriteRec = (zclWriteRec_t *) osal_mem_alloc( hdrLen + curLen );
        ; Setup parameters for call to function osal_mem_alloc
        MOV     ?V0 + 4,?V0 + 5
        MOV     ?V0 + 8,?V0 + 4
        MOV     ?V0 + 9,#0x0
        MOV     A,#0x4
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        ADD     A,?V0 + 8
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,?V0 + 9
        MOV     R3,A
        LCALL   ??osal_mem_alloc?relay
        MOV     ?V0 + 8,R2
        MOV     ?V0 + 9,R3
        MOV     ?V0 + 12,?V0 + 8
        MOV     ?V0 + 13,?V0 + 9
// 3701     if ( curWriteRec == NULL )
        MOV     A,?V0 + 12
        ORL     A,?V0 + 13
        JNZ     ??zclProcessInWriteUndividedCmd_12
// 3702     {
// 3703       osal_mem_free(writeRspCmd );
        ; Setup parameters for call to function osal_mem_free
        MOV     R2,?V0 + 0
        MOV     R3,?V0 + 1
        LCALL   ??osal_mem_free?relay
// 3704       return FALSE; // EMBEDDED RETURN
        MOV     R1,#0x0
        LJMP    ??zclProcessInWriteUndividedCmd_1 & 0xFFFF
// 3705     }
// 3706 
// 3707     curDataPtr = (uint8 *)((uint8 *)curWriteRec + hdrLen);
??zclProcessInWriteUndividedCmd_12:
        MOV     ?V0 + 4,?V0 + 5
        MOV     ?V0 + 8,?V0 + 4
        MOV     ?V0 + 9,#0x0
        MOV     A,?V0 + 12
        ADD     A,?V0 + 8
        MOV     R0,A
        MOV     A,?V0 + 13
        ADDC    A,?V0 + 9
        MOV     R1,A
        MOV     ?V0 + 6,R0
        MOV     ?V0 + 7,R1
// 3708 
// 3709     // Write the new data over
// 3710     for ( uint8 i = 0; i < writeCmd->numAttr; i++ )
        MOV     R7,#0x0
??zclProcessInWriteUndividedCmd_13:
        MOV     DPL,?V0 + 14
        MOV     DPH,?V0 + 15
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     A,R7
        CLR     C
        SUBB    A,R0
        JC      $+5
        LJMP    ??zclProcessInWriteUndividedCmd_14 & 0xFFFF
// 3711     {
// 3712       uint8 status;
// 3713       zclWriteRec_t *statusRec = &(writeCmd->attrList[i]);
        MOV     A,R7
        MOV     R0,A
        MOV     R1,#0x0
        MOV     A,R0
        MOV     B,#0x5
        MUL     AB
        XCH     A,R0
        MOV     R2,B
        MOV     B,#0x0
        MUL     AB
        ADD     A,R2
        MOV     R2,A
        MOV     B,#0x5
        MOV     A,R1
        MUL     AB
        ADD     A,R2
        MOV     R1,A
        MOV     A,?V0 + 14
        ADD     A,R0
        MOV     DPL,A
        MOV     A,?V0 + 15
        ADDC    A,R1
        MOV     DPH,A
        INC     DPTR
        MOV     ?V0 + 8,DPL
        MOV     ?V0 + 9,DPH
// 3714       zclWriteRec_t *curStatusRec = &(curWriteRec[i]);
        MOV     A,R7
        MOV     R0,A
        MOV     R1,#0x0
        MOV     A,R0
        MOV     B,#0x5
        MUL     AB
        XCH     A,R0
        MOV     R2,B
        MOV     B,#0x0
        MUL     AB
        ADD     A,R2
        MOV     R2,A
        MOV     B,#0x5
        MOV     A,R1
        MUL     AB
        ADD     A,R2
        MOV     R1,A
        MOV     A,?V0 + 12
        ADD     A,R0
        MOV     R0,A
        MOV     A,?V0 + 13
        ADDC    A,R1
        MOV     R1,A
        MOV     A,#0x2
        LCALL   ?XSTACK_DISP0_8
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
// 3715 
// 3716       if ( !zclFindAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId,
// 3717                             statusRec->attrID, &attrRec ) )
        ; Setup parameters for call to function zclFindAttrRec
        MOV     A,#0x6
        LCALL   ?XSTACK_DISP0_8
        MOV     ?V0 + 10,DPL
        MOV     ?V0 + 11,DPH
        MOV     R0,#?V0 + 10
        LCALL   ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 40)
        MOV     DPL,?V0 + 8
        MOV     DPH,?V0 + 9
        MOVX    A,@DPTR
        MOV     R4,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R5,A
        MOV     DPL,?V0 + 2
        MOV     DPH,?V0 + 3
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        MOV     DPL,?V0 + 2
        MOV     DPH,?V0 + 3
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        XCH     A,R0
        ADD     A,#0x14
        MOV     DPL,A
        MOV     A,R0
        ADDC    A,#0x0
        MOV     DPH,A
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??zclFindAttrRec?relay
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 38)
        MOV     A,R1
        JNZ     $+5
        LJMP    ??zclProcessInWriteUndividedCmd_14 & 0xFFFF
// 3718       {
// 3719         break; // should never happen
// 3720       }
// 3721 
// 3722       // Keep a copy of the current data before before writing the new data over
// 3723       curStatusRec->attrID = statusRec->attrID;
        MOV     DPL,?V0 + 8
        MOV     DPH,?V0 + 9
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        MOV     A,#0x2
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOV     A,R2
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R3
        MOVX    @DPTR,A
// 3724       curStatusRec->attrData = curDataPtr;
        MOV     A,#0x2
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOV     A,?V0 + 6
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,?V0 + 7
        MOVX    @DPTR,A
// 3725 
// 3726       if ( attrRec.attr.dataPtr != NULL )
        MOV     A,#0xc
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JZ      ??zclProcessInWriteUndividedCmd_15
// 3727       {
// 3728         // Read the current value
// 3729         zclReadAttrData( curDataPtr, &attrRec, &dataLen );
        ; Setup parameters for call to function zclReadAttrData
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     ?V0 + 10,DPL
        MOV     ?V0 + 11,DPH
        MOV     R0,#?V0 + 10
        LCALL   ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 40)
        MOV     A,#0x8
        LCALL   ?XSTACK_DISP0_8
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R2,?V0 + 6
        MOV     R3,?V0 + 7
        LCALL   ??zclReadAttrData?relay
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 38)
        MOV     A,R1
// 3730 
// 3731         // Write the new attribute value
// 3732         status = zclWriteAttrData( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr),
// 3733                                    &attrRec, statusRec );
        ; Setup parameters for call to function zclWriteAttrData
        MOV     R0,#?V0 + 8
        LCALL   ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 40)
        MOV     A,#0x8
        LCALL   ?XSTACK_DISP0_8
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     DPL,?V0 + 2
        MOV     DPH,?V0 + 3
        MOVX    A,@DPTR
        ADD     A,#0x6
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R3,A
        MOV     DPL,?V0 + 2
        MOV     DPH,?V0 + 3
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        XCH     A,R0
        ADD     A,#0x14
        MOV     DPL,A
        MOV     A,R0
        ADDC    A,#0x0
        MOV     DPH,A
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??zclWriteAttrData?relay
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 38)
        MOV     A,R1
        MOV     ?V0 + 4,A
        LJMP    ??zclProcessInWriteUndividedCmd_16 & 0xFFFF
// 3734       }
// 3735       else // Use CBs
// 3736       {
// 3737         // Read the current value
// 3738         zclReadAttrDataUsingCB( pInMsg->msg->endPoint, pInMsg->msg->clusterId,
// 3739                                 statusRec->attrID, curDataPtr, &dataLen );
??zclProcessInWriteUndividedCmd_15:
        ; Setup parameters for call to function zclReadAttrDataUsingCB
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     ?V0 + 10,DPL
        MOV     ?V0 + 11,DPH
        MOV     R0,#?V0 + 10
        LCALL   ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 40)
        MOV     R0,#?V0 + 6
        LCALL   ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 42)
        MOV     DPL,?V0 + 8
        MOV     DPH,?V0 + 9
        MOVX    A,@DPTR
        MOV     R4,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R5,A
        MOV     DPL,?V0 + 2
        MOV     DPH,?V0 + 3
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        MOV     DPL,?V0 + 2
        MOV     DPH,?V0 + 3
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        XCH     A,R0
        ADD     A,#0x14
        MOV     DPL,A
        MOV     A,R0
        ADDC    A,#0x0
        MOV     DPH,A
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??zclReadAttrDataUsingCB?relay
        MOV     A,#0x4
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 38)
        MOV     A,R1
// 3740         // Write the new attribute value
// 3741         status = zclWriteAttrDataUsingCB( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr),
// 3742                                           &attrRec, statusRec->attrData );
        ; Setup parameters for call to function zclWriteAttrDataUsingCB
        MOV     DPL,?V0 + 8
        MOV     DPH,?V0 + 9
        INC     DPTR
        INC     DPTR
        INC     DPTR
        LCALL   ?PUSH_XSTACK8_X_TWO
          CFI CFA_XSP16 add(XSP16, 40)
        MOV     A,#0x8
        LCALL   ?XSTACK_DISP0_8
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     DPL,?V0 + 2
        MOV     DPH,?V0 + 3
        MOVX    A,@DPTR
        ADD     A,#0x6
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R3,A
        MOV     DPL,?V0 + 2
        MOV     DPH,?V0 + 3
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        XCH     A,R0
        ADD     A,#0x14
        MOV     DPL,A
        MOV     A,R0
        ADDC    A,#0x0
        MOV     DPH,A
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??zclWriteAttrDataUsingCB?relay
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 38)
        MOV     A,R1
        MOV     ?V0 + 4,A
// 3743       }
// 3744 
// 3745       // If successful, a write attribute status record shall NOT be generated
// 3746       if ( status != ZCL_STATUS_SUCCESS )
??zclProcessInWriteUndividedCmd_16:
        MOV     A,?V0 + 4
        JZ      ??zclProcessInWriteUndividedCmd_17
// 3747       {
// 3748         writeRspCmd->attrList[j].status = status;
        MOV     A,?V0 + 4
        MOV     A,R6
        MOV     R0,A
        MOV     R1,#0x0
        MOV     A,R0
        MOV     B,#0x3
        MUL     AB
        XCH     A,R0
        MOV     R2,B
        MOV     B,#0x0
        MUL     AB
        ADD     A,R2
        MOV     R2,A
        MOV     B,#0x3
        MOV     A,R1
        MUL     AB
        ADD     A,R2
        MOV     R1,A
        MOV     A,?V0 + 0
        ADD     A,R0
        MOV     DPL,A
        MOV     A,?V0 + 1
        ADDC    A,R1
        MOV     DPH,A
        INC     DPTR
        MOV     A,?V0 + 4
        MOVX    @DPTR,A
// 3749         writeRspCmd->attrList[j++].attrID = statusRec->attrID;
        MOV     DPL,?V0 + 8
        MOV     DPH,?V0 + 9
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        MOV     A,R6
        MOV     R0,A
        MOV     R1,#0x0
        MOV     A,R0
        MOV     B,#0x3
        MUL     AB
        XCH     A,R0
        MOV     R4,B
        MOV     B,#0x0
        MUL     AB
        ADD     A,R4
        MOV     R4,A
        MOV     B,#0x3
        MOV     A,R1
        MUL     AB
        ADD     A,R4
        MOV     R1,A
        MOV     A,?V0 + 0
        ADD     A,R0
        MOV     DPL,A
        MOV     A,?V0 + 1
        ADDC    A,R1
        MOV     DPH,A
        INC     DPTR
        INC     DPTR
        MOV     A,R2
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R3
        MOVX    @DPTR,A
        INC     R6
// 3750 
// 3751         // Since this write failed, we need to revert all the pervious writes
// 3752         zclRevertWriteUndividedCmd( pInMsg, curWriteRec, i);
        ; Setup parameters for call to function zclRevertWriteUndividedCmd
        MOV     ?V0 + 10,R7
        MOV     ?V0 + 11,#0x0
        MOV     R0,#?V0 + 10
        LCALL   ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 40)
        MOV     R4,?V0 + 12
        MOV     R5,?V0 + 13
        MOV     R2,?V0 + 2
        MOV     R3,?V0 + 3
        LCALL   ??zclRevertWriteUndividedCmd?relay
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 38)
// 3753         break;
        SJMP    ??zclProcessInWriteUndividedCmd_14
// 3754       }
// 3755 
// 3756       // add padding if needed
// 3757       if ( PADDING_NEEDED( dataLen ) )
??zclProcessInWriteUndividedCmd_17:
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        MOV     C,0xE0 /* A   */.0
        JNC     ??zclProcessInWriteUndividedCmd_18
// 3758       {
// 3759         dataLen++;
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        ADD     A,#0x1
        MOVX    @DPTR,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOVX    @DPTR,A
// 3760       }
// 3761 
// 3762       curDataPtr += dataLen;
??zclProcessInWriteUndividedCmd_18:
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,?V0 + 6
        ADD     A,R0
        MOV     ?V0 + 6,A
        MOV     A,?V0 + 7
        ADDC    A,R1
        MOV     ?V0 + 7,A
// 3763     } // for loop
        INC     R7
        LJMP    ??zclProcessInWriteUndividedCmd_13 & 0xFFFF
// 3764 
// 3765     writeRspCmd->numAttr = j;
??zclProcessInWriteUndividedCmd_14:
        MOV     A,R6
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        MOVX    @DPTR,A
// 3766     if ( writeRspCmd->numAttr  == 0 )
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        MOVX    A,@DPTR
        JNZ     ??zclProcessInWriteUndividedCmd_19
// 3767     {
// 3768       // Since all records were written successful, include a single status record
// 3769       // in the resonse command with the status field set to SUCCESS and the
// 3770       // attribute ID field omitted.
// 3771       writeRspCmd->attrList[0].status = ZCL_STATUS_SUCCESS;
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
// 3772       writeRspCmd->numAttr = 1;
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        MOV     A,#0x1
        MOVX    @DPTR,A
// 3773     }
// 3774 
// 3775     osal_mem_free( curWriteRec );
??zclProcessInWriteUndividedCmd_19:
        ; Setup parameters for call to function osal_mem_free
        MOV     R2,?V0 + 12
        MOV     R3,?V0 + 13
        LCALL   ??osal_mem_free?relay
// 3776   }
// 3777 
// 3778   zcl_SendWriteRsp( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr),
// 3779                     pInMsg->msg->clusterId, writeRspCmd, ZCL_FRAME_SERVER_CLIENT_DIR,
// 3780                     true, pInMsg->hdr.transSeqNum );
??zclProcessInWriteUndividedCmd_11:
        ; Setup parameters for call to function zcl_SendWriteRsp
        MOV     DPL,?V0 + 2
        MOV     DPH,?V0 + 3
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     ?V0 + 4,A
        MOV     R0,#?V0 + 4
        LCALL   ?PUSH_XSTACK_I_ONE
          CFI CFA_XSP16 add(XSP16, 39)
        MOV     ?V0 + 4,#0x1
        MOV     R0,#?V0 + 4
        LCALL   ?PUSH_XSTACK_I_ONE
          CFI CFA_XSP16 add(XSP16, 40)
        MOV     ?V0 + 4,#0x1
        MOV     R0,#?V0 + 4
        LCALL   ?PUSH_XSTACK_I_ONE
          CFI CFA_XSP16 add(XSP16, 41)
        MOV     R0,#?V0 + 0
        LCALL   ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 43)
        MOV     DPL,?V0 + 2
        MOV     DPH,?V0 + 3
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R4,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R5,A
        MOV     DPL,?V0 + 2
        MOV     DPH,?V0 + 3
        MOVX    A,@DPTR
        ADD     A,#0x6
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R3,A
        MOV     DPL,?V0 + 2
        MOV     DPH,?V0 + 3
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        XCH     A,R0
        ADD     A,#0x14
        MOV     DPL,A
        MOV     A,R0
        ADDC    A,#0x0
        MOV     DPH,A
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??zcl_SendWriteRsp?relay
        MOV     A,#0x5
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 38)
        MOV     A,R1
// 3781   osal_mem_free( writeRspCmd );
        ; Setup parameters for call to function osal_mem_free
        MOV     R2,?V0 + 0
        MOV     R3,?V0 + 1
        LCALL   ??osal_mem_free?relay
// 3782 
// 3783   return TRUE;
        MOV     R1,#0x1
??zclProcessInWriteUndividedCmd_1:
        MOV     A,#0xe
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 24)
        MOV     R7,#0x10
        LJMP    ?BANKED_LEAVE_XDATA
          CFI EndBlock cfiBlock58
// 3784 }
// 3785 #endif // ZCL_WRITE
// 3786 
// 3787 #ifdef ZCL_DISCOVER
// 3788 /*********************************************************************
// 3789  * @fn      zclProcessInDiscCmd
// 3790  *
// 3791  * @brief   Process the "Profile" Discover Command
// 3792  *
// 3793  * @param   pInMsg - incoming message to process
// 3794  *
// 3795  * @return  TRUE if command processed. FALSE, otherwise.
// 3796  */
// 3797 static uint8 zclProcessInDiscCmd( zclIncoming_t *pInMsg )
// 3798 {
// 3799   zclDiscoverCmd_t *discoverCmd;
// 3800   zclDiscoverRspCmd_t *discoverRspCmd;
// 3801   uint8 discComplete = TRUE;
// 3802   zclAttrRec_t attrRec;
// 3803   uint16 attrID;
// 3804   uint8 i;
// 3805 
// 3806   discoverCmd = (zclDiscoverCmd_t *)pInMsg->attrCmd;
// 3807 
// 3808   // Find out the number of attributes supported within the specified range
// 3809   for ( i = 0, attrID = discoverCmd->startAttr; i < discoverCmd->maxAttrIDs; i++, attrID++ )
// 3810   {
// 3811     if ( !zclFindNextAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, &attrID, &attrRec ) )
// 3812     {
// 3813       break;
// 3814     }
// 3815   }
// 3816 
// 3817   // Allocate space for the response command
// 3818   discoverRspCmd = (zclDiscoverRspCmd_t *)osal_mem_alloc( sizeof (zclDiscoverRspCmd_t)
// 3819                                                          + sizeof ( zclDiscoverInfo_t ) * i );
// 3820   if ( discoverRspCmd == NULL )
// 3821   {
// 3822     return FALSE; // EMEDDED RETURN
// 3823   }
// 3824 
// 3825   discoverRspCmd->numAttr = i;
// 3826   if ( discoverRspCmd->numAttr != 0 )
// 3827   {
// 3828     for ( i = 0, attrID = discoverCmd->startAttr; i < discoverRspCmd->numAttr; i++, attrID++ )
// 3829     {
// 3830       if ( !zclFindNextAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, &attrID, &attrRec ) )
// 3831       {
// 3832         break; // Attribute not supported
// 3833       }
// 3834 
// 3835       discoverRspCmd->attrList[i].attrID = attrRec.attr.attrId;
// 3836       discoverRspCmd->attrList[i].dataType = attrRec.attr.dataType;
// 3837     }
// 3838 
// 3839     // Are there more attributes to be discovered?
// 3840     if ( zclFindNextAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, &attrID, &attrRec ) )
// 3841     {
// 3842       discComplete = FALSE;
// 3843     }
// 3844   }
// 3845 
// 3846   discoverRspCmd->discComplete = discComplete;
// 3847   zcl_SendDiscoverRspCmd( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
// 3848                           pInMsg->msg->clusterId, discoverRspCmd, ZCL_FRAME_SERVER_CLIENT_DIR,
// 3849                           true, pInMsg->hdr.transSeqNum );
// 3850   osal_mem_free( discoverRspCmd );
// 3851 
// 3852   return TRUE;
// 3853 }
// 3854 #endif // ZCL_DISCOVER
// 3855 
// 3856 /*********************************************************************
// 3857  * @fn      zclSendMsg
// 3858  *
// 3859  * @brief   Send an incoming message to the Application
// 3860  *
// 3861  * @param   pInMsg - incoming message to process
// 3862  *
// 3863  * @return  TRUE
// 3864  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 3865 static uint8 zclSendMsg( zclIncoming_t *pInMsg )
zclSendMsg:
          CFI Block cfiBlock59 Using cfiCommon0
          CFI Function zclSendMsg
        CODE
// 3866 {
        FUNCALL zclSendMsg, osal_msg_allocate
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 12, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 12, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL zclSendMsg, osal_msg_send
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 12, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 12, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0xc
        LCALL   ?BANKED_ENTER_XDATA
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 12)
        ; Saved register size: 12
        ; Auto size: 0
        MOV     ?V0 + 0,R2
        MOV     ?V0 + 1,R3
// 3867   zclIncomingMsg_t *pCmd;
// 3868 
// 3869   if ( zcl_RegisteredMsgTaskID == TASK_NO_TASK )
        MOV     DPTR,#zcl_RegisteredMsgTaskID
        MOVX    A,@DPTR
        XRL     A,#0xff
        JNZ     ??zclSendMsg_0
// 3870   {
// 3871     return ( TRUE );
        MOV     R1,#0x1
        LJMP    ??zclSendMsg_1 & 0xFFFF
// 3872   }
// 3873 
// 3874   pCmd = (zclIncomingMsg_t *)osal_msg_allocate( sizeof ( zclIncomingMsg_t ) );
??zclSendMsg_0:
        ; Setup parameters for call to function osal_msg_allocate
        MOV     R2,#0x19
        MOV     R3,#0x0
        LCALL   ??osal_msg_allocate?relay
        MOV     ?V0 + 2,R2
        MOV     ?V0 + 3,R3
        MOV     R6,?V0 + 2
        MOV     R7,?V0 + 3
// 3875   if ( pCmd != NULL )
        MOV     A,R6
        ORL     A,R7
        JNZ     $+5
        LJMP    ??zclSendMsg_2 & 0xFFFF
// 3876   {
// 3877     // fill in the message
// 3878     pCmd->hdr.event = ZCL_INCOMING_MSG;
        MOV     DPL,R6
        MOV     DPH,R7
        MOV     A,#0x34
        MOVX    @DPTR,A
// 3879     pCmd->zclHdr    = pInMsg->hdr;
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        INC     DPTR
        INC     DPTR
        MOV     A,R6
        ADD     A,#0x2
        MOV     R4,A
        MOV     A,R7
        ADDC    A,#0x0
        MOV     R5,A
        MOV     A,#0x6
        LCALL   ?MOVE_LONG8_XDATA_XDATA
// 3880     pCmd->clusterId = pInMsg->msg->clusterId;
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
// 3881     pCmd->srcAddr   = pInMsg->msg->srcAddr;
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        XCH     A,R0
        ADD     A,#0x6
        MOV     DPL,A
        MOV     A,R0
        ADDC    A,#0x0
        MOV     DPH,A
        MOV     A,R6
        ADD     A,#0xa
        MOV     R4,A
        MOV     A,R7
        ADDC    A,#0x0
        MOV     R5,A
        MOV     A,#0xc
        LCALL   ?MOVE_LONG8_XDATA_XDATA
// 3882     pCmd->endPoint  = pInMsg->msg->endPoint;
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        XCH     A,R0
        ADD     A,#0x14
        MOV     DPL,A
        MOV     A,R0
        ADDC    A,#0x0
        MOV     DPH,A
        MOVX    A,@DPTR
        PUSH    A
          CFI CFA_SP SP+-1
        MOV     A,R6
        ADD     A,#0x16
        MOV     DPL,A
        MOV     A,R7
        ADDC    A,#0x0
        MOV     DPH,A
        POP     A
          CFI CFA_SP SP+0
        MOVX    @DPTR,A
// 3883     pCmd->attrCmd   = pInMsg->attrCmd;
        MOV     A,?V0 + 0
        ADD     A,#0xc
        MOV     DPL,A
        MOV     A,?V0 + 1
        ADDC    A,#0x0
        MOV     DPH,A
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R6
        ADD     A,#0x17
        MOV     DPL,A
        MOV     A,R7
        ADDC    A,#0x0
        MOV     DPH,A
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
// 3884 
// 3885     // Application will free the attrCmd buffer
// 3886     pInMsg->attrCmd = NULL;
        MOV     A,?V0 + 0
        ADD     A,#0xc
        MOV     DPL,A
        MOV     A,?V0 + 1
        ADDC    A,#0x0
        MOV     DPH,A
        MOV     A,#0x0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
// 3887 
// 3888     /* send message through task message */
// 3889     osal_msg_send( zcl_RegisteredMsgTaskID, (uint8 *)pCmd );
        ; Setup parameters for call to function osal_msg_send
        MOV     A,R6
        MOV     R2,A
        MOV     A,R7
        MOV     R3,A
        MOV     DPTR,#zcl_RegisteredMsgTaskID
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??osal_msg_send?relay
        MOV     A,R1
// 3890   }
// 3891 
// 3892   return ( TRUE );
??zclSendMsg_2:
        MOV     R1,#0x1
??zclSendMsg_1:
        MOV     R7,#0x4
        LJMP    ?BANKED_LEAVE_XDATA
          CFI EndBlock cfiBlock59
// 3893 }

        RSEG XDATA_ID:CODE:NOROOT(0)
`?<Initializer for zcl_RegisteredMsgTaskID>`:
        DATA8
        DB 255

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??zcl_Init?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    zcl_Init

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??zcl_event_loop?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    zcl_event_loop

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??zcl_getRawAFMsg?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    zcl_getRawAFMsg

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??zcl_registerPlugin?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    zcl_registerPlugin

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??zcl_registerAttrList?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    zcl_registerAttrList

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??zcl_registerClusterOptionList?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    zcl_registerClusterOptionList

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??zcl_registerValidateAttrData?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    zcl_registerValidateAttrData

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??zcl_registerReadWriteCB?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    zcl_registerReadWriteCB

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??zcl_registerForMsg?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    zcl_registerForMsg

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??zcl_DeviceOperational?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    zcl_DeviceOperational

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??zcl_SendCommand?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    zcl_SendCommand

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??zcl_SendRead?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    zcl_SendRead

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??zcl_SendReadRsp?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    zcl_SendReadRsp

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??zcl_SendWriteRequest?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    zcl_SendWriteRequest

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??zcl_SendWriteRsp?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    zcl_SendWriteRsp

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??zcl_SendConfigReportCmd?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    zcl_SendConfigReportCmd

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??zcl_SendConfigReportRspCmd?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    zcl_SendConfigReportRspCmd

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??zcl_SendReadReportCfgCmd?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    zcl_SendReadReportCfgCmd

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??zcl_SendReadReportCfgRspCmd?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    zcl_SendReadReportCfgRspCmd

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??zcl_SendReportCmd?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    zcl_SendReportCmd

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??zcl_SendDefaultRspCmd?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    zcl_SendDefaultRspCmd

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??zclProcessMessageMSG?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    zclProcessMessageMSG

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??zclParseHdr?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    zclParseHdr

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??zclBuildHdr?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    zclBuildHdr

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??zclCalcHdrSize?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    zclCalcHdrSize

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??zclFindPlugin?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    zclFindPlugin

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??zclFindAttrRecsList?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    zclFindAttrRecsList

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??zclFindAttrRec?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    zclFindAttrRec

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??zclGetReadWriteCB?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    zclGetReadWriteCB

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??zclGetAuthorizeCB?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    zclGetAuthorizeCB

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??zclFindClusterOption?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    zclFindClusterOption

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??zclGetClusterOption?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    zclGetClusterOption

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??zclSetSecurityOption?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    zclSetSecurityOption

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??zclSerializeData?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    zclSerializeData

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??zclAnalogDataType?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    zclAnalogDataType

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??zcl_BuildAnalogData?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    zcl_BuildAnalogData

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??zclGetDataTypeLength?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    zclGetDataTypeLength

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??zclGetAttrDataLength?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    zclGetAttrDataLength

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??zclReadAttrData?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    zclReadAttrData

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??zclGetAttrDataLengthUsingCB?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    zclGetAttrDataLengthUsingCB

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??zclReadAttrDataUsingCB?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    zclReadAttrDataUsingCB

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??zclAuthorizeRead?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    zclAuthorizeRead

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??zclWriteAttrData?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    zclWriteAttrData

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??zclWriteAttrDataUsingCB?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    zclWriteAttrDataUsingCB

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??zclAuthorizeWrite?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    zclAuthorizeWrite

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??zclParseInReadCmd?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    zclParseInReadCmd

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??zclParseInReadRspCmd?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    zclParseInReadRspCmd

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??zclParseInWriteCmd?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    zclParseInWriteCmd

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??zclParseInWriteRspCmd?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    zclParseInWriteRspCmd

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??zclParseInConfigReportCmd?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    zclParseInConfigReportCmd

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??zclParseInConfigReportRspCmd?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    zclParseInConfigReportRspCmd

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??zclParseInReadReportCfgCmd?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    zclParseInReadReportCfgCmd

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??zclParseInReadReportCfgRspCmd?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    zclParseInReadReportCfgRspCmd

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??zclParseInReportCmd?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    zclParseInReportCmd

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??zclParseInDefaultRspCmd?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    zclParseInDefaultRspCmd

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??zclProcessInReadCmd?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    zclProcessInReadCmd

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??zclProcessInWriteCmd?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    zclProcessInWriteCmd

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??zclRevertWriteUndividedCmd?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    zclRevertWriteUndividedCmd

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??zclProcessInWriteUndividedCmd?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    zclProcessInWriteUndividedCmd

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??zclSendMsg?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    zclSendMsg

        END
// 3894 
// 3895 /*********************************************************************
// 3896 *********************************************************************/
// 
// 21 149 bytes in segment BANKED_CODE
//    360 bytes in segment BANK_RELAYS
//     56 bytes in segment CODE_C
//      1 byte  in segment XDATA_I
//      1 byte  in segment XDATA_ID
//     13 bytes in segment XDATA_Z
// 
// 21 566 bytes of CODE  memory
//     14 bytes of XDATA memory
//
//Errors: none
//Warnings: none

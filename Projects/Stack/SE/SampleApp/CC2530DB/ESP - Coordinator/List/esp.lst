###############################################################################
#                                                                             #
# IAR C/C++ Compiler V8.20.2.41139 for 8051             13/Jun/2013  13:50:22 #
# Copyright 2004-2013 IAR Systems AB.                                         #
#                                                                             #
#    Core               =  plain                                              #
#    Code model         =  banked                                             #
#    Data model         =  large                                              #
#    Calling convention =  xdata reentrant                                    #
#    Constant location  =  data_rom                                           #
#    Dptr setup         =  1,16                                               #
#                                                                             #
#    Source file        =  C:\Users\PedroZ\Documents\GitHub\TG\Projects\Stack #
#                          \SE\SampleApp\Source\ESP\esp.c                     #
#    Command line       =  -f C:\Users\PedroZ\Documents\GitHub\TG\Projects\St #
#                          ack\SE\SampleApp\CC2530DB\..\..\..\Tools\CC2530DB\ #
#                          f8wCoord.cfg (-DCPU32MHZ -DROOT=__near_func        #
#                          -DMAC_CFG_APP_PENDING_QUEUE=TRUE                   #
#                          -DMAC_CFG_TX_DATA_MAX=5 -DMAC_CFG_TX_MAX=8         #
#                          -DMAC_CFG_RX_MAX=5 -DZDO_COORDINATOR -DRTR_NWK)    #
#                          -f C:\Users\PedroZ\Documents\GitHub\TG\Projects\St #
#                          ack\SE\SampleApp\CC2530DB\..\..\..\Tools\CC2530DB\ #
#                          f8wConfig.cfg (-DZIGBEEPRO -DSECURE=0              #
#                          -DZG_SECURE_DYNAMIC=0 -DREFLECTOR                  #
#                          -DDEFAULT_CHANLIST=0x00000800                      #
#                          -DZDAPP_CONFIG_PAN_ID=0xFFFF                       #
#                          -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MA #
#                          SK=0x007F -DBEACON_REQUEST_DELAY=100               #
#                          -DBEACON_REQ_DELAY_MASK=0x00FF                     #
#                          -DLINK_STATUS_JITTER_MASK=0x007F                   #
#                          -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_PO #
#                          LLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7             #
#                          -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3    #
#                          -DNWK_MAX_DATA_RETRIES=2                           #
#                          -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9         #
#                          -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40           #
#                          -DNWK_MAX_BINDING_ENTRIES=4                        #
#                          -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01,  #
#                          0x03, 0x05, 0x07, 0x09, 0x0B, 0x0D, 0x0F, 0x00,    #
#                          0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C, 0x0D}"         #
#                          -DMAC_MAX_FRAME_SIZE=116                           #
#                          -DZDNWKMGR_MIN_TRANSMISSIONS=20 "-DCONST=const     #
#                          __code" -DGENERIC=__generic                        #
#                          -DRFD_RCVC_ALWAYS_ON=FALSE -DPOLL_RATE=1000        #
#                          -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100    #
#                          -DREJOIN_POLL_RATE=440) -f                         #
#                          C:\Users\PedroZ\Documents\GitHub\TG\Projects\Stack #
#                          \SE\SampleApp\CC2530DB\..\..\..\Tools\CC2530DB\f8w #
#                          ZCL.cfg (-DZCL_READ -DZCL_WRITE -DZCL_BASIC        #
#                          -DZCL_IDENTIFY -DZCL_ON_OFF -DZCL_KEY_ESTABLISH    #
#                          -DZCL_KEY_ESTABLISHMENT_KEY_GENERATE_TIMEOUT=4     #
#                          -DZCL_KEY_ESTABLISHMENT_MAC_GENERATE_TIMEOUT=10    #
#                          -DZCL_KEY_ESTABLISHMENT_EKEY_GENERATE_TIMEOUT=10   #
#                          -DZCL_LOAD_CONTROL -DZCL_SIMPLE_METERING           #
#                          -DZCL_PRICING -DZCL_MESSAGE -DZCL_TUNNELING        #
#                          -DZCL_TOU) -DZCL_DEVICE_MGMT                       #
#                          C:\Users\PedroZ\Documents\GitHub\TG\Projects\Stack #
#                          \SE\SampleApp\Source\ESP\esp.c -D TC_LINKKEY_JOIN  #
#                          -D ZTOOL_P1 -D MT_TASK -D MT_APP_FUNC -D           #
#                          MT_SYS_FUNC -D LCD_SUPPORTED -D INT_HEAP_LEN=2450  #
#                          -D NV_INIT -D xNV_RESTORE -D ZCL_REPORT -D         #
#                          INTER_PAN -D ZDSECMGR_TC_DEVICE_MAX=16 -D          #
#                          TEST_CERT_DATA -lC "C:\Users\PedroZ\Documents\GitH #
#                          ub\TG\Projects\Stack\SE\SampleApp\CC2530DB\ESP -   #
#                          Coordinator\List\" -lA "C:\Users\PedroZ\Documents\ #
#                          GitHub\TG\Projects\Stack\SE\SampleApp\CC2530DB\ESP #
#                           - Coordinator\List\" --diag_suppress Pe001,Pa010  #
#                          -o "C:\Users\PedroZ\Documents\GitHub\TG\Projects\S #
#                          tack\SE\SampleApp\CC2530DB\ESP -                   #
#                          Coordinator\Obj\" -e --no_cse --no_unroll          #
#                          --no_inline --no_code_motion --no_tbaa --debug     #
#                          --core=plain --dptr=16,1 --data_model=large        #
#                          --code_model=banked --calling_convention=xdata_ree #
#                          ntrant --place_constants=data_rom                  #
#                          --nr_virtual_regs 16 -I C:\Users\PedroZ\Documents\ #
#                          GitHub\TG\Projects\Stack\SE\SampleApp\CC2530DB\    #
#                          -I C:\Users\PedroZ\Documents\GitHub\TG\Projects\St #
#                          ack\SE\SampleApp\CC2530DB\..\Source\ -I            #
#                          C:\Users\PedroZ\Documents\GitHub\TG\Projects\Stack #
#                          \SE\SampleApp\CC2530DB\..\..\Source\ -I            #
#                          C:\Users\PedroZ\Documents\GitHub\TG\Projects\Stack #
#                          \SE\SampleApp\CC2530DB\..\..\..\ZMain\TI2530DB\    #
#                          -I C:\Users\PedroZ\Documents\GitHub\TG\Projects\St #
#                          ack\SE\SampleApp\CC2530DB\..\..\..\..\..\Component #
#                          s\hal\include\ -I C:\Users\PedroZ\Documents\GitHub #
#                          \TG\Projects\Stack\SE\SampleApp\CC2530DB\..\..\..\ #
#                          ..\..\Components\hal\target\CC2530EB\ -I           #
#                          C:\Users\PedroZ\Documents\GitHub\TG\Projects\Stack #
#                          \SE\SampleApp\CC2530DB\..\..\..\..\..\Components\m #
#                          ac\include\ -I C:\Users\PedroZ\Documents\GitHub\TG #
#                          \Projects\Stack\SE\SampleApp\CC2530DB\..\..\..\..\ #
#                          ..\Components\mac\high_level\ -I                   #
#                          C:\Users\PedroZ\Documents\GitHub\TG\Projects\Stack #
#                          \SE\SampleApp\CC2530DB\..\..\..\..\..\Components\m #
#                          ac\low_level\srf04\ -I C:\Users\PedroZ\Documents\G #
#                          itHub\TG\Projects\Stack\SE\SampleApp\CC2530DB\..\. #
#                          .\..\..\..\Components\mac\low_level\srf04\single_c #
#                          hip\ -I C:\Users\PedroZ\Documents\GitHub\TG\Projec #
#                          ts\Stack\SE\SampleApp\CC2530DB\..\..\..\..\..\Comp #
#                          onents\mt\ -I C:\Users\PedroZ\Documents\GitHub\TG\ #
#                          Projects\Stack\SE\SampleApp\CC2530DB\..\..\..\..\. #
#                          .\Components\osal\include\ -I                      #
#                          C:\Users\PedroZ\Documents\GitHub\TG\Projects\Stack #
#                          \SE\SampleApp\CC2530DB\..\..\..\..\..\Components\s #
#                          ervices\saddr\ -I C:\Users\PedroZ\Documents\GitHub #
#                          \TG\Projects\Stack\SE\SampleApp\CC2530DB\..\..\..\ #
#                          ..\..\Components\services\sdata\ -I                #
#                          C:\Users\PedroZ\Documents\GitHub\TG\Projects\Stack #
#                          \SE\SampleApp\CC2530DB\..\..\..\..\..\Components\s #
#                          tack\af\ -I C:\Users\PedroZ\Documents\GitHub\TG\Pr #
#                          ojects\Stack\SE\SampleApp\CC2530DB\..\..\..\..\..\ #
#                          Components\stack\nwk\ -I                           #
#                          C:\Users\PedroZ\Documents\GitHub\TG\Projects\Stack #
#                          \SE\SampleApp\CC2530DB\..\..\..\..\..\Components\s #
#                          tack\sapi\ -I C:\Users\PedroZ\Documents\GitHub\TG\ #
#                          Projects\Stack\SE\SampleApp\CC2530DB\..\..\..\..\. #
#                          .\Components\stack\sec\ -I                         #
#                          C:\Users\PedroZ\Documents\GitHub\TG\Projects\Stack #
#                          \SE\SampleApp\CC2530DB\..\..\..\..\..\Components\s #
#                          tack\sys\ -I C:\Users\PedroZ\Documents\GitHub\TG\P #
#                          rojects\Stack\SE\SampleApp\CC2530DB\..\..\..\..\.. #
#                          \Components\stack\zcl\ -I                          #
#                          C:\Users\PedroZ\Documents\GitHub\TG\Projects\Stack #
#                          \SE\SampleApp\CC2530DB\..\..\..\..\..\Components\s #
#                          tack\zdo\ -I C:\Users\PedroZ\Documents\GitHub\TG\P #
#                          rojects\Stack\SE\SampleApp\CC2530DB\..\..\..\..\.. #
#                          \Components\zmac\ -I C:\Users\PedroZ\Documents\Git #
#                          Hub\TG\Projects\Stack\SE\SampleApp\CC2530DB\..\..\ #
#                          ..\..\..\Components\zmac\f8w\ -On                  #
#                          --require_prototypes                               #
#    List file          =  C:\Users\PedroZ\Documents\GitHub\TG\Projects\Stack #
#                          \SE\SampleApp\CC2530DB\ESP -                       #
#                          Coordinator\List\esp.lst                           #
#    Object file        =  C:\Users\PedroZ\Documents\GitHub\TG\Projects\Stack #
#                          \SE\SampleApp\CC2530DB\ESP -                       #
#                          Coordinator\Obj\esp.r51                            #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\PedroZ\Documents\GitHub\TG\Projects\Stack\SE\SampleApp\Source\ESP\esp.c
      1          /**************************************************************************************************
      2            Filename:       esp.c
      3            Revised:        $Date: 2012-04-02 17:02:19 -0700 (Mon, 02 Apr 2012) $
      4            Revision:       $Revision: 29996 $
      5          
      6            Description:    This module implements the ESP functionality and contains the
      7                            init and event loop functions
      8          
      9          
     10            Copyright 2009-2012 Texas Instruments Incorporated. All rights reserved.
     11          
     12            IMPORTANT: Your use of this Software is limited to those specific rights
     13            granted under the terms of a software license agreement between the user
     14            who downloaded the software, his/her employer (which must be your employer)
     15            and Texas Instruments Incorporated (the "License").  You may not use this
     16            Software unless you agree to abide by the terms of the License. The License
     17            limits your use, and you acknowledge, that the Software may not be modified,
     18            copied or distributed unless embedded on a Texas Instruments microcontroller
     19            or used solely and exclusively in conjunction with a Texas Instruments radio
     20            frequency transceiver, which is integrated into your product.  Other than for
     21            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     22            works of, modify, distribute, perform, display or sell this Software and/or
     23            its documentation for any purpose.
     24          
     25            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     26            PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     27            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     28            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     29            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     30            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     31            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     32            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     33            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     34            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     35            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     36          
     37            Should you have any questions regarding your right to use this Software,
     38            contact Texas Instruments Incorporated at www.TI.com.
     39          **************************************************************************************************/
     40          
     41          /*********************************************************************
     42            This application is designed for the test purpose of the SE profile which
     43            exploits the following clusters for an ESP configuration:
     44          
     45            General Basic
     46            General Alarms
     47            General Time
     48            General Key Establishment
     49            SE     Price
     50            SE     Demand Response and Load Control
     51            SE     Simple Metering
     52            SE     Message
     53          
     54            Key control:
     55              SW1:  Send out Cooling Load Control Event to PCT
     56              SW2:  Send out Load Control Event to Load Control Device
     57              SW3:  Send out Message to In Premise Display
     58              SW4:  Not used
     59          *********************************************************************/
     60          
     61          /*********************************************************************
     62           * INCLUDES
     63           */
     64          
     65          #include "OSAL.h"
     66          #include "OSAL_Clock.h"
     67          #include "OSAL_Nv.h"
     68          #include "MT.h"
     69          #include "MT_APP.h"
     70          #include "ZDObject.h"
     71          #include "AddrMgr.h"
     72          
     73          #include "se.h"
     74          #include "esp.h"
     75          #include "zcl_general.h"
     76          #include "zcl_se.h"
     77          #include "zcl_key_establish.h"
     78          
     79          #if defined( INTER_PAN )
     80            #include "stub_aps.h"
     81          #endif
     82          
     83          #include "onboard.h"
     84          
     85          /* HAL */
     86          #include "hal_lcd.h"
     87          #include "hal_led.h"
     88          #include "hal_key.h"
     89          
     90          
     91          /*********************************************************************
     92           * MACROS
     93           */
     94          
     95          // There is no attribute in the Mandatory Reportable Attribute list for now
     96          #define zcl_MandatoryReportableAttribute( a ) ( a == NULL )
     97          
     98          /*********************************************************************
     99           * CONSTANTS
    100           */
    101          
    102          #define ESP_MIN_REPORTING_INTERVAL       5
    103          
    104          #if defined ( SE_UK_EXT ) && defined ( SE_MIRROR )
    105          // There can be up to ESP_MAX_MIRRORS mirror endpoints starting at the ESP_MIRROR_EP_BASE and
    106          // going up to ( ESP_MIRROR_EP_BASE + ESP_MAX_MIRRORS )
    107          #define ESP_MIRROR_EP_BASE                        24
    108          
    109          // The max number of mirrors the ESP can have.
    110          // Note: This value is limited by the number of bits in the mirrorMask mask
    111          #define ESP_MAX_MIRRORS                           16
    112          #define ESP_MIRROR_FULL_MASK                      0xFFFF
    113          
    114          #define ESP_MIRROR_NOTIFY_ATTR_COUNT              6
    115          #define ESP_MIRROR_USER_ATTRIBUTES_POSITION       ESP_MIRROR_NOTIFY_ATTR_COUNT
    116          #define ESP_MIRROR_MAX_USER_ATTRIBUTES            8
    117          #define ESP_MIRROR_MAX_ATTRIBUTES                 (ESP_MIRROR_NOTIFY_ATTR_COUNT + ESP_MIRROR_MAX_USER_ATTRIBUTES)
    118          #define ESP_MIRROR_INVALID_ENDPOINT               0xFF
    119          #endif  // SE_UK_EXT && SE_MIRROR
    120          
    121          /*********************************************************************
    122           * TYPEDEFS
    123           */
    124          
    125          /*********************************************************************
    126           * GLOBAL VARIABLES
    127           */
    128          
    129          /*********************************************************************
    130           * GLOBAL FUNCTIONS
    131           */
    132          
    133          /*********************************************************************
    134           * LOCAL VARIABLES
    135           */
    136          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    137          static uint8 espTaskID;                              // esp osal task id
   \                     espTaskID:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    138          static afAddrType_t ipdAddr;                         // destination address of in premise display
   \                     ipdAddr:
   \   000000                DS 12
   \   00000C                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    139          static afAddrType_t pctAddr;                         // destination address of PCT
   \                     pctAddr:
   \   000000                DS 12
   \   00000C                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    140          static afAddrType_t loadControlAddr;                 // destination address of load control device
   \                     loadControlAddr:
   \   000000                DS 12
   \   00000C                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    141          static zAddrType_t simpleDescReqAddr;                // destination addresses for simple desc request
   \                     simpleDescReqAddr:
   \   000000                DS 9
   \   000009                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    142          static zclCCLoadControlEvent_t loadControlCmd;       // command structure for load control command
   \                     loadControlCmd:
   \   000000                DS 24
   \   000018                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    143          static uint16 espFastPollModeDuration;               // number of fast poll events
   \                     espFastPollModeDuration:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
    144          
    145          #if defined ( INTER_PAN )
    146          // define endpoint structure to register with STUB APS for INTER-PAN support

   \                                 In  segment XDATA_I, align 1, keep-with-next
    147          static endPointDesc_t espEp =
   \                     espEp:
   \   000000                DS 6
   \   000006                REQUIRE `?<Initializer for espEp>`
   \   000006                REQUIRE __INIT_XDATA_I
    148          {
    149            ESP_ENDPOINT,
    150            &espTaskID,
    151            (SimpleDescriptionFormat_t *)&espSimpleDesc,
    152            (afNetworkLatencyReq_t)0
    153          };
    154          #endif
    155          
    156          #if defined ( SE_UK_EXT ) && defined ( SE_MIRROR )
    157          typedef struct
    158          {
    159            uint16 srcAddr;
    160            uint8 srcEndpoint;
    161            zclAttrRec_t *pAttr;
    162            uint8 notificationControl;
    163            zclCCReqMirrorReportAttrRsp_t notificationSet;
    164          } espMirrorInfo_t;
    165          
    166          typedef struct
    167          {
    168            uint16 mirrorMask;
    169            espMirrorInfo_t mirrorInfo[ESP_MAX_MIRRORS];
    170          } espMirrorControl_t;
    171          
    172          #define MIRROR_DEVICE_VERSION       0
    173          #define MIRROR_FLAGS                0
    174          
    175          #define MIRROR_MAX_INCLUSTERS       2
    176          CONST cId_t mirrorInClusterList[MIRROR_MAX_INCLUSTERS] =
    177          {
    178            ZCL_CLUSTER_ID_GEN_BASIC,
    179            ZCL_CLUSTER_ID_SE_SIMPLE_METERING
    180          };
    181          
    182          #define MIRROR_MAX_OUTCLUSTERS       2
    183          CONST cId_t mirrorOutClusterList[MIRROR_MAX_OUTCLUSTERS] =
    184          {
    185            ZCL_CLUSTER_ID_GEN_BASIC,
    186            ZCL_CLUSTER_ID_SE_SIMPLE_METERING
    187          };
    188          #endif  // SE_UK_EXT && SE_MIRROR
    189          
    190          /*********************************************************************
    191           * LOCAL FUNCTIONS
    192           */
    193          static void esp_HandleKeys( uint8 shift, uint8 keys );
    194          static void esp_ProcessAppMsg( uint8 *msg );
    195          
    196          static void esp_ProcessIdentifyTimeChange( void );
    197          
    198          /*************************************************************************/
    199          /*** Application Callback Functions                                    ***/
    200          /*************************************************************************/
    201          
    202          // Foundation Callback functions
    203          static uint8 esp_ValidateAttrDataCB( zclAttrRec_t *pAttr, zclWriteRec_t *pAttrInfo );
    204          
    205          // General Cluster Callback functions
    206          static void esp_BasicResetCB( void );
    207          static void esp_IdentifyCB( zclIdentify_t *pCmd );
    208          static void esp_IdentifyQueryRspCB( zclIdentifyQueryRsp_t *pRsp );
    209          static void esp_AlarmCB( zclAlarm_t *pAlarm );
    210          #ifdef SE_UK_EXT
    211          static void esp_GetEventLogCB( uint8 srcEP, afAddrType_t *srcAddr,
    212                                         zclGetEventLog_t *pEventLog, uint8 seqNum );
    213          static void esp_PublishEventLogCB( afAddrType_t *srcAddr, zclPublishEventLog_t *pEventLog );
    214          #endif // SE_UK_EXT
    215          
    216          // SE Callback functions
    217          static void esp_GetProfileCmdCB( zclCCGetProfileCmd_t *pCmd,
    218                                                 afAddrType_t *srcAddr, uint8 seqNum );
    219          static void esp_GetProfileRspCB( zclCCGetProfileRsp_t *pCmd,
    220                                                 afAddrType_t *srcAddr, uint8 seqNum );
    221          static void esp_ReqMirrorCmdCB( afAddrType_t *srcAddr, uint8 seqNum );
    222          static void esp_ReqMirrorRspCB( zclCCReqMirrorRsp_t *pCmd,
    223                                                 afAddrType_t *srcAddr, uint8 seqNum );
    224          static void esp_MirrorRemCmdCB( afAddrType_t *srcAddr, uint8 seqNum );
    225          static void esp_MirrorRemRspCB( zclCCMirrorRemRsp_t *pCmd,
    226                                                 afAddrType_t *srcAddr, uint8 seqNum );
    227          static void esp_ReqFastPollModeCmdCB( zclCCReqFastPollModeCmd_t *pCmd,
    228                                                 afAddrType_t *srcAddr, uint8 seqNum );
    229          static void esp_ReqFastPollModeRspCB( zclCCReqFastPollModeRsp_t *pRsp,
    230                                                 afAddrType_t *srcAddr, uint8 seqNum );
    231          static void esp_GetCurrentPriceCB( zclCCGetCurrentPrice_t *pCmd,
    232                                                 afAddrType_t *srcAddr, uint8 seqNum );
    233          static void esp_GetScheduledPriceCB( zclCCGetScheduledPrice_t *pCmd,
    234                                                 afAddrType_t *srcAddr, uint8 seqNum );
    235          static void esp_PriceAcknowledgementCB( zclCCPriceAcknowledgement_t *pCmd,
    236                                                 afAddrType_t *srcAddr, uint8 seqNum );
    237          static void esp_GetBlockPeriodCB( zclCCGetBlockPeriod_t *pCmd,
    238                                                 afAddrType_t *srcAddr, uint8 seqNum );
    239          static void esp_PublishPriceCB( zclCCPublishPrice_t *pCmd,
    240                                                 afAddrType_t *srcAddr, uint8 seqNum );
    241          static void esp_PublishBlockPeriodCB( zclCCPublishBlockPeriod_t *pCmd,
    242                                                 afAddrType_t *srcAddr, uint8 seqNum );
    243          static void esp_DisplayMessageCB( zclCCDisplayMessage_t *pCmd,
    244                                                 afAddrType_t *srcAddr, uint8 seqNum );
    245          static void esp_CancelMessageCB( zclCCCancelMessage_t *pCmd,
    246                                                 afAddrType_t *srcAddr, uint8 seqNum );
    247          static void esp_GetLastMessageCB( afAddrType_t *srcAddr, uint8 seqNum );
    248          static void esp_MessageConfirmationCB( zclCCMessageConfirmation_t *pCmd,
    249                                                 afAddrType_t *srcAddr, uint8 seqNum );
    250          static void esp_LoadControlEventCB( zclCCLoadControlEvent_t *pCmd,
    251                                    afAddrType_t *srcAddr, uint8 status, uint8 seqNum);
    252          static void esp_CancelLoadControlEventCB( zclCCCancelLoadControlEvent_t *pCmd,
    253                                                 afAddrType_t *srcAddr, uint8 seqNum );
    254          static void esp_CancelAllLoadControlEventsCB( zclCCCancelAllLoadControlEvents_t *pCmd,
    255                                                 afAddrType_t *srcAddr, uint8 seqNum );
    256          static void esp_ReportEventStatusCB( zclCCReportEventStatus_t *pCmd,
    257                                                 afAddrType_t *srcAddr, uint8 seqNum );
    258          static void esp_GetScheduledEventCB( zclCCGetScheduledEvent_t *pCmd,
    259                                                 afAddrType_t *srcAddr, uint8 seqNum );
    260          static void esp_SelAvailEmergencyCreditCmdCB( zclCCSelAvailEmergencyCredit_t *pCmd,
    261                                                 afAddrType_t *srcAddr, uint8 seqNum );
    262          static void esp_ChangeSupplyCmdCB( zclCCChangeSupply_t *pCmd,
    263                                                 afAddrType_t *srcAddr, uint8 seqNum );
    264          static void esp_SupplyStatusRspCB( zclCCSupplyStatusResponse_t *pCmd,
    265                                                 afAddrType_t *srcAddr, uint8 seqNum );
    266          #if defined ( SE_UK_EXT )
    267          static void esp_GetSnapshotRspCB( zclCCReqGetSnapshotRsp_t *pCmd,
    268                                                 afAddrType_t *srcAddr, uint8 seqNum );
    269          static void esp_PublishTariffInformationCB( zclCCPublishTariffInformation_t *pCmd,
    270                                                 afAddrType_t *srcAddr, uint8 seqNum );
    271          static void esp_PublishPriceMatrixCB( zclCCPublishPriceMatrix_t *pCmd,
    272                                                 afAddrType_t *srcAddr, uint8 seqNum );
    273          static void esp_PublishBlockThresholdsCB( zclCCPublishBlockThresholds_t *pCmd,
    274                                                 afAddrType_t *srcAddr, uint8 seqNum );
    275          static void esp_PublishConversionFactorCB( zclCCPublishConversionFactor_t *pCmd,
    276                                                 afAddrType_t *srcAddr, uint8 seqNum );
    277          static void esp_PublishCalorificValueCB( zclCCPublishCalorificValue_t *pCmd,
    278                                                 afAddrType_t *srcAddr, uint8 seqNum );
    279          static void esp_PublishCO2ValueCB( zclCCPublishCO2Value_t *pCmd,
    280                                                 afAddrType_t *srcAddr, uint8 seqNum );
    281          static void esp_PublishCPPEventCB( zclCCPublishCPPEvent_t *pCmd,
    282                                                 afAddrType_t *srcAddr, uint8 seqNum );
    283          static void esp_PublishBillingPeriodCB( zclCCPublishBillingPeriod_t *pCmd,
    284                                                 afAddrType_t *srcAddr, uint8 seqNum );
    285          static void esp_PublishConsolidatedBillCB( zclCCPublishConsolidatedBill_t *pCmd,
    286                                                 afAddrType_t *srcAddr, uint8 seqNum );
    287          static void esp_PublishCreditPaymentInfoCB( zclCCPublishCreditPaymentInfo_t *pCmd,
    288                                                 afAddrType_t *srcAddr, uint8 seqNum );
    289          static void esp_GetTariffInformationCB( zclCCGetTariffInformation_t *pCmd,
    290                                                 afAddrType_t *srcAddr, uint8 seqNum );
    291          static void esp_GetPriceMatrixCB( uint32 issuerTariffId,
    292                                                 afAddrType_t *srcAddr, uint8 seqNum );
    293          static void esp_GetBlockThresholdsCB( uint32 issuerTariffId,
    294                                                 afAddrType_t *srcAddr, uint8 seqNum );
    295          static void esp_GetConversionFactorCB( zclCCGetConversionFactor_t *pCmd,
    296                                                 afAddrType_t *srcAddr, uint8 seqNum );
    297          static void esp_GetCalorificValueCB( zclCCGetCalorificValue_t *pCmd,
    298                                                 afAddrType_t *srcAddr, uint8 seqNum );
    299          static void esp_GetCO2ValueCB( zclCCGetCO2Value_t *pCmd,
    300                                                 afAddrType_t *srcAddr, uint8 seqNum );
    301          static void esp_GetBillingPeriodCB( zclCCGetBillingPeriod_t *pCmd,
    302                                                 afAddrType_t *srcAddr, uint8 seqNum );
    303          static void esp_GetConsolidatedBillCB( zclCCGetConsolidatedBill_t *pCmd,
    304                                                 afAddrType_t *srcAddr, uint8 seqNum );
    305          static void esp_CPPEventResponseCB( zclCCCPPEventResponse_t *pCmd,
    306                                                 afAddrType_t *srcAddr, uint8 seqNum );
    307          static void esp_ChangeDebtCB( zclCCChangeDebt_t *pCmd,
    308                                                 afAddrType_t *srcAddr, uint8 seqNum );
    309          static void esp_EmergencyCreditSetupCB( zclCCEmergencyCreditSetup_t *pCmd,
    310                                                 afAddrType_t *srcAddr, uint8 seqNum );
    311          static void esp_ConsumerTopupCB( zclCCConsumerTopup_t *pCmd,
    312                                                 afAddrType_t *srcAddr, uint8 seqNum );
    313          static void esp_CreditAdjustmentCB( zclCCCreditAdjustment_t *pCmd,
    314                                                 afAddrType_t *srcAddr, uint8 seqNum );
    315          static void esp_ChangePaymentModeCB( zclCCChangePaymentMode_t *pCmd,
    316                                                 afAddrType_t *srcAddr, uint8 seqNum );
    317          static void esp_GetPrepaySnapshotCB( zclCCGetPrepaySnapshot_t *pCmd,
    318                                                 afAddrType_t *srcAddr, uint8 seqNum );
    319          static void esp_GetTopupLogCB( uint8 numEvents,
    320                                                 afAddrType_t *srcAddr, uint8 seqNum );
    321          static void esp_SetLowCreditWarningLevelCB( uint8 numEvents,
    322                                                 afAddrType_t *srcAddr, uint8 seqNum );
    323          static void esp_GetDebtRepaymentLogCB( zclCCGetDebtRepaymentLog_t *pCmd,
    324                                                 afAddrType_t *srcAddr, uint8 seqNum );
    325          static void esp_GetPrepaySnapshotResponseCB( zclCCGetPrepaySnapshotResponse_t *pCmd,
    326                                                 afAddrType_t *srcAddr, uint8 seqNum );
    327          static void esp_ChangePaymentModeResponseCB( zclCCChangePaymentModeResponse_t *pCmd,
    328                                                 afAddrType_t *srcAddr, uint8 seqNum );
    329          static void esp_ConsumerTopupResponseCB( zclCCConsumerTopupResponse_t *pCmd,
    330                                                 afAddrType_t *srcAddr, uint8 seqNum );
    331          static void esp_GetCommandsCB( uint8 prepayNotificationFlags,
    332                                                 afAddrType_t *srcAddr, uint8 seqNum );
    333          static void esp_PublishTopupLogCB( zclCCPublishTopupLog_t *pCmd,
    334                                                 afAddrType_t *srcAddr, uint8 seqNum );
    335          static void esp_PublishDebtLogCB( zclCCPublishDebtLog_t *pCmd,
    336                                                 afAddrType_t *srcAddr, uint8 seqNum );
    337          #endif  // SE_UK_EXT
    338          
    339          /************************************************************************/
    340          /***               Functions to process ZCL Foundation                ***/
    341          /***               incoming Command/Response messages                 ***/
    342          /************************************************************************/
    343          static void esp_ProcessZCLMsg( zclIncomingMsg_t *msg );
    344          #if defined ( ZCL_READ )
    345          static uint8 esp_ProcessInReadRspCmd( zclIncomingMsg_t *pInMsg );
    346          #endif // ZCL_READ
    347          #if defined ( ZCL_WRITE )
    348          static uint8 esp_ProcessInWriteRspCmd( zclIncomingMsg_t *pInMsg );
    349          #endif // ZCL_WRITE
    350          #if defined ( ZCL_REPORT )
    351          static uint8 esp_ProcessInConfigReportCmd( zclIncomingMsg_t *pInMsg );
    352          static uint8 esp_ProcessInConfigReportRspCmd( zclIncomingMsg_t *pInMsg );
    353          static uint8 esp_ProcessInReadReportCfgCmd( zclIncomingMsg_t *pInMsg );
    354          static uint8 esp_ProcessInReadReportCfgRspCmd( zclIncomingMsg_t *pInMsg );
    355          static uint8 esp_ProcessInReportCmd( zclIncomingMsg_t *pInMsg );
    356          #endif // ZCL_REPORT
    357          static uint8 esp_ProcessInDefaultRspCmd( zclIncomingMsg_t *pInMsg );
    358          #if defined ( ZCL_DISCOVER )
    359          static uint8 esp_ProcessInDiscRspCmd( zclIncomingMsg_t *pInMsg );
    360          #endif // ZCL_DISCOVER
    361          
    362          // Functions to handle ZDO messages
    363          static void esp_ProcessZDOMsg( zdoIncomingMsg_t *inMsg );
    364          
    365          #if defined ( SE_UK_EXT ) && defined ( SE_MIRROR )
    366          static void esp_MirrorInit( void );
    367          static uint8 esp_GetMirrorEndpoint( afAddrType_t *srcAddr );
    368          static uint8 esp_AllocMirror( afAddrType_t *srcAddr );
    369          static void esp_FreeMirror( uint8 endPoint );
    370          static uint8 esp_IsMirrorEndpoint( uint8 endpoint );
    371          static void esp_MirrorProcessZCLMsg( zclIncomingMsg_t *pInMsg );
    372          static espMirrorInfo_t *esp_GetMirrorInfo( uint8 endpoint );
    373          static uint8 esp_MirrorUpdateAttribute( uint8 endpoint, uint16 cluster,
    374                                                  zclReport_t *pReport );
    375          static void esp_MirrorInitAttributeSet( uint8 endpoint );
    376          
    377          static espMirrorControl_t esp_MirrorControl;
    378          #endif  // SE_UK_EXT && SE_MIRROR
    379          
    380          /*********************************************************************
    381           * ZCL General Clusters Callback table
    382           */

   \                                 In  segment XDATA_I, align 1, keep-with-next
    383          static zclGeneral_AppCallbacks_t esp_GenCmdCallbacks =
   \                     esp_GenCmdCallbacks:
   \   000000                DS 30
   \   00001E                REQUIRE `?<Initializer for esp_GenCmdCallbacks>`
   \   00001E                REQUIRE __INIT_XDATA_I
    384          {
    385            esp_BasicResetCB,              // Basic Cluster Reset command
    386            esp_IdentifyCB,                // Identify command
    387            esp_IdentifyQueryRspCB,        // Identify Query Response command
    388            NULL,                          // On/Off cluster commands
    389            NULL,                          // Level Control Move to Level command
    390            NULL,                          // Level Control Move command
    391            NULL,                          // Level Control Step command
    392            NULL,                          // Level Control Stop command
    393            NULL,                          // Group Response commands
    394            NULL,                          // Scene Store Request command
    395            NULL,                          // Scene Recall Request command
    396            NULL,                          // Scene Response command
    397            esp_AlarmCB,                   // Alarm (Response) command
    398          #ifdef SE_UK_EXT
    399            esp_GetEventLogCB,             // Get Event Log command
    400            esp_PublishEventLogCB,         // Publish Event Log command
    401          #endif
    402            NULL,                          // RSSI Location command
    403            NULL                           // RSSI Location Response command
    404          };
    405          
    406          /*********************************************************************
    407           * ZCL SE Clusters Callback table
    408           */

   \                                 In  segment XDATA_I, align 1, keep-with-next
    409          static zclSE_AppCallbacks_t esp_SECmdCallbacks =
   \                     esp_SECmdCallbacks:
   \   000000                DS 66
   \   000042                REQUIRE `?<Initializer for esp_SECmdCallbacks>`
   \   000042                REQUIRE __INIT_XDATA_I
    410          {
    411            esp_PublishPriceCB,                      // Publish Price
    412            esp_PublishBlockPeriodCB,                // Publish Block Period
    413          #if defined ( SE_UK_EXT )
    414            esp_PublishTariffInformationCB,          // Publish Tariff Information
    415            esp_PublishPriceMatrixCB,                // Publish Price Matrix
    416            esp_PublishBlockThresholdsCB,            // Publish Block Thresholds
    417            esp_PublishConversionFactorCB,           // Publish Conversion Factor
    418            esp_PublishCalorificValueCB,             // Publish Calorific Value
    419            esp_PublishCO2ValueCB,                   // Publish CO2 Value
    420            esp_PublishCPPEventCB,                   // Publish CPP Event
    421            esp_PublishBillingPeriodCB,              // Publish Billing Period
    422            esp_PublishConsolidatedBillCB,           // Publish Consolidated Bill
    423            esp_PublishCreditPaymentInfoCB,          // Publish Credit Payment Info
    424          #endif  // SE_UK_EXT
    425            esp_GetCurrentPriceCB,                   // Get Current Price
    426            esp_GetScheduledPriceCB,                 // Get Scheduled Price
    427            esp_PriceAcknowledgementCB,              // Price Acknowledgement
    428            esp_GetBlockPeriodCB,                    // Get Block Period
    429          #if defined ( SE_UK_EXT )
    430            esp_GetTariffInformationCB,              // Get Tariff Information
    431            esp_GetPriceMatrixCB,                    // Get Price Matrix
    432            esp_GetBlockThresholdsCB,                // Get Block Thresholds
    433            esp_GetConversionFactorCB,               // Get Conversion Factor
    434            esp_GetCalorificValueCB,                 // Get Calorific Value
    435            esp_GetCO2ValueCB,                       // Get CO2 Value
    436            esp_GetBillingPeriodCB,                  // Get Billing Period
    437            esp_GetConsolidatedBillCB,               // Get Consolidated Bill
    438            esp_CPPEventResponseCB,                  // CPP Event Response
    439          #endif  // SE_UK_EXT
    440            esp_LoadControlEventCB,                  // Load Control Event
    441            esp_CancelLoadControlEventCB,            // Cancel Load Control Event
    442            esp_CancelAllLoadControlEventsCB,        // Cancel All Load Control Events
    443            esp_ReportEventStatusCB,                 // Report Event Status
    444            esp_GetScheduledEventCB,                 // Get Scheduled Event
    445            esp_GetProfileRspCB,                     // Get Profile Response
    446            esp_ReqMirrorCmdCB,                      // Request Mirror Command
    447            esp_MirrorRemCmdCB,                      // Mirror Remove Command
    448            esp_ReqFastPollModeRspCB,                // Request Fast Poll Mode Response
    449          #if defined ( SE_UK_EXT )
    450            esp_GetSnapshotRspCB,                    // Get Snapshot Response
    451          #endif  // SE_UK_EXT
    452            esp_GetProfileCmdCB,                     // Get Profile Command
    453            esp_ReqMirrorRspCB,                      // Request Mirror Response
    454            esp_MirrorRemRspCB,                      // Mirror Remove Response
    455            esp_ReqFastPollModeCmdCB,                // Request Fast Poll Mode Command
    456          #if defined ( SE_UK_EXT )
    457            NULL,                                    // Get Snapshot Command
    458            NULL,                                    // Take Snapshot Command
    459            NULL,                                    // Mirror Report Attribute Response
    460          #endif  // SE_UK_EXT
    461            esp_DisplayMessageCB,                    // Display Message Command
    462            esp_CancelMessageCB,                     // Cancel Message Command
    463            esp_GetLastMessageCB,                    // Get Last Message Command
    464            esp_MessageConfirmationCB,               // Message Confirmation
    465            NULL,                                    // Request Tunnel Response
    466            NULL,                                    // Transfer Data
    467            NULL,                                    // Transfer Data Error
    468            NULL,                                    // Ack Transfer Data
    469            NULL,                                    // Ready Data
    470          #if defined ( SE_UK_EXT )
    471            NULL,                                    // Supported Tunnel Protocols Response
    472            NULL,                                    // Tunnel Closure Notification
    473          #endif  // SE_UK_EXT
    474            NULL,                                    // Request Tunnel
    475            NULL,                                    // Close Tunnel
    476          #if defined ( SE_UK_EXT )
    477            NULL,                                    // Get Supported Tunnel Protocols
    478          #endif  // SE_UK_EXT
    479            esp_SupplyStatusRspCB,                   // Supply Status Response
    480          #if defined ( SE_UK_EXT )
    481            esp_GetPrepaySnapshotResponseCB,         // Get Prepay Snapshot Response
    482            esp_ChangePaymentModeResponseCB,         // Change Payment Mode Response
    483            esp_ConsumerTopupResponseCB,             // Consumer Topup Response
    484            esp_GetCommandsCB,                       // Get Commands
    485            esp_PublishTopupLogCB,                   // Publish Topup Log
    486            esp_PublishDebtLogCB,                    // Publish Debt Log
    487          #endif  // SE_UK_EXT
    488            esp_SelAvailEmergencyCreditCmdCB,        // Select Available Emergency Credit Command
    489            esp_ChangeSupplyCmdCB,                   // Change Supply Command
    490          #if defined ( SE_UK_EXT )
    491            esp_ChangeDebtCB,                        // Change Debt
    492            esp_EmergencyCreditSetupCB,              // Emergency Credit Setup
    493            esp_ConsumerTopupCB,                     // Consumer Topup
    494            esp_CreditAdjustmentCB,                  // Credit Adjustment
    495            esp_ChangePaymentModeCB,                 // Change PaymentMode
    496            esp_GetPrepaySnapshotCB,                 // Get Prepay Snapshot
    497            esp_GetTopupLogCB,                       // Get Topup Log
    498            esp_SetLowCreditWarningLevelCB,          // Set Low Credit Warning Level
    499            esp_GetDebtRepaymentLogCB,               // Get Debt Repayment Log
    500            NULL,                                    // Publish Calendar
    501            NULL,                                    // Publish Day Profile
    502            NULL,                                    // Publish Week Profile
    503            NULL,                                    // Publish Seasons
    504            NULL,                                    // Publish Special Days
    505            NULL,                                    // Get Calendar
    506            NULL,                                    // Get Day Profiles
    507            NULL,                                    // Get Week Profiles
    508            NULL,                                    // Get Seasons
    509            NULL,                                    // Get Special Days
    510            NULL,                                    // Publish Change Tenancy
    511            NULL,                                    // Publish Change Supplier
    512            NULL,                                    // Change Supply
    513            NULL,                                    // Change Password
    514            NULL,                                    // Local Change Supply
    515            NULL,                                    // Get Change Tenancy
    516            NULL,                                    // Get Change Supplier
    517            NULL,                                    // Get Change Supply
    518            NULL,                                    // Supply Status Response
    519            NULL,                                    // Get Password
    520          #endif  // SE_UK_EXT
    521          };
    522          
    523          /*********************************************************************
    524           * @fn          esp_Init
    525           *
    526           * @brief       Initialization function for the ZCL App Application.
    527           *
    528           * @param       uint8 task_id - esp task id
    529           *
    530           * @return      none
    531           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    532          void esp_Init( uint8 task_id )
   \                     esp_Init:
    533          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 1
   \   000005   74FF         MOV     A,#-0x1
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   E9           MOV     A,R1
   \   00000B   FE           MOV     R6,A
    534            espTaskID = task_id;
   \   00000C   90....       MOV     DPTR,#espTaskID
   \   00000F   F0           MOVX    @DPTR,A
    535          
    536            // Register for an SE endpoint
    537            zclSE_Init( &espSimpleDesc );
   \   000010                ; Setup parameters for call to function zclSE_Init
   \   000010   7A..         MOV     R2,#espSimpleDesc & 0xff
   \   000012   7B..         MOV     R3,#(espSimpleDesc >> 8) & 0xff
   \   000014   12....       LCALL   ??zclSE_Init?relay
    538          
    539            // Register the ZCL General Cluster Library callback functions
    540            zclGeneral_RegisterCmdCallbacks( ESP_ENDPOINT, &esp_GenCmdCallbacks );
   \   000017                ; Setup parameters for call to function zclGeneral_RegisterCmdCallbacks
   \   000017   7A..         MOV     R2,#esp_GenCmdCallbacks & 0xff
   \   000019   7B..         MOV     R3,#(esp_GenCmdCallbacks >> 8) & 0xff
   \   00001B   7909         MOV     R1,#0x9
   \   00001D   12....       LCALL   ??zclGeneral_RegisterCmdCallbacks?relay
   \   000020   E9           MOV     A,R1
    541          
    542            // Register the ZCL SE Cluster Library callback functions
    543            zclSE_RegisterCmdCallbacks( ESP_ENDPOINT, &esp_SECmdCallbacks );
   \   000021                ; Setup parameters for call to function zclSE_RegisterCmdCallbacks
   \   000021   7A..         MOV     R2,#esp_SECmdCallbacks & 0xff
   \   000023   7B..         MOV     R3,#(esp_SECmdCallbacks >> 8) & 0xff
   \   000025   7909         MOV     R1,#0x9
   \   000027   12....       LCALL   ??zclSE_RegisterCmdCallbacks?relay
   \   00002A   E9           MOV     A,R1
    544          
    545            // Register the application's attribute list
    546            zcl_registerAttrList( ESP_ENDPOINT, ESP_MAX_ATTRIBUTES, espAttrs );
   \   00002B                ; Setup parameters for call to function zcl_registerAttrList
   \   00002B   7C..         MOV     R4,#espAttrs & 0xff
   \   00002D   7D..         MOV     R5,#(espAttrs >> 8) & 0xff
   \   00002F   7A59         MOV     R2,#0x59
   \   000031   7909         MOV     R1,#0x9
   \   000033   12....       LCALL   ??zcl_registerAttrList?relay
   \   000036   E9           MOV     A,R1
    547          
    548            // Register the application's cluster option list
    549            zcl_registerClusterOptionList( ESP_ENDPOINT, ESP_MAX_OPTIONS, espOptions );
   \   000037                ; Setup parameters for call to function zcl_registerClusterOptionList
   \   000037   7C..         MOV     R4,#espOptions & 0xff
   \   000039   7D..         MOV     R5,#(espOptions >> 8) & 0xff
   \   00003B   7A07         MOV     R2,#0x7
   \   00003D   7909         MOV     R1,#0x9
   \   00003F   12....       LCALL   ??zcl_registerClusterOptionList?relay
   \   000042   E9           MOV     A,R1
    550          
    551            // Register the application's attribute data validation callback function
    552            zcl_registerValidateAttrData( esp_ValidateAttrDataCB );
   \   000043                ; Setup parameters for call to function zcl_registerValidateAttrData
   \   000043   7A..         MOV     R2,#??esp_ValidateAttrDataCB?relay & 0xff
   \   000045   7B..         MOV     R3,#(??esp_ValidateAttrDataCB?relay >> 8) & 0xff
   \   000047   12....       LCALL   ??zcl_registerValidateAttrData?relay
   \   00004A   E9           MOV     A,R1
    553          
    554            // Register the Application to receive the unprocessed Foundation command/response messages
    555            zcl_registerForMsg( espTaskID );
   \   00004B                ; Setup parameters for call to function zcl_registerForMsg
   \   00004B   90....       MOV     DPTR,#espTaskID
   \   00004E   E0           MOVX    A,@DPTR
   \   00004F   F9           MOV     R1,A
   \   000050   12....       LCALL   ??zcl_registerForMsg?relay
   \   000053   E9           MOV     A,R1
    556          
    557            // register for end device annce and simple descriptor responses
    558            ZDO_RegisterForZDOMsg( espTaskID, Device_annce );
   \   000054                ; Setup parameters for call to function ZDO_RegisterForZDOMsg
   \   000054   7A13         MOV     R2,#0x13
   \   000056   7B00         MOV     R3,#0x0
   \   000058   90....       MOV     DPTR,#espTaskID
   \   00005B   E0           MOVX    A,@DPTR
   \   00005C   F9           MOV     R1,A
   \   00005D   12....       LCALL   ??ZDO_RegisterForZDOMsg?relay
   \   000060   E9           MOV     A,R1
    559            ZDO_RegisterForZDOMsg( espTaskID, Simple_Desc_rsp );
   \   000061                ; Setup parameters for call to function ZDO_RegisterForZDOMsg
   \   000061   7A04         MOV     R2,#0x4
   \   000063   7B80         MOV     R3,#-0x80
   \   000065   90....       MOV     DPTR,#espTaskID
   \   000068   E0           MOVX    A,@DPTR
   \   000069   F9           MOV     R1,A
   \   00006A   12....       LCALL   ??ZDO_RegisterForZDOMsg?relay
   \   00006D   E9           MOV     A,R1
    560          
    561            // Register for all key events - This app will handle all key events
    562            RegisterForKeys( espTaskID );
   \   00006E                ; Setup parameters for call to function RegisterForKeys
   \   00006E   90....       MOV     DPTR,#espTaskID
   \   000071   E0           MOVX    A,@DPTR
   \   000072   F9           MOV     R1,A
   \   000073   12....       LCALL   ??RegisterForKeys?relay
   \   000076   E9           MOV     A,R1
    563          
    564          #if defined ( INTER_PAN )
    565            // Register with Stub APS
    566            StubAPS_RegisterApp( &espEp );
   \   000077                ; Setup parameters for call to function StubAPS_RegisterApp
   \   000077   7A..         MOV     R2,#espEp & 0xff
   \   000079   7B..         MOV     R3,#(espEp >> 8) & 0xff
   \   00007B   12....       LCALL   ??StubAPS_RegisterApp?relay
    567          #endif
    568          
    569            // Start the timer to sync esp timer with the osal timer
    570            osal_start_timerEx( espTaskID, ESP_UPDATE_TIME_EVT, ESP_UPDATE_TIME_PERIOD );
   \   00007E                ; Setup parameters for call to function osal_start_timerEx
   \   00007E   7CE8         MOV     R4,#-0x18
   \   000080   7D03         MOV     R5,#0x3
   \   000082   7A02         MOV     R2,#0x2
   \   000084   7B00         MOV     R3,#0x0
   \   000086   90....       MOV     DPTR,#espTaskID
   \   000089   E0           MOVX    A,@DPTR
   \   00008A   F9           MOV     R1,A
   \   00008B   12....       LCALL   ??osal_start_timerEx?relay
   \   00008E   E9           MOV     A,R1
    571          
    572            // setup address mode and destination endpoint fields for PCT
    573            pctAddr.addrMode = (afAddrMode_t)Addr16Bit;
   \   00008F   90....       MOV     DPTR,#pctAddr + 8
   \   000092   7402         MOV     A,#0x2
   \   000094   F0           MOVX    @DPTR,A
    574            pctAddr.endPoint = ESP_ENDPOINT;
   \   000095   90....       MOV     DPTR,#pctAddr + 9
   \   000098   7409         MOV     A,#0x9
   \   00009A   F0           MOVX    @DPTR,A
    575          
    576            // setup address mode and destination endpoint fields for load control device
    577            loadControlAddr.addrMode = (afAddrMode_t)Addr16Bit;
   \   00009B   90....       MOV     DPTR,#loadControlAddr + 8
   \   00009E   7402         MOV     A,#0x2
   \   0000A0   F0           MOVX    @DPTR,A
    578            loadControlAddr.endPoint = ESP_ENDPOINT;
   \   0000A1   90....       MOV     DPTR,#loadControlAddr + 9
   \   0000A4   7409         MOV     A,#0x9
   \   0000A6   F0           MOVX    @DPTR,A
    579          
    580            //setup load control command structure
    581            loadControlCmd.issuerEvent = 0x12345678;            // arbitrary id
   \   0000A7   7A78         MOV     R2,#0x78
   \   0000A9   7B56         MOV     R3,#0x56
   \   0000AB   7C34         MOV     R4,#0x34
   \   0000AD   7D12         MOV     R5,#0x12
   \   0000AF   90....       MOV     DPTR,#loadControlCmd
   \   0000B2   EA           MOV     A,R2
   \   0000B3   F0           MOVX    @DPTR,A
   \   0000B4   A3           INC     DPTR
   \   0000B5   EB           MOV     A,R3
   \   0000B6   F0           MOVX    @DPTR,A
   \   0000B7   A3           INC     DPTR
   \   0000B8   EC           MOV     A,R4
   \   0000B9   F0           MOVX    @DPTR,A
   \   0000BA   A3           INC     DPTR
   \   0000BB   ED           MOV     A,R5
   \   0000BC   F0           MOVX    @DPTR,A
    582            loadControlCmd.deviceGroupClass = 0x000000;         // addresses all groups
   \   0000BD   7A00         MOV     R2,#0x0
   \   0000BF   7B00         MOV     R3,#0x0
   \   0000C1   7C00         MOV     R4,#0x0
   \   0000C3   7D00         MOV     R5,#0x0
   \   0000C5   90....       MOV     DPTR,#loadControlCmd + 4
   \   0000C8   EA           MOV     A,R2
   \   0000C9   F0           MOVX    @DPTR,A
   \   0000CA   A3           INC     DPTR
   \   0000CB   EB           MOV     A,R3
   \   0000CC   F0           MOVX    @DPTR,A
   \   0000CD   A3           INC     DPTR
   \   0000CE   EC           MOV     A,R4
   \   0000CF   F0           MOVX    @DPTR,A
   \   0000D0   A3           INC     DPTR
   \   0000D1   ED           MOV     A,R5
   \   0000D2   F0           MOVX    @DPTR,A
    583            loadControlCmd.startTime = 0x00000000;              // start time = NOW
   \   0000D3   7A00         MOV     R2,#0x0
   \   0000D5   7B00         MOV     R3,#0x0
   \   0000D7   7C00         MOV     R4,#0x0
   \   0000D9   7D00         MOV     R5,#0x0
   \   0000DB   90....       MOV     DPTR,#loadControlCmd + 8
   \   0000DE   EA           MOV     A,R2
   \   0000DF   F0           MOVX    @DPTR,A
   \   0000E0   A3           INC     DPTR
   \   0000E1   EB           MOV     A,R3
   \   0000E2   F0           MOVX    @DPTR,A
   \   0000E3   A3           INC     DPTR
   \   0000E4   EC           MOV     A,R4
   \   0000E5   F0           MOVX    @DPTR,A
   \   0000E6   A3           INC     DPTR
   \   0000E7   ED           MOV     A,R5
   \   0000E8   F0           MOVX    @DPTR,A
    584            loadControlCmd.durationInMinutes = 0x0001;          // duration of one minute
   \   0000E9   90....       MOV     DPTR,#loadControlCmd + 12
   \   0000EC   7401         MOV     A,#0x1
   \   0000EE   F0           MOVX    @DPTR,A
   \   0000EF   A3           INC     DPTR
   \   0000F0   7400         MOV     A,#0x0
   \   0000F2   F0           MOVX    @DPTR,A
    585            loadControlCmd.criticalityLevel = 0x01;             // green level
   \   0000F3   90....       MOV     DPTR,#loadControlCmd + 14
   \   0000F6   7401         MOV     A,#0x1
   \   0000F8   F0           MOVX    @DPTR,A
    586            loadControlCmd.coolingTemperatureSetPoint = 0x076C; // 19 degrees C, 66.2 degress fahrenheit
   \   0000F9   90....       MOV     DPTR,#loadControlCmd + 17
   \   0000FC   746C         MOV     A,#0x6c
   \   0000FE   F0           MOVX    @DPTR,A
   \   0000FF   A3           INC     DPTR
   \   000100   7407         MOV     A,#0x7
   \   000102   F0           MOVX    @DPTR,A
    587            loadControlCmd.eventControl = 0x00;                 // no randomized start or end applied
   \   000103   90....       MOV     DPTR,#loadControlCmd + 23
   \   000106   7400         MOV     A,#0x0
   \   000108   F0           MOVX    @DPTR,A
    588          
    589            // Initialize variable used to control number of fast poll events
    590            espFastPollModeDuration = 0;
   \   000109   90....       MOV     DPTR,#espFastPollModeDuration
   \   00010C   7400         MOV     A,#0x0
   \   00010E   F0           MOVX    @DPTR,A
   \   00010F   A3           INC     DPTR
   \   000110   7400         MOV     A,#0x0
   \   000112   F0           MOVX    @DPTR,A
    591          
    592            // detect and remove stored deprecated end device children after power up
    593            uint8 cleanupChildTable = TRUE;
   \   000113   85..82       MOV     DPL,?XSP + 0
   \   000116   85..83       MOV     DPH,?XSP + 1
   \   000119   7401         MOV     A,#0x1
   \   00011B   F0           MOVX    @DPTR,A
    594            zgSetItem( ZCD_NV_ROUTER_OFF_ASSOC_CLEANUP, sizeof(cleanupChildTable), &cleanupChildTable );
   \   00011C                ; Setup parameters for call to function zgSetItem
   \   00011C   85..82       MOV     DPL,?XSP + 0
   \   00011F   85..83       MOV     DPH,?XSP + 1
   \   000122   8582..       MOV     ?V0 + 0,DPL
   \   000125   8583..       MOV     ?V0 + 1,DPH
   \   000128   78..         MOV     R0,#?V0 + 0
   \   00012A   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00012D   7C01         MOV     R4,#0x1
   \   00012F   7D00         MOV     R5,#0x0
   \   000131   7A3C         MOV     R2,#0x3c
   \   000133   7B00         MOV     R3,#0x0
   \   000135   12....       LCALL   ??zgSetItem?relay
   \   000138   7402         MOV     A,#0x2
   \   00013A   12....       LCALL   ?DEALLOC_XSTACK8
    595          
    596          #if defined ( SE_UK_EXT ) && defined ( SE_MIRROR )
    597            esp_MirrorInit();
    598          #endif  // SE_UK_EXT && SE_MIRROR
    599          
    600          }
   \   00013D   7401         MOV     A,#0x1
   \   00013F   12....       LCALL   ?DEALLOC_XSTACK8
   \   000142   7F02         MOV     R7,#0x2
   \   000144   02....       LJMP    ?BANKED_LEAVE_XDATA
    601          
    602          /*********************************************************************
    603           * @fn          esp_event_loop
    604           *
    605           * @brief       Event Loop Processor for esp.
    606           *
    607           * @param       uint8 task_id - esp task id
    608           * @param       uint16 events - event bitmask
    609           *
    610           * @return      none
    611           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    612          uint16 esp_event_loop( uint8 task_id, uint16 events )
   \                     esp_event_loop:
    613          {
   \   000000   74F2         MOV     A,#-0xe
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V0 + 2,R1
   \   000007   EA           MOV     A,R2
   \   000008   FE           MOV     R6,A
   \   000009   EB           MOV     A,R3
   \   00000A   FF           MOV     R7,A
    614            afIncomingMSGPacket_t *MSGpkt;
    615          
    616            if ( events & SYS_EVENT_MSG )
   \   00000B   EE           MOV     A,R6
   \   00000C   5400         ANL     A,#0x0
   \   00000E   F8           MOV     R0,A
   \   00000F   EF           MOV     A,R7
   \   000010   5480         ANL     A,#0x80
   \   000012   F9           MOV     R1,A
   \   000013   E8           MOV     A,R0
   \   000014   49           ORL     A,R1
   \   000015   7003         JNZ     $+5
   \   000017   02....       LJMP    ??esp_event_loop_0 & 0xFFFF
    617            {
    618              while ( (MSGpkt = (afIncomingMSGPacket_t *)osal_msg_receive( espTaskID )) )
   \                     ??esp_event_loop_1:
   \   00001A                ; Setup parameters for call to function osal_msg_receive
   \   00001A   90....       MOV     DPTR,#espTaskID
   \   00001D   E0           MOVX    A,@DPTR
   \   00001E   F9           MOV     R1,A
   \   00001F   12....       LCALL   ??osal_msg_receive?relay
   \   000022   8A..         MOV     ?V0 + 4,R2
   \   000024   8B..         MOV     ?V0 + 5,R3
   \   000026   A8..         MOV     R0,?V0 + 4
   \   000028   A9..         MOV     R1,?V0 + 5
   \   00002A   88..         MOV     ?V0 + 0,R0
   \   00002C   89..         MOV     ?V0 + 1,R1
   \   00002E   E8           MOV     A,R0
   \   00002F   49           ORL     A,R1
   \   000030   6061         JZ      ??esp_event_loop_2
    619              {
    620                switch ( MSGpkt->hdr.event )
   \   000032   85..82       MOV     DPL,?V0 + 0
   \   000035   85..83       MOV     DPH,?V0 + 1
   \   000038   E0           MOVX    A,@DPTR
   \   000039   24DD         ADD     A,#-0x23
   \   00003B   600E         JZ      ??esp_event_loop_3
   \   00003D   24EF         ADD     A,#-0x11
   \   00003F   601E         JZ      ??esp_event_loop_4
   \   000041   2474         ADD     A,#0x74
   \   000043   6023         JZ      ??esp_event_loop_5
   \   000045   24ED         ADD     A,#-0x13
   \   000047   6039         JZ      ??esp_event_loop_6
   \   000049   803E         SJMP    ??esp_event_loop_7
    621                {
    622                  case MT_SYS_APP_MSG:
    623                    // Message received from MT (serial port)
    624                    esp_ProcessAppMsg( ((mtSysAppMsg_t *)MSGpkt)->appData );
   \                     ??esp_event_loop_3:
   \   00004B                ; Setup parameters for call to function esp_ProcessAppMsg
   \   00004B   85..82       MOV     DPL,?V0 + 0
   \   00004E   85..83       MOV     DPH,?V0 + 1
   \   000051   A3           INC     DPTR
   \   000052   A3           INC     DPTR
   \   000053   A3           INC     DPTR
   \   000054   A3           INC     DPTR
   \   000055   E0           MOVX    A,@DPTR
   \   000056   FA           MOV     R2,A
   \   000057   A3           INC     DPTR
   \   000058   E0           MOVX    A,@DPTR
   \   000059   FB           MOV     R3,A
   \   00005A   12....       LCALL   ??esp_ProcessAppMsg?relay
    625                    break;
   \   00005D   802A         SJMP    ??esp_event_loop_7
    626          
    627                  case ZCL_INCOMING_MSG:
    628                    // Incoming ZCL foundation command/response messages
    629                    esp_ProcessZCLMsg( (zclIncomingMsg_t *)MSGpkt );
   \                     ??esp_event_loop_4:
   \   00005F                ; Setup parameters for call to function esp_ProcessZCLMsg
   \   00005F   AA..         MOV     R2,?V0 + 0
   \   000061   AB..         MOV     R3,?V0 + 1
   \   000063   12....       LCALL   ??esp_ProcessZCLMsg?relay
    630                    break;
   \   000066   8021         SJMP    ??esp_event_loop_7
    631          
    632                  case KEY_CHANGE:
    633                    esp_HandleKeys( ((keyChange_t *)MSGpkt)->state, ((keyChange_t *)MSGpkt)->keys );
   \                     ??esp_event_loop_5:
   \   000068                ; Setup parameters for call to function esp_HandleKeys
   \   000068   85..82       MOV     DPL,?V0 + 0
   \   00006B   85..83       MOV     DPH,?V0 + 1
   \   00006E   A3           INC     DPTR
   \   00006F   A3           INC     DPTR
   \   000070   A3           INC     DPTR
   \   000071   E0           MOVX    A,@DPTR
   \   000072   FA           MOV     R2,A
   \   000073   85..82       MOV     DPL,?V0 + 0
   \   000076   85..83       MOV     DPH,?V0 + 1
   \   000079   A3           INC     DPTR
   \   00007A   A3           INC     DPTR
   \   00007B   E0           MOVX    A,@DPTR
   \   00007C   F9           MOV     R1,A
   \   00007D   12....       LCALL   ??esp_HandleKeys?relay
    634                    break;
   \   000080   8007         SJMP    ??esp_event_loop_7
    635          
    636                  case ZDO_CB_MSG:
    637                    // ZDO sends the message that we registered for
    638                    esp_ProcessZDOMsg( (zdoIncomingMsg_t *)MSGpkt );
   \                     ??esp_event_loop_6:
   \   000082                ; Setup parameters for call to function esp_ProcessZDOMsg
   \   000082   AA..         MOV     R2,?V0 + 0
   \   000084   AB..         MOV     R3,?V0 + 1
   \   000086   12....       LCALL   ??esp_ProcessZDOMsg?relay
    639                    break;
    640          
    641                  default:
    642                    break;
    643                }
    644          
    645                // Release the memory
    646                osal_msg_deallocate( (uint8 *)MSGpkt );
   \                     ??esp_event_loop_7:
   \   000089                ; Setup parameters for call to function osal_msg_deallocate
   \   000089   AA..         MOV     R2,?V0 + 0
   \   00008B   AB..         MOV     R3,?V0 + 1
   \   00008D   12....       LCALL   ??osal_msg_deallocate?relay
   \   000090   E9           MOV     A,R1
   \   000091   8087         SJMP    ??esp_event_loop_1
    647          
    648              }
    649          
    650              // return unprocessed events
    651              return (events ^ SYS_EVENT_MSG);
   \                     ??esp_event_loop_2:
   \   000093   EE           MOV     A,R6
   \   000094   6400         XRL     A,#0x0
   \   000096   FA           MOV     R2,A
   \   000097   EF           MOV     A,R7
   \   000098   6480         XRL     A,#0x80
   \   00009A   FB           MOV     R3,A
   \   00009B   02....       LJMP    ??esp_event_loop_8 & 0xFFFF
    652            }
    653          
    654            // handle processing of identify timeout event triggered by an identify command
    655            if ( events & ESP_IDENTIFY_TIMEOUT_EVT )
   \                     ??esp_event_loop_0:
   \   00009E   EE           MOV     A,R6
   \   00009F   A2E0         MOV     C,0xE0 /* A   */.0
   \   0000A1   5026         JNC     ??esp_event_loop_9
    656            {
    657              if ( espIdentifyTime > 0 )
   \   0000A3   90....       MOV     DPTR,#espIdentifyTime
   \   0000A6   E0           MOVX    A,@DPTR
   \   0000A7   F8           MOV     R0,A
   \   0000A8   A3           INC     DPTR
   \   0000A9   E0           MOVX    A,@DPTR
   \   0000AA   F9           MOV     R1,A
   \   0000AB   E8           MOV     A,R0
   \   0000AC   49           ORL     A,R1
   \   0000AD   600C         JZ      ??esp_event_loop_10
    658              {
    659                espIdentifyTime--;
   \   0000AF   90....       MOV     DPTR,#espIdentifyTime
   \   0000B2   E0           MOVX    A,@DPTR
   \   0000B3   24FF         ADD     A,#-0x1
   \   0000B5   F0           MOVX    @DPTR,A
   \   0000B6   A3           INC     DPTR
   \   0000B7   E0           MOVX    A,@DPTR
   \   0000B8   34FF         ADDC    A,#-0x1
   \   0000BA   F0           MOVX    @DPTR,A
    660              }
    661              esp_ProcessIdentifyTimeChange();
   \                     ??esp_event_loop_10:
   \   0000BB                ; Setup parameters for call to function esp_ProcessIdentifyTimeChange
   \   0000BB   12....       LCALL   ??esp_ProcessIdentifyTimeChange?relay
    662          
    663              return ( events ^ ESP_IDENTIFY_TIMEOUT_EVT );
   \   0000BE   EE           MOV     A,R6
   \   0000BF   6401         XRL     A,#0x1
   \   0000C1   FA           MOV     R2,A
   \   0000C2   EF           MOV     A,R7
   \   0000C3   6400         XRL     A,#0x0
   \   0000C5   FB           MOV     R3,A
   \   0000C6   02....       LJMP    ??esp_event_loop_8 & 0xFFFF
    664            }
    665          
    666            // event to get current time
    667            if ( events & ESP_UPDATE_TIME_EVT )
   \                     ??esp_event_loop_9:
   \   0000C9   EE           MOV     A,R6
   \   0000CA   5402         ANL     A,#0x2
   \   0000CC   6024         JZ      ??esp_event_loop_11
    668            {
    669              espTime = osal_getClock();
   \   0000CE                ; Setup parameters for call to function osal_getClock
   \   0000CE   12....       LCALL   ??osal_getClock?relay
   \   0000D1   90....       MOV     DPTR,#espTime
   \   0000D4   12....       LCALL   ?XSTORE_R2345
    670              osal_start_timerEx( espTaskID, ESP_UPDATE_TIME_EVT, ESP_UPDATE_TIME_PERIOD );
   \   0000D7                ; Setup parameters for call to function osal_start_timerEx
   \   0000D7   7CE8         MOV     R4,#-0x18
   \   0000D9   7D03         MOV     R5,#0x3
   \   0000DB   7A02         MOV     R2,#0x2
   \   0000DD   7B00         MOV     R3,#0x0
   \   0000DF   90....       MOV     DPTR,#espTaskID
   \   0000E2   E0           MOVX    A,@DPTR
   \   0000E3   F9           MOV     R1,A
   \   0000E4   12....       LCALL   ??osal_start_timerEx?relay
   \   0000E7   E9           MOV     A,R1
    671          
    672              return ( events ^ ESP_UPDATE_TIME_EVT );
   \   0000E8   EE           MOV     A,R6
   \   0000E9   6402         XRL     A,#0x2
   \   0000EB   FA           MOV     R2,A
   \   0000EC   EF           MOV     A,R7
   \   0000ED   6400         XRL     A,#0x0
   \   0000EF   FB           MOV     R3,A
   \   0000F0   806A         SJMP    ??esp_event_loop_8
    673            }
    674          
    675          
    676            // event to get simple descriptor of the newly joined device
    677            if ( events & SIMPLE_DESC_QUERY_EVT )
   \                     ??esp_event_loop_11:
   \   0000F2   EE           MOV     A,R6
   \   0000F3   5404         ANL     A,#0x4
   \   0000F5   6029         JZ      ??esp_event_loop_12
    678            {
    679                ZDP_SimpleDescReq( &simpleDescReqAddr, simpleDescReqAddr.addr.shortAddr,
    680                                  ESP_ENDPOINT, 0);
   \   0000F7                ; Setup parameters for call to function ZDP_SimpleDescReq
   \   0000F7   75..00       MOV     ?V0 + 3,#0x0
   \   0000FA   78..         MOV     R0,#?V0 + 3
   \   0000FC   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000FF   7909         MOV     R1,#0x9
   \   000101   90....       MOV     DPTR,#simpleDescReqAddr
   \   000104   E0           MOVX    A,@DPTR
   \   000105   FC           MOV     R4,A
   \   000106   A3           INC     DPTR
   \   000107   E0           MOVX    A,@DPTR
   \   000108   FD           MOV     R5,A
   \   000109   7A..         MOV     R2,#simpleDescReqAddr & 0xff
   \   00010B   7B..         MOV     R3,#(simpleDescReqAddr >> 8) & 0xff
   \   00010D   12....       LCALL   ??ZDP_SimpleDescReq?relay
   \   000110   7401         MOV     A,#0x1
   \   000112   12....       LCALL   ?DEALLOC_XSTACK8
   \   000115   E9           MOV     A,R1
    681          
    682                return ( events ^ SIMPLE_DESC_QUERY_EVT );
   \   000116   EE           MOV     A,R6
   \   000117   6404         XRL     A,#0x4
   \   000119   FA           MOV     R2,A
   \   00011A   EF           MOV     A,R7
   \   00011B   6400         XRL     A,#0x0
   \   00011D   FB           MOV     R3,A
   \   00011E   803C         SJMP    ??esp_event_loop_8
    683            }
    684          
    685            // handle processing of timeout event triggered by request fast polling command
    686            if ( events & ESP_FAST_POLL_MODE_EVT )
   \                     ??esp_event_loop_12:
   \   000120   EE           MOV     A,R6
   \   000121   5408         ANL     A,#0x8
   \   000123   6033         JZ      ??esp_event_loop_13
    687            {
    688              if (espFastPollModeDuration)
   \   000125   90....       MOV     DPTR,#espFastPollModeDuration
   \   000128   E0           MOVX    A,@DPTR
   \   000129   F8           MOV     R0,A
   \   00012A   A3           INC     DPTR
   \   00012B   E0           MOVX    A,@DPTR
   \   00012C   F9           MOV     R1,A
   \   00012D   E8           MOV     A,R0
   \   00012E   49           ORL     A,R1
   \   00012F   601D         JZ      ??esp_event_loop_14
    689              {
    690                espFastPollModeDuration--;
   \   000131   90....       MOV     DPTR,#espFastPollModeDuration
   \   000134   E0           MOVX    A,@DPTR
   \   000135   24FF         ADD     A,#-0x1
   \   000137   F0           MOVX    @DPTR,A
   \   000138   A3           INC     DPTR
   \   000139   E0           MOVX    A,@DPTR
   \   00013A   34FF         ADDC    A,#-0x1
   \   00013C   F0           MOVX    @DPTR,A
    691                // Start the timer for the fast poll period
    692                osal_start_timerEx( espTaskID, ESP_FAST_POLL_MODE_EVT, ESP_FAST_POLL_TIMER_PERIOD );
   \   00013D                ; Setup parameters for call to function osal_start_timerEx
   \   00013D   7CE8         MOV     R4,#-0x18
   \   00013F   7D03         MOV     R5,#0x3
   \   000141   7A08         MOV     R2,#0x8
   \   000143   7B00         MOV     R3,#0x0
   \   000145   90....       MOV     DPTR,#espTaskID
   \   000148   E0           MOVX    A,@DPTR
   \   000149   F9           MOV     R1,A
   \   00014A   12....       LCALL   ??osal_start_timerEx?relay
   \   00014D   E9           MOV     A,R1
    693              }
    694          
    695              return ( events ^ ESP_FAST_POLL_MODE_EVT );
   \                     ??esp_event_loop_14:
   \   00014E   EE           MOV     A,R6
   \   00014F   6408         XRL     A,#0x8
   \   000151   FA           MOV     R2,A
   \   000152   EF           MOV     A,R7
   \   000153   6400         XRL     A,#0x0
   \   000155   FB           MOV     R3,A
   \   000156   8004         SJMP    ??esp_event_loop_8
    696            }
    697          
    698            // Discard unknown events
    699            return 0;
   \                     ??esp_event_loop_13:
   \   000158   7A00         MOV     R2,#0x0
   \   00015A   7B00         MOV     R3,#0x0
   \                     ??esp_event_loop_8:
   \   00015C   7F06         MOV     R7,#0x6
   \   00015E   02....       LJMP    ?BANKED_LEAVE_XDATA
    700          }
    701          
    702          /*********************************************************************
    703           * @fn      esp_ProcessAppMsg
    704           *
    705           * @brief   Process MT SYS APP MSG
    706           *
    707           * @param   msg - pointer to message
    708           *
    709           * @return  none
    710           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    711          static void esp_ProcessAppMsg( uint8 *msg )
   \                     esp_ProcessAppMsg:
    712          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    713            // user should include code to handle MT SYS APP MSG here
    714          }
   \   000000   02....       LJMP    ?BRET
    715          
    716          /*********************************************************************
    717           * @fn      esp_ProcessIdentifyTimeChange
    718           *
    719           * @brief   Called to blink led for specified IdentifyTime attribute value
    720           *
    721           * @param   none
    722           *
    723           * @return  none
    724           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    725          static void esp_ProcessIdentifyTimeChange( void )
   \                     esp_ProcessIdentifyTimeChange:
    726          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    727            if ( espIdentifyTime > 0 )
   \   000004   90....       MOV     DPTR,#espIdentifyTime
   \   000007   E0           MOVX    A,@DPTR
   \   000008   F8           MOV     R0,A
   \   000009   A3           INC     DPTR
   \   00000A   E0           MOVX    A,@DPTR
   \   00000B   F9           MOV     R1,A
   \   00000C   E8           MOV     A,R0
   \   00000D   49           ORL     A,R1
   \   00000E   6020         JZ      ??esp_ProcessIdentifyTimeChange_0
    728            {
    729              osal_start_timerEx( espTaskID, ESP_IDENTIFY_TIMEOUT_EVT, 1000 );
   \   000010                ; Setup parameters for call to function osal_start_timerEx
   \   000010   7CE8         MOV     R4,#-0x18
   \   000012   7D03         MOV     R5,#0x3
   \   000014   7A01         MOV     R2,#0x1
   \   000016   7B00         MOV     R3,#0x0
   \   000018   90....       MOV     DPTR,#espTaskID
   \   00001B   E0           MOVX    A,@DPTR
   \   00001C   F9           MOV     R1,A
   \   00001D   12....       LCALL   ??osal_start_timerEx?relay
   \   000020   E9           MOV     A,R1
    730              HalLedBlink ( HAL_LED_4, 0xFF, HAL_LED_DEFAULT_DUTY_CYCLE, HAL_LED_DEFAULT_FLASH_TIME );
   \   000021                ; Setup parameters for call to function HalLedBlink
   \   000021   7CE8         MOV     R4,#-0x18
   \   000023   7D03         MOV     R5,#0x3
   \   000025   7B05         MOV     R3,#0x5
   \   000027   7AFF         MOV     R2,#-0x1
   \   000029   7908         MOV     R1,#0x8
   \   00002B   12....       LCALL   ??HalLedBlink?relay
   \   00002E   8015         SJMP    ??esp_ProcessIdentifyTimeChange_1
    731            }
    732            else
    733            {
    734              HalLedSet ( HAL_LED_4, HAL_LED_MODE_OFF );
   \                     ??esp_ProcessIdentifyTimeChange_0:
   \   000030                ; Setup parameters for call to function HalLedSet
   \   000030   7A00         MOV     R2,#0x0
   \   000032   7908         MOV     R1,#0x8
   \   000034   12....       LCALL   ??HalLedSet?relay
   \   000037   E9           MOV     A,R1
    735              osal_stop_timerEx( espTaskID, ESP_IDENTIFY_TIMEOUT_EVT );
   \   000038                ; Setup parameters for call to function osal_stop_timerEx
   \   000038   7A01         MOV     R2,#0x1
   \   00003A   7B00         MOV     R3,#0x0
   \   00003C   90....       MOV     DPTR,#espTaskID
   \   00003F   E0           MOVX    A,@DPTR
   \   000040   F9           MOV     R1,A
   \   000041   12....       LCALL   ??osal_stop_timerEx?relay
   \   000044   E9           MOV     A,R1
    736            }
    737          }
   \                     ??esp_ProcessIdentifyTimeChange_1:
   \   000045   D083         POP     DPH
   \   000047   D082         POP     DPL
   \   000049   02....       LJMP    ?BRET
    738          
    739          
    740          /*********************************************************************
    741           * @fn      esp_HandleKeys
    742           *
    743           * @brief   Handles all key events for this device.
    744           *
    745           * @param   shift - true if in shift/alt.
    746           * @param   keys - bit field for key events. Valid entries:
    747           *                 HAL_KEY_SW_4
    748           *                 HAL_KEY_SW_3
    749           *                 HAL_KEY_SW_2
    750           *                 HAL_KEY_SW_1
    751           *
    752           * @return  none
    753           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    754          static void esp_HandleKeys( uint8 shift, uint8 keys )
   \                     esp_HandleKeys:
    755          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 35
   \   000005   74DD         MOV     A,#-0x23
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   E9           MOV     A,R1
   \   00000B   FE           MOV     R6,A
   \   00000C   EA           MOV     A,R2
   \   00000D   FF           MOV     R7,A
    756            // Shift is used to make each button/switch dual purpose.
    757            if ( shift )
   \   00000E   EE           MOV     A,R6
   \   00000F   6003         JZ      $+5
   \   000011   02....       LJMP    ??esp_HandleKeys_0 & 0xFFFF
    758            {
    759              if ( keys & HAL_KEY_SW_1 )
    760              {
    761              }
    762              if ( keys & HAL_KEY_SW_2 )
    763              {
    764              }
    765              if ( keys & HAL_KEY_SW_3 )
    766              {
    767              }
    768              if ( keys & HAL_KEY_SW_4 )
    769              {
    770              }
    771            }
    772            else
    773            {
    774              if ( keys & HAL_KEY_SW_1 )
   \   000014   EF           MOV     A,R7
   \   000015   A2E0         MOV     C,0xE0 /* A   */.0
   \   000017   5039         JNC     ??esp_HandleKeys_1
    775              {
    776                // send out cooling event to PCT
    777                loadControlCmd.deviceGroupClass = HVAC_DEVICE_CLASS; // HVAC compressor or furnace - bit 0 is set
   \   000019   7A01         MOV     R2,#0x1
   \   00001B   7B00         MOV     R3,#0x0
   \   00001D   7C00         MOV     R4,#0x0
   \   00001F   7D00         MOV     R5,#0x0
   \   000021   90....       MOV     DPTR,#loadControlCmd + 4
   \   000024   EA           MOV     A,R2
   \   000025   F0           MOVX    @DPTR,A
   \   000026   A3           INC     DPTR
   \   000027   EB           MOV     A,R3
   \   000028   F0           MOVX    @DPTR,A
   \   000029   A3           INC     DPTR
   \   00002A   EC           MOV     A,R4
   \   00002B   F0           MOVX    @DPTR,A
   \   00002C   A3           INC     DPTR
   \   00002D   ED           MOV     A,R5
   \   00002E   F0           MOVX    @DPTR,A
    778                zclSE_LoadControl_Send_LoadControlEvent( ESP_ENDPOINT, &pctAddr, &loadControlCmd, TRUE, 0 );
   \   00002F                ; Setup parameters for call to function zclSE_LoadControl_Send_LoadControlEvent
   \   00002F   75..00       MOV     ?V0 + 0,#0x0
   \   000032   78..         MOV     R0,#?V0 + 0
   \   000034   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000037   75..01       MOV     ?V0 + 0,#0x1
   \   00003A   78..         MOV     R0,#?V0 + 0
   \   00003C   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00003F   7C..         MOV     R4,#loadControlCmd & 0xff
   \   000041   7D..         MOV     R5,#(loadControlCmd >> 8) & 0xff
   \   000043   7A..         MOV     R2,#pctAddr & 0xff
   \   000045   7B..         MOV     R3,#(pctAddr >> 8) & 0xff
   \   000047   7909         MOV     R1,#0x9
   \   000049   12....       LCALL   ??zclSE_LoadControl_Send_LoadControlEvent?relay
   \   00004C   7402         MOV     A,#0x2
   \   00004E   12....       LCALL   ?DEALLOC_XSTACK8
   \   000051   E9           MOV     A,R1
    779              }
    780          
    781              if ( keys & HAL_KEY_SW_2 )
   \                     ??esp_HandleKeys_1:
   \   000052   EF           MOV     A,R7
   \   000053   A2E1         MOV     C,0xE0 /* A   */.1
   \   000055   5039         JNC     ??esp_HandleKeys_2
    782              {
    783                // send out load control event to load control device
    784                loadControlCmd.deviceGroupClass = ONOFF_LOAD_DEVICE_CLASS; // simple misc residential on/off loads - bit 7 is set
   \   000057   7A80         MOV     R2,#-0x80
   \   000059   7B00         MOV     R3,#0x0
   \   00005B   7C00         MOV     R4,#0x0
   \   00005D   7D00         MOV     R5,#0x0
   \   00005F   90....       MOV     DPTR,#loadControlCmd + 4
   \   000062   EA           MOV     A,R2
   \   000063   F0           MOVX    @DPTR,A
   \   000064   A3           INC     DPTR
   \   000065   EB           MOV     A,R3
   \   000066   F0           MOVX    @DPTR,A
   \   000067   A3           INC     DPTR
   \   000068   EC           MOV     A,R4
   \   000069   F0           MOVX    @DPTR,A
   \   00006A   A3           INC     DPTR
   \   00006B   ED           MOV     A,R5
   \   00006C   F0           MOVX    @DPTR,A
    785                zclSE_LoadControl_Send_LoadControlEvent( ESP_ENDPOINT, &loadControlAddr, &loadControlCmd, TRUE, 0 );
   \   00006D                ; Setup parameters for call to function zclSE_LoadControl_Send_LoadControlEvent
   \   00006D   75..00       MOV     ?V0 + 0,#0x0
   \   000070   78..         MOV     R0,#?V0 + 0
   \   000072   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000075   75..01       MOV     ?V0 + 0,#0x1
   \   000078   78..         MOV     R0,#?V0 + 0
   \   00007A   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00007D   7C..         MOV     R4,#loadControlCmd & 0xff
   \   00007F   7D..         MOV     R5,#(loadControlCmd >> 8) & 0xff
   \   000081   7A..         MOV     R2,#loadControlAddr & 0xff
   \   000083   7B..         MOV     R3,#(loadControlAddr >> 8) & 0xff
   \   000085   7909         MOV     R1,#0x9
   \   000087   12....       LCALL   ??zclSE_LoadControl_Send_LoadControlEvent?relay
   \   00008A   7402         MOV     A,#0x2
   \   00008C   12....       LCALL   ?DEALLOC_XSTACK8
   \   00008F   E9           MOV     A,R1
    786              }
    787          
    788              if ( keys & HAL_KEY_SW_3 )
   \                     ??esp_HandleKeys_2:
   \   000090   EF           MOV     A,R7
   \   000091   A2E4         MOV     C,0xE0 /* A   */.4
   \   000093   5063         JNC     ??esp_HandleKeys_0
    789              {
    790                zclCCDisplayMessage_t displayCmd;             // command structure for message being sent to in premise display
    791          
    792                // Define to zero to send the TI IPD message, non-zero to send a string of abc's.
    793          #if   !defined IPD_MSG_SZ
    794                #define  IPD_MSG_SZ  0
    795          #endif
    796          #if   (IPD_MSG_SZ == 0)
    797                uint8 msgBuf[]="TI IPD Test Msg!";
   \   000095   90....       MOV     DPTR,#`?<Constant "TI IPD Test Msg!">`
   \   000098   C082         PUSH    DPL
   \   00009A   C083         PUSH    DPH
   \   00009C   85..82       MOV     DPL,?XSP + 0
   \   00009F   85..83       MOV     DPH,?XSP + 1
   \   0000A2   AC82         MOV     R4,DPL
   \   0000A4   AD83         MOV     R5,DPH
   \   0000A6   D083         POP     DPH
   \   0000A8   D082         POP     DPL
   \   0000AA   7411         MOV     A,#0x11
   \   0000AC   12....       LCALL   ?MOVE_LONG8_XDATA_XDATA
    798                const uint8 msgLen = sizeof(msgBuf);
   \   0000AF   75..11       MOV     ?V0 + 0,#0x11
    799          #else
    800                uint8 *msgBuf = osal_mem_alloc(IPD_MSG_SZ);
    801                const uint8 msgLen = IPD_MSG_SZ;
    802                uint8 idx;
    803          
    804                if (!msgBuf)  return;
    805          
    806                for (idx = 0; idx < msgLen; idx ++)
    807                {
    808                  msgBuf[idx] = 'a' + idx % 26;
    809                }
    810          #endif
    811          
    812                displayCmd.msgString.strLen = msgLen;
   \   0000B2   E5..         MOV     A,?V0 + 0
   \   0000B4   7420         MOV     A,#0x20
   \   0000B6   12....       LCALL   ?XSTACK_DISP0_8
   \   0000B9   E5..         MOV     A,?V0 + 0
   \   0000BB   F0           MOVX    @DPTR,A
    813                displayCmd.msgString.pStr = msgBuf;
   \   0000BC   85..82       MOV     DPL,?XSP + 0
   \   0000BF   85..83       MOV     DPH,?XSP + 1
   \   0000C2   A882         MOV     R0,DPL
   \   0000C4   A983         MOV     R1,DPH
   \   0000C6   7421         MOV     A,#0x21
   \   0000C8   12....       LCALL   ?XSTACK_DISP0_8
   \   0000CB   E8           MOV     A,R0
   \   0000CC   F0           MOVX    @DPTR,A
   \   0000CD   A3           INC     DPTR
   \   0000CE   E9           MOV     A,R1
   \   0000CF   F0           MOVX    @DPTR,A
    814          
    815                zclSE_Message_Send_DisplayMessage( ESP_ENDPOINT, &ipdAddr, &displayCmd, TRUE, 0 );
   \   0000D0                ; Setup parameters for call to function zclSE_Message_Send_DisplayMessage
   \   0000D0   75..00       MOV     ?V0 + 1,#0x0
   \   0000D3   78..         MOV     R0,#?V0 + 1
   \   0000D5   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000D8   75..01       MOV     ?V0 + 1,#0x1
   \   0000DB   78..         MOV     R0,#?V0 + 1
   \   0000DD   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000E0   7413         MOV     A,#0x13
   \   0000E2   12....       LCALL   ?XSTACK_DISP0_8
   \   0000E5   AC82         MOV     R4,DPL
   \   0000E7   AD83         MOV     R5,DPH
   \   0000E9   7A..         MOV     R2,#ipdAddr & 0xff
   \   0000EB   7B..         MOV     R3,#(ipdAddr >> 8) & 0xff
   \   0000ED   7909         MOV     R1,#0x9
   \   0000EF   12....       LCALL   ??zclSE_Message_Send_DisplayMessage?relay
   \   0000F2   7402         MOV     A,#0x2
   \   0000F4   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000F7   E9           MOV     A,R1
    816          
    817          #if   (IPD_MSG_SZ != 0)
    818                osal_mem_free(msgBuf);
    819          #endif
    820              }
    821          
    822              if ( keys & HAL_KEY_SW_4 )
    823              {
    824          
    825              }
    826            }
    827          }
   \                     ??esp_HandleKeys_0:
   \   0000F8   7423         MOV     A,#0x23
   \   0000FA   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000FD   7F02         MOV     R7,#0x2
   \   0000FF   02....       LJMP    ?BANKED_LEAVE_XDATA
    828          
    829          /*********************************************************************
    830           * @fn      esp_ValidateAttrDataCB
    831           *
    832           * @brief   Check to see if the supplied value for the attribute data
    833           *          is within the specified range of the attribute.
    834           *
    835           *
    836           * @param   pAttr - pointer to attribute
    837           * @param   pAttrInfo - pointer to attribute info
    838           *
    839           * @return  TRUE if data valid. FALSE otherwise.
    840           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    841          static uint8 esp_ValidateAttrDataCB( zclAttrRec_t *pAttr, zclWriteRec_t *pAttrInfo )
   \                     esp_ValidateAttrDataCB:
    842          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    843            uint8 valid = TRUE;
   \   000004   7901         MOV     R1,#0x1
    844          
    845            switch ( pAttrInfo->dataType )
   \   000006   8C82         MOV     DPL,R4
   \   000008   8D83         MOV     DPH,R5
   \   00000A   A3           INC     DPTR
   \   00000B   A3           INC     DPTR
   \   00000C   E0           MOVX    A,@DPTR
   \   00000D   6410         XRL     A,#0x10
   \   00000F   7028         JNZ     ??esp_ValidateAttrDataCB_0
    846            {
    847              case ZCL_DATATYPE_BOOLEAN:
    848                if ( ( *(pAttrInfo->attrData) != 0 ) && ( *(pAttrInfo->attrData) != 1 ) )
   \   000011   8C82         MOV     DPL,R4
   \   000013   8D83         MOV     DPH,R5
   \   000015   A3           INC     DPTR
   \   000016   A3           INC     DPTR
   \   000017   A3           INC     DPTR
   \   000018   E0           MOVX    A,@DPTR
   \   000019   F8           MOV     R0,A
   \   00001A   A3           INC     DPTR
   \   00001B   E0           MOVX    A,@DPTR
   \   00001C   F583         MOV     DPH,A
   \   00001E   8882         MOV     DPL,R0
   \   000020   E0           MOVX    A,@DPTR
   \   000021   6016         JZ      ??esp_ValidateAttrDataCB_0
   \   000023   8C82         MOV     DPL,R4
   \   000025   8D83         MOV     DPH,R5
   \   000027   A3           INC     DPTR
   \   000028   A3           INC     DPTR
   \   000029   A3           INC     DPTR
   \   00002A   E0           MOVX    A,@DPTR
   \   00002B   F8           MOV     R0,A
   \   00002C   A3           INC     DPTR
   \   00002D   E0           MOVX    A,@DPTR
   \   00002E   F583         MOV     DPH,A
   \   000030   8882         MOV     DPL,R0
   \   000032   E0           MOVX    A,@DPTR
   \   000033   6401         XRL     A,#0x1
   \   000035   6002         JZ      ??esp_ValidateAttrDataCB_0
    849                {
    850                  valid = FALSE;
   \   000037   7900         MOV     R1,#0x0
    851                }
    852                break;
    853          
    854              default:
    855                break;
    856            }
    857          
    858            return ( valid );
   \                     ??esp_ValidateAttrDataCB_0:
   \   000039   D083         POP     DPH
   \   00003B   D082         POP     DPL
   \   00003D   02....       LJMP    ?BRET
    859          }
    860          
    861          /*********************************************************************
    862           * @fn      esp_BasicResetCB
    863           *
    864           * @brief   Callback from the ZCL General Cluster Library to set all
    865           *          the attributes of all the clusters to their factory defaults
    866           *
    867           * @param   none
    868           *
    869           * @return  none
    870           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    871          static void esp_BasicResetCB( void )
   \                     esp_BasicResetCB:
    872          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    873            // user should handle setting attributes to factory defaults here
    874          }
   \   000000   02....       LJMP    ?BRET
    875          
    876          /*********************************************************************
    877           * @fn      esp_IdentifyCB
    878           *
    879           * @brief   Callback from the ZCL General Cluster Library when
    880           *          it received an Identify Command for this application.
    881           *
    882           * @param   pCmd - pointer to structure for Identify command
    883           *
    884           * @return  none
    885           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    886          static void esp_IdentifyCB( zclIdentify_t *pCmd )
   \                     esp_IdentifyCB:
    887          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
    888            espIdentifyTime = pCmd->identifyTime;
   \   000009   8E82         MOV     DPL,R6
   \   00000B   8F83         MOV     DPH,R7
   \   00000D   A3           INC     DPTR
   \   00000E   A3           INC     DPTR
   \   00000F   E0           MOVX    A,@DPTR
   \   000010   F8           MOV     R0,A
   \   000011   A3           INC     DPTR
   \   000012   E0           MOVX    A,@DPTR
   \   000013   F9           MOV     R1,A
   \   000014   90....       MOV     DPTR,#espIdentifyTime
   \   000017   E8           MOV     A,R0
   \   000018   F0           MOVX    @DPTR,A
   \   000019   A3           INC     DPTR
   \   00001A   E9           MOV     A,R1
   \   00001B   F0           MOVX    @DPTR,A
    889            esp_ProcessIdentifyTimeChange();
   \   00001C                ; Setup parameters for call to function esp_ProcessIdentifyTimeChange
   \   00001C   12....       LCALL   ??esp_ProcessIdentifyTimeChange?relay
    890          }
   \   00001F   7F01         MOV     R7,#0x1
   \   000021   02....       LJMP    ?BANKED_LEAVE_XDATA
    891          
    892          /*********************************************************************
    893           * @fn      esp_IdentifyQueryRspCB
    894           *
    895           * @brief   Callback from the ZCL General Cluster Library when
    896           *          it received an Identity Query Response Command for this application.
    897           *
    898           * @param   pRsp - pointer to structure for Identity Query Response command
    899           *
    900           * @return  none
    901           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    902          static void esp_IdentifyQueryRspCB( zclIdentifyQueryRsp_t *pRsp )
   \                     esp_IdentifyQueryRspCB:
    903          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    904            // add user code here
    905          }
   \   000000   02....       LJMP    ?BRET
    906          
    907          /*********************************************************************
    908           * @fn      esp_AlarmCB
    909           *
    910           * @brief   Callback from the ZCL General Cluster Library when
    911           *          it received an Alam request or response command for
    912           *          this application.
    913           *
    914           * @param   pAlarm - pointer to structure for Alarm command
    915           *
    916           * @return  none
    917           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    918          static void esp_AlarmCB( zclAlarm_t *pAlarm )
   \                     esp_AlarmCB:
    919          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    920            // add user code here
    921          }
   \   000000   02....       LJMP    ?BRET
    922          
    923          #ifdef SE_UK_EXT
    924          /*********************************************************************
    925           * @fn      esp_GetEventLogCB
    926           *
    927           * @brief   Callback from the ZCL General Cluster Library when
    928           *          it received a Get Event Log command for this
    929           *          application.
    930           *
    931           * @param   srcEP - source endpoint
    932           * @param   srcAddr - pointer to source address
    933           * @param   pEventLog - pointer to structure for Get Event Log command
    934           * @param   seqNum - sequence number of this command
    935           *
    936           * @return  none
    937           */
    938          static void esp_GetEventLogCB( uint8 srcEP, afAddrType_t *srcAddr,
    939                                         zclGetEventLog_t *pEventLog, uint8 seqNum )
    940          {
    941            // add user code here, which could fragment the event log payload if
    942            // the entire payload doesn't fit into one Publish Event Log Command.
    943            // Note: the Command Index starts at 0 and is incremented for each
    944            // fragment belonging to the same command.
    945          
    946            // There's no event log for now! The Metering Device will support
    947            // logging for all events configured to do so.
    948          }
    949          
    950          /*********************************************************************
    951           * @fn      esp_PublishEventLogCB
    952           *
    953           * @brief   Callback from the ZCL General Cluster Library when
    954           *          it received a Publish Event Log command for this
    955           *          application.
    956           *
    957           * @param   srcAddr - pointer to source address
    958           * @param   pEventLog - pointer to structure for Publish Event Log command
    959           *
    960           * @return  none
    961           */
    962          static void esp_PublishEventLogCB( afAddrType_t *srcAddr, zclPublishEventLog_t *pEventLog )
    963          {
    964            // add user code here
    965          }
    966          #endif // SE_UK_EXT
    967          
    968          /*********************************************************************
    969           * @fn      esp_GetProfileCmdCB
    970           *
    971           * @brief   Callback from the ZCL SE Profile Simple Metering Cluster Library when
    972           *          it received a Get Profile Command for
    973           *          this application.
    974           *
    975           * @param   pCmd - pointer to structure for Get Profile command
    976           * @param   srcAddr - pointer to source address
    977           * @param   seqNum - sequence number of this command
    978           *
    979           * @return  none
    980           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    981          static void esp_GetProfileCmdCB( zclCCGetProfileCmd_t *pCmd,
   \                     esp_GetProfileCmdCB:
    982                                           afAddrType_t *srcAddr, uint8 seqNum )
    983          {
   \   000000   74EA         MOV     A,#-0x16
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 22
   \   000005                ; Auto size: 20
   \   000005   74EC         MOV     A,#-0x14
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V0 + 12,R2
   \   00000C   8B..         MOV     ?V0 + 13,R3
   \   00000E   8C..         MOV     ?V0 + 10,R4
   \   000010   8D..         MOV     ?V0 + 11,R5
   \   000012   89..         MOV     ?V0 + 9,R1
    984          #if defined ( ZCL_SIMPLE_METERING )
    985            // Upon receipt of the Get Profile Command, the metering device shall send
    986            // Get Profile Response back.
    987          
    988            // Variables in the following are initialized to arbitrary value for test purpose
    989            // In real application, user shall look up the interval data captured during
    990            // the period specified in the pCmd->endTime and return corresponding data.
    991          
    992            uint32 endTime;
    993            uint8  status = zclSE_SimpleMeter_GetProfileRsp_Status_Success;
   \   000014   75..00       MOV     ?V0 + 8,#0x0
    994            uint8  profileIntervalPeriod = PROFILE_INTERVAL_PERIOD_60MIN;
   \   000017   7F01         MOV     R7,#0x1
    995            uint8  numberOfPeriodDelivered = 5;
   \   000019   7E05         MOV     R6,#0x5
    996            uint24 intervals[] = {0xa00001, 0xa00002, 0xa00003, 0xa00004, 0xa00005};
   \   00001B   90....       MOV     DPTR,#`?<Constant {10485761L, 10485762L, 10485763L, 1`
   \   00001E   C082         PUSH    DPL
   \   000020   C083         PUSH    DPH
   \   000022   85..82       MOV     DPL,?XSP + 0
   \   000025   85..83       MOV     DPH,?XSP + 1
   \   000028   AC82         MOV     R4,DPL
   \   00002A   AD83         MOV     R5,DPH
   \   00002C   D083         POP     DPH
   \   00002E   D082         POP     DPL
   \   000030   7414         MOV     A,#0x14
   \   000032   12....       LCALL   ?MOVE_LONG8_XDATA_XDATA
    997          
    998            // endTime: 32 bit value (in UTC) representing the end time of the most
    999            // chronologically recent interval being requested.
   1000            // Example: Data collected from 2:00 PM to 3:00 PM would be specified as a
   1001            // 3:00 PM interval (end time).
   1002          
   1003            // The Intervals block returned shall be the most recent block with
   1004            // its EndTime equal or older to the one in the request (pCmd->endTime).
   1005            // Requested End Time with value 0xFFFFFFFF indicats the most recent
   1006            // Intervals block is requested.
   1007          
   1008            // Sample Code - assuming the end time of the requested block is the same as
   1009            // it in the request.
   1010            endTime = pCmd->endTime;
   \   000035   85..82       MOV     DPL,?V0 + 12
   \   000038   85..83       MOV     DPH,?V0 + 13
   \   00003B   A3           INC     DPTR
   \   00003C   78..         MOV     R0,#?V0 + 0
   \   00003E   12....       LCALL   ?L_MOV_X
   \   000041   85....       MOV     ?V0 + 4,?V0 + 0
   \   000044   85....       MOV     ?V0 + 5,?V0 + 1
   \   000047   85....       MOV     ?V0 + 6,?V0 + 2
   \   00004A   85....       MOV     ?V0 + 7,?V0 + 3
   1011          
   1012            // Send Get Profile Response Command back
   1013          
   1014            zclSE_SimpleMetering_Send_GetProfileRsp( ESP_ENDPOINT, srcAddr, endTime,
   1015                                                     status,
   1016                                                     profileIntervalPeriod,
   1017                                                     numberOfPeriodDelivered, intervals,
   1018                                                     FALSE, seqNum );
   \   00004D                ; Setup parameters for call to function zclSE_SimpleMetering_Send_GetProfileRsp
   \   00004D   E5..         MOV     A,?V0 + 9
   \   00004F   F5..         MOV     ?V0 + 0,A
   \   000051   78..         MOV     R0,#?V0 + 0
   \   000053   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000056   75..00       MOV     ?V0 + 0,#0x0
   \   000059   78..         MOV     R0,#?V0 + 0
   \   00005B   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00005E   7402         MOV     A,#0x2
   \   000060   12....       LCALL   ?XSTACK_DISP0_8
   \   000063   8582..       MOV     ?V0 + 0,DPL
   \   000066   8583..       MOV     ?V0 + 1,DPH
   \   000069   78..         MOV     R0,#?V0 + 0
   \   00006B   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00006E   EE           MOV     A,R6
   \   00006F   F5..         MOV     ?V0 + 0,A
   \   000071   78..         MOV     R0,#?V0 + 0
   \   000073   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000076   78..         MOV     R0,#?V0 + 4
   \   000078   12....       LCALL   ?PUSH_XSTACK_I_FOUR
   \   00007B   EF           MOV     A,R7
   \   00007C   FD           MOV     R5,A
   \   00007D   AC..         MOV     R4,?V0 + 8
   \   00007F   AA..         MOV     R2,?V0 + 10
   \   000081   AB..         MOV     R3,?V0 + 11
   \   000083   7909         MOV     R1,#0x9
   \   000085   12....       LCALL   ??zclSE_SimpleMetering_Send_GetProfileRsp?relay
   \   000088   7409         MOV     A,#0x9
   \   00008A   12....       LCALL   ?DEALLOC_XSTACK8
   \   00008D   E9           MOV     A,R1
   1019          #endif // ZCL_SIMPLE_METERING
   1020          }
   \   00008E   7414         MOV     A,#0x14
   \   000090   12....       LCALL   ?DEALLOC_XSTACK8
   \   000093   7F0E         MOV     R7,#0xe
   \   000095   02....       LJMP    ?BANKED_LEAVE_XDATA
   1021          
   1022          /*********************************************************************
   1023           * @fn      esp_GetProfileRspCB
   1024           *
   1025           * @brief   Callback from the ZCL SE Profile Simple Metering Cluster Library when
   1026           *          it received a Get Profile Response for
   1027           *          this application.
   1028           *
   1029           * @param   pCmd - pointer to structure for Get Profile Response command
   1030           * @param   srcAddr - pointer to source address
   1031           * @param   seqNum - sequence number of this command
   1032           *
   1033           * @return  none
   1034           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1035          static void esp_GetProfileRspCB( zclCCGetProfileRsp_t *pCmd,
   \                     esp_GetProfileRspCB:
   1036                                           afAddrType_t *srcAddr, uint8 seqNum )
   1037          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   1038            // add user code here
   1039          }
   \   000000   02....       LJMP    ?BRET
   1040          
   1041          /*********************************************************************
   1042           * @fn      esp_ReqMirrorCmdCB
   1043           *
   1044           * @brief   Callback from the ZCL SE Profile Simple Metering Cluster Library when
   1045           *          it received a Request Mirror Command for
   1046           *          this application.
   1047           *
   1048           * @param   srcAddr - pointer to source address
   1049           * @param   seqNum - sequence number of this command
   1050           *
   1051           * @return  none
   1052           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1053          static void esp_ReqMirrorCmdCB( afAddrType_t *srcAddr, uint8 seqNum )
   \                     esp_ReqMirrorCmdCB:
   1054          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   1055          #if defined ( ZCL_SIMPLE_METERING )
   1056          #if defined ( SE_UK_EXT ) && defined ( SE_MIRROR )
   1057            uint8 endpoint;
   1058          
   1059            // See if a mirror exists for the given source address and endpoint
   1060            endpoint = esp_GetMirrorEndpoint( srcAddr );
   1061          
   1062            if ( endpoint == ESP_MIRROR_INVALID_ENDPOINT )
   1063            {
   1064              // No endpoint exists.  Try allocating one.
   1065              endpoint = esp_AllocMirror(srcAddr);
   1066          
   1067              if (endpoint != ESP_MIRROR_INVALID_ENDPOINT)
   1068              {
   1069                // Setup endpoint
   1070                espMirrorInfo_t *pInfo = esp_GetMirrorInfo(endpoint);
   1071          
   1072                if ( pInfo != NULL )
   1073                {
   1074                  // Create a simple descriptor for the mirror
   1075                  SimpleDescriptionFormat_t *pMirrorSimpleDesc = osal_mem_alloc( sizeof( SimpleDescriptionFormat_t ) );
   1076          
   1077                  if ( pMirrorSimpleDesc != NULL )
   1078                  {
   1079                    zclAttrRec_t *pAttr = pInfo->pAttr;
   1080          
   1081                    pMirrorSimpleDesc->EndPoint = endpoint;
   1082                    pMirrorSimpleDesc->AppProfId = ZCL_SE_PROFILE_ID;
   1083                    pMirrorSimpleDesc->AppDeviceId = ZCL_SE_DEVICEID_METER;
   1084                    pMirrorSimpleDesc->AppDevVer = MIRROR_DEVICE_VERSION;
   1085                    pMirrorSimpleDesc->Reserved = MIRROR_FLAGS;
   1086                    pMirrorSimpleDesc->AppNumInClusters = MIRROR_MAX_INCLUSTERS;
   1087                    pMirrorSimpleDesc->pAppInClusterList = (cId_t *) mirrorInClusterList;
   1088                    pMirrorSimpleDesc->AppNumOutClusters = MIRROR_MAX_OUTCLUSTERS;
   1089                    pMirrorSimpleDesc->pAppOutClusterList = (cId_t *) mirrorOutClusterList;
   1090          
   1091                    zclSE_Init( pMirrorSimpleDesc );
   1092          
   1093                    // Register the attribute list
   1094                    zcl_registerAttrList( endpoint, ESP_MIRROR_MAX_ATTRIBUTES, (CONST zclAttrRec_t *) pAttr );
   1095                  }
   1096                  else
   1097                  {
   1098                    esp_FreeMirror( endpoint );
   1099                    endpoint = ESP_MIRROR_INVALID_ENDPOINT;
   1100                  }
   1101                }
   1102              }
   1103            }
   1104          
   1105            if ( endpoint != ESP_MIRROR_INVALID_ENDPOINT )
   1106            {
   1107              // Send response to the peer with the mirror endpoint ID
   1108              zclSE_SimpleMetering_Send_ReqMirrorRsp( ESP_ENDPOINT, srcAddr, endpoint, TRUE, seqNum );
   1109            }
   1110            else
   1111            {
   1112              // Send response indicating we cannot create the mirror
   1113              zclSE_SimpleMetering_Send_ReqMirrorRsp(ESP_ENDPOINT, srcAddr, 0xFFFF, TRUE, seqNum);
   1114            }
   1115          #endif  // SE_UK_EXT && SE_MIRROR
   1116          #endif  // ZCL_SIMPLE_METERING
   1117          }
   \   000000   02....       LJMP    ?BRET
   1118          /*********************************************************************
   1119           * @fn      esp_ReqMirrorRspCB
   1120           *
   1121           * @brief   Callback from the ZCL SE Profile Simple Metering Cluster Library when
   1122           *          it received a Request Mirror Response for
   1123           *          this application.
   1124           *
   1125           * @param   pCmd - pointer to structure for Request Mirror Response command
   1126           * @param   srcAddr - pointer to source address
   1127           * @param   seqNum - sequence number of this command
   1128           *
   1129           * @return  none
   1130           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1131          static void esp_ReqMirrorRspCB( zclCCReqMirrorRsp_t *pCmd,
   \                     esp_ReqMirrorRspCB:
   1132                                          afAddrType_t *srcAddr, uint8 seqNum )
   1133          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   1134            // add user code here
   1135          }
   \   000000   02....       LJMP    ?BRET
   1136          
   1137          /*********************************************************************
   1138           * @fn      esp_MirrorRemCmdCB
   1139           *
   1140           * @brief   Callback from the ZCL SE Profile Simple Metering Cluster Library when
   1141           *          it received a Mirror Remove Command for
   1142           *          this application.
   1143           *
   1144           * @param   srcAddr - pointer to source address
   1145           * @param   seqNum - sequence number of this command
   1146           *
   1147           * @return  none
   1148           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1149          static void esp_MirrorRemCmdCB( afAddrType_t *srcAddr, uint8 seqNum )
   \                     esp_MirrorRemCmdCB:
   1150          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   1151          #if defined ( ZCL_SIMPLE_METERING )
   1152          #if defined ( SE_UK_EXT ) && defined ( SE_MIRROR )
   1153            // Check if this is a valid endpoint for a mirror
   1154            uint8 endpoint = esp_GetMirrorEndpoint( srcAddr );
   1155          
   1156            if ( endpoint != ESP_MIRROR_INVALID_ENDPOINT )
   1157            {
   1158              // Set the PhysicalEnvironment attribute indicating a mirror slot is available
   1159              espPhysicalEnvironment |= PHY_MIRROR_CAPACITY_ENV;
   1160          
   1161              endPointDesc_t *epDesc = afFindEndPointDesc( endpoint );
   1162          
   1163              // Free memory allocated for SimpleDescriptor in esp_ReqMirrorCmdCB()
   1164              if ( epDesc->simpleDesc != NULL )
   1165              {
   1166                osal_mem_free( epDesc->simpleDesc );
   1167              }
   1168          
   1169              // Delete endpoint completely
   1170              afDelete( endpoint );
   1171          
   1172              // Free the mirror in the mirror control block
   1173              esp_FreeMirror( endpoint );
   1174          
   1175              // Send response to peer
   1176              zclSE_SimpleMetering_Send_RemMirrorRsp( ESP_ENDPOINT, srcAddr, endpoint, TRUE, seqNum );
   1177            }
   1178            else
   1179            {
   1180              // The specification does not state how to deal with the case where no mirror exists,
   1181              // For now, send 0xFFFF in the endpoint.
   1182              zclSE_SimpleMetering_Send_RemMirrorRsp( ESP_ENDPOINT, srcAddr, 0xFFFF, TRUE, seqNum );
   1183            }
   1184          #endif  // SE_UK_EXT && SE_MIRROR
   1185          #endif  // ZCL_SIMPLE_METERING
   1186          }
   \   000000   02....       LJMP    ?BRET
   1187          
   1188          /*********************************************************************
   1189           * @fn      esp_MirrorRemRspCB
   1190           *
   1191           * @brief   Callback from the ZCL SE Profile Simple Metering Cluster Library when
   1192           *          it received a Mirror Remove Response for
   1193           *          this application.
   1194           *
   1195           * @param   pCmd - pointer to structure for Mirror Remove Response command
   1196           * @param   srcAddr - pointer to source address
   1197           * @param   seqNum - sequence number of this command
   1198           *
   1199           * @return  none
   1200           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1201          static void esp_MirrorRemRspCB( zclCCMirrorRemRsp_t *pCmd,
   \                     esp_MirrorRemRspCB:
   1202                                          afAddrType_t *srcAddr, uint8 seqNum )
   1203          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   1204            // add user code here
   1205          }
   \   000000   02....       LJMP    ?BRET
   1206          
   1207          /*********************************************************************
   1208           * @fn      esp_ReqFastPollModeCmdCB
   1209           *
   1210           * @brief   Callback from the ZCL SE Profile Simple Metering Cluster Library when
   1211           *          it received a Request Fast Poll Mode Command for
   1212           *          this application.
   1213           *
   1214           * @param   pCmd - pointer to structure for Request Fast Poll Mode command
   1215           * @param   srcAddr - pointer to source address
   1216           * @param   seqNum - sequence number of this command
   1217           *
   1218           * @return  none
   1219           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1220          static void esp_ReqFastPollModeCmdCB( zclCCReqFastPollModeCmd_t *pCmd, afAddrType_t *srcAddr, uint8 seqNum )
   \                     esp_ReqFastPollModeCmdCB:
   1221          {
   \   000000   74E8         MOV     A,#-0x18
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 24
   \   000005                ; Auto size: 5
   \   000005   74FB         MOV     A,#-0x5
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   \   00000E   8C..         MOV     ?V0 + 14,R4
   \   000010   8D..         MOV     ?V0 + 15,R5
   \   000012   89..         MOV     ?V0 + 12,R1
   1222          #if defined ( ZCL_SIMPLE_METERING )
   1223            if ( pCmd != NULL )
   \   000014   EE           MOV     A,R6
   \   000015   4F           ORL     A,R7
   \   000016   7003         JNZ     $+5
   \   000018   02....       LJMP    ??esp_ReqFastPollModeCmdCB_0 & 0xFFFF
   1224            {
   1225              zclCCReqFastPollModeRsp_t fastPollRsp;
   1226              UTCTime utcSecs;
   1227          
   1228              if (pCmd->fastPollUpdatePeriod < espFastPollUpdatePeriod)
   \   00001B   90....       MOV     DPTR,#espFastPollUpdatePeriod
   \   00001E   E0           MOVX    A,@DPTR
   \   00001F   F8           MOV     R0,A
   \   000020   8E82         MOV     DPL,R6
   \   000022   8F83         MOV     DPH,R7
   \   000024   E0           MOVX    A,@DPTR
   \   000025   C3           CLR     C
   \   000026   98           SUBB    A,R0
   \   000027   500D         JNC     ??esp_ReqFastPollModeCmdCB_1
   1229              {
   1230                // handles client requests for a fast poll rate that is less than the
   1231                // value of the its FastPollUpdateRate attribute
   1232                fastPollRsp.appliedUpdatePeriod = espFastPollUpdatePeriod;
   \   000029   90....       MOV     DPTR,#espFastPollUpdatePeriod
   \   00002C   E0           MOVX    A,@DPTR
   \   00002D   85..82       MOV     DPL,?XSP + 0
   \   000030   85..83       MOV     DPH,?XSP + 1
   \   000033   F0           MOVX    @DPTR,A
   \   000034   800C         SJMP    ??esp_ReqFastPollModeCmdCB_2
   1233              }
   1234              else
   1235              {
   1236                fastPollRsp.appliedUpdatePeriod = pCmd->fastPollUpdatePeriod;
   \                     ??esp_ReqFastPollModeCmdCB_1:
   \   000036   8E82         MOV     DPL,R6
   \   000038   8F83         MOV     DPH,R7
   \   00003A   E0           MOVX    A,@DPTR
   \   00003B   85..82       MOV     DPL,?XSP + 0
   \   00003E   85..83       MOV     DPH,?XSP + 1
   \   000041   F0           MOVX    @DPTR,A
   1237              }
   1238          
   1239              if ((espFastPollModeDuration == 0) && (pCmd->duration > 0))
   \                     ??esp_ReqFastPollModeCmdCB_2:
   \   000042   90....       MOV     DPTR,#espFastPollModeDuration
   \   000045   E0           MOVX    A,@DPTR
   \   000046   F8           MOV     R0,A
   \   000047   A3           INC     DPTR
   \   000048   E0           MOVX    A,@DPTR
   \   000049   F9           MOV     R1,A
   \   00004A   E8           MOV     A,R0
   \   00004B   49           ORL     A,R1
   \   00004C   7068         JNZ     ??esp_ReqFastPollModeCmdCB_3
   \   00004E   8E82         MOV     DPL,R6
   \   000050   8F83         MOV     DPH,R7
   \   000052   A3           INC     DPTR
   \   000053   E0           MOVX    A,@DPTR
   \   000054   C3           CLR     C
   \   000055   9401         SUBB    A,#0x1
   \   000057   405D         JC      ??esp_ReqFastPollModeCmdCB_3
   1240              {
   1241                if (pCmd->duration > MAX_DURATION_IN_MINUTES_FAST_POLL_MODE)
   \   000059   8E82         MOV     DPL,R6
   \   00005B   8F83         MOV     DPH,R7
   \   00005D   A3           INC     DPTR
   \   00005E   E0           MOVX    A,@DPTR
   \   00005F   C3           CLR     C
   \   000060   9410         SUBB    A,#0x10
   \   000062   400C         JC      ??esp_ReqFastPollModeCmdCB_4
   1242                {
   1243                  // handles client requests for duration that is greater than the
   1244                  // maximum allowable 15 minutes.
   1245                  espFastPollModeDuration = MAX_DURATION_IN_MINUTES_FAST_POLL_MODE;
   \   000064   90....       MOV     DPTR,#espFastPollModeDuration
   \   000067   740F         MOV     A,#0xf
   \   000069   F0           MOVX    @DPTR,A
   \   00006A   A3           INC     DPTR
   \   00006B   7400         MOV     A,#0x0
   \   00006D   F0           MOVX    @DPTR,A
   \   00006E   8010         SJMP    ??esp_ReqFastPollModeCmdCB_5
   1246                }
   1247                else
   1248                {
   1249                  espFastPollModeDuration = pCmd->duration;
   \                     ??esp_ReqFastPollModeCmdCB_4:
   \   000070   8E82         MOV     DPL,R6
   \   000072   8F83         MOV     DPH,R7
   \   000074   A3           INC     DPTR
   \   000075   E0           MOVX    A,@DPTR
   \   000076   F8           MOV     R0,A
   \   000077   7900         MOV     R1,#0x0
   \   000079   90....       MOV     DPTR,#espFastPollModeDuration
   \   00007C   F0           MOVX    @DPTR,A
   \   00007D   A3           INC     DPTR
   \   00007E   E9           MOV     A,R1
   \   00007F   F0           MOVX    @DPTR,A
   1250                }
   1251          
   1252                // This controls the counter for ZCLTESTAPP_FAST_POLL_MODE_EVT based on a 1 second timer
   1253                espFastPollModeDuration *= 60;  // Duration in seconds
   \                     ??esp_ReqFastPollModeCmdCB_5:
   \   000080   90....       MOV     DPTR,#espFastPollModeDuration
   \   000083   E0           MOVX    A,@DPTR
   \   000084   F8           MOV     R0,A
   \   000085   A3           INC     DPTR
   \   000086   E0           MOVX    A,@DPTR
   \   000087   F9           MOV     R1,A
   \   000088   E8           MOV     A,R0
   \   000089   75F03C       MOV     B,#0x3c
   \   00008C   A4           MUL     AB
   \   00008D   C8           XCH     A,R0
   \   00008E   AAF0         MOV     R2,B
   \   000090   75F000       MOV     B,#0x0
   \   000093   A4           MUL     AB
   \   000094   2A           ADD     A,R2
   \   000095   FA           MOV     R2,A
   \   000096   75F03C       MOV     B,#0x3c
   \   000099   E9           MOV     A,R1
   \   00009A   A4           MUL     AB
   \   00009B   2A           ADD     A,R2
   \   00009C   F9           MOV     R1,A
   \   00009D   90....       MOV     DPTR,#espFastPollModeDuration
   \   0000A0   E8           MOV     A,R0
   \   0000A1   F0           MOVX    @DPTR,A
   \   0000A2   A3           INC     DPTR
   \   0000A3   E9           MOV     A,R1
   \   0000A4   F0           MOVX    @DPTR,A
   1254          
   1255                // Start the timer for the fast poll period
   1256                osal_start_timerEx( espTaskID, ESP_FAST_POLL_MODE_EVT, ESP_FAST_POLL_TIMER_PERIOD );
   \   0000A5                ; Setup parameters for call to function osal_start_timerEx
   \   0000A5   7CE8         MOV     R4,#-0x18
   \   0000A7   7D03         MOV     R5,#0x3
   \   0000A9   7A08         MOV     R2,#0x8
   \   0000AB   7B00         MOV     R3,#0x0
   \   0000AD   90....       MOV     DPTR,#espTaskID
   \   0000B0   E0           MOVX    A,@DPTR
   \   0000B1   F9           MOV     R1,A
   \   0000B2   12....       LCALL   ??osal_start_timerEx?relay
   \   0000B5   E9           MOV     A,R1
   1257              }
   1258          
   1259              // get UTC time and update with requested duration in seconds
   1260              utcSecs = osal_getClock();
   \                     ??esp_ReqFastPollModeCmdCB_3:
   \   0000B6                ; Setup parameters for call to function osal_getClock
   \   0000B6   12....       LCALL   ??osal_getClock?relay
   \   0000B9   8A..         MOV     ?V0 + 0,R2
   \   0000BB   8B..         MOV     ?V0 + 1,R3
   \   0000BD   8C..         MOV     ?V0 + 2,R4
   \   0000BF   8D..         MOV     ?V0 + 3,R5
   \   0000C1   85....       MOV     ?V0 + 4,?V0 + 0
   \   0000C4   85....       MOV     ?V0 + 5,?V0 + 1
   \   0000C7   85....       MOV     ?V0 + 6,?V0 + 2
   \   0000CA   85....       MOV     ?V0 + 7,?V0 + 3
   1261              fastPollRsp.fastPollModeEndTime = utcSecs + espFastPollModeDuration;
   \   0000CD   85....       MOV     ?V0 + 0,?V0 + 4
   \   0000D0   85....       MOV     ?V0 + 1,?V0 + 5
   \   0000D3   85....       MOV     ?V0 + 2,?V0 + 6
   \   0000D6   85....       MOV     ?V0 + 3,?V0 + 7
   \   0000D9   90....       MOV     DPTR,#espFastPollModeDuration
   \   0000DC   E0           MOVX    A,@DPTR
   \   0000DD   F5..         MOV     ?V0 + 8,A
   \   0000DF   A3           INC     DPTR
   \   0000E0   E0           MOVX    A,@DPTR
   \   0000E1   F5..         MOV     ?V0 + 9,A
   \   0000E3   E4           CLR     A
   \   0000E4   F5..         MOV     ?V0 + 10,A
   \   0000E6   F5..         MOV     ?V0 + 11,A
   \   0000E8   78..         MOV     R0,#?V0 + 0
   \   0000EA   79..         MOV     R1,#?V0 + 8
   \   0000EC   12....       LCALL   ?L_ADD
   \   0000EF   7401         MOV     A,#0x1
   \   0000F1   12....       LCALL   ?XSTACK_DISP0_8
   \   0000F4   78..         MOV     R0,#?V0 + 0
   \   0000F6   12....       LCALL   ?L_MOV_TO_X
   1262          
   1263              zclSE_SimpleMetering_Send_ReqFastPollModeRsp( ESP_ENDPOINT, srcAddr,
   1264                                                            &fastPollRsp,
   1265                                                            TRUE, seqNum );
   \   0000F9                ; Setup parameters for call to function zclSE_SimpleMetering_Send_ReqFastPollModeRsp
   \   0000F9   E5..         MOV     A,?V0 + 12
   \   0000FB   F5..         MOV     ?V0 + 0,A
   \   0000FD   78..         MOV     R0,#?V0 + 0
   \   0000FF   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000102   75..01       MOV     ?V0 + 0,#0x1
   \   000105   78..         MOV     R0,#?V0 + 0
   \   000107   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00010A   7402         MOV     A,#0x2
   \   00010C   12....       LCALL   ?XSTACK_DISP0_8
   \   00010F   AC82         MOV     R4,DPL
   \   000111   AD83         MOV     R5,DPH
   \   000113   AA..         MOV     R2,?V0 + 14
   \   000115   AB..         MOV     R3,?V0 + 15
   \   000117   7909         MOV     R1,#0x9
   \   000119   12....       LCALL   ??zclSE_SimpleMetering_Send_ReqFastPollModeRsp?
   \   00011C   7402         MOV     A,#0x2
   \   00011E   12....       LCALL   ?DEALLOC_XSTACK8
   \   000121   E9           MOV     A,R1
   1266          
   1267          #if defined ( LCD_SUPPORTED )
   1268              HalLcdWriteString("Fast Polling", HAL_LCD_LINE_1);
   \   000122                ; Setup parameters for call to function HalLcdWriteString
   \   000122   7901         MOV     R1,#0x1
   \   000124   7A..         MOV     R2,#`?<Constant "Fast Polling">` & 0xff
   \   000126   7B..         MOV     R3,#(`?<Constant "Fast Polling">` >> 8) & 0xff
   \   000128   12....       LCALL   ??HalLcdWriteString?relay
   1269              HalLcdWriteStringValue("Cur 0x", utcSecs, 16, HAL_LCD_LINE_2 );
   \   00012B                ; Setup parameters for call to function HalLcdWriteStringValue
   \   00012B   75..02       MOV     ?V0 + 0,#0x2
   \   00012E   78..         MOV     R0,#?V0 + 0
   \   000130   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000133   7910         MOV     R1,#0x10
   \   000135   85....       MOV     ?V0 + 0,?V0 + 4
   \   000138   85....       MOV     ?V0 + 1,?V0 + 5
   \   00013B   AC..         MOV     R4,?V0 + 0
   \   00013D   AD..         MOV     R5,?V0 + 1
   \   00013F   7A..         MOV     R2,#`?<Constant "Cur 0x">` & 0xff
   \   000141   7B..         MOV     R3,#(`?<Constant "Cur 0x">` >> 8) & 0xff
   \   000143   12....       LCALL   ??HalLcdWriteStringValue?relay
   \   000146   7401         MOV     A,#0x1
   \   000148   12....       LCALL   ?DEALLOC_XSTACK8
   1270              HalLcdWriteStringValue("End 0x", fastPollRsp.fastPollModeEndTime, 16, HAL_LCD_LINE_3 );
   \   00014B                ; Setup parameters for call to function HalLcdWriteStringValue
   \   00014B   75..03       MOV     ?V0 + 0,#0x3
   \   00014E   78..         MOV     R0,#?V0 + 0
   \   000150   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000153   7910         MOV     R1,#0x10
   \   000155   7402         MOV     A,#0x2
   \   000157   12....       LCALL   ?XSTACK_DISP0_8
   \   00015A   78..         MOV     R0,#?V0 + 0
   \   00015C   12....       LCALL   ?L_MOV_X
   \   00015F   AC..         MOV     R4,?V0 + 0
   \   000161   AD..         MOV     R5,?V0 + 1
   \   000163   7A..         MOV     R2,#`?<Constant "End 0x">` & 0xff
   \   000165   7B..         MOV     R3,#(`?<Constant "End 0x">` >> 8) & 0xff
   \   000167   12....       LCALL   ??HalLcdWriteStringValue?relay
   \   00016A   7401         MOV     A,#0x1
   \   00016C   12....       LCALL   ?DEALLOC_XSTACK8
   1271          #endif
   1272            }
   1273          #endif // ZCL_SIMPLE_METERING
   1274          }
   \                     ??esp_ReqFastPollModeCmdCB_0:
   \   00016F   7405         MOV     A,#0x5
   \   000171   12....       LCALL   ?DEALLOC_XSTACK8
   \   000174   7F10         MOV     R7,#0x10
   \   000176   02....       LJMP    ?BANKED_LEAVE_XDATA
   1275          
   1276          /*********************************************************************
   1277           * @fn      esp_ReqFastPollModeRspCB
   1278           *
   1279           * @brief   Callback from the ZCL SE Profile Simple Metering Cluster Library when
   1280           *          it received a Request Fast Poll Mode Response for
   1281           *          this application.
   1282           *
   1283           * @param   pRsp - pointer to structure for Request Fast Poll Mode Response command
   1284           * @param   srcAddr - pointer to source address
   1285           * @param   seqNum - sequence number of this command
   1286           *
   1287           * @return  none
   1288           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1289          static void esp_ReqFastPollModeRspCB( zclCCReqFastPollModeRsp_t *pRsp,
   \                     esp_ReqFastPollModeRspCB:
   1290                                                afAddrType_t *srcAddr, uint8 seqNum )
   1291          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   1292            // add user code here
   1293          }
   \   000000   02....       LJMP    ?BRET
   1294          
   1295          /*********************************************************************
   1296           * @fn      esp_GetCurrentPriceCB
   1297           *
   1298           * @brief   Callback from the ZCL SE Profile Pricing Cluster Library when
   1299           *          it received a Get Current Price for
   1300           *          this application.
   1301           *
   1302           * @param   pCmd - pointer to structure for Get Current Price command
   1303           * @param   srcAddr - pointer to source address
   1304           * @param   seqNum - sequence number for this command
   1305           *
   1306           * @return  none
   1307           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1308          static void esp_GetCurrentPriceCB( zclCCGetCurrentPrice_t *pCmd,
   \                     esp_GetCurrentPriceCB:
   1309                                                   afAddrType_t *srcAddr, uint8 seqNum )
   1310          {
   \   000000   74F1         MOV     A,#-0xf
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 15
   \   000005                ; Auto size: 44
   \   000005   74D4         MOV     A,#-0x2c
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V0 + 2,R2
   \   00000C   8B..         MOV     ?V0 + 3,R3
   \   00000E   8C..         MOV     ?V0 + 0,R4
   \   000010   8D..         MOV     ?V0 + 1,R5
   \   000012   E9           MOV     A,R1
   \   000013   FE           MOV     R6,A
   1311          #if defined ( ZCL_PRICING )
   1312            // On receipt of Get Current Price command, the device shall send a
   1313            // Publish Price command with the information for the current time.
   1314            zclCCPublishPrice_t cmd;
   1315            uint8 rateLabelLen = 4; // adjust this value if different label is set, test label "BASE"
   \   000014   7F04         MOV     R7,#0x4
   1316          
   1317            osal_memset( &cmd, 0, sizeof( zclCCPublishPrice_t ) );
   \   000016                ; Setup parameters for call to function osal_memset
   \   000016   7C2C         MOV     R4,#0x2c
   \   000018   7D00         MOV     R5,#0x0
   \   00001A   7900         MOV     R1,#0x0
   \   00001C   85..82       MOV     DPL,?XSP + 0
   \   00001F   85..83       MOV     DPH,?XSP + 1
   \   000022   AA82         MOV     R2,DPL
   \   000024   AB83         MOV     R3,DPH
   \   000026   12....       LCALL   ??osal_memset?relay
   1318          
   1319            // Set Pricing information
   1320            cmd.providerId = 0xbabeface;
   \   000029   7ACE         MOV     R2,#-0x32
   \   00002B   7BFA         MOV     R3,#-0x6
   \   00002D   7CBE         MOV     R4,#-0x42
   \   00002F   7DBA         MOV     R5,#-0x46
   \   000031   85..82       MOV     DPL,?XSP + 0
   \   000034   85..83       MOV     DPH,?XSP + 1
   \   000037   EA           MOV     A,R2
   \   000038   F0           MOVX    @DPTR,A
   \   000039   A3           INC     DPTR
   \   00003A   EB           MOV     A,R3
   \   00003B   F0           MOVX    @DPTR,A
   \   00003C   A3           INC     DPTR
   \   00003D   EC           MOV     A,R4
   \   00003E   F0           MOVX    @DPTR,A
   \   00003F   A3           INC     DPTR
   \   000040   ED           MOV     A,R5
   \   000041   F0           MOVX    @DPTR,A
   1321            cmd.rateLabel.pStr = (uint8 *)osal_mem_alloc(rateLabelLen);
   \   000042                ; Setup parameters for call to function osal_mem_alloc
   \   000042   8F..         MOV     ?V0 + 4,R7
   \   000044   75..00       MOV     ?V0 + 5,#0x0
   \   000047   AA..         MOV     R2,?V0 + 4
   \   000049   AB..         MOV     R3,?V0 + 5
   \   00004B   12....       LCALL   ??osal_mem_alloc?relay
   \   00004E   7405         MOV     A,#0x5
   \   000050   12....       LCALL   ?XSTACK_DISP0_8
   \   000053   EA           MOV     A,R2
   \   000054   F0           MOVX    @DPTR,A
   \   000055   A3           INC     DPTR
   \   000056   EB           MOV     A,R3
   \   000057   F0           MOVX    @DPTR,A
   1322            if (cmd.rateLabel.pStr != NULL)
   \   000058   7405         MOV     A,#0x5
   \   00005A   12....       LCALL   ?XSTACK_DISP0_8
   \   00005D   E0           MOVX    A,@DPTR
   \   00005E   F8           MOV     R0,A
   \   00005F   A3           INC     DPTR
   \   000060   E0           MOVX    A,@DPTR
   \   000061   F9           MOV     R1,A
   \   000062   E8           MOV     A,R0
   \   000063   49           ORL     A,R1
   \   000064   6034         JZ      ??esp_GetCurrentPriceCB_0
   1323            {
   1324              cmd.rateLabel.strLen = rateLabelLen;
   \   000066   EF           MOV     A,R7
   \   000067   C0E0         PUSH    A
   \   000069   7404         MOV     A,#0x4
   \   00006B   12....       LCALL   ?XSTACK_DISP0_8
   \   00006E   D0E0         POP     A
   \   000070   F0           MOVX    @DPTR,A
   1325              osal_memcpy(cmd.rateLabel.pStr, "BASE", rateLabelLen);
   \   000071                ; Setup parameters for call to function osal_memcpy
   \   000071   75....       MOV     ?V0 + 4,#`?<Constant "BASE">` & 0xff
   \   000074   75....       MOV     ?V0 + 5,#(`?<Constant "BASE">` >> 8) & 0xff
   \   000077   75..00       MOV     ?V0 + 6,#0x0
   \   00007A   78..         MOV     R0,#?V0 + 4
   \   00007C   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   00007F   8F..         MOV     ?V0 + 4,R7
   \   000081   75..00       MOV     ?V0 + 5,#0x0
   \   000084   AC..         MOV     R4,?V0 + 4
   \   000086   AD..         MOV     R5,?V0 + 5
   \   000088   7408         MOV     A,#0x8
   \   00008A   12....       LCALL   ?XSTACK_DISP0_8
   \   00008D   E0           MOVX    A,@DPTR
   \   00008E   FA           MOV     R2,A
   \   00008F   A3           INC     DPTR
   \   000090   E0           MOVX    A,@DPTR
   \   000091   FB           MOV     R3,A
   \   000092   12....       LCALL   ??osal_memcpy?relay
   \   000095   7403         MOV     A,#0x3
   \   000097   12....       LCALL   ?DEALLOC_XSTACK8
   1326            }
   1327            cmd.issuerEventId = 0x00000000;
   \                     ??esp_GetCurrentPriceCB_0:
   \   00009A   7A00         MOV     R2,#0x0
   \   00009C   7B00         MOV     R3,#0x0
   \   00009E   7C00         MOV     R4,#0x0
   \   0000A0   7D00         MOV     R5,#0x0
   \   0000A2   7407         MOV     A,#0x7
   \   0000A4   12....       LCALL   ?XSTACK_DISP0_8
   \   0000A7   EA           MOV     A,R2
   \   0000A8   F0           MOVX    @DPTR,A
   \   0000A9   A3           INC     DPTR
   \   0000AA   EB           MOV     A,R3
   \   0000AB   F0           MOVX    @DPTR,A
   \   0000AC   A3           INC     DPTR
   \   0000AD   EC           MOV     A,R4
   \   0000AE   F0           MOVX    @DPTR,A
   \   0000AF   A3           INC     DPTR
   \   0000B0   ED           MOV     A,R5
   \   0000B1   F0           MOVX    @DPTR,A
   1328            cmd.currentTime = osal_getClock();
   \   0000B2                ; Setup parameters for call to function osal_getClock
   \   0000B2   12....       LCALL   ??osal_getClock?relay
   \   0000B5   740B         MOV     A,#0xb
   \   0000B7   12....       LCALL   ?XSTACK_DISP0_8
   \   0000BA   12....       LCALL   ?XSTORE_R2345
   1329            cmd.unitOfMeasure = 0x00;
   \   0000BD   740F         MOV     A,#0xf
   \   0000BF   12....       LCALL   ?XSTACK_DISP0_8
   \   0000C2   7400         MOV     A,#0x0
   \   0000C4   F0           MOVX    @DPTR,A
   1330            cmd.currency = 0x0348;
   \   0000C5   7410         MOV     A,#0x10
   \   0000C7   12....       LCALL   ?XSTACK_DISP0_8
   \   0000CA   7448         MOV     A,#0x48
   \   0000CC   F0           MOVX    @DPTR,A
   \   0000CD   A3           INC     DPTR
   \   0000CE   7403         MOV     A,#0x3
   \   0000D0   F0           MOVX    @DPTR,A
   1331            cmd.priceTrailingDigit = 0x11;
   \   0000D1   7412         MOV     A,#0x12
   \   0000D3   12....       LCALL   ?XSTACK_DISP0_8
   \   0000D6   7411         MOV     A,#0x11
   \   0000D8   F0           MOVX    @DPTR,A
   1332            cmd.numberOfPriceTiers = 0x21;
   \   0000D9   7413         MOV     A,#0x13
   \   0000DB   12....       LCALL   ?XSTACK_DISP0_8
   \   0000DE   7421         MOV     A,#0x21
   \   0000E0   F0           MOVX    @DPTR,A
   1333            cmd.startTime = 0x00000000;
   \   0000E1   7A00         MOV     R2,#0x0
   \   0000E3   7B00         MOV     R3,#0x0
   \   0000E5   7C00         MOV     R4,#0x0
   \   0000E7   7D00         MOV     R5,#0x0
   \   0000E9   7414         MOV     A,#0x14
   \   0000EB   12....       LCALL   ?XSTACK_DISP0_8
   \   0000EE   EA           MOV     A,R2
   \   0000EF   F0           MOVX    @DPTR,A
   \   0000F0   A3           INC     DPTR
   \   0000F1   EB           MOV     A,R3
   \   0000F2   F0           MOVX    @DPTR,A
   \   0000F3   A3           INC     DPTR
   \   0000F4   EC           MOV     A,R4
   \   0000F5   F0           MOVX    @DPTR,A
   \   0000F6   A3           INC     DPTR
   \   0000F7   ED           MOV     A,R5
   \   0000F8   F0           MOVX    @DPTR,A
   1334            cmd.durationInMinutes = 0x003C;
   \   0000F9   7418         MOV     A,#0x18
   \   0000FB   12....       LCALL   ?XSTACK_DISP0_8
   \   0000FE   743C         MOV     A,#0x3c
   \   000100   F0           MOVX    @DPTR,A
   \   000101   A3           INC     DPTR
   \   000102   7400         MOV     A,#0x0
   \   000104   F0           MOVX    @DPTR,A
   1335            cmd.price = 0x00000018;
   \   000105   7A18         MOV     R2,#0x18
   \   000107   7B00         MOV     R3,#0x0
   \   000109   7C00         MOV     R4,#0x0
   \   00010B   7D00         MOV     R5,#0x0
   \   00010D   741A         MOV     A,#0x1a
   \   00010F   12....       LCALL   ?XSTACK_DISP0_8
   \   000112   EA           MOV     A,R2
   \   000113   F0           MOVX    @DPTR,A
   \   000114   A3           INC     DPTR
   \   000115   EB           MOV     A,R3
   \   000116   F0           MOVX    @DPTR,A
   \   000117   A3           INC     DPTR
   \   000118   EC           MOV     A,R4
   \   000119   F0           MOVX    @DPTR,A
   \   00011A   A3           INC     DPTR
   \   00011B   ED           MOV     A,R5
   \   00011C   F0           MOVX    @DPTR,A
   1336            cmd.priceRatio = SE_OPTIONAL_FIELD_UINT8;
   \   00011D   741E         MOV     A,#0x1e
   \   00011F   12....       LCALL   ?XSTACK_DISP0_8
   \   000122   74FF         MOV     A,#-0x1
   \   000124   F0           MOVX    @DPTR,A
   1337            cmd.generationPrice = SE_OPTIONAL_FIELD_UINT32;
   \   000125   7AFF         MOV     R2,#-0x1
   \   000127   7BFF         MOV     R3,#-0x1
   \   000129   7CFF         MOV     R4,#-0x1
   \   00012B   7DFF         MOV     R5,#-0x1
   \   00012D   741F         MOV     A,#0x1f
   \   00012F   12....       LCALL   ?XSTACK_DISP0_8
   \   000132   EA           MOV     A,R2
   \   000133   F0           MOVX    @DPTR,A
   \   000134   A3           INC     DPTR
   \   000135   EB           MOV     A,R3
   \   000136   F0           MOVX    @DPTR,A
   \   000137   A3           INC     DPTR
   \   000138   EC           MOV     A,R4
   \   000139   F0           MOVX    @DPTR,A
   \   00013A   A3           INC     DPTR
   \   00013B   ED           MOV     A,R5
   \   00013C   F0           MOVX    @DPTR,A
   1338            cmd.generationPriceRatio = SE_OPTIONAL_FIELD_UINT8;
   \   00013D   7423         MOV     A,#0x23
   \   00013F   12....       LCALL   ?XSTACK_DISP0_8
   \   000142   74FF         MOV     A,#-0x1
   \   000144   F0           MOVX    @DPTR,A
   1339            cmd.alternateCostDelivered = SE_OPTIONAL_FIELD_UINT32;
   \   000145   7AFF         MOV     R2,#-0x1
   \   000147   7BFF         MOV     R3,#-0x1
   \   000149   7CFF         MOV     R4,#-0x1
   \   00014B   7DFF         MOV     R5,#-0x1
   \   00014D   7424         MOV     A,#0x24
   \   00014F   12....       LCALL   ?XSTACK_DISP0_8
   \   000152   EA           MOV     A,R2
   \   000153   F0           MOVX    @DPTR,A
   \   000154   A3           INC     DPTR
   \   000155   EB           MOV     A,R3
   \   000156   F0           MOVX    @DPTR,A
   \   000157   A3           INC     DPTR
   \   000158   EC           MOV     A,R4
   \   000159   F0           MOVX    @DPTR,A
   \   00015A   A3           INC     DPTR
   \   00015B   ED           MOV     A,R5
   \   00015C   F0           MOVX    @DPTR,A
   1340            cmd.alternateCostUnit = SE_OPTIONAL_FIELD_UINT8;
   \   00015D   7428         MOV     A,#0x28
   \   00015F   12....       LCALL   ?XSTACK_DISP0_8
   \   000162   74FF         MOV     A,#-0x1
   \   000164   F0           MOVX    @DPTR,A
   1341            cmd.alternateCostTrailingDigit = SE_OPTIONAL_FIELD_UINT8;
   \   000165   7429         MOV     A,#0x29
   \   000167   12....       LCALL   ?XSTACK_DISP0_8
   \   00016A   74FF         MOV     A,#-0x1
   \   00016C   F0           MOVX    @DPTR,A
   1342            cmd.numberOfBlockThresholds = SE_OPTIONAL_FIELD_UINT8;
   \   00016D   742A         MOV     A,#0x2a
   \   00016F   12....       LCALL   ?XSTACK_DISP0_8
   \   000172   74FF         MOV     A,#-0x1
   \   000174   F0           MOVX    @DPTR,A
   1343            cmd.priceControl = SE_PROFILE_PRICEACK_REQUIRED_MASK;
   \   000175   742B         MOV     A,#0x2b
   \   000177   12....       LCALL   ?XSTACK_DISP0_8
   \   00017A   7401         MOV     A,#0x1
   \   00017C   F0           MOVX    @DPTR,A
   1344          
   1345            // copy source address of display device that requested current pricing info so
   1346            // that esp can send messages to it using destination address of IPDAddr
   1347            osal_memcpy( &ipdAddr, srcAddr, sizeof ( afAddrType_t ) );
   \   00017D                ; Setup parameters for call to function osal_memcpy
   \   00017D   85....       MOV     ?V0 + 4,?V0 + 0
   \   000180   85....       MOV     ?V0 + 5,?V0 + 1
   \   000183   75..00       MOV     ?V0 + 6,#0x0
   \   000186   78..         MOV     R0,#?V0 + 4
   \   000188   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   00018B   7C0C         MOV     R4,#0xc
   \   00018D   7D00         MOV     R5,#0x0
   \   00018F   7A..         MOV     R2,#ipdAddr & 0xff
   \   000191   7B..         MOV     R3,#(ipdAddr >> 8) & 0xff
   \   000193   12....       LCALL   ??osal_memcpy?relay
   \   000196   7403         MOV     A,#0x3
   \   000198   12....       LCALL   ?DEALLOC_XSTACK8
   1348          
   1349            zclSE_Pricing_Send_PublishPrice( ESP_ENDPOINT, srcAddr, &cmd, FALSE, seqNum );
   \   00019B                ; Setup parameters for call to function zclSE_Pricing_Send_PublishPrice
   \   00019B   EE           MOV     A,R6
   \   00019C   F5..         MOV     ?V0 + 4,A
   \   00019E   78..         MOV     R0,#?V0 + 4
   \   0001A0   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0001A3   75..00       MOV     ?V0 + 4,#0x0
   \   0001A6   78..         MOV     R0,#?V0 + 4
   \   0001A8   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0001AB   7402         MOV     A,#0x2
   \   0001AD   12....       LCALL   ?XSTACK_DISP0_8
   \   0001B0   AC82         MOV     R4,DPL
   \   0001B2   AD83         MOV     R5,DPH
   \   0001B4   AA..         MOV     R2,?V0 + 0
   \   0001B6   AB..         MOV     R3,?V0 + 1
   \   0001B8   7909         MOV     R1,#0x9
   \   0001BA   12....       LCALL   ??zclSE_Pricing_Send_PublishPrice?relay
   \   0001BD   7402         MOV     A,#0x2
   \   0001BF   12....       LCALL   ?DEALLOC_XSTACK8
   \   0001C2   E9           MOV     A,R1
   1350          
   1351            if (cmd.rateLabel.pStr != NULL)
   \   0001C3   7405         MOV     A,#0x5
   \   0001C5   12....       LCALL   ?XSTACK_DISP0_8
   \   0001C8   E0           MOVX    A,@DPTR
   \   0001C9   F8           MOV     R0,A
   \   0001CA   A3           INC     DPTR
   \   0001CB   E0           MOVX    A,@DPTR
   \   0001CC   F9           MOV     R1,A
   \   0001CD   E8           MOV     A,R0
   \   0001CE   49           ORL     A,R1
   \   0001CF   600D         JZ      ??esp_GetCurrentPriceCB_1
   1352            {
   1353              osal_mem_free(cmd.rateLabel.pStr);
   \   0001D1                ; Setup parameters for call to function osal_mem_free
   \   0001D1   7405         MOV     A,#0x5
   \   0001D3   12....       LCALL   ?XSTACK_DISP0_8
   \   0001D6   E0           MOVX    A,@DPTR
   \   0001D7   FA           MOV     R2,A
   \   0001D8   A3           INC     DPTR
   \   0001D9   E0           MOVX    A,@DPTR
   \   0001DA   FB           MOV     R3,A
   \   0001DB   12....       LCALL   ??osal_mem_free?relay
   1354            }
   1355          #endif // ZCL_PRICING
   1356          }
   \                     ??esp_GetCurrentPriceCB_1:
   \   0001DE   742C         MOV     A,#0x2c
   \   0001E0   12....       LCALL   ?DEALLOC_XSTACK8
   \   0001E3   7F07         MOV     R7,#0x7
   \   0001E5   02....       LJMP    ?BANKED_LEAVE_XDATA
   1357          
   1358          /*********************************************************************
   1359           * @fn      esp_GetScheduledPriceCB
   1360           *
   1361           * @brief   Callback from the ZCL SE Profile Pricing Cluster Library when
   1362           *          it received a Get Scheduled Price for
   1363           *          this application.
   1364           *
   1365           * @param   pCmd - pointer to structure for Get Scheduled Price command
   1366           * @param   srcAddr - pointer to source address
   1367           * @param   seqNum - sequence number for this command
   1368           *
   1369           * @return  none
   1370           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1371          static void esp_GetScheduledPriceCB( zclCCGetScheduledPrice_t *pCmd,
   \                     esp_GetScheduledPriceCB:
   1372                                               afAddrType_t *srcAddr, uint8 seqNum  )
   1373          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 44
   \   000005   74D4         MOV     A,#-0x2c
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V0 + 2,R2
   \   00000C   8B..         MOV     ?V0 + 3,R3
   \   00000E   EC           MOV     A,R4
   \   00000F   FE           MOV     R6,A
   \   000010   ED           MOV     A,R5
   \   000011   FF           MOV     R7,A
   \   000012   89..         MOV     ?V0 + 0,R1
   1374            // On receipt of Get Scheduled Price command, the device shall send a
   1375            // Publish Price command for all currently scheduled price events.
   1376            // The sample code as follows only sends one.
   1377          
   1378          #if defined ( ZCL_PRICING )
   1379            zclCCPublishPrice_t cmd;
   1380          
   1381            osal_memset( &cmd, 0, sizeof( zclCCPublishPrice_t ) );
   \   000014                ; Setup parameters for call to function osal_memset
   \   000014   7C2C         MOV     R4,#0x2c
   \   000016   7D00         MOV     R5,#0x0
   \   000018   7900         MOV     R1,#0x0
   \   00001A   85..82       MOV     DPL,?XSP + 0
   \   00001D   85..83       MOV     DPH,?XSP + 1
   \   000020   AA82         MOV     R2,DPL
   \   000022   AB83         MOV     R3,DPH
   \   000024   12....       LCALL   ??osal_memset?relay
   1382          
   1383            cmd.providerId = 0xbabeface;
   \   000027   7ACE         MOV     R2,#-0x32
   \   000029   7BFA         MOV     R3,#-0x6
   \   00002B   7CBE         MOV     R4,#-0x42
   \   00002D   7DBA         MOV     R5,#-0x46
   \   00002F   85..82       MOV     DPL,?XSP + 0
   \   000032   85..83       MOV     DPH,?XSP + 1
   \   000035   EA           MOV     A,R2
   \   000036   F0           MOVX    @DPTR,A
   \   000037   A3           INC     DPTR
   \   000038   EB           MOV     A,R3
   \   000039   F0           MOVX    @DPTR,A
   \   00003A   A3           INC     DPTR
   \   00003B   EC           MOV     A,R4
   \   00003C   F0           MOVX    @DPTR,A
   \   00003D   A3           INC     DPTR
   \   00003E   ED           MOV     A,R5
   \   00003F   F0           MOVX    @DPTR,A
   1384            cmd.numberOfPriceTiers = 0xfe;
   \   000040   7413         MOV     A,#0x13
   \   000042   12....       LCALL   ?XSTACK_DISP0_8
   \   000045   74FE         MOV     A,#-0x2
   \   000047   F0           MOVX    @DPTR,A
   1385          
   1386            zclSE_Pricing_Send_PublishPrice( ESP_ENDPOINT, srcAddr, &cmd, FALSE, seqNum );
   \   000048                ; Setup parameters for call to function zclSE_Pricing_Send_PublishPrice
   \   000048   E5..         MOV     A,?V0 + 0
   \   00004A   F5..         MOV     ?V0 + 1,A
   \   00004C   78..         MOV     R0,#?V0 + 1
   \   00004E   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000051   75..00       MOV     ?V0 + 1,#0x0
   \   000054   78..         MOV     R0,#?V0 + 1
   \   000056   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000059   7402         MOV     A,#0x2
   \   00005B   12....       LCALL   ?XSTACK_DISP0_8
   \   00005E   AC82         MOV     R4,DPL
   \   000060   AD83         MOV     R5,DPH
   \   000062   EE           MOV     A,R6
   \   000063   FA           MOV     R2,A
   \   000064   EF           MOV     A,R7
   \   000065   FB           MOV     R3,A
   \   000066   7909         MOV     R1,#0x9
   \   000068   12....       LCALL   ??zclSE_Pricing_Send_PublishPrice?relay
   \   00006B   7402         MOV     A,#0x2
   \   00006D   12....       LCALL   ?DEALLOC_XSTACK8
   \   000070   E9           MOV     A,R1
   1387          
   1388          #endif // ZCL_PRICING
   1389          }
   \   000071   742C         MOV     A,#0x2c
   \   000073   12....       LCALL   ?DEALLOC_XSTACK8
   \   000076   7F04         MOV     R7,#0x4
   \   000078   02....       LJMP    ?BANKED_LEAVE_XDATA
   1390          
   1391          /*********************************************************************
   1392           * @fn      esp_PriceAcknowledgementCB
   1393           *
   1394           * @brief   Callback from the ZCL SE Profile Pricing Cluster Library when
   1395           *          it received a Price Acknowledgement for this application.
   1396           *
   1397           * @param   pCmd - pointer to structure for Price Acknowledgement command
   1398           * @param   srcAddr - pointer to source address
   1399           * @param   seqNum - sequence number for this command
   1400           *
   1401           * @return  none
   1402           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1403          static void esp_PriceAcknowledgementCB( zclCCPriceAcknowledgement_t *pCmd,
   \                     esp_PriceAcknowledgementCB:
   1404                                                  afAddrType_t *srcAddr, uint8 seqNum )
   1405          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   1406            // add user code here
   1407          }
   \   000000   02....       LJMP    ?BRET
   1408          
   1409          /*********************************************************************
   1410           * @fn      esp_GetBlockPeriodCB
   1411           *
   1412           * @brief   Callback from the ZCL SE Profile Pricing Cluster Library when
   1413           *          it received a Get Block Period for this application.
   1414           *
   1415           * @param   pCmd - pointer to structure for Get Block Period command
   1416           * @param   srcAddr - pointer to source address
   1417           * @param   seqNum - sequence number for this command
   1418           *
   1419           * @return  none
   1420           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1421          static void esp_GetBlockPeriodCB( zclCCGetBlockPeriod_t *pCmd,
   \                     esp_GetBlockPeriodCB:
   1422                                            afAddrType_t *srcAddr, uint8 seqNum )
   1423          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   1424            // add user code here
   1425          }
   \   000000   02....       LJMP    ?BRET
   1426          
   1427          /*********************************************************************
   1428           * @fn      esp_PublishPriceCB
   1429           *
   1430           * @brief   Callback from the ZCL SE Profile Pricing Cluster Library when
   1431           *          it received a Publish Price for this application.
   1432           *
   1433           * @param   pCmd - pointer to structure for Publish Price command
   1434           * @param   srcAddr - pointer to source address
   1435           * @param   seqNum - sequence number for this command
   1436           *
   1437           * @return  none
   1438           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1439          static void esp_PublishPriceCB( zclCCPublishPrice_t *pCmd,
   \                     esp_PublishPriceCB:
   1440                                                afAddrType_t *srcAddr, uint8 seqNum )
   1441          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   1442            // add user code here
   1443          }
   \   000000   02....       LJMP    ?BRET
   1444          
   1445          /*********************************************************************
   1446           * @fn      esp_PublishBlockPeriodCB
   1447           *
   1448           * @brief   Callback from the ZCL SE Profile Pricing Cluster Library when
   1449           *          it received a Publish Block Period for this application.
   1450           *
   1451           * @param   pCmd - pointer to structure for Get Block Period command
   1452           * @param   srcAddr - pointer to source address
   1453           * @param   seqNum - sequence number for this command
   1454           *
   1455           * @return  none
   1456           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1457          static void esp_PublishBlockPeriodCB( zclCCPublishBlockPeriod_t *pCmd,
   \                     esp_PublishBlockPeriodCB:
   1458                                                afAddrType_t *srcAddr, uint8 seqNum )
   1459          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   1460            // add user code here
   1461          }
   \   000000   02....       LJMP    ?BRET
   1462          
   1463          /*********************************************************************
   1464           * @fn      esp_DisplayMessageCB
   1465           *
   1466           * @brief   Callback from the ZCL SE Profile Message Cluster Library when
   1467           *          it received a Display Message Command for
   1468           *          this application.
   1469           *
   1470           * @param   pCmd - pointer to structure for Display Message command
   1471           * @param   srcAddr - pointer to source address
   1472           * @param   seqNum - sequence number for this command
   1473           *
   1474           * @return  none
   1475           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1476          static void esp_DisplayMessageCB( zclCCDisplayMessage_t *pCmd,
   \                     esp_DisplayMessageCB:
   1477                                                  afAddrType_t *srcAddr, uint8 seqNum )
   1478          {
   \   000000   74F5         MOV     A,#-0xb
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 11
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   \   000009   8C..         MOV     ?V0 + 0,R4
   \   00000B   8D..         MOV     ?V0 + 1,R5
   \   00000D   89..         MOV     ?V0 + 2,R1
   1479            // Upon receipt of the Display Message Command, the device shall
   1480            // display the message. If the Message Confirmation bit indicates
   1481            // the message originator require a confirmation of receipt from
   1482            // a Utility Customer, the device should display the message or
   1483            // alert the user until it is either confirmed via a button or by
   1484            // selecting a confirmation option on the device.  Confirmation is
   1485            // typically used when the Utility is sending down information
   1486            // such as a disconnection notice, or prepaid billing information.
   1487            // Message duration is ignored when confirmation is requested and
   1488            // the message is displayed until confirmed.
   1489          
   1490          #if defined ( LCD_SUPPORTED )
   1491              HalLcdWriteString( (char*)pCmd->msgString.pStr, HAL_LCD_LINE_1 );
   \   00000F                ; Setup parameters for call to function HalLcdWriteString
   \   00000F   7901         MOV     R1,#0x1
   \   000011   EE           MOV     A,R6
   \   000012   2410         ADD     A,#0x10
   \   000014   F582         MOV     DPL,A
   \   000016   EF           MOV     A,R7
   \   000017   3400         ADDC    A,#0x0
   \   000019   F583         MOV     DPH,A
   \   00001B   E0           MOVX    A,@DPTR
   \   00001C   FA           MOV     R2,A
   \   00001D   A3           INC     DPTR
   \   00001E   E0           MOVX    A,@DPTR
   \   00001F   FB           MOV     R3,A
   \   000020   12....       LCALL   ??HalLcdWriteString?relay
   1492          #endif // LCD_SUPPORTED
   1493          }
   \   000023   7F03         MOV     R7,#0x3
   \   000025   02....       LJMP    ?BANKED_LEAVE_XDATA
   1494          
   1495          /*********************************************************************
   1496           * @fn      esp_CancelMessageCB
   1497           *
   1498           * @brief   Callback from the ZCL SE Profile Message Cluster Library when
   1499           *          it received a Cancel Message Command for
   1500           *          this application.
   1501           *
   1502           * @param   pCmd - pointer to structure for Cancel Message command
   1503           * @param   srcAddr - pointer to source address
   1504           * @param   seqNum - sequence number for this command
   1505           *
   1506           * @return  none
   1507           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1508          static void esp_CancelMessageCB( zclCCCancelMessage_t *pCmd,
   \                     esp_CancelMessageCB:
   1509                                                  afAddrType_t *srcAddr, uint8 seqNum )
   1510          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   1511            // add user code here
   1512          }
   \   000000   02....       LJMP    ?BRET
   1513          
   1514          /*********************************************************************
   1515           * @fn      esp_GetLastMessageCB
   1516           *
   1517           * @brief   Callback from the ZCL SE Profile Message Cluster Library when
   1518           *          it received a Get Last Message Command for
   1519           *          this application.
   1520           *
   1521           * @param   pCmd - pointer to structure for Get Last Message command
   1522           * @param   srcAddr - pointer to source address
   1523           * @param   seqNum - sequence number for this command
   1524           *
   1525           * @return  none
   1526           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1527          static void esp_GetLastMessageCB( afAddrType_t *srcAddr, uint8 seqNum )
   \                     esp_GetLastMessageCB:
   1528          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 28
   \   000005   74E4         MOV     A,#-0x1c
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   \   00000E   89..         MOV     ?V0 + 0,R1
   1529            // On receipt of Get Last Message command, the device shall send a
   1530            // Display Message command back to the sender
   1531          
   1532          #if defined ( ZCL_MESSAGE )
   1533            zclCCDisplayMessage_t cmd;
   1534            uint8 msg[10] = { 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29 };
   \   000010   90....       MOV     DPTR,#`?<Constant {32, 33, 34, 35, 36, 37, 38, 39, 40`
   \   000013   C082         PUSH    DPL
   \   000015   C083         PUSH    DPH
   \   000017   7412         MOV     A,#0x12
   \   000019   12....       LCALL   ?XSTACK_DISP0_8
   \   00001C   AC82         MOV     R4,DPL
   \   00001E   AD83         MOV     R5,DPH
   \   000020   D083         POP     DPH
   \   000022   D082         POP     DPL
   \   000024   740A         MOV     A,#0xa
   \   000026   12....       LCALL   ?MOVE_LONG8_XDATA_XDATA
   1535          
   1536            // Fill in the command with information for the last message
   1537            cmd.messageId = 0xaabbccdd;
   \   000029   7ADD         MOV     R2,#-0x23
   \   00002B   7BCC         MOV     R3,#-0x34
   \   00002D   7CBB         MOV     R4,#-0x45
   \   00002F   7DAA         MOV     R5,#-0x56
   \   000031   85..82       MOV     DPL,?XSP + 0
   \   000034   85..83       MOV     DPH,?XSP + 1
   \   000037   EA           MOV     A,R2
   \   000038   F0           MOVX    @DPTR,A
   \   000039   A3           INC     DPTR
   \   00003A   EB           MOV     A,R3
   \   00003B   F0           MOVX    @DPTR,A
   \   00003C   A3           INC     DPTR
   \   00003D   EC           MOV     A,R4
   \   00003E   F0           MOVX    @DPTR,A
   \   00003F   A3           INC     DPTR
   \   000040   ED           MOV     A,R5
   \   000041   F0           MOVX    @DPTR,A
   1538            cmd.messageCtrl.transmissionMode = 0;
   \   000042   7404         MOV     A,#0x4
   \   000044   12....       LCALL   ?XSTACK_DISP0_8
   \   000047   7400         MOV     A,#0x0
   \   000049   F0           MOVX    @DPTR,A
   1539            cmd.messageCtrl.importance = 1;
   \   00004A   7405         MOV     A,#0x5
   \   00004C   12....       LCALL   ?XSTACK_DISP0_8
   \   00004F   7401         MOV     A,#0x1
   \   000051   F0           MOVX    @DPTR,A
   1540            cmd.messageCtrl.confirmationRequired = 1;
   \   000052   7408         MOV     A,#0x8
   \   000054   12....       LCALL   ?XSTACK_DISP0_8
   \   000057   7401         MOV     A,#0x1
   \   000059   F0           MOVX    @DPTR,A
   1541            cmd.durationInMinutes = 60;
   \   00005A   740D         MOV     A,#0xd
   \   00005C   12....       LCALL   ?XSTACK_DISP0_8
   \   00005F   743C         MOV     A,#0x3c
   \   000061   F0           MOVX    @DPTR,A
   \   000062   A3           INC     DPTR
   \   000063   7400         MOV     A,#0x0
   \   000065   F0           MOVX    @DPTR,A
   1542          
   1543            cmd.msgString.strLen = 10;
   \   000066   740F         MOV     A,#0xf
   \   000068   12....       LCALL   ?XSTACK_DISP0_8
   \   00006B   740A         MOV     A,#0xa
   \   00006D   F0           MOVX    @DPTR,A
   1544            cmd.msgString.pStr = msg;
   \   00006E   7412         MOV     A,#0x12
   \   000070   12....       LCALL   ?XSTACK_DISP0_8
   \   000073   A882         MOV     R0,DPL
   \   000075   A983         MOV     R1,DPH
   \   000077   7410         MOV     A,#0x10
   \   000079   12....       LCALL   ?XSTACK_DISP0_8
   \   00007C   E8           MOV     A,R0
   \   00007D   F0           MOVX    @DPTR,A
   \   00007E   A3           INC     DPTR
   \   00007F   E9           MOV     A,R1
   \   000080   F0           MOVX    @DPTR,A
   1545          
   1546            zclSE_Message_Send_DisplayMessage( ESP_ENDPOINT, srcAddr, &cmd,
   1547                                               FALSE, seqNum );
   \   000081                ; Setup parameters for call to function zclSE_Message_Send_DisplayMessage
   \   000081   E5..         MOV     A,?V0 + 0
   \   000083   F5..         MOV     ?V0 + 1,A
   \   000085   78..         MOV     R0,#?V0 + 1
   \   000087   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00008A   75..00       MOV     ?V0 + 1,#0x0
   \   00008D   78..         MOV     R0,#?V0 + 1
   \   00008F   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000092   7402         MOV     A,#0x2
   \   000094   12....       LCALL   ?XSTACK_DISP0_8
   \   000097   AC82         MOV     R4,DPL
   \   000099   AD83         MOV     R5,DPH
   \   00009B   EE           MOV     A,R6
   \   00009C   FA           MOV     R2,A
   \   00009D   EF           MOV     A,R7
   \   00009E   FB           MOV     R3,A
   \   00009F   7909         MOV     R1,#0x9
   \   0000A1   12....       LCALL   ??zclSE_Message_Send_DisplayMessage?relay
   \   0000A4   7402         MOV     A,#0x2
   \   0000A6   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000A9   E9           MOV     A,R1
   1548          #endif // ZCL_MESSAGe
   1549          }
   \   0000AA   741C         MOV     A,#0x1c
   \   0000AC   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000AF   7F02         MOV     R7,#0x2
   \   0000B1   02....       LJMP    ?BANKED_LEAVE_XDATA
   1550          
   1551          /*********************************************************************
   1552           * @fn      esp_MessageConfirmationCB
   1553           *
   1554           * @brief   Callback from the ZCL SE Profile Message Cluster Library when
   1555           *          it received a Message Confirmation Command for
   1556           *          this application.
   1557           *
   1558           * @param   pCmd - pointer to structure for Message Confirmation command
   1559           * @param   srcAddr - pointer to source address
   1560           * @param   seqNum - sequence number for this command
   1561           *
   1562           * @return  none
   1563           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1564          static void esp_MessageConfirmationCB( zclCCMessageConfirmation_t *pCmd,
   \                     esp_MessageConfirmationCB:
   1565                                                       afAddrType_t *srcAddr, uint8 seqNum)
   1566          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   1567            // add user code here
   1568          }
   \   000000   02....       LJMP    ?BRET
   1569          
   1570          #if defined (ZCL_LOAD_CONTROL)
   1571          /*********************************************************************
   1572           * @fn      esp_SendReportEventStatus
   1573           *
   1574           * @brief   Callback from the ZCL SE Profile Message Cluster Library when
   1575           *          it received a Load Control Event Command for
   1576           *          this application.
   1577           *
   1578           * @param   afAddrType_t *srcAddr - pointer to source address
   1579           * @param   uint8 seqNum - sequence number for this event
   1580           * @param   uint32 eventID - event ID for this event
   1581           * @param   uint32 startTime - start time for this event
   1582           * @param   uint8 eventStatus - status for this event
   1583           * @param   uint8 criticalityLevel - criticality level for this event
   1584           * @param   uint8 eventControl - event control for this event
   1585           *
   1586           * @return  none
   1587           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1588          static void esp_SendReportEventStatus( afAddrType_t *srcAddr, uint8 seqNum,
   \                     esp_SendReportEventStatus:
   1589                                                        uint32 eventID, uint32 startTime,
   1590                                                        uint8 eventStatus, uint8 criticalityLevel,
   1591                                                        uint8 eventControl )
   1592          {
   \   000000   74E9         MOV     A,#-0x17
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 23
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   85..82       MOV     DPL,?XSP + 0
   \   00000D   85..83       MOV     DPH,?XSP + 1
   \   000010   EA           MOV     A,R2
   \   000011   F0           MOVX    @DPTR,A
   \   000012   A3           INC     DPTR
   \   000013   EB           MOV     A,R3
   \   000014   F0           MOVX    @DPTR,A
   \   000015   89..         MOV     ?V0 + 14,R1
   \   000017   8C..         MOV     ?V0 + 13,R4
   \   000019   8D..         MOV     ?V0 + 12,R5
   \   00001B   7419         MOV     A,#0x19
   \   00001D   12....       LCALL   ?XSTACK_DISP0_8
   \   000020   78..         MOV     R0,#?V0 + 0
   \   000022   12....       LCALL   ?L_MOV_X
   \   000025   741D         MOV     A,#0x1d
   \   000027   12....       LCALL   ?XSTACK_DISP0_8
   \   00002A   78..         MOV     R0,#?V0 + 4
   \   00002C   12....       LCALL   ?L_MOV_X
   \   00002F   7421         MOV     A,#0x21
   \   000031   12....       LCALL   ?XSTACK_DISP0_8
   \   000034   E0           MOVX    A,@DPTR
   \   000035   F5..         MOV     ?V0 + 11,A
   1593            zclCCReportEventStatus_t *pRsp;
   1594          
   1595            pRsp = (zclCCReportEventStatus_t *)osal_mem_alloc( sizeof( zclCCReportEventStatus_t ) );
   \   000037                ; Setup parameters for call to function osal_mem_alloc
   \   000037   7A3C         MOV     R2,#0x3c
   \   000039   7B00         MOV     R3,#0x0
   \   00003B   12....       LCALL   ??osal_mem_alloc?relay
   \   00003E   8A..         MOV     ?V0 + 8,R2
   \   000040   8B..         MOV     ?V0 + 9,R3
   \   000042   AE..         MOV     R6,?V0 + 8
   \   000044   AF..         MOV     R7,?V0 + 9
   1596          
   1597            if ( pRsp != NULL)
   \   000046   EE           MOV     A,R6
   \   000047   4F           ORL     A,R7
   \   000048   7003         JNZ     $+5
   \   00004A   02....       LJMP    ??esp_SendReportEventStatus_0 & 0xFFFF
   1598            {
   1599              // Mandatory fields - use the incoming data
   1600              pRsp->issuerEventID = eventID;
   \   00004D   8E82         MOV     DPL,R6
   \   00004F   8F83         MOV     DPH,R7
   \   000051   78..         MOV     R0,#?V0 + 0
   \   000053   12....       LCALL   ?L_MOV_TO_X
   1601              pRsp->eventStartTime = startTime;
   \   000056   8E82         MOV     DPL,R6
   \   000058   8F83         MOV     DPH,R7
   \   00005A   A3           INC     DPTR
   \   00005B   A3           INC     DPTR
   \   00005C   A3           INC     DPTR
   \   00005D   A3           INC     DPTR
   \   00005E   78..         MOV     R0,#?V0 + 4
   \   000060   12....       LCALL   ?L_MOV_TO_X
   1602              pRsp->criticalityLevelApplied = criticalityLevel;
   \   000063   E5..         MOV     A,?V0 + 12
   \   000065   8E82         MOV     DPL,R6
   \   000067   8F83         MOV     DPH,R7
   \   000069   A3           INC     DPTR
   \   00006A   A3           INC     DPTR
   \   00006B   A3           INC     DPTR
   \   00006C   A3           INC     DPTR
   \   00006D   A3           INC     DPTR
   \   00006E   A3           INC     DPTR
   \   00006F   A3           INC     DPTR
   \   000070   A3           INC     DPTR
   \   000071   A3           INC     DPTR
   \   000072   E5..         MOV     A,?V0 + 12
   \   000074   F0           MOVX    @DPTR,A
   1603              pRsp->eventControl = eventControl;
   \   000075   E5..         MOV     A,?V0 + 11
   \   000077   EE           MOV     A,R6
   \   000078   2410         ADD     A,#0x10
   \   00007A   F582         MOV     DPL,A
   \   00007C   EF           MOV     A,R7
   \   00007D   3400         ADDC    A,#0x0
   \   00007F   F583         MOV     DPH,A
   \   000081   E5..         MOV     A,?V0 + 11
   \   000083   F0           MOVX    @DPTR,A
   1604              pRsp->eventStatus = eventStatus;
   \   000084   E5..         MOV     A,?V0 + 13
   \   000086   8E82         MOV     DPL,R6
   \   000088   8F83         MOV     DPH,R7
   \   00008A   A3           INC     DPTR
   \   00008B   A3           INC     DPTR
   \   00008C   A3           INC     DPTR
   \   00008D   A3           INC     DPTR
   \   00008E   A3           INC     DPTR
   \   00008F   A3           INC     DPTR
   \   000090   A3           INC     DPTR
   \   000091   A3           INC     DPTR
   \   000092   E5..         MOV     A,?V0 + 13
   \   000094   F0           MOVX    @DPTR,A
   1605              pRsp->signatureType = SE_PROFILE_SIGNATURE_TYPE_ECDSA;
   \   000095   EE           MOV     A,R6
   \   000096   2411         ADD     A,#0x11
   \   000098   F582         MOV     DPL,A
   \   00009A   EF           MOV     A,R7
   \   00009B   3400         ADDC    A,#0x0
   \   00009D   F583         MOV     DPH,A
   \   00009F   7401         MOV     A,#0x1
   \   0000A1   F0           MOVX    @DPTR,A
   1606          
   1607              // esp_Signature is a static array.
   1608              // value can be changed in esp_data.c
   1609              osal_memcpy( pRsp->signature, espSignature, 16 );
   \   0000A2                ; Setup parameters for call to function osal_memcpy
   \   0000A2   75....       MOV     ?V0 + 8,#espSignature & 0xff
   \   0000A5   75....       MOV     ?V0 + 9,#(espSignature >> 8) & 0xff
   \   0000A8   75..00       MOV     ?V0 + 10,#0x0
   \   0000AB   78..         MOV     R0,#?V0 + 8
   \   0000AD   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   0000B0   7C10         MOV     R4,#0x10
   \   0000B2   7D00         MOV     R5,#0x0
   \   0000B4   EE           MOV     A,R6
   \   0000B5   2412         ADD     A,#0x12
   \   0000B7   FA           MOV     R2,A
   \   0000B8   EF           MOV     A,R7
   \   0000B9   3400         ADDC    A,#0x0
   \   0000BB   FB           MOV     R3,A
   \   0000BC   12....       LCALL   ??osal_memcpy?relay
   \   0000BF   7403         MOV     A,#0x3
   \   0000C1   12....       LCALL   ?DEALLOC_XSTACK8
   1610          
   1611              // Optional fields - fill in with non-used value by default
   1612              pRsp->coolingTemperatureSetPointApplied = SE_OPTIONAL_FIELD_TEMPERATURE_SET_POINT;
   \   0000C4   8E82         MOV     DPL,R6
   \   0000C6   8F83         MOV     DPH,R7
   \   0000C8   A3           INC     DPTR
   \   0000C9   A3           INC     DPTR
   \   0000CA   A3           INC     DPTR
   \   0000CB   A3           INC     DPTR
   \   0000CC   A3           INC     DPTR
   \   0000CD   A3           INC     DPTR
   \   0000CE   A3           INC     DPTR
   \   0000CF   A3           INC     DPTR
   \   0000D0   A3           INC     DPTR
   \   0000D1   A3           INC     DPTR
   \   0000D2   7400         MOV     A,#0x0
   \   0000D4   F0           MOVX    @DPTR,A
   \   0000D5   A3           INC     DPTR
   \   0000D6   7480         MOV     A,#-0x80
   \   0000D8   F0           MOVX    @DPTR,A
   1613              pRsp->heatingTemperatureSetPointApplied = SE_OPTIONAL_FIELD_TEMPERATURE_SET_POINT;
   \   0000D9   EE           MOV     A,R6
   \   0000DA   240C         ADD     A,#0xc
   \   0000DC   F582         MOV     DPL,A
   \   0000DE   EF           MOV     A,R7
   \   0000DF   3400         ADDC    A,#0x0
   \   0000E1   F583         MOV     DPH,A
   \   0000E3   7400         MOV     A,#0x0
   \   0000E5   F0           MOVX    @DPTR,A
   \   0000E6   A3           INC     DPTR
   \   0000E7   7480         MOV     A,#-0x80
   \   0000E9   F0           MOVX    @DPTR,A
   1614              pRsp->averageLoadAdjustment = SE_OPTIONAL_FIELD_INT8;
   \   0000EA   EE           MOV     A,R6
   \   0000EB   240E         ADD     A,#0xe
   \   0000ED   F582         MOV     DPL,A
   \   0000EF   EF           MOV     A,R7
   \   0000F0   3400         ADDC    A,#0x0
   \   0000F2   F583         MOV     DPH,A
   \   0000F4   7480         MOV     A,#-0x80
   \   0000F6   F0           MOVX    @DPTR,A
   1615              pRsp->dutyCycleApplied = SE_OPTIONAL_FIELD_UINT8;
   \   0000F7   EE           MOV     A,R6
   \   0000F8   240F         ADD     A,#0xf
   \   0000FA   F582         MOV     DPL,A
   \   0000FC   EF           MOV     A,R7
   \   0000FD   3400         ADDC    A,#0x0
   \   0000FF   F583         MOV     DPH,A
   \   000101   74FF         MOV     A,#-0x1
   \   000103   F0           MOVX    @DPTR,A
   1616          
   1617              // Send response back
   1618              // DisableDefaultResponse is set to FALSE - it is recommended to turn on
   1619              // default response since Report Event Status Command does not have
   1620              // a response.
   1621              zclSE_LoadControl_Send_ReportEventStatus( ESP_ENDPOINT, srcAddr,
   1622                                                      pRsp, FALSE, seqNum );
   \   000104                ; Setup parameters for call to function zclSE_LoadControl_Send_ReportEventStatus
   \   000104   E5..         MOV     A,?V0 + 14
   \   000106   F5..         MOV     ?V0 + 8,A
   \   000108   78..         MOV     R0,#?V0 + 8
   \   00010A   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00010D   75..00       MOV     ?V0 + 8,#0x0
   \   000110   78..         MOV     R0,#?V0 + 8
   \   000112   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000115   EE           MOV     A,R6
   \   000116   FC           MOV     R4,A
   \   000117   EF           MOV     A,R7
   \   000118   FD           MOV     R5,A
   \   000119   7402         MOV     A,#0x2
   \   00011B   12....       LCALL   ?XSTACK_DISP0_8
   \   00011E   E0           MOVX    A,@DPTR
   \   00011F   FA           MOV     R2,A
   \   000120   A3           INC     DPTR
   \   000121   E0           MOVX    A,@DPTR
   \   000122   FB           MOV     R3,A
   \   000123   7909         MOV     R1,#0x9
   \   000125   12....       LCALL   ??zclSE_LoadControl_Send_ReportEventStatus?rela
   \   000128   7402         MOV     A,#0x2
   \   00012A   12....       LCALL   ?DEALLOC_XSTACK8
   \   00012D   E9           MOV     A,R1
   1623              osal_mem_free( pRsp );
   \   00012E                ; Setup parameters for call to function osal_mem_free
   \   00012E   EE           MOV     A,R6
   \   00012F   FA           MOV     R2,A
   \   000130   EF           MOV     A,R7
   \   000131   FB           MOV     R3,A
   \   000132   12....       LCALL   ??osal_mem_free?relay
   1624            }
   1625          }
   \                     ??esp_SendReportEventStatus_0:
   \   000135   7402         MOV     A,#0x2
   \   000137   12....       LCALL   ?DEALLOC_XSTACK8
   \   00013A   7F0F         MOV     R7,#0xf
   \   00013C   02....       LJMP    ?BANKED_LEAVE_XDATA
   1626          #endif // ZCL_LOAD_CONTROL
   1627          
   1628          /*********************************************************************
   1629           * @fn      esp_LoadControlEventCB
   1630           *
   1631           * @brief   Callback from the ZCL SE Profile Load Control Cluster Library when
   1632           *          it received a Load Control Event Command for
   1633           *          this application.
   1634           *
   1635           * @param   pCmd - pointer to load control event command
   1636           * @param   srcAddr - pointer to source address
   1637           * @param   status - event status
   1638           * @param   seqNum - sequence number of this command
   1639           *
   1640           * @return  none
   1641           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1642          static void esp_LoadControlEventCB( zclCCLoadControlEvent_t *pCmd,
   \                     esp_LoadControlEventCB:
   1643                                                         afAddrType_t *srcAddr, uint8 status,
   1644                                                         uint8 seqNum)
   1645          {
   \   000000   74F2         MOV     A,#-0xe
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   \   000009   8C..         MOV     ?V0 + 0,R4
   \   00000B   8D..         MOV     ?V0 + 1,R5
   \   00000D   89..         MOV     ?V0 + 3,R1
   \   00000F   740E         MOV     A,#0xe
   \   000011   12....       LCALL   ?XSTACK_DISP0_8
   \   000014   E0           MOVX    A,@DPTR
   \   000015   F5..         MOV     ?V0 + 2,A
   1646          #if defined ( ZCL_LOAD_CONTROL )
   1647            // According to the Smart Metering Specification, upon receipt
   1648            // of the Load Control Event command, the receiving device shall
   1649            // send Report Event Status command back.
   1650            uint8 eventStatus;
   1651          
   1652            if ( status == ZCL_STATUS_INVALID_FIELD )
   \   000017   7485         MOV     A,#-0x7b
   \   000019   65..         XRL     A,?V0 + 3
   \   00001B   7005         JNZ     ??esp_LoadControlEventCB_0
   1653            {
   1654              // If the incoming message has invalid fields in it
   1655              // Send response back with status: rejected
   1656              eventStatus = EVENT_STATUS_LOAD_CONTROL_EVENT_REJECTED;
   \   00001D   75..FE       MOV     ?V0 + 5,#-0x2
   \   000020   8003         SJMP    ??esp_LoadControlEventCB_1
   1657            }
   1658            else
   1659            { // Send response back with status: received
   1660              eventStatus = EVENT_STATUS_LOAD_CONTROL_EVENT_RECEIVED;
   \                     ??esp_LoadControlEventCB_0:
   \   000022   75..01       MOV     ?V0 + 5,#0x1
   1661            }
   1662          
   1663            // Send response back
   1664            esp_SendReportEventStatus( srcAddr, seqNum, pCmd->issuerEvent,
   1665                                             pCmd->startTime, eventStatus,
   1666                                             pCmd->criticalityLevel, pCmd->eventControl);
   \                     ??esp_LoadControlEventCB_1:
   \   000025                ; Setup parameters for call to function esp_SendReportEventStatus
   \   000025   EE           MOV     A,R6
   \   000026   2417         ADD     A,#0x17
   \   000028   F582         MOV     DPL,A
   \   00002A   EF           MOV     A,R7
   \   00002B   3400         ADDC    A,#0x0
   \   00002D   F583         MOV     DPH,A
   \   00002F   E0           MOVX    A,@DPTR
   \   000030   F5..         MOV     ?V0 + 4,A
   \   000032   78..         MOV     R0,#?V0 + 4
   \   000034   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000037   8E82         MOV     DPL,R6
   \   000039   8F83         MOV     DPH,R7
   \   00003B   A3           INC     DPTR
   \   00003C   A3           INC     DPTR
   \   00003D   A3           INC     DPTR
   \   00003E   A3           INC     DPTR
   \   00003F   A3           INC     DPTR
   \   000040   A3           INC     DPTR
   \   000041   A3           INC     DPTR
   \   000042   A3           INC     DPTR
   \   000043   12....       LCALL   ?PUSH_XSTACK8_X_FOUR
   \   000046   8E82         MOV     DPL,R6
   \   000048   8F83         MOV     DPH,R7
   \   00004A   12....       LCALL   ?PUSH_XSTACK8_X_FOUR
   \   00004D   EE           MOV     A,R6
   \   00004E   240E         ADD     A,#0xe
   \   000050   F582         MOV     DPL,A
   \   000052   EF           MOV     A,R7
   \   000053   3400         ADDC    A,#0x0
   \   000055   F583         MOV     DPH,A
   \   000057   E0           MOVX    A,@DPTR
   \   000058   FD           MOV     R5,A
   \   000059   AC..         MOV     R4,?V0 + 5
   \   00005B   A9..         MOV     R1,?V0 + 2
   \   00005D   AA..         MOV     R2,?V0 + 0
   \   00005F   AB..         MOV     R3,?V0 + 1
   \   000061   12....       LCALL   ??esp_SendReportEventStatus?relay
   \   000064   7409         MOV     A,#0x9
   \   000066   12....       LCALL   ?DEALLOC_XSTACK8
   1667          
   1668            if ( status != ZCL_STATUS_INVALID_FIELD )
   1669            {
   1670              // add user load control event handler here
   1671            }
   1672          #endif // ZCL_LOAD_CONTROL
   1673          }
   \   000069   7F06         MOV     R7,#0x6
   \   00006B   02....       LJMP    ?BANKED_LEAVE_XDATA
   1674          
   1675          /*********************************************************************
   1676           * @fn      esp_CancelLoadControlEventCB
   1677           *
   1678           * @brief   Callback from the ZCL SE Profile Load Control Cluster Library when
   1679           *          it received a Cancel Load Control Event Command for
   1680           *          this application.
   1681           *
   1682           * @param   pCmd - pointer to structure for Cancel Load Control Event command
   1683           * @param   scrAddr - source address
   1684           * @param   seqNum - sequence number for this command
   1685           *
   1686           * @return  none
   1687           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1688          static void esp_CancelLoadControlEventCB( zclCCCancelLoadControlEvent_t *pCmd,
   \                     esp_CancelLoadControlEventCB:
   1689                                                          afAddrType_t *srcAddr, uint8 seqNum )
   1690          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   \   000009   8C..         MOV     ?V0 + 0,R4
   \   00000B   8D..         MOV     ?V0 + 1,R5
   \   00000D   89..         MOV     ?V0 + 2,R1
   1691          #if defined ( ZCL_LOAD_CONTROL )
   1692            if ( 0 )  // User shall replace the if condition with "if the event exist"
   1693            {
   1694              // If the event exist, stop the event, and respond with status: cancelled
   1695          
   1696              // Cancel the event here
   1697          
   1698              // Use the following sample code to send response back.
   1699              /*
   1700              esp_SendReportEventStatus( srcAddr, seqNum, pCmd->issuerEventID,
   1701                                               // startTime
   1702                                               EVENT_STATUS_LOAD_CONTROL_EVENT_CANCELLED, // eventStatus
   1703                                               // Criticality level
   1704                                               // eventControl };
   1705              */
   1706          
   1707            }
   1708            else
   1709            {
   1710              // If the event does not exist, respond with status: rejected
   1711              // The rest of the mandatory fields are not available, therefore,
   1712              // set to optional value
   1713              esp_SendReportEventStatus( srcAddr, seqNum, pCmd->issuerEventID,
   1714                                               SE_OPTIONAL_FIELD_UINT32,                  // startTime
   1715                                               EVENT_STATUS_LOAD_CONTROL_EVENT_RECEIVED,  // eventStatus
   1716                                               SE_OPTIONAL_FIELD_UINT8,                   // Criticality level
   1717                                               SE_OPTIONAL_FIELD_UINT8 );                 // eventControl
   \   00000F                ; Setup parameters for call to function esp_SendReportEventStatus
   \   00000F   75..FF       MOV     ?V0 + 3,#-0x1
   \   000012   78..         MOV     R0,#?V0 + 3
   \   000014   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000017   90....       MOV     DPTR,#__Constant_ffffffff
   \   00001A   12....       LCALL   ?PUSH_XSTACK8_X_FOUR
   \   00001D   8E82         MOV     DPL,R6
   \   00001F   8F83         MOV     DPH,R7
   \   000021   12....       LCALL   ?PUSH_XSTACK8_X_FOUR
   \   000024   7DFF         MOV     R5,#-0x1
   \   000026   7C01         MOV     R4,#0x1
   \   000028   A9..         MOV     R1,?V0 + 2
   \   00002A   AA..         MOV     R2,?V0 + 0
   \   00002C   AB..         MOV     R3,?V0 + 1
   \   00002E   12....       LCALL   ??esp_SendReportEventStatus?relay
   \   000031   7409         MOV     A,#0x9
   \   000033   12....       LCALL   ?DEALLOC_XSTACK8
   1718            }
   1719          
   1720          #endif // ZCL_LOAD_CONTROL
   1721          }
   \   000036   7F04         MOV     R7,#0x4
   \   000038   02....       LJMP    ?BANKED_LEAVE_XDATA
   1722          
   1723          /*********************************************************************
   1724           * @fn      esp_CancelAllLoadControlEventsCB
   1725           *
   1726           * @brief   Callback from the ZCL SE Profile Load Control Cluster Library when
   1727           *          it received a Cancel All Load Control Event Command for
   1728           *          this application.
   1729           *
   1730           * @param   pCmd - pointer to structure for Cancel All Load Control Event command
   1731           * @param   scrAddr - source address
   1732           * @param   seqNum - sequence number for this command
   1733           *
   1734           * @return  none
   1735           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1736          static void esp_CancelAllLoadControlEventsCB( zclCCCancelAllLoadControlEvents_t *pCmd,
   \                     esp_CancelAllLoadControlEventsCB:
   1737                                                              afAddrType_t *srcAddr, uint8 seqNum )
   1738          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   1739            // Upon receipt of Cancel All Load Control Event Command,
   1740            // the receiving device shall look up the table for all events
   1741            // and send a seperate response for each event
   1742          
   1743          }
   \   000000   02....       LJMP    ?BRET
   1744          
   1745          /*********************************************************************
   1746           * @fn      esp_ReportEventStatusCB
   1747           *
   1748           * @brief   Callback from the ZCL SE Profile Load Control Cluster Library when
   1749           *          it received a Report Event Status Command for
   1750           *          this application.
   1751           *
   1752           * @param   pCmd - pointer to structure for Report Event Status command
   1753           * @param   scrAddr - source address
   1754           * @param   seqNum - sequence number for this command
   1755           *
   1756           * @return  none
   1757           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1758          static void esp_ReportEventStatusCB( zclCCReportEventStatus_t *pCmd,
   \                     esp_ReportEventStatusCB:
   1759                                                     afAddrType_t *srcAddr, uint8 seqNum)
   1760          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   1761            // add user code here
   1762          }
   \   000000   02....       LJMP    ?BRET
   1763          /*********************************************************************
   1764           * @fn      esp_GetScheduledEventCB
   1765           *
   1766           * @brief   Callback from the ZCL SE Profile Load Control Cluster Library when
   1767           *          it received a Get Scheduled Event Command for
   1768           *          this application.
   1769           *
   1770           * @param   pCmd - pointer to structure for Get Scheduled Event command
   1771           * @param   scrAddr - source address
   1772           * @param   seqNum - sequence number for this command
   1773           *
   1774           * @return  none
   1775           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1776          static void esp_GetScheduledEventCB( zclCCGetScheduledEvent_t *pCmd,
   \                     esp_GetScheduledEventCB:
   1777                                                     afAddrType_t *srcAddr, uint8 seqNum )
   1778          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   1779            // add user code here
   1780          }
   \   000000   02....       LJMP    ?BRET
   1781          
   1782          /*********************************************************************
   1783           * @fn      esp_SelAvailEmergencyCreditCmdCB
   1784           *
   1785           * @brief   Callback from the ZCL SE Prepayment Cluster Library when it recieved
   1786           *          Select Available Emergency Credit command in the application
   1787           *
   1788           * @param   pCmd - pointer to structure for Select Available Emergency Credit command
   1789           * @param   srcAddr - pointer to source address
   1790           * @param   seqNum - Sequence no of the message
   1791           *
   1792           * @return  none
   1793           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1794          static void esp_SelAvailEmergencyCreditCmdCB( zclCCSelAvailEmergencyCredit_t *pCmd,
   \                     esp_SelAvailEmergencyCreditCmdCB:
   1795                                                        afAddrType_t *srcAddr, uint8 seqNum )
   1796          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   1797          #if defined ( ZCL_PREPAYMENT )
   1798          #if defined ( LCD_SUPPORTED )
   1799            HalLcdWriteString("Emergency Credit", HAL_LCD_LINE_1);
   1800          
   1801            if ((pCmd->siteId.strLen > 0) &&
   1802                (pCmd->siteId.strLen <= HAL_LCD_MAX_CHARS) &&
   1803                (pCmd->siteId.pStr != NULL))
   1804            {
   1805              HalLcdWriteString((char*)pCmd->siteId.pStr, HAL_LCD_LINE_2);
   1806            }
   1807          
   1808            if ((pCmd->meterSerialNumber.strLen > 0) &&
   1809                (pCmd->meterSerialNumber.strLen <= HAL_LCD_MAX_CHARS) &&
   1810                (pCmd->meterSerialNumber.pStr != NULL))
   1811            {
   1812              HalLcdWriteString((char*)pCmd->meterSerialNumber.pStr, HAL_LCD_LINE_3);
   1813            }
   1814          #endif
   1815          #endif  // ZCL_PREPAYMENT
   1816          }
   \   000000   02....       LJMP    ?BRET
   1817          
   1818          /*********************************************************************
   1819           * @fn      esp_ChangeSupplyCmdCB
   1820           *
   1821           * @brief   Callback from the ZCL SE Prepayment Cluster Library when it recieved
   1822           *          Change Supply command in the application
   1823           *
   1824           * @param   pCmd - pointer to structure for Change Supply command
   1825           * @param   srcAddr - pointer to source address
   1826           * @param   seqNum - Sequence no of the message
   1827           *
   1828           * @return  none
   1829           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1830          static void esp_ChangeSupplyCmdCB( zclCCChangeSupply_t *pCmd,
   \                     esp_ChangeSupplyCmdCB:
   1831                                                 afAddrType_t *srcAddr, uint8 seqNum )
   1832          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   1833          #if defined ( ZCL_PREPAYMENT )
   1834          #if !defined ( SE_UK_EXT )
   1835            zclCCSupplyStatusResponse_t SupplyStatus_cmd;
   1836          
   1837            osal_memset( &SupplyStatus_cmd, 0, sizeof( zclCCSupplyStatusResponse_t ) );
   1838          
   1839            SupplyStatus_cmd.providerId = pCmd->providerId;
   1840            SupplyStatus_cmd.implementationDateTime = osal_getClock();
   1841            SupplyStatus_cmd.supplyStatus = pCmd->proposedSupplyStatus;
   1842          
   1843            zclSE_Prepayment_Send_SupplyStatusResponse( ESP_ENDPOINT, srcAddr, &SupplyStatus_cmd,
   1844                                                        FALSE, seqNum );
   1845          #endif  // SE_UK_EXT
   1846          #endif  // ZCL_PREPAYMENT
   1847          }
   \   000000   02....       LJMP    ?BRET
   1848          
   1849          /*********************************************************************
   1850           * @fn      esp_SupplyStatusRspCB
   1851           *
   1852           * @brief    Callback from the ZCL SE Prepayment Cluster Library when it recieved
   1853           *           Supply Status Response command in the application
   1854           *
   1855           * @param   pCmd - pointer to structure for Supply Status Response command
   1856           * @param   srcAddr - pointer to source address
   1857           * @param   seqNum - Sequence no of the message
   1858           *
   1859           * @return  none
   1860           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1861          static void esp_SupplyStatusRspCB( zclCCSupplyStatusResponse_t *pCmd,
   \                     esp_SupplyStatusRspCB:
   1862                                                 afAddrType_t *srcAddr, uint8 seqNum )
   1863          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   1864            // add user code here
   1865          }
   \   000000   02....       LJMP    ?BRET
   1866          
   1867          #if defined ( SE_UK_EXT )
   1868          /*********************************************************************
   1869           * @fn      esp_GetSnapshotRspCB
   1870           *
   1871           * @brief   Callback from the ZCL SE Profile Simple Metering Cluster Library when
   1872           *          it received a Get Snapshot Response for
   1873           *          this application.
   1874           *
   1875           * @param   pCmd - pointer to structure for Get Snapshot Response command
   1876           * @param   srcAddr - pointer to source address
   1877           * @param   seqNum - sequence number of this command
   1878           *
   1879           * @return  none
   1880           */
   1881          static void esp_GetSnapshotRspCB( zclCCReqGetSnapshotRsp_t *pCmd,
   1882                                            afAddrType_t *srcAddr, uint8 seqNum )
   1883          {
   1884            // add user code here
   1885          }
   1886          
   1887          /*********************************************************************
   1888           * @fn      esp_PublishTariffInformationCB
   1889           *
   1890           * @brief   Callback from the ZCL SE Profile Price Cluster Library when
   1891           *          it received a Publish Tariff Information for this application.
   1892           *
   1893           * @param   pCmd - pointer to structure for Publish Tariff Information command
   1894           * @param   srcAddr - pointer to source address
   1895           * @param   seqNum - sequence number of this command
   1896           *
   1897           * @return  none
   1898           */
   1899          static void esp_PublishTariffInformationCB( zclCCPublishTariffInformation_t *pCmd,
   1900                                                      afAddrType_t *srcAddr, uint8 seqNum )
   1901          {
   1902            // add user code here
   1903          }
   1904          
   1905          /*********************************************************************
   1906           * @fn      esp_PublishPriceMatrixCB
   1907           *
   1908           * @brief   Callback from the ZCL SE Profile Price Cluster Library when
   1909           *          it received a Publish Price Matrix for this application.
   1910           *
   1911           * @param   pCmd - pointer to structure for Publish Price Matrix command
   1912           * @param   srcAddr - pointer to source address
   1913           * @param   seqNum - sequence number of this command
   1914           *
   1915           * @return  none
   1916           */
   1917          static void esp_PublishPriceMatrixCB( zclCCPublishPriceMatrix_t *pCmd,
   1918                                                afAddrType_t *srcAddr, uint8 seqNum )
   1919          {
   1920            // add user code here
   1921          }
   1922          
   1923          /*********************************************************************
   1924           * @fn      esp_PublishBlockThresholdsCB
   1925           *
   1926           * @brief   Callback from the ZCL SE Profile Price Cluster Library when
   1927           *          it received a Publish Block Thresholds for this application.
   1928           *
   1929           * @param   pCmd - pointer to structure for Publish Block Thresholds command
   1930           * @param   srcAddr - pointer to source address
   1931           * @param   seqNum - sequence number of this command
   1932           *
   1933           * @return  none
   1934           */
   1935          static void esp_PublishBlockThresholdsCB( zclCCPublishBlockThresholds_t *pCmd,
   1936                                                    afAddrType_t *srcAddr, uint8 seqNum )
   1937          {
   1938            // add user code here
   1939          }
   1940          
   1941          /*********************************************************************
   1942           * @fn      esp_PublishConversionFactorCB
   1943           *
   1944           * @brief   Callback from the ZCL SE Profile Price Cluster Library when
   1945           *          it received a Publish Conversion Factor for this application.
   1946           *
   1947           * @param   pCmd - pointer to structure for Publish Conversion Factor command
   1948           * @param   srcAddr - pointer to source address
   1949           * @param   seqNum - sequence number of this command
   1950           *
   1951           * @return  none
   1952           */
   1953          static void esp_PublishConversionFactorCB( zclCCPublishConversionFactor_t *pCmd,
   1954                                                     afAddrType_t *srcAddr, uint8 seqNum )
   1955          {
   1956            // add user code here
   1957          }
   1958          
   1959          /*********************************************************************
   1960           * @fn      esp_PublishCalorificValueCB
   1961           *
   1962           * @brief   Callback from the ZCL SE Profile Price Cluster Library when
   1963           *          it received a Publish Calorific Value for this application.
   1964           *
   1965           * @param   pCmd - pointer to structure for Publish Calorific Value command
   1966           * @param   srcAddr - pointer to source address
   1967           * @param   seqNum - sequence number of this command
   1968           *
   1969           * @return  none
   1970           */
   1971          static void esp_PublishCalorificValueCB( zclCCPublishCalorificValue_t *pCmd,
   1972                                                   afAddrType_t *srcAddr, uint8 seqNum )
   1973          {
   1974            // add user code here
   1975          }
   1976          
   1977          /*********************************************************************
   1978           * @fn      esp_PublishCO2ValueCB
   1979           *
   1980           * @brief   Callback from the ZCL SE Profile Price Cluster Library when
   1981           *          it received a Publish CO2 Value for this application.
   1982           *
   1983           * @param   pCmd - pointer to structure for Publish CO2 Value command
   1984           * @param   srcAddr - pointer to source address
   1985           * @param   seqNum - sequence number of this command
   1986           *
   1987           * @return  none
   1988           */
   1989          static void esp_PublishCO2ValueCB( zclCCPublishCO2Value_t *pCmd,
   1990                                             afAddrType_t *srcAddr, uint8 seqNum )
   1991          {
   1992            // add user code here
   1993          }
   1994          
   1995          /*********************************************************************
   1996           * @fn      esp_PublishCPPEventCB
   1997           *
   1998           * @brief   Callback from the ZCL SE Profile Price Cluster Library when
   1999           *          it received a Publish CPP Event for this application.
   2000           *
   2001           * @param   pCmd - pointer to structure for Publish CPP Event command
   2002           * @param   srcAddr - pointer to source address
   2003           * @param   seqNum - sequence number of this command
   2004           *
   2005           * @return  none
   2006           */
   2007          static void esp_PublishCPPEventCB( zclCCPublishCPPEvent_t *pCmd,
   2008                                             afAddrType_t *srcAddr, uint8 seqNum )
   2009          {
   2010            // add user code here
   2011          }
   2012          
   2013          /*********************************************************************
   2014           * @fn      esp_PublishBillingPeriodCB
   2015           *
   2016           * @brief   Callback from the ZCL SE Profile Price Cluster Library when
   2017           *          it received a Publish Billing Period for this application.
   2018           *
   2019           * @param   pCmd - pointer to structure for Publish Billing Period command
   2020           * @param   srcAddr - pointer to source address
   2021           * @param   seqNum - sequence number of this command
   2022           *
   2023           * @return  none
   2024           */
   2025          static void esp_PublishBillingPeriodCB( zclCCPublishBillingPeriod_t *pCmd,
   2026                                                  afAddrType_t *srcAddr, uint8 seqNum )
   2027          {
   2028            // add user code here
   2029          }
   2030          
   2031          /*********************************************************************
   2032           * @fn      esp_PublishConsolidatedBillCB
   2033           *
   2034           * @brief   Callback from the ZCL SE Profile Price Cluster Library when
   2035           *          it received a Publish Consolidated Bill for this application.
   2036           *
   2037           * @param   pCmd - pointer to structure for Publish Consolidated Bill command
   2038           * @param   srcAddr - pointer to source address
   2039           * @param   seqNum - sequence number of this command
   2040           *
   2041           * @return  none
   2042           */
   2043          static void esp_PublishConsolidatedBillCB( zclCCPublishConsolidatedBill_t *pCmd,
   2044                                                     afAddrType_t *srcAddr, uint8 seqNum )
   2045          {
   2046            // add user code here
   2047          }
   2048          
   2049          /*********************************************************************
   2050           * @fn      esp_PublishCreditPaymentInfoCB
   2051           *
   2052           * @brief   Callback from the ZCL SE Profile Price Cluster Library when
   2053           *          it received a Publish Credit Payment Info for this application.
   2054           *
   2055           * @param   pCmd - pointer to structure for Publish Credit Payment Info command
   2056           * @param   srcAddr - pointer to source address
   2057           * @param   seqNum - sequence number of this command
   2058           *
   2059           * @return  none
   2060           */
   2061          static void esp_PublishCreditPaymentInfoCB( zclCCPublishCreditPaymentInfo_t *pCmd,
   2062                                                      afAddrType_t *srcAddr, uint8 seqNum )
   2063          {
   2064            // add user code here
   2065          }
   2066          
   2067          /*********************************************************************
   2068           * @fn      esp_GetTariffInformationCB
   2069           *
   2070           * @brief   Callback from the ZCL SE Profile Price Cluster Library when
   2071           *          it received a Get Tariff Information for this application.
   2072           *
   2073           * @param   pCmd - pointer to structure for Get Tariff Information command
   2074           * @param   srcAddr - pointer to source address
   2075           * @param   seqNum - sequence number of this command
   2076           *
   2077           * @return  none
   2078           */
   2079          static void esp_GetTariffInformationCB( zclCCGetTariffInformation_t *pCmd,
   2080                                                  afAddrType_t *srcAddr, uint8 seqNum )
   2081          {
   2082            // add user code here
   2083          }
   2084          
   2085          /*********************************************************************
   2086           * @fn      esp_GetPriceMatrixCB
   2087           *
   2088           * @brief   Callback from the ZCL SE Profile Price Cluster Library when
   2089           *          it received a Get Price Matrix for this application.
   2090           *
   2091           * @param   issuerTariffId - issuer tariff Id
   2092           * @param   srcAddr - pointer to source address
   2093           * @param   seqNum - sequence number of this command
   2094           *
   2095           * @return  none
   2096           */
   2097          static void esp_GetPriceMatrixCB( uint32 issuerTariffId,
   2098                                            afAddrType_t *srcAddr, uint8 seqNum )
   2099          {
   2100            // add user code here
   2101          }
   2102          
   2103          /*********************************************************************
   2104           * @fn      esp_GetBlockThresholdsCB
   2105           *
   2106           * @brief   Callback from the ZCL SE Profile Price Cluster Library when
   2107           *          it received a Get Block Thresholds for this application.
   2108           *
   2109           * @param   issuerTariffId - issuer tariff Id
   2110           * @param   srcAddr - pointer to source address
   2111           * @param   seqNum - sequence number of this command
   2112           *
   2113           * @return  none
   2114           */
   2115          static void esp_GetBlockThresholdsCB( uint32 issuerTariffId,
   2116                                                afAddrType_t *srcAddr, uint8 seqNum )
   2117          {
   2118            // add user code here
   2119          }
   2120          
   2121          /*********************************************************************
   2122           * @fn      esp_GetConversionFactorCB
   2123           *
   2124           * @brief   Callback from the ZCL SE Profile Price Cluster Library when
   2125           *          it received a Get Conversion Factor for this application.
   2126           *
   2127           * @param   pCmd - pointer to structure for Get Conversion Factor command
   2128           * @param   srcAddr - pointer to source address
   2129           * @param   seqNum - sequence number of this command
   2130           *
   2131           * @return  none
   2132           */
   2133          static void esp_GetConversionFactorCB( zclCCGetConversionFactor_t *pCmd,
   2134                                                 afAddrType_t *srcAddr, uint8 seqNum )
   2135          {
   2136            // add user code here
   2137          }
   2138          
   2139          /*********************************************************************
   2140           * @fn      esp_GetCalorificValueCB
   2141           *
   2142           * @brief   Callback from the ZCL SE Profile Price Cluster Library when
   2143           *          it received a Get Calorific Value for this application.
   2144           *
   2145           * @param   pCmd - pointer to structure for Get Calorific Value command
   2146           * @param   srcAddr - pointer to source address
   2147           * @param   seqNum - sequence number of this command
   2148           *
   2149           * @return  none
   2150           */
   2151          static void esp_GetCalorificValueCB( zclCCGetCalorificValue_t *pCmd,
   2152                                               afAddrType_t *srcAddr, uint8 seqNum )
   2153          {
   2154            // add user code here
   2155          }
   2156          
   2157          /*********************************************************************
   2158           * @fn      esp_GetCO2ValueCB
   2159           *
   2160           * @brief   Callback from the ZCL SE Profile Price Cluster Library when
   2161           *          it received a Get CO2 Value for this application.
   2162           *
   2163           * @param   pCmd - pointer to structure for Get CO2 Value command
   2164           * @param   srcAddr - pointer to source address
   2165           * @param   seqNum - sequence number of this command
   2166           *
   2167           * @return  none
   2168           */
   2169          static void esp_GetCO2ValueCB( zclCCGetCO2Value_t *pCmd,
   2170                                         afAddrType_t *srcAddr, uint8 seqNum )
   2171          {
   2172            // add user code here
   2173          }
   2174          
   2175          /*********************************************************************
   2176           * @fn      esp_GetBillingPeriodCB
   2177           *
   2178           * @brief   Callback from the ZCL SE Profile Price Cluster Library when
   2179           *          it received a Get Billing Period for this application.
   2180           *
   2181           * @param   pCmd - pointer to structure for Get Billing Period command
   2182           * @param   srcAddr - pointer to source address
   2183           * @param   seqNum - sequence number of this command
   2184           *
   2185           * @return  none
   2186           */
   2187          static void esp_GetBillingPeriodCB( zclCCGetBillingPeriod_t *pCmd,
   2188                                              afAddrType_t *srcAddr, uint8 seqNum )
   2189          {
   2190            // add user code here
   2191          }
   2192          
   2193          /*********************************************************************
   2194           * @fn      esp_GetConsolidatedBillCB
   2195           *
   2196           * @brief   Callback from the ZCL SE Profile Price Cluster Library when
   2197           *          it received a Get Consolidated Bill for this application.
   2198           *
   2199           * @param   pCmd - pointer to structure for Get Consolidated Bill command
   2200           * @param   srcAddr - pointer to source address
   2201           * @param   seqNum - sequence number of this command
   2202           *
   2203           * @return  none
   2204           */
   2205          static void esp_GetConsolidatedBillCB( zclCCGetConsolidatedBill_t *pCmd,
   2206                                                 afAddrType_t *srcAddr, uint8 seqNum )
   2207          {
   2208            // add user code here
   2209          }
   2210          
   2211          /*********************************************************************
   2212           * @fn      esp_CPPEventResponseCB
   2213           *
   2214           * @brief   Callback from the ZCL SE Profile Price Cluster Library when
   2215           *          it received a CPP Event Response for this application.
   2216           *
   2217           * @param   pCmd - pointer to structure for CPP Event Response command
   2218           * @param   srcAddr - pointer to source address
   2219           * @param   seqNum - sequence number of this command
   2220           *
   2221           * @return  none
   2222           */
   2223          static void esp_CPPEventResponseCB( zclCCCPPEventResponse_t *pCmd,
   2224                                              afAddrType_t *srcAddr, uint8 seqNum )
   2225          {
   2226            // add user code here
   2227          }
   2228          
   2229          /*********************************************************************
   2230           * @fn      esp_ChangeDebtCB
   2231           *
   2232           * @brief   Callback from the ZCL SE Profile Prepayment Cluster Library when
   2233           *          it received a Change Debt for this application.
   2234           *
   2235           * @param   pCmd - pointer to structure for Change Debt command
   2236           * @param   srcAddr - pointer to source address
   2237           * @param   seqNum - sequence number of this command
   2238           *
   2239           * @return  none
   2240           */
   2241          static void esp_ChangeDebtCB( zclCCChangeDebt_t *pCmd,
   2242                                        afAddrType_t *srcAddr, uint8 seqNum )
   2243          {
   2244            // add user code here
   2245          }
   2246          
   2247          /*********************************************************************
   2248           * @fn      esp_EmergencyCreditSetupCB
   2249           *
   2250           * @brief   Callback from the ZCL SE Profile Prepayment Cluster Library when
   2251           *          it received a Emergency Credit Setup for this application.
   2252           *
   2253           * @param   pCmd - pointer to structure for Emergency Credit Setup command
   2254           * @param   srcAddr - pointer to source address
   2255           * @param   seqNum - sequence number of this command
   2256           *
   2257           * @return  none
   2258           */
   2259          static void esp_EmergencyCreditSetupCB( zclCCEmergencyCreditSetup_t *pCmd,
   2260                                                  afAddrType_t *srcAddr, uint8 seqNum )
   2261          {
   2262            // add user code here
   2263          }
   2264          
   2265          /*********************************************************************
   2266           * @fn      esp_ConsumerTopupCB
   2267           *
   2268           * @brief   Callback from the ZCL SE Profile Prepayment Cluster Library when
   2269           *          it received a Consumer Topup for this application.
   2270           *
   2271           * @param   pCmd - pointer to structure for Consumer Topup command
   2272           * @param   srcAddr - pointer to source address
   2273           * @param   seqNum - sequence number of this command
   2274           *
   2275           * @return  none
   2276           */
   2277          static void esp_ConsumerTopupCB( zclCCConsumerTopup_t *pCmd,
   2278                                           afAddrType_t *srcAddr, uint8 seqNum )
   2279          {
   2280            // add user code here
   2281          }
   2282          
   2283          /*********************************************************************
   2284           * @fn      esp_CreditAdjustmentCB
   2285           *
   2286           * @brief   Callback from the ZCL SE Profile Prepayment Cluster Library when
   2287           *          it received a Credit Adjustment for this application.
   2288           *
   2289           * @param   pCmd - pointer to structure for Credit Adjustment command
   2290           * @param   srcAddr - pointer to source address
   2291           * @param   seqNum - sequence number of this command
   2292           *
   2293           * @return  none
   2294           */
   2295          static void esp_CreditAdjustmentCB( zclCCCreditAdjustment_t *pCmd,
   2296                                              afAddrType_t *srcAddr, uint8 seqNum )
   2297          {
   2298            // add user code here
   2299          }
   2300          
   2301          /*********************************************************************
   2302           * @fn      esp_ChangePaymentModeCB
   2303           *
   2304           * @brief   Callback from the ZCL SE Profile Prepayment Cluster Library when
   2305           *          it received a Change Payment Mode for this application.
   2306           *
   2307           * @param   pCmd - pointer to structure for Change Payment Mode command
   2308           * @param   srcAddr - pointer to source address
   2309           * @param   seqNum - sequence number of this command
   2310           *
   2311           * @return  none
   2312           */
   2313          static void esp_ChangePaymentModeCB( zclCCChangePaymentMode_t *pCmd,
   2314                                               afAddrType_t *srcAddr, uint8 seqNum )
   2315          {
   2316            // add user code here
   2317          }
   2318          
   2319          /*********************************************************************
   2320           * @fn      esp_GetPrepaySnapshotCB
   2321           *
   2322           * @brief   Callback from the ZCL SE Profile Prepayment Cluster Library when
   2323           *          it received a Get Prepay Snapshot for this application.
   2324           *
   2325           * @param   pCmd - pointer to structure for Get Prepay Snapshot command
   2326           * @param   srcAddr - pointer to source address
   2327           * @param   seqNum - sequence number of this command
   2328           *
   2329           * @return  none
   2330           */
   2331          static void esp_GetPrepaySnapshotCB( zclCCGetPrepaySnapshot_t *pCmd,
   2332                                               afAddrType_t *srcAddr, uint8 seqNum )
   2333          {
   2334            // add user code here
   2335          }
   2336          
   2337          /*********************************************************************
   2338           * @fn      esp_GetTopupLogCB
   2339           *
   2340           * @brief   Callback from the ZCL SE Profile Prepayment Cluster Library when
   2341           *          it received a Get Topup Log for this application.
   2342           *
   2343           * @param   numEvents - number of events
   2344           * @param   srcAddr - pointer to source address
   2345           * @param   seqNum - sequence number of this command
   2346           *
   2347           * @return  none
   2348           */
   2349          static void esp_GetTopupLogCB( uint8 numEvents,
   2350                                         afAddrType_t *srcAddr, uint8 seqNum )
   2351          {
   2352            // add user code here
   2353          }
   2354          
   2355          /*********************************************************************
   2356           * @fn      esp_SetLowCreditWarningLevelCB
   2357           *
   2358           * @brief   Callback from the ZCL SE Profile Prepayment Cluster Library when
   2359           *          it received a Set Low Credit Warning Level for this application.
   2360           *
   2361           * @param   numEvents - number of events
   2362           * @param   srcAddr - pointer to source address
   2363           * @param   seqNum - sequence number of this command
   2364           *
   2365           * @return  none
   2366           */
   2367          static void esp_SetLowCreditWarningLevelCB( uint8 numEvents,
   2368                                                      afAddrType_t *srcAddr, uint8 seqNum )
   2369          {
   2370            // add user code here
   2371          }
   2372          
   2373          /*********************************************************************
   2374           * @fn      esp_GetDebtRepaymentLogCB
   2375           *
   2376           * @brief   Callback from the ZCL SE Profile Prepayment Cluster Library when
   2377           *          it received a Get Debt Repayment Log for this application.
   2378           *
   2379           * @param   pCmd - pointer to structure for Get Debt Repayment Log command
   2380           * @param   srcAddr - pointer to source address
   2381           * @param   seqNum - sequence number of this command
   2382           *
   2383           * @return  none
   2384           */
   2385          static void esp_GetDebtRepaymentLogCB( zclCCGetDebtRepaymentLog_t *pCmd,
   2386                                                 afAddrType_t *srcAddr, uint8 seqNum )
   2387          {
   2388            // add user code here
   2389          }
   2390          
   2391          /*********************************************************************
   2392           * @fn      esp_GetPrepaySnapshotResponseCB
   2393           *
   2394           * @brief   Callback from the ZCL SE Profile Prepayment Cluster Library when
   2395           *          it received a Get Prepay Snapshot Response for this application.
   2396           *
   2397           * @param   pCmd - pointer to structure for Get Prepay Snapshot Response command
   2398           * @param   srcAddr - pointer to source address
   2399           * @param   seqNum - sequence number of this command
   2400           *
   2401           * @return  none
   2402           */
   2403          static void esp_GetPrepaySnapshotResponseCB( zclCCGetPrepaySnapshotResponse_t *pCmd,
   2404                                                       afAddrType_t *srcAddr, uint8 seqNum )
   2405          {
   2406            // add user code here
   2407          }
   2408          
   2409          /*********************************************************************
   2410           * @fn      esp_ChangePaymentModeResponseCB
   2411           *
   2412           * @brief   Callback from the ZCL SE Profile Prepayment Cluster Library when
   2413           *          it received a Change Payment Mode Response for this application.
   2414           *
   2415           * @param   pCmd - pointer to structure for Change Payment Mode Response command
   2416           * @param   srcAddr - pointer to source address
   2417           * @param   seqNum - sequence number of this command
   2418           *
   2419           * @return  none
   2420           */
   2421          static void esp_ChangePaymentModeResponseCB( zclCCChangePaymentModeResponse_t *pCmd,
   2422                                                       afAddrType_t *srcAddr, uint8 seqNum )
   2423          {
   2424            // add user code here
   2425          }
   2426          
   2427          /*********************************************************************
   2428           * @fn      esp_ConsumerTopupResponseCB
   2429           *
   2430           * @brief   Callback from the ZCL SE Profile Prepayment Cluster Library when
   2431           *          it received a Consumer Topup Response for this application.
   2432           *
   2433           * @param   pCmd - pointer to structure for Consumer Topup Response command
   2434           * @param   srcAddr - pointer to source address
   2435           * @param   seqNum - sequence number of this command
   2436           *
   2437           * @return  none
   2438           */
   2439          static void esp_ConsumerTopupResponseCB( zclCCConsumerTopupResponse_t *pCmd,
   2440                                                   afAddrType_t *srcAddr, uint8 seqNum )
   2441          {
   2442            // add user code here
   2443          }
   2444          
   2445          /*********************************************************************
   2446           * @fn      esp_GetCommandsCB
   2447           *
   2448           * @brief   Callback from the ZCL SE Profile Prepayment Cluster Library when
   2449           *          it received a Get Commands for this application.
   2450           *
   2451           * @param   prepayNotificationFlags - prepayment notification flags
   2452           * @param   srcAddr - pointer to source address
   2453           * @param   seqNum - sequence number of this command
   2454           *
   2455           * @return  none
   2456           */
   2457          static void esp_GetCommandsCB( uint8 prepayNotificationFlags,
   2458                                         afAddrType_t *srcAddr, uint8 seqNum )
   2459          {
   2460            // add user code here
   2461          }
   2462          
   2463          /*********************************************************************
   2464           * @fn      esp_PublishTopupLogCB
   2465           *
   2466           * @brief   Callback from the ZCL SE Profile Prepayment Cluster Library when
   2467           *          it received a Publish Topup Log for this application.
   2468           *
   2469           * @param   pCmd - pointer to structure for Publish Topup Log command
   2470           * @param   srcAddr - pointer to source address
   2471           * @param   seqNum - sequence number of this command
   2472           *
   2473           * @return  none
   2474           */
   2475          static void esp_PublishTopupLogCB( zclCCPublishTopupLog_t *pCmd,
   2476                                             afAddrType_t *srcAddr, uint8 seqNum )
   2477          {
   2478            // add user code here
   2479          }
   2480          
   2481          /*********************************************************************
   2482           * @fn      esp_PublishDebtLogCB
   2483           *
   2484           * @brief   Callback from the ZCL SE Profile Prepayment Cluster Library when
   2485           *          it received a Publish Debt Log for this application.
   2486           *
   2487           * @param   pCmd - pointer to structure for Publish Debt Log command
   2488           * @param   srcAddr - pointer to source address
   2489           * @param   seqNum - sequence number of this command
   2490           *
   2491           * @return  none
   2492           */
   2493          static void esp_PublishDebtLogCB( zclCCPublishDebtLog_t *pCmd,
   2494                                            afAddrType_t *srcAddr, uint8 seqNum )
   2495          {
   2496            // add user code here
   2497          }
   2498          #endif // SE_UK_EXT
   2499          
   2500          /******************************************************************************
   2501           *
   2502           *  Functions for processing ZDO incoming messages
   2503           *
   2504           *****************************************************************************/
   2505          
   2506          /*********************************************************************
   2507           * @fn      esp_ProcessZDOMsg
   2508           *
   2509           * @brief   Process the incoming ZDO messages.
   2510           *
   2511           * @param   inMsg - message to process
   2512           *
   2513           * @return  none
   2514           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2515          static void esp_ProcessZDOMsg( zdoIncomingMsg_t *inMsg )
   \                     esp_ProcessZDOMsg:
   2516          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 11
   \   000005   74F5         MOV     A,#-0xb
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   2517            ZDO_DeviceAnnce_t devAnnce;
   2518          
   2519            switch ( inMsg->clusterID )
   \   00000E   EE           MOV     A,R6
   \   00000F   240C         ADD     A,#0xc
   \   000011   F582         MOV     DPL,A
   \   000013   EF           MOV     A,R7
   \   000014   3400         ADDC    A,#0x0
   \   000016   F583         MOV     DPH,A
   \   000018   E0           MOVX    A,@DPTR
   \   000019   F5..         MOV     ?V0 + 0,A
   \   00001B   A3           INC     DPTR
   \   00001C   E0           MOVX    A,@DPTR
   \   00001D   F5..         MOV     ?V0 + 1,A
   \   00001F   78..         MOV     R0,#?V0 + 0
   \   000021   12....       LCALL   ?US_SWITCH_SPARSE
   \                     `?<Jumptable for esp_ProcessZDOMsg>_0`:
   \   000024   0000         DW        0
   \   000026   0200         DW        2
   \   000028   1300         DW        19
   \   00002A   ....         DW        ??esp_ProcessZDOMsg_0
   \   00002C   0480         DW        32772
   \   00002E   ....         DW        ??esp_ProcessZDOMsg_1
   \   000030   ....         DW        ??esp_ProcessZDOMsg_2
   2520            {
   2521              case Device_annce:
   2522                {
   2523                  ZDO_ParseDeviceAnnce( inMsg, &devAnnce );
   \                     ??esp_ProcessZDOMsg_0:
   \   000032                ; Setup parameters for call to function ZDO_ParseDeviceAnnce
   \   000032   85..82       MOV     DPL,?XSP + 0
   \   000035   85..83       MOV     DPH,?XSP + 1
   \   000038   AC82         MOV     R4,DPL
   \   00003A   AD83         MOV     R5,DPH
   \   00003C   EE           MOV     A,R6
   \   00003D   FA           MOV     R2,A
   \   00003E   EF           MOV     A,R7
   \   00003F   FB           MOV     R3,A
   \   000040   12....       LCALL   ??ZDO_ParseDeviceAnnce?relay
   2524                  simpleDescReqAddr.addrMode = (afAddrMode_t)Addr16Bit;
   \   000043   90....       MOV     DPTR,#simpleDescReqAddr + 8
   \   000046   7402         MOV     A,#0x2
   \   000048   F0           MOVX    @DPTR,A
   2525                  simpleDescReqAddr.addr.shortAddr = devAnnce.nwkAddr;
   \   000049   85..82       MOV     DPL,?XSP + 0
   \   00004C   85..83       MOV     DPH,?XSP + 1
   \   00004F   E0           MOVX    A,@DPTR
   \   000050   F8           MOV     R0,A
   \   000051   A3           INC     DPTR
   \   000052   E0           MOVX    A,@DPTR
   \   000053   F9           MOV     R1,A
   \   000054   90....       MOV     DPTR,#simpleDescReqAddr
   \   000057   E8           MOV     A,R0
   \   000058   F0           MOVX    @DPTR,A
   \   000059   A3           INC     DPTR
   \   00005A   E9           MOV     A,R1
   \   00005B   F0           MOVX    @DPTR,A
   2526          
   2527                  // set simple descriptor query event
   2528                  osal_set_event( espTaskID, SIMPLE_DESC_QUERY_EVT );
   \   00005C                ; Setup parameters for call to function osal_set_event
   \   00005C   7A04         MOV     R2,#0x4
   \   00005E   7B00         MOV     R3,#0x0
   \   000060   90....       MOV     DPTR,#espTaskID
   \   000063   E0           MOVX    A,@DPTR
   \   000064   F9           MOV     R1,A
   \   000065   12....       LCALL   ??osal_set_event?relay
   \   000068   E9           MOV     A,R1
   2529                }
   2530                break;
   \   000069   02....       LJMP    ??esp_ProcessZDOMsg_2 & 0xFFFF
   2531          
   2532              case Simple_Desc_rsp:
   2533                {
   2534                  ZDO_SimpleDescRsp_t *pSimpleDescRsp;   // pointer to received simple desc response
   2535                  pSimpleDescRsp = (ZDO_SimpleDescRsp_t *)osal_mem_alloc( sizeof( ZDO_SimpleDescRsp_t ) );
   \                     ??esp_ProcessZDOMsg_1:
   \   00006C                ; Setup parameters for call to function osal_mem_alloc
   \   00006C   7A0F         MOV     R2,#0xf
   \   00006E   7B00         MOV     R3,#0x0
   \   000070   12....       LCALL   ??osal_mem_alloc?relay
   \   000073   8A..         MOV     ?V0 + 2,R2
   \   000075   8B..         MOV     ?V0 + 3,R3
   \   000077   85....       MOV     ?V0 + 0,?V0 + 2
   \   00007A   85....       MOV     ?V0 + 1,?V0 + 3
   2536          
   2537                  if(pSimpleDescRsp)
   \   00007D   E5..         MOV     A,?V0 + 0
   \   00007F   45..         ORL     A,?V0 + 1
   \   000081   7003         JNZ     $+5
   \   000083   02....       LJMP    ??esp_ProcessZDOMsg_2 & 0xFFFF
   2538                  {
   2539                    pSimpleDescRsp->simpleDesc.pAppInClusterList = NULL;
   \   000086   85..82       MOV     DPL,?V0 + 0
   \   000089   85..83       MOV     DPH,?V0 + 1
   \   00008C   A3           INC     DPTR
   \   00008D   A3           INC     DPTR
   \   00008E   A3           INC     DPTR
   \   00008F   A3           INC     DPTR
   \   000090   A3           INC     DPTR
   \   000091   A3           INC     DPTR
   \   000092   A3           INC     DPTR
   \   000093   A3           INC     DPTR
   \   000094   A3           INC     DPTR
   \   000095   A3           INC     DPTR
   \   000096   7400         MOV     A,#0x0
   \   000098   F0           MOVX    @DPTR,A
   \   000099   A3           INC     DPTR
   \   00009A   7400         MOV     A,#0x0
   \   00009C   F0           MOVX    @DPTR,A
   2540                    pSimpleDescRsp->simpleDesc.pAppOutClusterList = NULL;
   \   00009D   E5..         MOV     A,?V0 + 0
   \   00009F   240D         ADD     A,#0xd
   \   0000A1   F582         MOV     DPL,A
   \   0000A3   E5..         MOV     A,?V0 + 1
   \   0000A5   3400         ADDC    A,#0x0
   \   0000A7   F583         MOV     DPH,A
   \   0000A9   7400         MOV     A,#0x0
   \   0000AB   F0           MOVX    @DPTR,A
   \   0000AC   A3           INC     DPTR
   \   0000AD   7400         MOV     A,#0x0
   \   0000AF   F0           MOVX    @DPTR,A
   2541          
   2542                    ZDO_ParseSimpleDescRsp( inMsg, pSimpleDescRsp );
   \   0000B0                ; Setup parameters for call to function ZDO_ParseSimpleDescRsp
   \   0000B0   AC..         MOV     R4,?V0 + 0
   \   0000B2   AD..         MOV     R5,?V0 + 1
   \   0000B4   EE           MOV     A,R6
   \   0000B5   FA           MOV     R2,A
   \   0000B6   EF           MOV     A,R7
   \   0000B7   FB           MOV     R3,A
   \   0000B8   12....       LCALL   ??ZDO_ParseSimpleDescRsp?relay
   2543                    if( pSimpleDescRsp->simpleDesc.AppDeviceId == ZCL_SE_DEVICEID_PCT ) // this is a PCT
   \   0000BB   85..82       MOV     DPL,?V0 + 0
   \   0000BE   85..83       MOV     DPH,?V0 + 1
   \   0000C1   A3           INC     DPTR
   \   0000C2   A3           INC     DPTR
   \   0000C3   A3           INC     DPTR
   \   0000C4   A3           INC     DPTR
   \   0000C5   A3           INC     DPTR
   \   0000C6   A3           INC     DPTR
   \   0000C7   E0           MOVX    A,@DPTR
   \   0000C8   6403         XRL     A,#0x3
   \   0000CA   7004         JNZ     ??esp_ProcessZDOMsg_3
   \   0000CC   A3           INC     DPTR
   \   0000CD   E0           MOVX    A,@DPTR
   \   0000CE   6405         XRL     A,#0x5
   \                     ??esp_ProcessZDOMsg_3:
   \   0000D0   7016         JNZ     ??esp_ProcessZDOMsg_4
   2544                    {
   2545                      pctAddr.addr.shortAddr = pSimpleDescRsp->nwkAddr;
   \   0000D2   85..82       MOV     DPL,?V0 + 0
   \   0000D5   85..83       MOV     DPH,?V0 + 1
   \   0000D8   A3           INC     DPTR
   \   0000D9   E0           MOVX    A,@DPTR
   \   0000DA   F8           MOV     R0,A
   \   0000DB   A3           INC     DPTR
   \   0000DC   E0           MOVX    A,@DPTR
   \   0000DD   F9           MOV     R1,A
   \   0000DE   90....       MOV     DPTR,#pctAddr
   \   0000E1   E8           MOV     A,R0
   \   0000E2   F0           MOVX    @DPTR,A
   \   0000E3   A3           INC     DPTR
   \   0000E4   E9           MOV     A,R1
   \   0000E5   F0           MOVX    @DPTR,A
   \   0000E6   802B         SJMP    ??esp_ProcessZDOMsg_5
   2546                    }
   2547                    else if ( pSimpleDescRsp->simpleDesc.AppDeviceId == ZCL_SE_DEVICEID_LOAD_CTRL_EXTENSION ) // this is a load control device
   \                     ??esp_ProcessZDOMsg_4:
   \   0000E8   85..82       MOV     DPL,?V0 + 0
   \   0000EB   85..83       MOV     DPH,?V0 + 1
   \   0000EE   A3           INC     DPTR
   \   0000EF   A3           INC     DPTR
   \   0000F0   A3           INC     DPTR
   \   0000F1   A3           INC     DPTR
   \   0000F2   A3           INC     DPTR
   \   0000F3   A3           INC     DPTR
   \   0000F4   E0           MOVX    A,@DPTR
   \   0000F5   6404         XRL     A,#0x4
   \   0000F7   7004         JNZ     ??esp_ProcessZDOMsg_6
   \   0000F9   A3           INC     DPTR
   \   0000FA   E0           MOVX    A,@DPTR
   \   0000FB   6405         XRL     A,#0x5
   \                     ??esp_ProcessZDOMsg_6:
   \   0000FD   7014         JNZ     ??esp_ProcessZDOMsg_5
   2548                    {
   2549                      loadControlAddr.addr.shortAddr = pSimpleDescRsp->nwkAddr;
   \   0000FF   85..82       MOV     DPL,?V0 + 0
   \   000102   85..83       MOV     DPH,?V0 + 1
   \   000105   A3           INC     DPTR
   \   000106   E0           MOVX    A,@DPTR
   \   000107   F8           MOV     R0,A
   \   000108   A3           INC     DPTR
   \   000109   E0           MOVX    A,@DPTR
   \   00010A   F9           MOV     R1,A
   \   00010B   90....       MOV     DPTR,#loadControlAddr
   \   00010E   E8           MOV     A,R0
   \   00010F   F0           MOVX    @DPTR,A
   \   000110   A3           INC     DPTR
   \   000111   E9           MOV     A,R1
   \   000112   F0           MOVX    @DPTR,A
   2550                    }
   2551          
   2552                    // free memory for InClusterList
   2553                    if (pSimpleDescRsp->simpleDesc.pAppInClusterList)
   \                     ??esp_ProcessZDOMsg_5:
   \   000113   85..82       MOV     DPL,?V0 + 0
   \   000116   85..83       MOV     DPH,?V0 + 1
   \   000119   A3           INC     DPTR
   \   00011A   A3           INC     DPTR
   \   00011B   A3           INC     DPTR
   \   00011C   A3           INC     DPTR
   \   00011D   A3           INC     DPTR
   \   00011E   A3           INC     DPTR
   \   00011F   A3           INC     DPTR
   \   000120   A3           INC     DPTR
   \   000121   A3           INC     DPTR
   \   000122   A3           INC     DPTR
   \   000123   E0           MOVX    A,@DPTR
   \   000124   F8           MOV     R0,A
   \   000125   A3           INC     DPTR
   \   000126   E0           MOVX    A,@DPTR
   \   000127   F9           MOV     R1,A
   \   000128   E8           MOV     A,R0
   \   000129   49           ORL     A,R1
   \   00012A   6018         JZ      ??esp_ProcessZDOMsg_7
   2554                    {
   2555                      osal_mem_free(pSimpleDescRsp->simpleDesc.pAppInClusterList);
   \   00012C                ; Setup parameters for call to function osal_mem_free
   \   00012C   85..82       MOV     DPL,?V0 + 0
   \   00012F   85..83       MOV     DPH,?V0 + 1
   \   000132   A3           INC     DPTR
   \   000133   A3           INC     DPTR
   \   000134   A3           INC     DPTR
   \   000135   A3           INC     DPTR
   \   000136   A3           INC     DPTR
   \   000137   A3           INC     DPTR
   \   000138   A3           INC     DPTR
   \   000139   A3           INC     DPTR
   \   00013A   A3           INC     DPTR
   \   00013B   A3           INC     DPTR
   \   00013C   E0           MOVX    A,@DPTR
   \   00013D   FA           MOV     R2,A
   \   00013E   A3           INC     DPTR
   \   00013F   E0           MOVX    A,@DPTR
   \   000140   FB           MOV     R3,A
   \   000141   12....       LCALL   ??osal_mem_free?relay
   2556                    }
   2557          
   2558                    // free memory for OutClusterList
   2559                    if (pSimpleDescRsp->simpleDesc.pAppOutClusterList)
   \                     ??esp_ProcessZDOMsg_7:
   \   000144   E5..         MOV     A,?V0 + 0
   \   000146   240D         ADD     A,#0xd
   \   000148   F582         MOV     DPL,A
   \   00014A   E5..         MOV     A,?V0 + 1
   \   00014C   3400         ADDC    A,#0x0
   \   00014E   F583         MOV     DPH,A
   \   000150   E0           MOVX    A,@DPTR
   \   000151   F8           MOV     R0,A
   \   000152   A3           INC     DPTR
   \   000153   E0           MOVX    A,@DPTR
   \   000154   F9           MOV     R1,A
   \   000155   E8           MOV     A,R0
   \   000156   49           ORL     A,R1
   \   000157   6014         JZ      ??esp_ProcessZDOMsg_8
   2560                    {
   2561                      osal_mem_free(pSimpleDescRsp->simpleDesc.pAppOutClusterList);
   \   000159                ; Setup parameters for call to function osal_mem_free
   \   000159   E5..         MOV     A,?V0 + 0
   \   00015B   240D         ADD     A,#0xd
   \   00015D   F582         MOV     DPL,A
   \   00015F   E5..         MOV     A,?V0 + 1
   \   000161   3400         ADDC    A,#0x0
   \   000163   F583         MOV     DPH,A
   \   000165   E0           MOVX    A,@DPTR
   \   000166   FA           MOV     R2,A
   \   000167   A3           INC     DPTR
   \   000168   E0           MOVX    A,@DPTR
   \   000169   FB           MOV     R3,A
   \   00016A   12....       LCALL   ??osal_mem_free?relay
   2562                    }
   2563          
   2564                    osal_mem_free( pSimpleDescRsp );
   \                     ??esp_ProcessZDOMsg_8:
   \   00016D                ; Setup parameters for call to function osal_mem_free
   \   00016D   AA..         MOV     R2,?V0 + 0
   \   00016F   AB..         MOV     R3,?V0 + 1
   \   000171   12....       LCALL   ??osal_mem_free?relay
   2565                  }
   2566                }
   2567                break;
   2568            }
   2569          }
   \                     ??esp_ProcessZDOMsg_2:
   \   000174   740B         MOV     A,#0xb
   \   000176   12....       LCALL   ?DEALLOC_XSTACK8
   \   000179   7F04         MOV     R7,#0x4
   \   00017B   02....       LJMP    ?BANKED_LEAVE_XDATA
   2570          
   2571          
   2572          /******************************************************************************
   2573           *
   2574           *  Functions for processing ZCL Foundation incoming Command/Response messages
   2575           *
   2576           *****************************************************************************/
   2577          
   2578          /*********************************************************************
   2579           * @fn      esp_ProcessZCLMsg
   2580           *
   2581           * @brief   Process ZCL Foundation incoming message
   2582           *
   2583           * @param   pInMsg - message to process
   2584           *
   2585           * @return  none
   2586           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2587          static void esp_ProcessZCLMsg( zclIncomingMsg_t *pInMsg )
   \                     esp_ProcessZCLMsg:
   2588          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   2589          
   2590          #if defined ( SE_UK_EXT ) && defined ( SE_MIRROR )
   2591            if ( esp_IsMirrorEndpoint( pInMsg->endPoint ) )
   2592            {
   2593              esp_MirrorProcessZCLMsg( pInMsg );
   2594            }
   2595            else
   2596          #endif  // SE_UK_EXT && SE_MIRROR
   2597            {
   2598              switch ( pInMsg->zclHdr.commandID )
   \   000009   8E82         MOV     DPL,R6
   \   00000B   8F83         MOV     DPH,R7
   \   00000D   A3           INC     DPTR
   \   00000E   A3           INC     DPTR
   \   00000F   A3           INC     DPTR
   \   000010   A3           INC     DPTR
   \   000011   A3           INC     DPTR
   \   000012   A3           INC     DPTR
   \   000013   A3           INC     DPTR
   \   000014   E0           MOVX    A,@DPTR
   \   000015   14           DEC     A
   \   000016   6019         JZ      ??esp_ProcessZCLMsg_0
   \   000018   24FD         ADD     A,#-0x3
   \   00001A   601F         JZ      ??esp_ProcessZCLMsg_1
   \   00001C   24FE         ADD     A,#-0x2
   \   00001E   6025         JZ      ??esp_ProcessZCLMsg_2
   \   000020   14           DEC     A
   \   000021   602C         JZ      ??esp_ProcessZCLMsg_3
   \   000023   14           DEC     A
   \   000024   6033         JZ      ??esp_ProcessZCLMsg_4
   \   000026   14           DEC     A
   \   000027   603A         JZ      ??esp_ProcessZCLMsg_5
   \   000029   14           DEC     A
   \   00002A   6041         JZ      ??esp_ProcessZCLMsg_6
   \   00002C   14           DEC     A
   \   00002D   6048         JZ      ??esp_ProcessZCLMsg_7
   \   00002F   804E         SJMP    ??esp_ProcessZCLMsg_8
   2599              {
   2600          #if defined ( ZCL_READ )
   2601                case ZCL_CMD_READ_RSP:
   2602                  esp_ProcessInReadRspCmd( pInMsg );
   \                     ??esp_ProcessZCLMsg_0:
   \   000031                ; Setup parameters for call to function esp_ProcessInReadRspCmd
   \   000031   EE           MOV     A,R6
   \   000032   FA           MOV     R2,A
   \   000033   EF           MOV     A,R7
   \   000034   FB           MOV     R3,A
   \   000035   12....       LCALL   ??esp_ProcessInReadRspCmd?relay
   \   000038   E9           MOV     A,R1
   2603                  break;
   \   000039   8044         SJMP    ??esp_ProcessZCLMsg_8
   2604          #endif // ZCL_READ
   2605          #if defined ( ZCL_WRITE )
   2606                case ZCL_CMD_WRITE_RSP:
   2607                  esp_ProcessInWriteRspCmd( pInMsg );
   \                     ??esp_ProcessZCLMsg_1:
   \   00003B                ; Setup parameters for call to function esp_ProcessInWriteRspCmd
   \   00003B   EE           MOV     A,R6
   \   00003C   FA           MOV     R2,A
   \   00003D   EF           MOV     A,R7
   \   00003E   FB           MOV     R3,A
   \   00003F   12....       LCALL   ??esp_ProcessInWriteRspCmd?relay
   \   000042   E9           MOV     A,R1
   2608                  break;
   \   000043   803A         SJMP    ??esp_ProcessZCLMsg_8
   2609          #endif // ZCL_WRITE
   2610          #if defined ( ZCL_REPORT )
   2611                case ZCL_CMD_CONFIG_REPORT:
   2612                  esp_ProcessInConfigReportCmd( pInMsg );
   \                     ??esp_ProcessZCLMsg_2:
   \   000045                ; Setup parameters for call to function esp_ProcessInConfigReportCmd
   \   000045   EE           MOV     A,R6
   \   000046   FA           MOV     R2,A
   \   000047   EF           MOV     A,R7
   \   000048   FB           MOV     R3,A
   \   000049   12....       LCALL   ??esp_ProcessInConfigReportCmd?relay
   \   00004C   E9           MOV     A,R1
   2613                  break;
   \   00004D   8030         SJMP    ??esp_ProcessZCLMsg_8
   2614          
   2615                case ZCL_CMD_CONFIG_REPORT_RSP:
   2616                  esp_ProcessInConfigReportRspCmd( pInMsg );
   \                     ??esp_ProcessZCLMsg_3:
   \   00004F                ; Setup parameters for call to function esp_ProcessInConfigReportRspCmd
   \   00004F   EE           MOV     A,R6
   \   000050   FA           MOV     R2,A
   \   000051   EF           MOV     A,R7
   \   000052   FB           MOV     R3,A
   \   000053   12....       LCALL   ??esp_ProcessInConfigReportRspCmd?relay
   \   000056   E9           MOV     A,R1
   2617                  break;
   \   000057   8026         SJMP    ??esp_ProcessZCLMsg_8
   2618          
   2619                case ZCL_CMD_READ_REPORT_CFG:
   2620                  esp_ProcessInReadReportCfgCmd( pInMsg );
   \                     ??esp_ProcessZCLMsg_4:
   \   000059                ; Setup parameters for call to function esp_ProcessInReadReportCfgCmd
   \   000059   EE           MOV     A,R6
   \   00005A   FA           MOV     R2,A
   \   00005B   EF           MOV     A,R7
   \   00005C   FB           MOV     R3,A
   \   00005D   12....       LCALL   ??esp_ProcessInReadReportCfgCmd?relay
   \   000060   E9           MOV     A,R1
   2621                  break;
   \   000061   801C         SJMP    ??esp_ProcessZCLMsg_8
   2622          
   2623                case ZCL_CMD_READ_REPORT_CFG_RSP:
   2624                  esp_ProcessInReadReportCfgRspCmd( pInMsg );
   \                     ??esp_ProcessZCLMsg_5:
   \   000063                ; Setup parameters for call to function esp_ProcessInReadReportCfgRspCmd
   \   000063   EE           MOV     A,R6
   \   000064   FA           MOV     R2,A
   \   000065   EF           MOV     A,R7
   \   000066   FB           MOV     R3,A
   \   000067   12....       LCALL   ??esp_ProcessInReadReportCfgRspCmd?relay
   \   00006A   E9           MOV     A,R1
   2625                  break;
   \   00006B   8012         SJMP    ??esp_ProcessZCLMsg_8
   2626          
   2627                case ZCL_CMD_REPORT:
   2628                  esp_ProcessInReportCmd( pInMsg );
   \                     ??esp_ProcessZCLMsg_6:
   \   00006D                ; Setup parameters for call to function esp_ProcessInReportCmd
   \   00006D   EE           MOV     A,R6
   \   00006E   FA           MOV     R2,A
   \   00006F   EF           MOV     A,R7
   \   000070   FB           MOV     R3,A
   \   000071   12....       LCALL   ??esp_ProcessInReportCmd?relay
   \   000074   E9           MOV     A,R1
   2629                  break;
   \   000075   8008         SJMP    ??esp_ProcessZCLMsg_8
   2630          #endif // ZCL_REPORT
   2631                case ZCL_CMD_DEFAULT_RSP:
   2632                  esp_ProcessInDefaultRspCmd( pInMsg );
   \                     ??esp_ProcessZCLMsg_7:
   \   000077                ; Setup parameters for call to function esp_ProcessInDefaultRspCmd
   \   000077   EE           MOV     A,R6
   \   000078   FA           MOV     R2,A
   \   000079   EF           MOV     A,R7
   \   00007A   FB           MOV     R3,A
   \   00007B   12....       LCALL   ??esp_ProcessInDefaultRspCmd?relay
   \   00007E   E9           MOV     A,R1
   2633                  break;
   2634          #if defined ( ZCL_DISCOVER )
   2635                case ZCL_CMD_DISCOVER_RSP:
   2636                  esp_ProcessInDiscRspCmd( pInMsg );
   2637                  break;
   2638          #endif // ZCL_DISCOVER
   2639                default:
   2640                  break;
   2641              }
   2642            }
   2643          
   2644            if ( pInMsg->attrCmd != NULL )
   \                     ??esp_ProcessZCLMsg_8:
   \   00007F   EE           MOV     A,R6
   \   000080   2417         ADD     A,#0x17
   \   000082   F582         MOV     DPL,A
   \   000084   EF           MOV     A,R7
   \   000085   3400         ADDC    A,#0x0
   \   000087   F583         MOV     DPH,A
   \   000089   E0           MOVX    A,@DPTR
   \   00008A   F8           MOV     R0,A
   \   00008B   A3           INC     DPTR
   \   00008C   E0           MOVX    A,@DPTR
   \   00008D   F9           MOV     R1,A
   \   00008E   E8           MOV     A,R0
   \   00008F   49           ORL     A,R1
   \   000090   6023         JZ      ??esp_ProcessZCLMsg_9
   2645            {
   2646              // free the parsed command
   2647              osal_mem_free( pInMsg->attrCmd );
   \   000092                ; Setup parameters for call to function osal_mem_free
   \   000092   EE           MOV     A,R6
   \   000093   2417         ADD     A,#0x17
   \   000095   F582         MOV     DPL,A
   \   000097   EF           MOV     A,R7
   \   000098   3400         ADDC    A,#0x0
   \   00009A   F583         MOV     DPH,A
   \   00009C   E0           MOVX    A,@DPTR
   \   00009D   FA           MOV     R2,A
   \   00009E   A3           INC     DPTR
   \   00009F   E0           MOVX    A,@DPTR
   \   0000A0   FB           MOV     R3,A
   \   0000A1   12....       LCALL   ??osal_mem_free?relay
   2648              pInMsg->attrCmd = NULL;
   \   0000A4   EE           MOV     A,R6
   \   0000A5   2417         ADD     A,#0x17
   \   0000A7   F582         MOV     DPL,A
   \   0000A9   EF           MOV     A,R7
   \   0000AA   3400         ADDC    A,#0x0
   \   0000AC   F583         MOV     DPH,A
   \   0000AE   7400         MOV     A,#0x0
   \   0000B0   F0           MOVX    @DPTR,A
   \   0000B1   A3           INC     DPTR
   \   0000B2   7400         MOV     A,#0x0
   \   0000B4   F0           MOVX    @DPTR,A
   2649            }
   2650          }
   \                     ??esp_ProcessZCLMsg_9:
   \   0000B5   7F01         MOV     R7,#0x1
   \   0000B7   02....       LJMP    ?BANKED_LEAVE_XDATA
   2651          
   2652          #if defined ( ZCL_READ )
   2653          /*********************************************************************
   2654           * @fn      esp_ProcessInReadRspCmd
   2655           *
   2656           * @brief   Process the "Profile" Read Response Command
   2657           *
   2658           * @param   pInMsg - incoming message to process
   2659           *
   2660           * @return  none
   2661           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2662          static uint8 esp_ProcessInReadRspCmd( zclIncomingMsg_t *pInMsg )
   \                     esp_ProcessInReadRspCmd:
   2663          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   2664            zclReadRspCmd_t *readRspCmd;
   2665            uint8 i;
   2666          
   2667            readRspCmd = (zclReadRspCmd_t *)pInMsg->attrCmd;
   \   000005   EA           MOV     A,R2
   \   000006   2417         ADD     A,#0x17
   \   000008   F582         MOV     DPL,A
   \   00000A   EB           MOV     A,R3
   \   00000B   3400         ADDC    A,#0x0
   \   00000D   F583         MOV     DPH,A
   \   00000F   E0           MOVX    A,@DPTR
   \   000010   F8           MOV     R0,A
   \   000011   A3           INC     DPTR
   \   000012   E0           MOVX    A,@DPTR
   \   000013   F9           MOV     R1,A
   \   000014   E8           MOV     A,R0
   \   000015   FE           MOV     R6,A
   \   000016   E9           MOV     A,R1
   \   000017   FF           MOV     R7,A
   2668            for (i = 0; i < readRspCmd->numAttr; i++)
   \   000018   7C00         MOV     R4,#0x0
   \                     ??esp_ProcessInReadRspCmd_0:
   \   00001A   8E82         MOV     DPL,R6
   \   00001C   8F83         MOV     DPH,R7
   \   00001E   E0           MOVX    A,@DPTR
   \   00001F   F8           MOV     R0,A
   \   000020   EC           MOV     A,R4
   \   000021   C3           CLR     C
   \   000022   98           SUBB    A,R0
   \   000023   5003         JNC     ??esp_ProcessInReadRspCmd_1
   \   000025   0C           INC     R4
   \   000026   80F2         SJMP    ??esp_ProcessInReadRspCmd_0
   2669            {
   2670              // Notify the originator of the results of the original read attributes
   2671              // attempt and, for each successfull request, the value of the requested
   2672              // attribute
   2673            }
   2674          
   2675            return TRUE;
   \                     ??esp_ProcessInReadRspCmd_1:
   \   000028   7901         MOV     R1,#0x1
   \   00002A   7F01         MOV     R7,#0x1
   \   00002C   02....       LJMP    ?BANKED_LEAVE_XDATA
   2676          }
   2677          #endif // ZCL_READ
   2678          
   2679          #if defined ( ZCL_WRITE )
   2680          /*********************************************************************
   2681           * @fn      esp_ProcessInWriteRspCmd
   2682           *
   2683           * @brief   Process the "Profile" Write Response Command
   2684           *
   2685           * @param   pInMsg - incoming message to process
   2686           *
   2687           * @return  none
   2688           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2689          static uint8 esp_ProcessInWriteRspCmd( zclIncomingMsg_t *pInMsg )
   \                     esp_ProcessInWriteRspCmd:
   2690          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   2691            zclWriteRspCmd_t *writeRspCmd;
   2692            uint8 i;
   2693          
   2694            writeRspCmd = (zclWriteRspCmd_t *)pInMsg->attrCmd;
   \   000005   EA           MOV     A,R2
   \   000006   2417         ADD     A,#0x17
   \   000008   F582         MOV     DPL,A
   \   00000A   EB           MOV     A,R3
   \   00000B   3400         ADDC    A,#0x0
   \   00000D   F583         MOV     DPH,A
   \   00000F   E0           MOVX    A,@DPTR
   \   000010   F8           MOV     R0,A
   \   000011   A3           INC     DPTR
   \   000012   E0           MOVX    A,@DPTR
   \   000013   F9           MOV     R1,A
   \   000014   E8           MOV     A,R0
   \   000015   FE           MOV     R6,A
   \   000016   E9           MOV     A,R1
   \   000017   FF           MOV     R7,A
   2695            for (i = 0; i < writeRspCmd->numAttr; i++)
   \   000018   7C00         MOV     R4,#0x0
   \                     ??esp_ProcessInWriteRspCmd_0:
   \   00001A   8E82         MOV     DPL,R6
   \   00001C   8F83         MOV     DPH,R7
   \   00001E   E0           MOVX    A,@DPTR
   \   00001F   F8           MOV     R0,A
   \   000020   EC           MOV     A,R4
   \   000021   C3           CLR     C
   \   000022   98           SUBB    A,R0
   \   000023   5003         JNC     ??esp_ProcessInWriteRspCmd_1
   \   000025   0C           INC     R4
   \   000026   80F2         SJMP    ??esp_ProcessInWriteRspCmd_0
   2696            {
   2697              // Notify the device of the results of the its original write attributes
   2698              // command.
   2699            }
   2700          
   2701            return TRUE;
   \                     ??esp_ProcessInWriteRspCmd_1:
   \   000028   7901         MOV     R1,#0x1
   \   00002A   7F01         MOV     R7,#0x1
   \   00002C   02....       LJMP    ?BANKED_LEAVE_XDATA
   2702          }
   2703          #endif // ZCL_WRITE
   2704          
   2705          #if defined ( ZCL_REPORT )
   2706          /*********************************************************************
   2707           * @fn      esp_ProcessInConfigReportCmd
   2708           *
   2709           * @brief   Process the "Profile" Configure Reporting Command
   2710           *
   2711           * @param   pInMsg - incoming message to process
   2712           *
   2713           * @return  TRUE if attribute was found in the Attribute list,
   2714           *          FALSE if not
   2715           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2716          static uint8 esp_ProcessInConfigReportCmd( zclIncomingMsg_t *pInMsg )
   \                     esp_ProcessInConfigReportCmd:
   2717          {
   \   000000   74EC         MOV     A,#-0x14
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 20
   \   000005                ; Auto size: 8
   \   000005   74F8         MOV     A,#-0x8
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V0 + 4,R2
   \   00000C   8B..         MOV     ?V0 + 5,R3
   2718            zclCfgReportCmd_t *cfgReportCmd;
   2719            zclCfgReportRec_t *reportRec;
   2720            zclCfgReportRspCmd_t *cfgReportRspCmd;
   2721            zclAttrRec_t attrRec;
   2722            uint8 status;
   2723            uint8 i, j = 0;
   \   00000E   7E00         MOV     R6,#0x0
   2724          
   2725            cfgReportCmd = (zclCfgReportCmd_t *)pInMsg->attrCmd;
   \   000010   E5..         MOV     A,?V0 + 4
   \   000012   2417         ADD     A,#0x17
   \   000014   F582         MOV     DPL,A
   \   000016   E5..         MOV     A,?V0 + 5
   \   000018   3400         ADDC    A,#0x0
   \   00001A   F583         MOV     DPH,A
   \   00001C   E0           MOVX    A,@DPTR
   \   00001D   F8           MOV     R0,A
   \   00001E   A3           INC     DPTR
   \   00001F   E0           MOVX    A,@DPTR
   \   000020   F9           MOV     R1,A
   \   000021   88..         MOV     ?V0 + 6,R0
   \   000023   89..         MOV     ?V0 + 7,R1
   2726          
   2727            // Allocate space for the response command
   2728            cfgReportRspCmd = (zclCfgReportRspCmd_t *)osal_mem_alloc( sizeof ( zclCfgReportRspCmd_t ) +
   2729                                                  sizeof ( zclCfgReportStatus_t) * cfgReportCmd->numAttr );
   \   000025                ; Setup parameters for call to function osal_mem_alloc
   \   000025   85..82       MOV     DPL,?V0 + 6
   \   000028   85..83       MOV     DPH,?V0 + 7
   \   00002B   E0           MOVX    A,@DPTR
   \   00002C   F8           MOV     R0,A
   \   00002D   7900         MOV     R1,#0x0
   \   00002F   E8           MOV     A,R0
   \   000030   75F004       MOV     B,#0x4
   \   000033   A4           MUL     AB
   \   000034   C8           XCH     A,R0
   \   000035   AAF0         MOV     R2,B
   \   000037   75F000       MOV     B,#0x0
   \   00003A   A4           MUL     AB
   \   00003B   2A           ADD     A,R2
   \   00003C   FA           MOV     R2,A
   \   00003D   75F004       MOV     B,#0x4
   \   000040   E9           MOV     A,R1
   \   000041   A4           MUL     AB
   \   000042   2A           ADD     A,R2
   \   000043   F9           MOV     R1,A
   \   000044   E8           MOV     A,R0
   \   000045   2401         ADD     A,#0x1
   \   000047   FA           MOV     R2,A
   \   000048   E9           MOV     A,R1
   \   000049   3400         ADDC    A,#0x0
   \   00004B   FB           MOV     R3,A
   \   00004C   12....       LCALL   ??osal_mem_alloc?relay
   \   00004F   8A..         MOV     ?V0 + 10,R2
   \   000051   8B..         MOV     ?V0 + 11,R3
   \   000053   85....       MOV     ?V0 + 8,?V0 + 10
   \   000056   85....       MOV     ?V0 + 9,?V0 + 11
   2730            if ( cfgReportRspCmd == NULL )
   \   000059   E5..         MOV     A,?V0 + 8
   \   00005B   45..         ORL     A,?V0 + 9
   \   00005D   7005         JNZ     ??esp_ProcessInConfigReportCmd_0
   2731            {
   2732              return FALSE; // EMBEDDED RETURN
   \   00005F   7900         MOV     R1,#0x0
   \   000061   02....       LJMP    ??esp_ProcessInConfigReportCmd_1 & 0xFFFF
   2733            }
   2734          
   2735            // Process each Attribute Reporting Configuration record
   2736            for ( i = 0; i < cfgReportCmd->numAttr; i++ )
   \                     ??esp_ProcessInConfigReportCmd_0:
   \   000064   75..00       MOV     ?V0 + 2,#0x0
   \                     ??esp_ProcessInConfigReportCmd_2:
   \   000067   85..82       MOV     DPL,?V0 + 6
   \   00006A   85..83       MOV     DPH,?V0 + 7
   \   00006D   E0           MOVX    A,@DPTR
   \   00006E   F8           MOV     R0,A
   \   00006F   E5..         MOV     A,?V0 + 2
   \   000071   C3           CLR     C
   \   000072   98           SUBB    A,R0
   \   000073   4003         JC      $+5
   \   000075   02....       LJMP    ??esp_ProcessInConfigReportCmd_3 & 0xFFFF
   2737            {
   2738              reportRec = &(cfgReportCmd->attrList[i]);
   \   000078   E5..         MOV     A,?V0 + 2
   \   00007A   A8..         MOV     R0,?V0 + 2
   \   00007C   7900         MOV     R1,#0x0
   \   00007E   E8           MOV     A,R0
   \   00007F   75F00C       MOV     B,#0xc
   \   000082   A4           MUL     AB
   \   000083   C8           XCH     A,R0
   \   000084   AAF0         MOV     R2,B
   \   000086   75F000       MOV     B,#0x0
   \   000089   A4           MUL     AB
   \   00008A   2A           ADD     A,R2
   \   00008B   FA           MOV     R2,A
   \   00008C   75F00C       MOV     B,#0xc
   \   00008F   E9           MOV     A,R1
   \   000090   A4           MUL     AB
   \   000091   2A           ADD     A,R2
   \   000092   F9           MOV     R1,A
   \   000093   E5..         MOV     A,?V0 + 6
   \   000095   28           ADD     A,R0
   \   000096   F582         MOV     DPL,A
   \   000098   E5..         MOV     A,?V0 + 7
   \   00009A   39           ADDC    A,R1
   \   00009B   F583         MOV     DPH,A
   \   00009D   A3           INC     DPTR
   \   00009E   8582..       MOV     ?V0 + 0,DPL
   \   0000A1   8583..       MOV     ?V0 + 1,DPH
   2739          
   2740              status = ZCL_STATUS_SUCCESS;
   \   0000A4   7F00         MOV     R7,#0x0
   2741          
   2742              if ( zclFindAttrRec( ESP_ENDPOINT, pInMsg->clusterId, reportRec->attrID, &attrRec ) )
   \   0000A6                ; Setup parameters for call to function zclFindAttrRec
   \   0000A6   85..82       MOV     DPL,?XSP + 0
   \   0000A9   85..83       MOV     DPH,?XSP + 1
   \   0000AC   8582..       MOV     ?V0 + 10,DPL
   \   0000AF   8583..       MOV     ?V0 + 11,DPH
   \   0000B2   78..         MOV     R0,#?V0 + 10
   \   0000B4   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000B7   85..82       MOV     DPL,?V0 + 0
   \   0000BA   85..83       MOV     DPH,?V0 + 1
   \   0000BD   A3           INC     DPTR
   \   0000BE   E0           MOVX    A,@DPTR
   \   0000BF   FC           MOV     R4,A
   \   0000C0   A3           INC     DPTR
   \   0000C1   E0           MOVX    A,@DPTR
   \   0000C2   FD           MOV     R5,A
   \   0000C3   85..82       MOV     DPL,?V0 + 4
   \   0000C6   85..83       MOV     DPH,?V0 + 5
   \   0000C9   A3           INC     DPTR
   \   0000CA   A3           INC     DPTR
   \   0000CB   A3           INC     DPTR
   \   0000CC   A3           INC     DPTR
   \   0000CD   A3           INC     DPTR
   \   0000CE   A3           INC     DPTR
   \   0000CF   A3           INC     DPTR
   \   0000D0   A3           INC     DPTR
   \   0000D1   E0           MOVX    A,@DPTR
   \   0000D2   FA           MOV     R2,A
   \   0000D3   A3           INC     DPTR
   \   0000D4   E0           MOVX    A,@DPTR
   \   0000D5   FB           MOV     R3,A
   \   0000D6   7909         MOV     R1,#0x9
   \   0000D8   12....       LCALL   ??zclFindAttrRec?relay
   \   0000DB   7402         MOV     A,#0x2
   \   0000DD   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000E0   E9           MOV     A,R1
   \   0000E1   7003         JNZ     $+5
   \   0000E3   02....       LJMP    ??esp_ProcessInConfigReportCmd_4 & 0xFFFF
   2743              {
   2744                if ( reportRec->direction == ZCL_SEND_ATTR_REPORTS )
   \   0000E6   85..82       MOV     DPL,?V0 + 0
   \   0000E9   85..83       MOV     DPH,?V0 + 1
   \   0000EC   E0           MOVX    A,@DPTR
   \   0000ED   6003         JZ      $+5
   \   0000EF   02....       LJMP    ??esp_ProcessInConfigReportCmd_5 & 0xFFFF
   2745                {
   2746                  if ( reportRec->dataType == attrRec.attr.dataType )
   \   0000F2   85..82       MOV     DPL,?V0 + 0
   \   0000F5   85..83       MOV     DPH,?V0 + 1
   \   0000F8   A3           INC     DPTR
   \   0000F9   A3           INC     DPTR
   \   0000FA   A3           INC     DPTR
   \   0000FB   E0           MOVX    A,@DPTR
   \   0000FC   F8           MOV     R0,A
   \   0000FD   7404         MOV     A,#0x4
   \   0000FF   12....       LCALL   ?XSTACK_DISP0_8
   \   000102   E0           MOVX    A,@DPTR
   \   000103   68           XRL     A,R0
   \   000104   706C         JNZ     ??esp_ProcessInConfigReportCmd_6
   2747                  {
   2748                    // This the attribute that is to be reported
   2749                    if ( zcl_MandatoryReportableAttribute( &attrRec ) == TRUE )
   \   000106   85..82       MOV     DPL,?XSP + 0
   \   000109   85..83       MOV     DPH,?XSP + 1
   \   00010C   E582         MOV     A,DPL
   \   00010E   4583         ORL     A,DPH
   \   000110   705C         JNZ     ??esp_ProcessInConfigReportCmd_7
   2750                    {
   2751                      if ( reportRec->minReportInt < ESP_MIN_REPORTING_INTERVAL ||
   2752                           ( reportRec->maxReportInt != 0 &&
   2753                             reportRec->maxReportInt < reportRec->minReportInt ) )
   \   000112   85..82       MOV     DPL,?V0 + 0
   \   000115   85..83       MOV     DPH,?V0 + 1
   \   000118   A3           INC     DPTR
   \   000119   A3           INC     DPTR
   \   00011A   A3           INC     DPTR
   \   00011B   A3           INC     DPTR
   \   00011C   C3           CLR     C
   \   00011D   E0           MOVX    A,@DPTR
   \   00011E   9405         SUBB    A,#0x5
   \   000120   A3           INC     DPTR
   \   000121   E0           MOVX    A,@DPTR
   \   000122   9400         SUBB    A,#0x0
   \   000124   4040         JC      ??esp_ProcessInConfigReportCmd_8
   \   000126   85..82       MOV     DPL,?V0 + 0
   \   000129   85..83       MOV     DPH,?V0 + 1
   \   00012C   A3           INC     DPTR
   \   00012D   A3           INC     DPTR
   \   00012E   A3           INC     DPTR
   \   00012F   A3           INC     DPTR
   \   000130   A3           INC     DPTR
   \   000131   A3           INC     DPTR
   \   000132   E0           MOVX    A,@DPTR
   \   000133   F8           MOV     R0,A
   \   000134   A3           INC     DPTR
   \   000135   E0           MOVX    A,@DPTR
   \   000136   F9           MOV     R1,A
   \   000137   E8           MOV     A,R0
   \   000138   49           ORL     A,R1
   \   000139   602F         JZ      ??esp_ProcessInConfigReportCmd_9
   \   00013B   85..82       MOV     DPL,?V0 + 0
   \   00013E   85..83       MOV     DPH,?V0 + 1
   \   000141   A3           INC     DPTR
   \   000142   A3           INC     DPTR
   \   000143   A3           INC     DPTR
   \   000144   A3           INC     DPTR
   \   000145   A3           INC     DPTR
   \   000146   A3           INC     DPTR
   \   000147   C082         PUSH    DPL
   \   000149   C083         PUSH    DPH
   \   00014B   85..82       MOV     DPL,?V0 + 0
   \   00014E   85..83       MOV     DPH,?V0 + 1
   \   000151   A3           INC     DPTR
   \   000152   A3           INC     DPTR
   \   000153   A3           INC     DPTR
   \   000154   A3           INC     DPTR
   \   000155   E0           MOVX    A,@DPTR
   \   000156   F8           MOV     R0,A
   \   000157   A3           INC     DPTR
   \   000158   E0           MOVX    A,@DPTR
   \   000159   F9           MOV     R1,A
   \   00015A   D083         POP     DPH
   \   00015C   D082         POP     DPL
   \   00015E   C3           CLR     C
   \   00015F   E0           MOVX    A,@DPTR
   \   000160   98           SUBB    A,R0
   \   000161   A3           INC     DPTR
   \   000162   E0           MOVX    A,@DPTR
   \   000163   99           SUBB    A,R1
   \   000164   5004         JNC     ??esp_ProcessInConfigReportCmd_9
   2754                      {
   2755                        // Invalid fields
   2756                        status = ZCL_STATUS_INVALID_VALUE;
   \                     ??esp_ProcessInConfigReportCmd_8:
   \   000166   7F87         MOV     R7,#-0x79
   \   000168   8022         SJMP    ??esp_ProcessInConfigReportCmd_10
   2757                      }
   2758                      else
   2759                      {
   2760                        // Set the Min and Max Reporting Intervals and Reportable Change
   2761                        //status = zclSetAttrReportInterval( pAttr, cfgReportCmd );
   2762                        status = ZCL_STATUS_UNREPORTABLE_ATTRIBUTE; // for now
   \                     ??esp_ProcessInConfigReportCmd_9:
   \   00016A   7F8C         MOV     R7,#-0x74
   \   00016C   801E         SJMP    ??esp_ProcessInConfigReportCmd_10
   2763                      }
   2764                    }
   2765                    else
   2766                    {
   2767                      // Attribute cannot be reported
   2768                      status = ZCL_STATUS_UNREPORTABLE_ATTRIBUTE;
   \                     ??esp_ProcessInConfigReportCmd_7:
   \   00016E   7F8C         MOV     R7,#-0x74
   \   000170   801A         SJMP    ??esp_ProcessInConfigReportCmd_10
   2769                    }
   2770                  }
   2771                  else
   2772                  {
   2773                    // Attribute data type is incorrect
   2774                    status = ZCL_STATUS_INVALID_DATA_TYPE;
   \                     ??esp_ProcessInConfigReportCmd_6:
   \   000172   7F8D         MOV     R7,#-0x73
   \   000174   8016         SJMP    ??esp_ProcessInConfigReportCmd_10
   2775                  }
   2776                }
   2777                else
   2778                {
   2779                  // We shall expect reports of values of this attribute
   2780                  if ( zcl_MandatoryReportableAttribute( &attrRec ) == TRUE )
   \                     ??esp_ProcessInConfigReportCmd_5:
   \   000176   85..82       MOV     DPL,?XSP + 0
   \   000179   85..83       MOV     DPH,?XSP + 1
   \   00017C   E582         MOV     A,DPL
   \   00017E   4583         ORL     A,DPH
   \   000180   7004         JNZ     ??esp_ProcessInConfigReportCmd_11
   2781                  {
   2782                    // Set the Timeout Period
   2783                    //status = zclSetAttrTimeoutPeriod( pAttr, cfgReportCmd );
   2784                    status = ZCL_STATUS_UNSUPPORTED_ATTRIBUTE; // for now
   \   000182   7F86         MOV     R7,#-0x7a
   \   000184   8006         SJMP    ??esp_ProcessInConfigReportCmd_10
   2785                  }
   2786                  else
   2787                  {
   2788                    // Reports of attribute cannot be received
   2789                    status = ZCL_STATUS_UNSUPPORTED_ATTRIBUTE;
   \                     ??esp_ProcessInConfigReportCmd_11:
   \   000186   7F86         MOV     R7,#-0x7a
   \   000188   8002         SJMP    ??esp_ProcessInConfigReportCmd_10
   2790                  }
   2791                }
   2792              }
   2793              else
   2794              {
   2795                // Attribute is not supported
   2796                status = ZCL_STATUS_UNSUPPORTED_ATTRIBUTE;
   \                     ??esp_ProcessInConfigReportCmd_4:
   \   00018A   7F86         MOV     R7,#-0x7a
   2797              }
   2798          
   2799              // If not successful then record the status
   2800              if ( status != ZCL_STATUS_SUCCESS )
   \                     ??esp_ProcessInConfigReportCmd_10:
   \   00018C   EF           MOV     A,R7
   \   00018D   6062         JZ      ??esp_ProcessInConfigReportCmd_12
   2801              {
   2802                cfgReportRspCmd->attrList[j].status = status;
   \   00018F   EF           MOV     A,R7
   \   000190   C0E0         PUSH    A
   \   000192   EE           MOV     A,R6
   \   000193   F8           MOV     R0,A
   \   000194   7900         MOV     R1,#0x0
   \   000196   E8           MOV     A,R0
   \   000197   75F004       MOV     B,#0x4
   \   00019A   A4           MUL     AB
   \   00019B   C8           XCH     A,R0
   \   00019C   AAF0         MOV     R2,B
   \   00019E   75F000       MOV     B,#0x0
   \   0001A1   A4           MUL     AB
   \   0001A2   2A           ADD     A,R2
   \   0001A3   FA           MOV     R2,A
   \   0001A4   75F004       MOV     B,#0x4
   \   0001A7   E9           MOV     A,R1
   \   0001A8   A4           MUL     AB
   \   0001A9   2A           ADD     A,R2
   \   0001AA   F9           MOV     R1,A
   \   0001AB   E5..         MOV     A,?V0 + 8
   \   0001AD   28           ADD     A,R0
   \   0001AE   F582         MOV     DPL,A
   \   0001B0   E5..         MOV     A,?V0 + 9
   \   0001B2   39           ADDC    A,R1
   \   0001B3   F583         MOV     DPH,A
   \   0001B5   A3           INC     DPTR
   \   0001B6   D0E0         POP     A
   \   0001B8   F0           MOVX    @DPTR,A
   2803                cfgReportRspCmd->attrList[j++].attrID = reportRec->attrID;
   \   0001B9   85..82       MOV     DPL,?V0 + 0
   \   0001BC   85..83       MOV     DPH,?V0 + 1
   \   0001BF   A3           INC     DPTR
   \   0001C0   E0           MOVX    A,@DPTR
   \   0001C1   FA           MOV     R2,A
   \   0001C2   A3           INC     DPTR
   \   0001C3   E0           MOVX    A,@DPTR
   \   0001C4   FB           MOV     R3,A
   \   0001C5   EE           MOV     A,R6
   \   0001C6   F8           MOV     R0,A
   \   0001C7   7900         MOV     R1,#0x0
   \   0001C9   E8           MOV     A,R0
   \   0001CA   75F004       MOV     B,#0x4
   \   0001CD   A4           MUL     AB
   \   0001CE   C8           XCH     A,R0
   \   0001CF   ACF0         MOV     R4,B
   \   0001D1   75F000       MOV     B,#0x0
   \   0001D4   A4           MUL     AB
   \   0001D5   2C           ADD     A,R4
   \   0001D6   FC           MOV     R4,A
   \   0001D7   75F004       MOV     B,#0x4
   \   0001DA   E9           MOV     A,R1
   \   0001DB   A4           MUL     AB
   \   0001DC   2C           ADD     A,R4
   \   0001DD   F9           MOV     R1,A
   \   0001DE   E5..         MOV     A,?V0 + 8
   \   0001E0   28           ADD     A,R0
   \   0001E1   F582         MOV     DPL,A
   \   0001E3   E5..         MOV     A,?V0 + 9
   \   0001E5   39           ADDC    A,R1
   \   0001E6   F583         MOV     DPH,A
   \   0001E8   A3           INC     DPTR
   \   0001E9   A3           INC     DPTR
   \   0001EA   A3           INC     DPTR
   \   0001EB   EA           MOV     A,R2
   \   0001EC   F0           MOVX    @DPTR,A
   \   0001ED   A3           INC     DPTR
   \   0001EE   EB           MOV     A,R3
   \   0001EF   F0           MOVX    @DPTR,A
   \   0001F0   0E           INC     R6
   2804              }
   2805            } // for loop
   \                     ??esp_ProcessInConfigReportCmd_12:
   \   0001F1   05..         INC     ?V0 + 2
   \   0001F3   02....       LJMP    ??esp_ProcessInConfigReportCmd_2 & 0xFFFF
   2806          
   2807            if ( j == 0 )
   \                     ??esp_ProcessInConfigReportCmd_3:
   \   0001F6   EE           MOV     A,R6
   \   0001F7   7015         JNZ     ??esp_ProcessInConfigReportCmd_13
   2808            {
   2809              // Since all attributes were configured successfully, include a single
   2810              // attribute status record in the response command with the status field
   2811              // set to SUCCESS and the attribute ID field omitted.
   2812              cfgReportRspCmd->attrList[0].status = ZCL_STATUS_SUCCESS;
   \   0001F9   85..82       MOV     DPL,?V0 + 8
   \   0001FC   85..83       MOV     DPH,?V0 + 9
   \   0001FF   A3           INC     DPTR
   \   000200   7400         MOV     A,#0x0
   \   000202   F0           MOVX    @DPTR,A
   2813              cfgReportRspCmd->numAttr = 1;
   \   000203   85..82       MOV     DPL,?V0 + 8
   \   000206   85..83       MOV     DPH,?V0 + 9
   \   000209   7401         MOV     A,#0x1
   \   00020B   F0           MOVX    @DPTR,A
   \   00020C   8008         SJMP    ??esp_ProcessInConfigReportCmd_14
   2814            }
   2815            else
   2816            {
   2817              cfgReportRspCmd->numAttr = j;
   \                     ??esp_ProcessInConfigReportCmd_13:
   \   00020E   EE           MOV     A,R6
   \   00020F   85..82       MOV     DPL,?V0 + 8
   \   000212   85..83       MOV     DPH,?V0 + 9
   \   000215   F0           MOVX    @DPTR,A
   2818            }
   2819          
   2820            // Send the response back
   2821            zcl_SendConfigReportRspCmd( ESP_ENDPOINT, &(pInMsg->srcAddr),
   2822                                        pInMsg->clusterId, cfgReportRspCmd, ZCL_FRAME_SERVER_CLIENT_DIR,
   2823                                        TRUE, pInMsg->zclHdr.transSeqNum );
   \                     ??esp_ProcessInConfigReportCmd_14:
   \   000216                ; Setup parameters for call to function zcl_SendConfigReportRspCmd
   \   000216   85..82       MOV     DPL,?V0 + 4
   \   000219   85..83       MOV     DPH,?V0 + 5
   \   00021C   A3           INC     DPTR
   \   00021D   A3           INC     DPTR
   \   00021E   A3           INC     DPTR
   \   00021F   A3           INC     DPTR
   \   000220   A3           INC     DPTR
   \   000221   A3           INC     DPTR
   \   000222   E0           MOVX    A,@DPTR
   \   000223   F5..         MOV     ?V0 + 3,A
   \   000225   78..         MOV     R0,#?V0 + 3
   \   000227   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00022A   75..01       MOV     ?V0 + 3,#0x1
   \   00022D   78..         MOV     R0,#?V0 + 3
   \   00022F   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000232   75..01       MOV     ?V0 + 3,#0x1
   \   000235   78..         MOV     R0,#?V0 + 3
   \   000237   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00023A   78..         MOV     R0,#?V0 + 8
   \   00023C   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00023F   85..82       MOV     DPL,?V0 + 4
   \   000242   85..83       MOV     DPH,?V0 + 5
   \   000245   A3           INC     DPTR
   \   000246   A3           INC     DPTR
   \   000247   A3           INC     DPTR
   \   000248   A3           INC     DPTR
   \   000249   A3           INC     DPTR
   \   00024A   A3           INC     DPTR
   \   00024B   A3           INC     DPTR
   \   00024C   A3           INC     DPTR
   \   00024D   E0           MOVX    A,@DPTR
   \   00024E   FC           MOV     R4,A
   \   00024F   A3           INC     DPTR
   \   000250   E0           MOVX    A,@DPTR
   \   000251   FD           MOV     R5,A
   \   000252   E5..         MOV     A,?V0 + 4
   \   000254   240A         ADD     A,#0xa
   \   000256   FA           MOV     R2,A
   \   000257   E5..         MOV     A,?V0 + 5
   \   000259   3400         ADDC    A,#0x0
   \   00025B   FB           MOV     R3,A
   \   00025C   7909         MOV     R1,#0x9
   \   00025E   12....       LCALL   ??zcl_SendConfigReportRspCmd?relay
   \   000261   7405         MOV     A,#0x5
   \   000263   12....       LCALL   ?DEALLOC_XSTACK8
   \   000266   E9           MOV     A,R1
   2824            osal_mem_free( cfgReportRspCmd );
   \   000267                ; Setup parameters for call to function osal_mem_free
   \   000267   AA..         MOV     R2,?V0 + 8
   \   000269   AB..         MOV     R3,?V0 + 9
   \   00026B   12....       LCALL   ??osal_mem_free?relay
   2825          
   2826            return TRUE ;
   \   00026E   7901         MOV     R1,#0x1
   \                     ??esp_ProcessInConfigReportCmd_1:
   \   000270   7408         MOV     A,#0x8
   \   000272   12....       LCALL   ?DEALLOC_XSTACK8
   \   000275   7F0C         MOV     R7,#0xc
   \   000277   02....       LJMP    ?BANKED_LEAVE_XDATA
   2827          }
   2828          
   2829          /*********************************************************************
   2830           * @fn      esp_ProcessInConfigReportRspCmd
   2831           *
   2832           * @brief   Process the "Profile" Configure Reporting Response Command
   2833           *
   2834           * @param   pInMsg - incoming message to process
   2835           *
   2836           * @return  none
   2837           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2838          static uint8 esp_ProcessInConfigReportRspCmd( zclIncomingMsg_t *pInMsg )
   \                     esp_ProcessInConfigReportRspCmd:
   2839          {
   \   000000   74F2         MOV     A,#-0xe
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 8
   \   000005   74F8         MOV     A,#-0x8
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V0 + 0,R2
   \   00000C   8B..         MOV     ?V0 + 1,R3
   2840            zclCfgReportRspCmd_t *cfgReportRspCmd;
   2841            zclAttrRec_t attrRec;
   2842            uint8 i;
   2843          
   2844            cfgReportRspCmd = (zclCfgReportRspCmd_t *)pInMsg->attrCmd;
   \   00000E   E5..         MOV     A,?V0 + 0
   \   000010   2417         ADD     A,#0x17
   \   000012   F582         MOV     DPL,A
   \   000014   E5..         MOV     A,?V0 + 1
   \   000016   3400         ADDC    A,#0x0
   \   000018   F583         MOV     DPH,A
   \   00001A   E0           MOVX    A,@DPTR
   \   00001B   F8           MOV     R0,A
   \   00001C   A3           INC     DPTR
   \   00001D   E0           MOVX    A,@DPTR
   \   00001E   F9           MOV     R1,A
   \   00001F   E8           MOV     A,R0
   \   000020   FE           MOV     R6,A
   \   000021   E9           MOV     A,R1
   \   000022   FF           MOV     R7,A
   2845            for (i = 0; i < cfgReportRspCmd->numAttr; i++)
   \   000023   75..00       MOV     ?V0 + 2,#0x0
   \                     ??esp_ProcessInConfigReportRspCmd_0:
   \   000026   8E82         MOV     DPL,R6
   \   000028   8F83         MOV     DPH,R7
   \   00002A   E0           MOVX    A,@DPTR
   \   00002B   F8           MOV     R0,A
   \   00002C   E5..         MOV     A,?V0 + 2
   \   00002E   C3           CLR     C
   \   00002F   98           SUBB    A,R0
   \   000030   505E         JNC     ??esp_ProcessInConfigReportRspCmd_1
   2846            {
   2847              if ( zclFindAttrRec( ESP_ENDPOINT, pInMsg->clusterId,
   2848                                   cfgReportRspCmd->attrList[i].attrID, &attrRec ) )
   \   000032                ; Setup parameters for call to function zclFindAttrRec
   \   000032   85..82       MOV     DPL,?XSP + 0
   \   000035   85..83       MOV     DPH,?XSP + 1
   \   000038   8582..       MOV     ?V0 + 4,DPL
   \   00003B   8583..       MOV     ?V0 + 5,DPH
   \   00003E   78..         MOV     R0,#?V0 + 4
   \   000040   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000043   E5..         MOV     A,?V0 + 2
   \   000045   A8..         MOV     R0,?V0 + 2
   \   000047   7900         MOV     R1,#0x0
   \   000049   E8           MOV     A,R0
   \   00004A   75F004       MOV     B,#0x4
   \   00004D   A4           MUL     AB
   \   00004E   C8           XCH     A,R0
   \   00004F   AAF0         MOV     R2,B
   \   000051   75F000       MOV     B,#0x0
   \   000054   A4           MUL     AB
   \   000055   2A           ADD     A,R2
   \   000056   FA           MOV     R2,A
   \   000057   75F004       MOV     B,#0x4
   \   00005A   E9           MOV     A,R1
   \   00005B   A4           MUL     AB
   \   00005C   2A           ADD     A,R2
   \   00005D   F9           MOV     R1,A
   \   00005E   EE           MOV     A,R6
   \   00005F   28           ADD     A,R0
   \   000060   F582         MOV     DPL,A
   \   000062   EF           MOV     A,R7
   \   000063   39           ADDC    A,R1
   \   000064   F583         MOV     DPH,A
   \   000066   A3           INC     DPTR
   \   000067   A3           INC     DPTR
   \   000068   A3           INC     DPTR
   \   000069   E0           MOVX    A,@DPTR
   \   00006A   FC           MOV     R4,A
   \   00006B   A3           INC     DPTR
   \   00006C   E0           MOVX    A,@DPTR
   \   00006D   FD           MOV     R5,A
   \   00006E   85..82       MOV     DPL,?V0 + 0
   \   000071   85..83       MOV     DPH,?V0 + 1
   \   000074   A3           INC     DPTR
   \   000075   A3           INC     DPTR
   \   000076   A3           INC     DPTR
   \   000077   A3           INC     DPTR
   \   000078   A3           INC     DPTR
   \   000079   A3           INC     DPTR
   \   00007A   A3           INC     DPTR
   \   00007B   A3           INC     DPTR
   \   00007C   E0           MOVX    A,@DPTR
   \   00007D   FA           MOV     R2,A
   \   00007E   A3           INC     DPTR
   \   00007F   E0           MOVX    A,@DPTR
   \   000080   FB           MOV     R3,A
   \   000081   7909         MOV     R1,#0x9
   \   000083   12....       LCALL   ??zclFindAttrRec?relay
   \   000086   7402         MOV     A,#0x2
   \   000088   12....       LCALL   ?DEALLOC_XSTACK8
   \   00008B   E9           MOV     A,R1
   2849              {
   2850                // Notify the device of success (or otherwise) of the its original configure
   2851                // reporting command, for each attribute.
   2852              }
   2853            }
   \   00008C   05..         INC     ?V0 + 2
   \   00008E   8096         SJMP    ??esp_ProcessInConfigReportRspCmd_0
   2854          
   2855            return TRUE;
   \                     ??esp_ProcessInConfigReportRspCmd_1:
   \   000090   7901         MOV     R1,#0x1
   \   000092   7408         MOV     A,#0x8
   \   000094   12....       LCALL   ?DEALLOC_XSTACK8
   \   000097   7F06         MOV     R7,#0x6
   \   000099   02....       LJMP    ?BANKED_LEAVE_XDATA
   2856          }
   2857          
   2858          /*********************************************************************
   2859           * @fn      esp_ProcessInReadReportCfgCmd
   2860           *
   2861           * @brief   Process the "Profile" Read Reporting Configuration Command
   2862           *
   2863           * @param   pInMsg - incoming message to process
   2864           *
   2865           * @return  none
   2866           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2867          static uint8 esp_ProcessInReadReportCfgCmd( zclIncomingMsg_t *pInMsg )
   \                     esp_ProcessInReadReportCfgCmd:
   2868          {
   \   000000   74E8         MOV     A,#-0x18
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 24
   \   000005                ; Auto size: 10
   \   000005   74F6         MOV     A,#-0xa
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V0 + 6,R2
   \   00000C   8B..         MOV     ?V0 + 7,R3
   2869            zclReadReportCfgCmd_t *readReportCfgCmd;
   2870            zclReadReportCfgRspCmd_t *readReportCfgRspCmd;
   2871            zclReportCfgRspRec_t *reportRspRec;
   2872            zclAttrRec_t attrRec;
   2873            uint8 reportChangeLen;
   2874            uint8 *dataPtr;
   2875            uint8 hdrLen;
   2876            uint8 dataLen = 0;
   \   00000E   75..00       MOV     ?V0 + 1,#0x0
   2877            uint8 status;
   2878            uint8 i;
   2879          
   2880            readReportCfgCmd = (zclReadReportCfgCmd_t *)pInMsg->attrCmd;
   \   000011   E5..         MOV     A,?V0 + 6
   \   000013   2417         ADD     A,#0x17
   \   000015   F582         MOV     DPL,A
   \   000017   E5..         MOV     A,?V0 + 7
   \   000019   3400         ADDC    A,#0x0
   \   00001B   F583         MOV     DPH,A
   \   00001D   E0           MOVX    A,@DPTR
   \   00001E   F8           MOV     R0,A
   \   00001F   A3           INC     DPTR
   \   000020   E0           MOVX    A,@DPTR
   \   000021   F9           MOV     R1,A
   \   000022   88..         MOV     ?V0 + 2,R0
   \   000024   89..         MOV     ?V0 + 3,R1
   2881          
   2882            // Find out the response length (Reportable Change field is of variable length)
   2883            for ( i = 0; i < readReportCfgCmd->numAttr; i++ )
   \   000026   7E00         MOV     R6,#0x0
   \                     ??esp_ProcessInReadReportCfgCmd_0:
   \   000028   85..82       MOV     DPL,?V0 + 2
   \   00002B   85..83       MOV     DPH,?V0 + 3
   \   00002E   E0           MOVX    A,@DPTR
   \   00002F   F8           MOV     R0,A
   \   000030   EE           MOV     A,R6
   \   000031   C3           CLR     C
   \   000032   98           SUBB    A,R0
   \   000033   4003         JC      $+5
   \   000035   02....       LJMP    ??esp_ProcessInReadReportCfgCmd_1 & 0xFFFF
   2884            {
   2885              // For supported attributes with 'analog' data type, find out the length of
   2886              // the Reportable Change field
   2887              if ( zclFindAttrRec( ESP_ENDPOINT, pInMsg->clusterId,
   2888                                   readReportCfgCmd->attrList[i].attrID, &attrRec ) )
   \   000038                ; Setup parameters for call to function zclFindAttrRec
   \   000038   7402         MOV     A,#0x2
   \   00003A   12....       LCALL   ?XSTACK_DISP0_8
   \   00003D   8582..       MOV     ?V0 + 8,DPL
   \   000040   8583..       MOV     ?V0 + 9,DPH
   \   000043   78..         MOV     R0,#?V0 + 8
   \   000045   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000048   EE           MOV     A,R6
   \   000049   F8           MOV     R0,A
   \   00004A   7900         MOV     R1,#0x0
   \   00004C   E8           MOV     A,R0
   \   00004D   75F003       MOV     B,#0x3
   \   000050   A4           MUL     AB
   \   000051   C8           XCH     A,R0
   \   000052   AAF0         MOV     R2,B
   \   000054   75F000       MOV     B,#0x0
   \   000057   A4           MUL     AB
   \   000058   2A           ADD     A,R2
   \   000059   FA           MOV     R2,A
   \   00005A   75F003       MOV     B,#0x3
   \   00005D   E9           MOV     A,R1
   \   00005E   A4           MUL     AB
   \   00005F   2A           ADD     A,R2
   \   000060   F9           MOV     R1,A
   \   000061   E5..         MOV     A,?V0 + 2
   \   000063   28           ADD     A,R0
   \   000064   F582         MOV     DPL,A
   \   000066   E5..         MOV     A,?V0 + 3
   \   000068   39           ADDC    A,R1
   \   000069   F583         MOV     DPH,A
   \   00006B   A3           INC     DPTR
   \   00006C   A3           INC     DPTR
   \   00006D   E0           MOVX    A,@DPTR
   \   00006E   FC           MOV     R4,A
   \   00006F   A3           INC     DPTR
   \   000070   E0           MOVX    A,@DPTR
   \   000071   FD           MOV     R5,A
   \   000072   85..82       MOV     DPL,?V0 + 6
   \   000075   85..83       MOV     DPH,?V0 + 7
   \   000078   A3           INC     DPTR
   \   000079   A3           INC     DPTR
   \   00007A   A3           INC     DPTR
   \   00007B   A3           INC     DPTR
   \   00007C   A3           INC     DPTR
   \   00007D   A3           INC     DPTR
   \   00007E   A3           INC     DPTR
   \   00007F   A3           INC     DPTR
   \   000080   E0           MOVX    A,@DPTR
   \   000081   FA           MOV     R2,A
   \   000082   A3           INC     DPTR
   \   000083   E0           MOVX    A,@DPTR
   \   000084   FB           MOV     R3,A
   \   000085   7909         MOV     R1,#0x9
   \   000087   12....       LCALL   ??zclFindAttrRec?relay
   \   00008A   7402         MOV     A,#0x2
   \   00008C   12....       LCALL   ?DEALLOC_XSTACK8
   \   00008F   E9           MOV     A,R1
   \   000090   6028         JZ      ??esp_ProcessInReadReportCfgCmd_2
   2889              {
   2890                if ( zclAnalogDataType( attrRec.attr.dataType ) )
   \   000092                ; Setup parameters for call to function zclAnalogDataType
   \   000092   7406         MOV     A,#0x6
   \   000094   12....       LCALL   ?XSTACK_DISP0_8
   \   000097   E0           MOVX    A,@DPTR
   \   000098   F9           MOV     R1,A
   \   000099   12....       LCALL   ??zclAnalogDataType?relay
   \   00009C   E9           MOV     A,R1
   \   00009D   601B         JZ      ??esp_ProcessInReadReportCfgCmd_2
   2891                {
   2892                   reportChangeLen = zclGetDataTypeLength( attrRec.attr.dataType );
   \   00009F                ; Setup parameters for call to function zclGetDataTypeLength
   \   00009F   7406         MOV     A,#0x6
   \   0000A1   12....       LCALL   ?XSTACK_DISP0_8
   \   0000A4   E0           MOVX    A,@DPTR
   \   0000A5   F9           MOV     R1,A
   \   0000A6   12....       LCALL   ??zclGetDataTypeLength?relay
   \   0000A9   E9           MOV     A,R1
   \   0000AA   FF           MOV     R7,A
   2893          
   2894                   // add padding if neede
   2895                   if ( PADDING_NEEDED( reportChangeLen ) )
   \   0000AB   EF           MOV     A,R7
   \   0000AC   75F002       MOV     B,#0x2
   \   0000AF   84           DIV     AB
   \   0000B0   E5F0         MOV     A,B
   \   0000B2   6001         JZ      ??esp_ProcessInReadReportCfgCmd_3
   2896                   {
   2897                     reportChangeLen++;
   \   0000B4   0F           INC     R7
   2898                   }
   2899                   dataLen += reportChangeLen;
   \                     ??esp_ProcessInReadReportCfgCmd_3:
   \   0000B5   EF           MOV     A,R7
   \   0000B6   25..         ADD     A,?V0 + 1
   \   0000B8   F5..         MOV     ?V0 + 1,A
   2900                }
   2901              }
   2902            }
   \                     ??esp_ProcessInReadReportCfgCmd_2:
   \   0000BA   0E           INC     R6
   \   0000BB   02....       LJMP    ??esp_ProcessInReadReportCfgCmd_0 & 0xFFFF
   2903          
   2904            hdrLen = sizeof( zclReadReportCfgRspCmd_t ) + ( readReportCfgCmd->numAttr * sizeof( zclReportCfgRspRec_t ) );
   \                     ??esp_ProcessInReadReportCfgCmd_1:
   \   0000BE   75F00D       MOV     B,#0xd
   \   0000C1   85..82       MOV     DPL,?V0 + 2
   \   0000C4   85..83       MOV     DPH,?V0 + 3
   \   0000C7   E0           MOVX    A,@DPTR
   \   0000C8   A4           MUL     AB
   \   0000C9   2401         ADD     A,#0x1
   \   0000CB   F5..         MOV     ?V0 + 12,A
   2905          
   2906            // Allocate space for the response command
   2907            readReportCfgRspCmd = (zclReadReportCfgRspCmd_t *)osal_mem_alloc( hdrLen + dataLen );
   \   0000CD                ; Setup parameters for call to function osal_mem_alloc
   \   0000CD   85....       MOV     ?V0 + 10,?V0 + 12
   \   0000D0   75..00       MOV     ?V0 + 11,#0x0
   \   0000D3   85....       MOV     ?V0 + 8,?V0 + 1
   \   0000D6   75..00       MOV     ?V0 + 9,#0x0
   \   0000D9   E5..         MOV     A,?V0 + 10
   \   0000DB   25..         ADD     A,?V0 + 8
   \   0000DD   FA           MOV     R2,A
   \   0000DE   E5..         MOV     A,?V0 + 11
   \   0000E0   35..         ADDC    A,?V0 + 9
   \   0000E2   FB           MOV     R3,A
   \   0000E3   12....       LCALL   ??osal_mem_alloc?relay
   \   0000E6   8A..         MOV     ?V0 + 8,R2
   \   0000E8   8B..         MOV     ?V0 + 9,R3
   \   0000EA   85....       MOV     ?V0 + 4,?V0 + 8
   \   0000ED   85....       MOV     ?V0 + 5,?V0 + 9
   2908            if ( readReportCfgRspCmd == NULL )
   \   0000F0   E5..         MOV     A,?V0 + 4
   \   0000F2   45..         ORL     A,?V0 + 5
   \   0000F4   7005         JNZ     ??esp_ProcessInReadReportCfgCmd_4
   2909            {
   2910              return FALSE; // EMBEDDED RETURN
   \   0000F6   7900         MOV     R1,#0x0
   \   0000F8   02....       LJMP    ??esp_ProcessInReadReportCfgCmd_5 & 0xFFFF
   2911            }
   2912          
   2913            dataPtr = (uint8 *)( (uint8 *)readReportCfgRspCmd + hdrLen );
   \                     ??esp_ProcessInReadReportCfgCmd_4:
   \   0000FB   85....       MOV     ?V0 + 8,?V0 + 12
   \   0000FE   75..00       MOV     ?V0 + 9,#0x0
   \   000101   E5..         MOV     A,?V0 + 4
   \   000103   25..         ADD     A,?V0 + 8
   \   000105   F8           MOV     R0,A
   \   000106   E5..         MOV     A,?V0 + 5
   \   000108   35..         ADDC    A,?V0 + 9
   \   00010A   F9           MOV     R1,A
   \   00010B   88..         MOV     ?V0 + 14,R0
   \   00010D   89..         MOV     ?V0 + 15,R1
   2914            readReportCfgRspCmd->numAttr = readReportCfgCmd->numAttr;
   \   00010F   85..82       MOV     DPL,?V0 + 2
   \   000112   85..83       MOV     DPH,?V0 + 3
   \   000115   E0           MOVX    A,@DPTR
   \   000116   85..82       MOV     DPL,?V0 + 4
   \   000119   85..83       MOV     DPH,?V0 + 5
   \   00011C   F0           MOVX    @DPTR,A
   2915            for (i = 0; i < readReportCfgCmd->numAttr; i++)
   \   00011D   7E00         MOV     R6,#0x0
   \                     ??esp_ProcessInReadReportCfgCmd_6:
   \   00011F   85..82       MOV     DPL,?V0 + 2
   \   000122   85..83       MOV     DPH,?V0 + 3
   \   000125   E0           MOVX    A,@DPTR
   \   000126   F8           MOV     R0,A
   \   000127   EE           MOV     A,R6
   \   000128   C3           CLR     C
   \   000129   98           SUBB    A,R0
   \   00012A   4003         JC      $+5
   \   00012C   02....       LJMP    ??esp_ProcessInReadReportCfgCmd_7 & 0xFFFF
   2916            {
   2917              reportRspRec = &(readReportCfgRspCmd->attrList[i]);
   \   00012F   EE           MOV     A,R6
   \   000130   F8           MOV     R0,A
   \   000131   7900         MOV     R1,#0x0
   \   000133   E8           MOV     A,R0
   \   000134   75F00D       MOV     B,#0xd
   \   000137   A4           MUL     AB
   \   000138   C8           XCH     A,R0
   \   000139   AAF0         MOV     R2,B
   \   00013B   75F000       MOV     B,#0x0
   \   00013E   A4           MUL     AB
   \   00013F   2A           ADD     A,R2
   \   000140   FA           MOV     R2,A
   \   000141   75F00D       MOV     B,#0xd
   \   000144   E9           MOV     A,R1
   \   000145   A4           MUL     AB
   \   000146   2A           ADD     A,R2
   \   000147   F9           MOV     R1,A
   \   000148   E5..         MOV     A,?V0 + 4
   \   00014A   28           ADD     A,R0
   \   00014B   F582         MOV     DPL,A
   \   00014D   E5..         MOV     A,?V0 + 5
   \   00014F   39           ADDC    A,R1
   \   000150   F583         MOV     DPH,A
   \   000152   A3           INC     DPTR
   \   000153   A882         MOV     R0,DPL
   \   000155   A983         MOV     R1,DPH
   \   000157   85..82       MOV     DPL,?XSP + 0
   \   00015A   85..83       MOV     DPH,?XSP + 1
   \   00015D   E8           MOV     A,R0
   \   00015E   F0           MOVX    @DPTR,A
   \   00015F   A3           INC     DPTR
   \   000160   E9           MOV     A,R1
   \   000161   F0           MOVX    @DPTR,A
   2918          
   2919              if ( zclFindAttrRec( ESP_ENDPOINT, pInMsg->clusterId,
   2920                                   readReportCfgCmd->attrList[i].attrID, &attrRec ) )
   \   000162                ; Setup parameters for call to function zclFindAttrRec
   \   000162   7402         MOV     A,#0x2
   \   000164   12....       LCALL   ?XSTACK_DISP0_8
   \   000167   8582..       MOV     ?V0 + 8,DPL
   \   00016A   8583..       MOV     ?V0 + 9,DPH
   \   00016D   78..         MOV     R0,#?V0 + 8
   \   00016F   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000172   EE           MOV     A,R6
   \   000173   F8           MOV     R0,A
   \   000174   7900         MOV     R1,#0x0
   \   000176   E8           MOV     A,R0
   \   000177   75F003       MOV     B,#0x3
   \   00017A   A4           MUL     AB
   \   00017B   C8           XCH     A,R0
   \   00017C   AAF0         MOV     R2,B
   \   00017E   75F000       MOV     B,#0x0
   \   000181   A4           MUL     AB
   \   000182   2A           ADD     A,R2
   \   000183   FA           MOV     R2,A
   \   000184   75F003       MOV     B,#0x3
   \   000187   E9           MOV     A,R1
   \   000188   A4           MUL     AB
   \   000189   2A           ADD     A,R2
   \   00018A   F9           MOV     R1,A
   \   00018B   E5..         MOV     A,?V0 + 2
   \   00018D   28           ADD     A,R0
   \   00018E   F582         MOV     DPL,A
   \   000190   E5..         MOV     A,?V0 + 3
   \   000192   39           ADDC    A,R1
   \   000193   F583         MOV     DPH,A
   \   000195   A3           INC     DPTR
   \   000196   A3           INC     DPTR
   \   000197   E0           MOVX    A,@DPTR
   \   000198   FC           MOV     R4,A
   \   000199   A3           INC     DPTR
   \   00019A   E0           MOVX    A,@DPTR
   \   00019B   FD           MOV     R5,A
   \   00019C   85..82       MOV     DPL,?V0 + 6
   \   00019F   85..83       MOV     DPH,?V0 + 7
   \   0001A2   A3           INC     DPTR
   \   0001A3   A3           INC     DPTR
   \   0001A4   A3           INC     DPTR
   \   0001A5   A3           INC     DPTR
   \   0001A6   A3           INC     DPTR
   \   0001A7   A3           INC     DPTR
   \   0001A8   A3           INC     DPTR
   \   0001A9   A3           INC     DPTR
   \   0001AA   E0           MOVX    A,@DPTR
   \   0001AB   FA           MOV     R2,A
   \   0001AC   A3           INC     DPTR
   \   0001AD   E0           MOVX    A,@DPTR
   \   0001AE   FB           MOV     R3,A
   \   0001AF   7909         MOV     R1,#0x9
   \   0001B1   12....       LCALL   ??zclFindAttrRec?relay
   \   0001B4   7402         MOV     A,#0x2
   \   0001B6   12....       LCALL   ?DEALLOC_XSTACK8
   \   0001B9   E9           MOV     A,R1
   \   0001BA   6068         JZ      ??esp_ProcessInReadReportCfgCmd_8
   2921              {
   2922                if ( zcl_MandatoryReportableAttribute( &attrRec ) == TRUE )
   \   0001BC   7402         MOV     A,#0x2
   \   0001BE   12....       LCALL   ?XSTACK_DISP0_8
   \   0001C1   E582         MOV     A,DPL
   \   0001C3   4583         ORL     A,DPH
   \   0001C5   7058         JNZ     ??esp_ProcessInReadReportCfgCmd_9
   2923                {
   2924                  // Get the Reporting Configuration
   2925                  // status = zclReadReportCfg( readReportCfgCmd->attrID[i], reportRspRec );
   2926                  status = ZCL_STATUS_UNREPORTABLE_ATTRIBUTE; // for now
   \   0001C7   75..8C       MOV     ?V0 + 0,#-0x74
   2927                  if ( status == ZCL_STATUS_SUCCESS && zclAnalogDataType( attrRec.attr.dataType ) )
   \   0001CA   E5..         MOV     A,?V0 + 0
   \   0001CC   7059         JNZ     ??esp_ProcessInReadReportCfgCmd_10
   \   0001CE                ; Setup parameters for call to function zclAnalogDataType
   \   0001CE   7406         MOV     A,#0x6
   \   0001D0   12....       LCALL   ?XSTACK_DISP0_8
   \   0001D3   E0           MOVX    A,@DPTR
   \   0001D4   F9           MOV     R1,A
   \   0001D5   12....       LCALL   ??zclAnalogDataType?relay
   \   0001D8   E9           MOV     A,R1
   \   0001D9   604C         JZ      ??esp_ProcessInReadReportCfgCmd_10
   2928                  {
   2929                    reportChangeLen = zclGetDataTypeLength( attrRec.attr.dataType );
   \   0001DB                ; Setup parameters for call to function zclGetDataTypeLength
   \   0001DB   7406         MOV     A,#0x6
   \   0001DD   12....       LCALL   ?XSTACK_DISP0_8
   \   0001E0   E0           MOVX    A,@DPTR
   \   0001E1   F9           MOV     R1,A
   \   0001E2   12....       LCALL   ??zclGetDataTypeLength?relay
   \   0001E5   E9           MOV     A,R1
   \   0001E6   FF           MOV     R7,A
   2930                    //osal_memcpy( dataPtr, pBuf, reportChangeLen );
   2931                    reportRspRec->reportableChange = dataPtr;
   \   0001E7   85..82       MOV     DPL,?XSP + 0
   \   0001EA   85..83       MOV     DPH,?XSP + 1
   \   0001ED   E0           MOVX    A,@DPTR
   \   0001EE   F8           MOV     R0,A
   \   0001EF   A3           INC     DPTR
   \   0001F0   E0           MOVX    A,@DPTR
   \   0001F1   C8           XCH     A,R0
   \   0001F2   240B         ADD     A,#0xb
   \   0001F4   F582         MOV     DPL,A
   \   0001F6   E8           MOV     A,R0
   \   0001F7   3400         ADDC    A,#0x0
   \   0001F9   F583         MOV     DPH,A
   \   0001FB   E5..         MOV     A,?V0 + 14
   \   0001FD   F0           MOVX    @DPTR,A
   \   0001FE   A3           INC     DPTR
   \   0001FF   E5..         MOV     A,?V0 + 15
   \   000201   F0           MOVX    @DPTR,A
   2932          
   2933                    // add padding if needed
   2934                    if ( PADDING_NEEDED( reportChangeLen ) )
   \   000202   EF           MOV     A,R7
   \   000203   75F002       MOV     B,#0x2
   \   000206   84           DIV     AB
   \   000207   E5F0         MOV     A,B
   \   000209   6001         JZ      ??esp_ProcessInReadReportCfgCmd_11
   2935                    {
   2936                      reportChangeLen++;
   \   00020B   0F           INC     R7
   2937                    }
   2938                    dataPtr += reportChangeLen;
   \                     ??esp_ProcessInReadReportCfgCmd_11:
   \   00020C   8F..         MOV     ?V0 + 8,R7
   \   00020E   75..00       MOV     ?V0 + 9,#0x0
   \   000211   E5..         MOV     A,?V0 + 14
   \   000213   25..         ADD     A,?V0 + 8
   \   000215   F5..         MOV     ?V0 + 14,A
   \   000217   E5..         MOV     A,?V0 + 15
   \   000219   35..         ADDC    A,?V0 + 9
   \   00021B   F5..         MOV     ?V0 + 15,A
   \   00021D   8008         SJMP    ??esp_ProcessInReadReportCfgCmd_10
   2939                  }
   2940                }
   2941                else
   2942                {
   2943                  // Attribute not in the Mandatory Reportable Attribute list
   2944                  status = ZCL_STATUS_UNREPORTABLE_ATTRIBUTE;
   \                     ??esp_ProcessInReadReportCfgCmd_9:
   \   00021F   75..8C       MOV     ?V0 + 0,#-0x74
   \   000222   8003         SJMP    ??esp_ProcessInReadReportCfgCmd_10
   2945                }
   2946              }
   2947              else
   2948              {
   2949                // Attribute not found
   2950                status = ZCL_STATUS_UNSUPPORTED_ATTRIBUTE;
   \                     ??esp_ProcessInReadReportCfgCmd_8:
   \   000224   75..86       MOV     ?V0 + 0,#-0x7a
   2951              }
   2952          
   2953              reportRspRec->status = status;
   \                     ??esp_ProcessInReadReportCfgCmd_10:
   \   000227   E5..         MOV     A,?V0 + 0
   \   000229   85..82       MOV     DPL,?XSP + 0
   \   00022C   85..83       MOV     DPH,?XSP + 1
   \   00022F   E0           MOVX    A,@DPTR
   \   000230   F8           MOV     R0,A
   \   000231   A3           INC     DPTR
   \   000232   E0           MOVX    A,@DPTR
   \   000233   F583         MOV     DPH,A
   \   000235   8882         MOV     DPL,R0
   \   000237   E5..         MOV     A,?V0 + 0
   \   000239   F0           MOVX    @DPTR,A
   2954              reportRspRec->attrID = readReportCfgCmd->attrList[i].attrID;
   \   00023A   EE           MOV     A,R6
   \   00023B   F8           MOV     R0,A
   \   00023C   7900         MOV     R1,#0x0
   \   00023E   E8           MOV     A,R0
   \   00023F   75F003       MOV     B,#0x3
   \   000242   A4           MUL     AB
   \   000243   C8           XCH     A,R0
   \   000244   AAF0         MOV     R2,B
   \   000246   75F000       MOV     B,#0x0
   \   000249   A4           MUL     AB
   \   00024A   2A           ADD     A,R2
   \   00024B   FA           MOV     R2,A
   \   00024C   75F003       MOV     B,#0x3
   \   00024F   E9           MOV     A,R1
   \   000250   A4           MUL     AB
   \   000251   2A           ADD     A,R2
   \   000252   F9           MOV     R1,A
   \   000253   E5..         MOV     A,?V0 + 2
   \   000255   28           ADD     A,R0
   \   000256   F582         MOV     DPL,A
   \   000258   E5..         MOV     A,?V0 + 3
   \   00025A   39           ADDC    A,R1
   \   00025B   F583         MOV     DPH,A
   \   00025D   A3           INC     DPTR
   \   00025E   A3           INC     DPTR
   \   00025F   E0           MOVX    A,@DPTR
   \   000260   FA           MOV     R2,A
   \   000261   A3           INC     DPTR
   \   000262   E0           MOVX    A,@DPTR
   \   000263   FB           MOV     R3,A
   \   000264   85..82       MOV     DPL,?XSP + 0
   \   000267   85..83       MOV     DPH,?XSP + 1
   \   00026A   E0           MOVX    A,@DPTR
   \   00026B   F8           MOV     R0,A
   \   00026C   A3           INC     DPTR
   \   00026D   E0           MOVX    A,@DPTR
   \   00026E   F583         MOV     DPH,A
   \   000270   8882         MOV     DPL,R0
   \   000272   A3           INC     DPTR
   \   000273   A3           INC     DPTR
   \   000274   EA           MOV     A,R2
   \   000275   F0           MOVX    @DPTR,A
   \   000276   A3           INC     DPTR
   \   000277   EB           MOV     A,R3
   \   000278   F0           MOVX    @DPTR,A
   2955            }
   \   000279   0E           INC     R6
   \   00027A   02....       LJMP    ??esp_ProcessInReadReportCfgCmd_6 & 0xFFFF
   2956          
   2957            // Send the response back
   2958            zcl_SendReadReportCfgRspCmd( ESP_ENDPOINT, &(pInMsg->srcAddr),
   2959                                         pInMsg->clusterId, readReportCfgRspCmd, ZCL_FRAME_SERVER_CLIENT_DIR,
   2960                                         TRUE, pInMsg->zclHdr.transSeqNum );
   \                     ??esp_ProcessInReadReportCfgCmd_7:
   \   00027D                ; Setup parameters for call to function zcl_SendReadReportCfgRspCmd
   \   00027D   85..82       MOV     DPL,?V0 + 6
   \   000280   85..83       MOV     DPH,?V0 + 7
   \   000283   A3           INC     DPTR
   \   000284   A3           INC     DPTR
   \   000285   A3           INC     DPTR
   \   000286   A3           INC     DPTR
   \   000287   A3           INC     DPTR
   \   000288   A3           INC     DPTR
   \   000289   E0           MOVX    A,@DPTR
   \   00028A   F5..         MOV     ?V0 + 8,A
   \   00028C   78..         MOV     R0,#?V0 + 8
   \   00028E   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000291   75..01       MOV     ?V0 + 8,#0x1
   \   000294   78..         MOV     R0,#?V0 + 8
   \   000296   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000299   75..01       MOV     ?V0 + 8,#0x1
   \   00029C   78..         MOV     R0,#?V0 + 8
   \   00029E   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0002A1   78..         MOV     R0,#?V0 + 4
   \   0002A3   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0002A6   85..82       MOV     DPL,?V0 + 6
   \   0002A9   85..83       MOV     DPH,?V0 + 7
   \   0002AC   A3           INC     DPTR
   \   0002AD   A3           INC     DPTR
   \   0002AE   A3           INC     DPTR
   \   0002AF   A3           INC     DPTR
   \   0002B0   A3           INC     DPTR
   \   0002B1   A3           INC     DPTR
   \   0002B2   A3           INC     DPTR
   \   0002B3   A3           INC     DPTR
   \   0002B4   E0           MOVX    A,@DPTR
   \   0002B5   FC           MOV     R4,A
   \   0002B6   A3           INC     DPTR
   \   0002B7   E0           MOVX    A,@DPTR
   \   0002B8   FD           MOV     R5,A
   \   0002B9   E5..         MOV     A,?V0 + 6
   \   0002BB   240A         ADD     A,#0xa
   \   0002BD   FA           MOV     R2,A
   \   0002BE   E5..         MOV     A,?V0 + 7
   \   0002C0   3400         ADDC    A,#0x0
   \   0002C2   FB           MOV     R3,A
   \   0002C3   7909         MOV     R1,#0x9
   \   0002C5   12....       LCALL   ??zcl_SendReadReportCfgRspCmd?relay
   \   0002C8   7405         MOV     A,#0x5
   \   0002CA   12....       LCALL   ?DEALLOC_XSTACK8
   \   0002CD   E9           MOV     A,R1
   2961            osal_mem_free( readReportCfgRspCmd );
   \   0002CE                ; Setup parameters for call to function osal_mem_free
   \   0002CE   AA..         MOV     R2,?V0 + 4
   \   0002D0   AB..         MOV     R3,?V0 + 5
   \   0002D2   12....       LCALL   ??osal_mem_free?relay
   2962          
   2963            return TRUE;
   \   0002D5   7901         MOV     R1,#0x1
   \                     ??esp_ProcessInReadReportCfgCmd_5:
   \   0002D7   740A         MOV     A,#0xa
   \   0002D9   12....       LCALL   ?DEALLOC_XSTACK8
   \   0002DC   7F10         MOV     R7,#0x10
   \   0002DE   02....       LJMP    ?BANKED_LEAVE_XDATA
   2964          }
   2965          
   2966          /*********************************************************************
   2967           * @fn      esp_ProcessInReadReportCfgRspCmd
   2968           *
   2969           * @brief   Process the "Profile" Read Reporting Configuration Response Command
   2970           *
   2971           * @param   pInMsg - incoming message to process
   2972           *
   2973           * @return  none
   2974           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2975          static uint8 esp_ProcessInReadReportCfgRspCmd( zclIncomingMsg_t *pInMsg )
   \                     esp_ProcessInReadReportCfgRspCmd:
   2976          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   2977            zclReadReportCfgRspCmd_t *readReportCfgRspCmd;
   2978            zclReportCfgRspRec_t *reportRspRec;
   2979            uint8 i;
   2980          
   2981            readReportCfgRspCmd = (zclReadReportCfgRspCmd_t *)pInMsg->attrCmd;
   \   000005   EA           MOV     A,R2
   \   000006   2417         ADD     A,#0x17
   \   000008   F582         MOV     DPL,A
   \   00000A   EB           MOV     A,R3
   \   00000B   3400         ADDC    A,#0x0
   \   00000D   F583         MOV     DPH,A
   \   00000F   E0           MOVX    A,@DPTR
   \   000010   F8           MOV     R0,A
   \   000011   A3           INC     DPTR
   \   000012   E0           MOVX    A,@DPTR
   \   000013   F9           MOV     R1,A
   \   000014   E8           MOV     A,R0
   \   000015   FC           MOV     R4,A
   \   000016   E9           MOV     A,R1
   \   000017   FD           MOV     R5,A
   2982            for ( i = 0; i < readReportCfgRspCmd->numAttr; i++ )
   \   000018   7F00         MOV     R7,#0x0
   \                     ??esp_ProcessInReadReportCfgRspCmd_0:
   \   00001A   8C82         MOV     DPL,R4
   \   00001C   8D83         MOV     DPH,R5
   \   00001E   E0           MOVX    A,@DPTR
   \   00001F   F8           MOV     R0,A
   \   000020   EF           MOV     A,R7
   \   000021   C3           CLR     C
   \   000022   98           SUBB    A,R0
   \   000023   5032         JNC     ??esp_ProcessInReadReportCfgRspCmd_1
   2983            {
   2984              reportRspRec = &(readReportCfgRspCmd->attrList[i]);
   \   000025   EF           MOV     A,R7
   \   000026   F8           MOV     R0,A
   \   000027   7900         MOV     R1,#0x0
   \   000029   E8           MOV     A,R0
   \   00002A   75F00D       MOV     B,#0xd
   \   00002D   A4           MUL     AB
   \   00002E   F8           MOV     R0,A
   \   00002F   AEF0         MOV     R6,B
   \   000031   75F000       MOV     B,#0x0
   \   000034   A4           MUL     AB
   \   000035   2E           ADD     A,R6
   \   000036   FE           MOV     R6,A
   \   000037   75F00D       MOV     B,#0xd
   \   00003A   E9           MOV     A,R1
   \   00003B   A4           MUL     AB
   \   00003C   2E           ADD     A,R6
   \   00003D   F9           MOV     R1,A
   \   00003E   EC           MOV     A,R4
   \   00003F   28           ADD     A,R0
   \   000040   F582         MOV     DPL,A
   \   000042   ED           MOV     A,R5
   \   000043   39           ADDC    A,R1
   \   000044   F583         MOV     DPH,A
   \   000046   A3           INC     DPTR
   \   000047   8582..       MOV     ?V0 + 0,DPL
   \   00004A   8583..       MOV     ?V0 + 1,DPH
   2985          
   2986              // Notify the device of the results of the its original read reporting
   2987              // configuration command.
   2988          
   2989              if ( reportRspRec->status == ZCL_STATUS_SUCCESS )
   \   00004D   85..82       MOV     DPL,?V0 + 0
   \   000050   85..83       MOV     DPH,?V0 + 1
   \   000053   E0           MOVX    A,@DPTR
   2990              {
   2991                if ( reportRspRec->direction == ZCL_SEND_ATTR_REPORTS )
   2992                {
   2993                  // add user code here
   2994                }
   2995                else
   2996                {
   2997                  // expecting attribute reports
   2998                }
   2999              }
   3000            }
   \   000054   0F           INC     R7
   \   000055   80C3         SJMP    ??esp_ProcessInReadReportCfgRspCmd_0
   3001          
   3002            return TRUE;
   \                     ??esp_ProcessInReadReportCfgRspCmd_1:
   \   000057   7901         MOV     R1,#0x1
   \   000059   7F02         MOV     R7,#0x2
   \   00005B   02....       LJMP    ?BANKED_LEAVE_XDATA
   3003          }
   3004          
   3005          /*********************************************************************
   3006           * @fn      esp_ProcessInReportCmd
   3007           *
   3008           * @brief   Process the "Profile" Report Command
   3009           *
   3010           * @param   pInMsg - incoming message to process
   3011           *
   3012           * @return  none
   3013           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3014          static uint8 esp_ProcessInReportCmd( zclIncomingMsg_t *pInMsg )
   \                     esp_ProcessInReportCmd:
   3015          {
   \   000000   74EE         MOV     A,#-0x12
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 18
   \   000005                ; Auto size: 13
   \   000005   74F3         MOV     A,#-0xd
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V0 + 6,R2
   \   00000C   8B..         MOV     ?V0 + 7,R3
   3016            zclReportCmd_t *reportCmd;
   3017            zclReport_t *reportRec;
   3018            uint8 i;
   3019            uint8 *meterData;
   3020            char lcdBuf[13];
   3021          
   3022            reportCmd = (zclReportCmd_t *)pInMsg->attrCmd;
   \   00000E   E5..         MOV     A,?V0 + 6
   \   000010   2417         ADD     A,#0x17
   \   000012   F582         MOV     DPL,A
   \   000014   E5..         MOV     A,?V0 + 7
   \   000016   3400         ADDC    A,#0x0
   \   000018   F583         MOV     DPH,A
   \   00001A   E0           MOVX    A,@DPTR
   \   00001B   F8           MOV     R0,A
   \   00001C   A3           INC     DPTR
   \   00001D   E0           MOVX    A,@DPTR
   \   00001E   F9           MOV     R1,A
   \   00001F   88..         MOV     ?V0 + 4,R0
   \   000021   89..         MOV     ?V0 + 5,R1
   3023            for (i = 0; i < reportCmd->numAttr; i++)
   \   000023   75..00       MOV     ?V0 + 0,#0x0
   \                     ??esp_ProcessInReportCmd_0:
   \   000026   85..82       MOV     DPL,?V0 + 4
   \   000029   85..83       MOV     DPH,?V0 + 5
   \   00002C   E0           MOVX    A,@DPTR
   \   00002D   F8           MOV     R0,A
   \   00002E   E5..         MOV     A,?V0 + 0
   \   000030   C3           CLR     C
   \   000031   98           SUBB    A,R0
   \   000032   4003         JC      $+5
   \   000034   02....       LJMP    ??esp_ProcessInReportCmd_1 & 0xFFFF
   3024            {
   3025              // Device is notified of the latest values of the attribute of another device.
   3026              reportRec = &(reportCmd->attrList[i]);
   \   000037   E5..         MOV     A,?V0 + 0
   \   000039   A8..         MOV     R0,?V0 + 0
   \   00003B   7900         MOV     R1,#0x0
   \   00003D   E8           MOV     A,R0
   \   00003E   75F005       MOV     B,#0x5
   \   000041   A4           MUL     AB
   \   000042   C8           XCH     A,R0
   \   000043   AAF0         MOV     R2,B
   \   000045   75F000       MOV     B,#0x0
   \   000048   A4           MUL     AB
   \   000049   2A           ADD     A,R2
   \   00004A   FA           MOV     R2,A
   \   00004B   75F005       MOV     B,#0x5
   \   00004E   E9           MOV     A,R1
   \   00004F   A4           MUL     AB
   \   000050   2A           ADD     A,R2
   \   000051   F9           MOV     R1,A
   \   000052   E5..         MOV     A,?V0 + 4
   \   000054   28           ADD     A,R0
   \   000055   F582         MOV     DPL,A
   \   000057   E5..         MOV     A,?V0 + 5
   \   000059   39           ADDC    A,R1
   \   00005A   F583         MOV     DPH,A
   \   00005C   A3           INC     DPTR
   \   00005D   8582..       MOV     ?V0 + 2,DPL
   \   000060   8583..       MOV     ?V0 + 3,DPH
   3027          
   3028              if ( reportRec->attrID == ATTRID_SE_CURRENT_SUMMATION_DELIVERED )
   \   000063   85..82       MOV     DPL,?V0 + 2
   \   000066   85..83       MOV     DPH,?V0 + 3
   \   000069   E0           MOVX    A,@DPTR
   \   00006A   F8           MOV     R0,A
   \   00006B   A3           INC     DPTR
   \   00006C   E0           MOVX    A,@DPTR
   \   00006D   F9           MOV     R1,A
   \   00006E   E8           MOV     A,R0
   \   00006F   49           ORL     A,R1
   \   000070   6003         JZ      $+5
   \   000072   02....       LJMP    ??esp_ProcessInReportCmd_2 & 0xFFFF
   3029              {
   3030                // process simple metering current summation delivered attribute
   3031                meterData = reportRec->attrData;
   \   000075   85..82       MOV     DPL,?V0 + 2
   \   000078   85..83       MOV     DPH,?V0 + 3
   \   00007B   A3           INC     DPTR
   \   00007C   A3           INC     DPTR
   \   00007D   A3           INC     DPTR
   \   00007E   E0           MOVX    A,@DPTR
   \   00007F   F8           MOV     R0,A
   \   000080   A3           INC     DPTR
   \   000081   E0           MOVX    A,@DPTR
   \   000082   F9           MOV     R1,A
   \   000083   E8           MOV     A,R0
   \   000084   FE           MOV     R6,A
   \   000085   E9           MOV     A,R1
   \   000086   FF           MOV     R7,A
   3032          
   3033                // process to convert hex to ascii
   3034                for(i=0; i<6; i++)
   \   000087   75..00       MOV     ?V0 + 0,#0x0
   \                     ??esp_ProcessInReportCmd_3:
   \   00008A   E5..         MOV     A,?V0 + 0
   \   00008C   C3           CLR     C
   \   00008D   9406         SUBB    A,#0x6
   \   00008F   4003         JC      $+5
   \   000091   02....       LJMP    ??esp_ProcessInReportCmd_4 & 0xFFFF
   3035                {
   3036                  if(meterData[5-i] == 0)
   \   000094   E5..         MOV     A,?V0 + 0
   \   000096   A8..         MOV     R0,?V0 + 0
   \   000098   7900         MOV     R1,#0x0
   \   00009A   C3           CLR     C
   \   00009B   E4           CLR     A
   \   00009C   98           SUBB    A,R0
   \   00009D   F8           MOV     R0,A
   \   00009E   E4           CLR     A
   \   00009F   99           SUBB    A,R1
   \   0000A0   F9           MOV     R1,A
   \   0000A1   EE           MOV     A,R6
   \   0000A2   28           ADD     A,R0
   \   0000A3   F582         MOV     DPL,A
   \   0000A5   EF           MOV     A,R7
   \   0000A6   39           ADDC    A,R1
   \   0000A7   F583         MOV     DPH,A
   \   0000A9   A3           INC     DPTR
   \   0000AA   A3           INC     DPTR
   \   0000AB   A3           INC     DPTR
   \   0000AC   A3           INC     DPTR
   \   0000AD   A3           INC     DPTR
   \   0000AE   E0           MOVX    A,@DPTR
   \   0000AF   7060         JNZ     ??esp_ProcessInReportCmd_5
   3037                  {
   3038                    lcdBuf[i*2] = '0';
   \   0000B1   E5..         MOV     A,?V0 + 0
   \   0000B3   A8..         MOV     R0,?V0 + 0
   \   0000B5   7900         MOV     R1,#0x0
   \   0000B7   E8           MOV     A,R0
   \   0000B8   75F002       MOV     B,#0x2
   \   0000BB   A4           MUL     AB
   \   0000BC   C8           XCH     A,R0
   \   0000BD   AAF0         MOV     R2,B
   \   0000BF   75F000       MOV     B,#0x0
   \   0000C2   A4           MUL     AB
   \   0000C3   2A           ADD     A,R2
   \   0000C4   FA           MOV     R2,A
   \   0000C5   75F002       MOV     B,#0x2
   \   0000C8   E9           MOV     A,R1
   \   0000C9   A4           MUL     AB
   \   0000CA   2A           ADD     A,R2
   \   0000CB   F9           MOV     R1,A
   \   0000CC   85..82       MOV     DPL,?XSP + 0
   \   0000CF   85..83       MOV     DPH,?XSP + 1
   \   0000D2   E582         MOV     A,DPL
   \   0000D4   28           ADD     A,R0
   \   0000D5   F582         MOV     DPL,A
   \   0000D7   E583         MOV     A,DPH
   \   0000D9   39           ADDC    A,R1
   \   0000DA   F583         MOV     DPH,A
   \   0000DC   7430         MOV     A,#0x30
   \   0000DE   F0           MOVX    @DPTR,A
   3039                    lcdBuf[i*2+1] = '0';
   \   0000DF   E5..         MOV     A,?V0 + 0
   \   0000E1   A8..         MOV     R0,?V0 + 0
   \   0000E3   7900         MOV     R1,#0x0
   \   0000E5   E8           MOV     A,R0
   \   0000E6   75F002       MOV     B,#0x2
   \   0000E9   A4           MUL     AB
   \   0000EA   C8           XCH     A,R0
   \   0000EB   AAF0         MOV     R2,B
   \   0000ED   75F000       MOV     B,#0x0
   \   0000F0   A4           MUL     AB
   \   0000F1   2A           ADD     A,R2
   \   0000F2   FA           MOV     R2,A
   \   0000F3   75F002       MOV     B,#0x2
   \   0000F6   E9           MOV     A,R1
   \   0000F7   A4           MUL     AB
   \   0000F8   2A           ADD     A,R2
   \   0000F9   F9           MOV     R1,A
   \   0000FA   85..82       MOV     DPL,?XSP + 0
   \   0000FD   85..83       MOV     DPH,?XSP + 1
   \   000100   E582         MOV     A,DPL
   \   000102   28           ADD     A,R0
   \   000103   F582         MOV     DPL,A
   \   000105   E583         MOV     A,DPH
   \   000107   39           ADDC    A,R1
   \   000108   F583         MOV     DPH,A
   \   00010A   A3           INC     DPTR
   \   00010B   7430         MOV     A,#0x30
   \   00010D   F0           MOVX    @DPTR,A
   \   00010E   02....       LJMP    ??esp_ProcessInReportCmd_6 & 0xFFFF
   3040                  }
   3041                  else if(meterData[5-i] <= 0x0A)
   \                     ??esp_ProcessInReportCmd_5:
   \   000111   E5..         MOV     A,?V0 + 0
   \   000113   A8..         MOV     R0,?V0 + 0
   \   000115   7900         MOV     R1,#0x0
   \   000117   C3           CLR     C
   \   000118   E4           CLR     A
   \   000119   98           SUBB    A,R0
   \   00011A   F8           MOV     R0,A
   \   00011B   E4           CLR     A
   \   00011C   99           SUBB    A,R1
   \   00011D   F9           MOV     R1,A
   \   00011E   EE           MOV     A,R6
   \   00011F   28           ADD     A,R0
   \   000120   F582         MOV     DPL,A
   \   000122   EF           MOV     A,R7
   \   000123   39           ADDC    A,R1
   \   000124   F583         MOV     DPH,A
   \   000126   A3           INC     DPTR
   \   000127   A3           INC     DPTR
   \   000128   A3           INC     DPTR
   \   000129   A3           INC     DPTR
   \   00012A   A3           INC     DPTR
   \   00012B   E0           MOVX    A,@DPTR
   \   00012C   C3           CLR     C
   \   00012D   940B         SUBB    A,#0xb
   \   00012F   4003         JC      $+5
   \   000131   02....       LJMP    ??esp_ProcessInReportCmd_7 & 0xFFFF
   3042                  {
   3043                    lcdBuf[i*2] = '0';
   \   000134   E5..         MOV     A,?V0 + 0
   \   000136   A8..         MOV     R0,?V0 + 0
   \   000138   7900         MOV     R1,#0x0
   \   00013A   E8           MOV     A,R0
   \   00013B   75F002       MOV     B,#0x2
   \   00013E   A4           MUL     AB
   \   00013F   C8           XCH     A,R0
   \   000140   AAF0         MOV     R2,B
   \   000142   75F000       MOV     B,#0x0
   \   000145   A4           MUL     AB
   \   000146   2A           ADD     A,R2
   \   000147   FA           MOV     R2,A
   \   000148   75F002       MOV     B,#0x2
   \   00014B   E9           MOV     A,R1
   \   00014C   A4           MUL     AB
   \   00014D   2A           ADD     A,R2
   \   00014E   F9           MOV     R1,A
   \   00014F   85..82       MOV     DPL,?XSP + 0
   \   000152   85..83       MOV     DPH,?XSP + 1
   \   000155   E582         MOV     A,DPL
   \   000157   28           ADD     A,R0
   \   000158   F582         MOV     DPL,A
   \   00015A   E583         MOV     A,DPH
   \   00015C   39           ADDC    A,R1
   \   00015D   F583         MOV     DPH,A
   \   00015F   7430         MOV     A,#0x30
   \   000161   F0           MOVX    @DPTR,A
   3044                    _ltoa(meterData[5-i],(uint8*)&lcdBuf[i*2+1],16);
   \   000162                ; Setup parameters for call to function _ltoa
   \   000162   E5..         MOV     A,?V0 + 0
   \   000164   A8..         MOV     R0,?V0 + 0
   \   000166   7900         MOV     R1,#0x0
   \   000168   E8           MOV     A,R0
   \   000169   75F002       MOV     B,#0x2
   \   00016C   A4           MUL     AB
   \   00016D   C8           XCH     A,R0
   \   00016E   AAF0         MOV     R2,B
   \   000170   75F000       MOV     B,#0x0
   \   000173   A4           MUL     AB
   \   000174   2A           ADD     A,R2
   \   000175   FA           MOV     R2,A
   \   000176   75F002       MOV     B,#0x2
   \   000179   E9           MOV     A,R1
   \   00017A   A4           MUL     AB
   \   00017B   2A           ADD     A,R2
   \   00017C   F9           MOV     R1,A
   \   00017D   85..82       MOV     DPL,?XSP + 0
   \   000180   85..83       MOV     DPH,?XSP + 1
   \   000183   E582         MOV     A,DPL
   \   000185   28           ADD     A,R0
   \   000186   F582         MOV     DPL,A
   \   000188   E583         MOV     A,DPH
   \   00018A   39           ADDC    A,R1
   \   00018B   F583         MOV     DPH,A
   \   00018D   A3           INC     DPTR
   \   00018E   8582..       MOV     ?V0 + 8,DPL
   \   000191   8583..       MOV     ?V0 + 9,DPH
   \   000194   78..         MOV     R0,#?V0 + 8
   \   000196   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000199   7910         MOV     R1,#0x10
   \   00019B   E5..         MOV     A,?V0 + 0
   \   00019D   AA..         MOV     R2,?V0 + 0
   \   00019F   7B00         MOV     R3,#0x0
   \   0001A1   C3           CLR     C
   \   0001A2   E4           CLR     A
   \   0001A3   9A           SUBB    A,R2
   \   0001A4   FA           MOV     R2,A
   \   0001A5   E4           CLR     A
   \   0001A6   9B           SUBB    A,R3
   \   0001A7   FB           MOV     R3,A
   \   0001A8   EE           MOV     A,R6
   \   0001A9   2A           ADD     A,R2
   \   0001AA   F582         MOV     DPL,A
   \   0001AC   EF           MOV     A,R7
   \   0001AD   3B           ADDC    A,R3
   \   0001AE   F583         MOV     DPH,A
   \   0001B0   A3           INC     DPTR
   \   0001B1   A3           INC     DPTR
   \   0001B2   A3           INC     DPTR
   \   0001B3   A3           INC     DPTR
   \   0001B4   A3           INC     DPTR
   \   0001B5   E0           MOVX    A,@DPTR
   \   0001B6   F5..         MOV     ?V0 + 1,A
   \   0001B8   AA..         MOV     R2,?V0 + 1
   \   0001BA   E4           CLR     A
   \   0001BB   FB           MOV     R3,A
   \   0001BC   FC           MOV     R4,A
   \   0001BD   FD           MOV     R5,A
   \   0001BE   12....       LCALL   ??_ltoa?relay
   \   0001C1   7402         MOV     A,#0x2
   \   0001C3   12....       LCALL   ?DEALLOC_XSTACK8
   \   0001C6   805D         SJMP    ??esp_ProcessInReportCmd_6
   3045                  }
   3046                  else
   3047                  {
   3048                    _ltoa(meterData[5-i],(uint8*)&lcdBuf[i*2],16);
   \                     ??esp_ProcessInReportCmd_7:
   \   0001C8                ; Setup parameters for call to function _ltoa
   \   0001C8   E5..         MOV     A,?V0 + 0
   \   0001CA   A8..         MOV     R0,?V0 + 0
   \   0001CC   7900         MOV     R1,#0x0
   \   0001CE   E8           MOV     A,R0
   \   0001CF   75F002       MOV     B,#0x2
   \   0001D2   A4           MUL     AB
   \   0001D3   C8           XCH     A,R0
   \   0001D4   AAF0         MOV     R2,B
   \   0001D6   75F000       MOV     B,#0x0
   \   0001D9   A4           MUL     AB
   \   0001DA   2A           ADD     A,R2
   \   0001DB   FA           MOV     R2,A
   \   0001DC   75F002       MOV     B,#0x2
   \   0001DF   E9           MOV     A,R1
   \   0001E0   A4           MUL     AB
   \   0001E1   2A           ADD     A,R2
   \   0001E2   F9           MOV     R1,A
   \   0001E3   85..82       MOV     DPL,?XSP + 0
   \   0001E6   85..83       MOV     DPH,?XSP + 1
   \   0001E9   E582         MOV     A,DPL
   \   0001EB   28           ADD     A,R0
   \   0001EC   F5..         MOV     ?V0 + 8,A
   \   0001EE   E583         MOV     A,DPH
   \   0001F0   39           ADDC    A,R1
   \   0001F1   F5..         MOV     ?V0 + 9,A
   \   0001F3   78..         MOV     R0,#?V0 + 8
   \   0001F5   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0001F8   7910         MOV     R1,#0x10
   \   0001FA   E5..         MOV     A,?V0 + 0
   \   0001FC   AA..         MOV     R2,?V0 + 0
   \   0001FE   7B00         MOV     R3,#0x0
   \   000200   C3           CLR     C
   \   000201   E4           CLR     A
   \   000202   9A           SUBB    A,R2
   \   000203   FA           MOV     R2,A
   \   000204   E4           CLR     A
   \   000205   9B           SUBB    A,R3
   \   000206   FB           MOV     R3,A
   \   000207   EE           MOV     A,R6
   \   000208   2A           ADD     A,R2
   \   000209   F582         MOV     DPL,A
   \   00020B   EF           MOV     A,R7
   \   00020C   3B           ADDC    A,R3
   \   00020D   F583         MOV     DPH,A
   \   00020F   A3           INC     DPTR
   \   000210   A3           INC     DPTR
   \   000211   A3           INC     DPTR
   \   000212   A3           INC     DPTR
   \   000213   A3           INC     DPTR
   \   000214   E0           MOVX    A,@DPTR
   \   000215   F5..         MOV     ?V0 + 1,A
   \   000217   AA..         MOV     R2,?V0 + 1
   \   000219   E4           CLR     A
   \   00021A   FB           MOV     R3,A
   \   00021B   FC           MOV     R4,A
   \   00021C   FD           MOV     R5,A
   \   00021D   12....       LCALL   ??_ltoa?relay
   \   000220   7402         MOV     A,#0x2
   \   000222   12....       LCALL   ?DEALLOC_XSTACK8
   3049                  }
   3050                }
   \                     ??esp_ProcessInReportCmd_6:
   \   000225   05..         INC     ?V0 + 0
   \   000227   02....       LJMP    ??esp_ProcessInReportCmd_3 & 0xFFFF
   3051          
   3052                // print out value of current summation delivered in hex
   3053                HalLcdWriteString("Zigbee Coord esp", HAL_LCD_LINE_1);
   \                     ??esp_ProcessInReportCmd_4:
   \   00022A                ; Setup parameters for call to function HalLcdWriteString
   \   00022A   7901         MOV     R1,#0x1
   \   00022C   7A..         MOV     R2,#`?<Constant "Zigbee Coord esp">` & 0xff
   \   00022E   7B..         MOV     R3,#(`?<Constant "Zigbee Coord esp">` >> 8) & 0xff
   \   000230   12....       LCALL   ??HalLcdWriteString?relay
   3054                HalLcdWriteString("Curr Summ Dlvd", HAL_LCD_LINE_2);
   \   000233                ; Setup parameters for call to function HalLcdWriteString
   \   000233   7902         MOV     R1,#0x2
   \   000235   7A..         MOV     R2,#`?<Constant "Curr Summ Dlvd">` & 0xff
   \   000237   7B..         MOV     R3,#(`?<Constant "Curr Summ Dlvd">` >> 8) & 0xff
   \   000239   12....       LCALL   ??HalLcdWriteString?relay
   3055                HalLcdWriteString(lcdBuf, HAL_LCD_LINE_3);
   \   00023C                ; Setup parameters for call to function HalLcdWriteString
   \   00023C   7903         MOV     R1,#0x3
   \   00023E   85..82       MOV     DPL,?XSP + 0
   \   000241   85..83       MOV     DPH,?XSP + 1
   \   000244   AA82         MOV     R2,DPL
   \   000246   AB83         MOV     R3,DPH
   \   000248   12....       LCALL   ??HalLcdWriteString?relay
   3056              }
   3057            }
   \                     ??esp_ProcessInReportCmd_2:
   \   00024B   05..         INC     ?V0 + 0
   \   00024D   02....       LJMP    ??esp_ProcessInReportCmd_0 & 0xFFFF
   3058            return TRUE;
   \                     ??esp_ProcessInReportCmd_1:
   \   000250   7901         MOV     R1,#0x1
   \   000252   740D         MOV     A,#0xd
   \   000254   12....       LCALL   ?DEALLOC_XSTACK8
   \   000257   7F0A         MOV     R7,#0xa
   \   000259   02....       LJMP    ?BANKED_LEAVE_XDATA
   3059          }
   3060          #endif // ZCL_REPORT
   3061          
   3062          /*********************************************************************
   3063           * @fn      esp_ProcessInDefaultRspCmd
   3064           *
   3065           * @brief   Process the "Profile" Default Response Command
   3066           *
   3067           * @param   pInMsg - incoming message to process
   3068           *
   3069           * @return  none
   3070           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3071          static uint8 esp_ProcessInDefaultRspCmd( zclIncomingMsg_t *pInMsg )
   \                     esp_ProcessInDefaultRspCmd:
   3072          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   3073            // zclDefaultRspCmd_t *defaultRspCmd = (zclDefaultRspCmd_t *)pInMsg->attrCmd;
   3074          
   3075            // Device is notified of the Default Response command.
   3076          
   3077            return TRUE;
   \   000000   7901         MOV     R1,#0x1
   \   000002   02....       LJMP    ?BRET
   3078          }

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for espEp>`:
   \   000000   09           DB 9
   \   000001   ....         DW espTaskID
   \   000003   ....         DW espSimpleDesc
   \   000005   00           DB 0

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for esp_GenCmdCallbacks>`:
   \   000000   ....         DW ??esp_BasicResetCB?relay
   \   000002   ....         DW ??esp_IdentifyCB?relay
   \   000004   ....         DW ??esp_IdentifyQueryRspCB?relay
   \   000006   0000         DW 0H
   \   000008   0000         DW 0H
   \   00000A   0000         DW 0H
   \   00000C   0000         DW 0H
   \   00000E   0000         DW 0H
   \   000010   0000         DW 0H
   \   000012   0000         DW 0H
   \   000014   0000         DW 0H
   \   000016   0000         DW 0H
   \   000018   ....         DW ??esp_AlarmCB?relay
   \   00001A   0000         DW 0H
   \   00001C   0000         DW 0H

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for esp_SECmdCallbacks>`:
   \   000000   ....         DW ??esp_PublishPriceCB?relay
   \   000002   ....         DW ??esp_PublishBlockPeriodCB?relay
   \   000004   ....         DW ??esp_GetCurrentPriceCB?relay
   \   000006   ....         DW ??esp_GetScheduledPriceCB?relay
   \   000008   ....         DW ??esp_PriceAcknowledgementCB?relay
   \   00000A   ....         DW ??esp_GetBlockPeriodCB?relay
   \   00000C   ....         DW ??esp_LoadControlEventCB?relay
   \   00000E   ....         DW ??esp_CancelLoadControlEventCB?relay
   \   000010   ....         DW ??esp_CancelAllLoadControlEventsCB?relay
   \   000012   ....         DW ??esp_ReportEventStatusCB?relay
   \   000014   ....         DW ??esp_GetScheduledEventCB?relay
   \   000016   ....         DW ??esp_GetProfileRspCB?relay
   \   000018   ....         DW ??esp_ReqMirrorCmdCB?relay
   \   00001A   ....         DW ??esp_MirrorRemCmdCB?relay
   \   00001C   ....         DW ??esp_ReqFastPollModeRspCB?relay
   \   00001E   ....         DW ??esp_GetProfileCmdCB?relay
   \   000020   ....         DW ??esp_ReqMirrorRspCB?relay
   \   000022   ....         DW ??esp_MirrorRemRspCB?relay
   \   000024   ....         DW ??esp_ReqFastPollModeCmdCB?relay
   \   000026   ....         DW ??esp_DisplayMessageCB?relay
   \   000028   ....         DW ??esp_CancelMessageCB?relay
   \   00002A   ....         DW ??esp_GetLastMessageCB?relay
   \   00002C   ....         DW ??esp_MessageConfirmationCB?relay
   \   00002E   0000         DW 0H
   \   000030   0000         DW 0H
   \   000032   0000         DW 0H
   \   000034   0000         DW 0H
   \   000036   0000         DW 0H
   \   000038   0000         DW 0H
   \   00003A   0000         DW 0H
   \   00003C   ....         DW ??esp_SupplyStatusRspCB?relay
   \   00003E   ....         DW ??esp_SelAvailEmergencyCreditCmdCB?relay
   \   000040   ....         DW ??esp_ChangeSupplyCmdCB?relay

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??esp_Init?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    esp_Init

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??esp_event_loop?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    esp_event_loop

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??esp_ProcessAppMsg?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    esp_ProcessAppMsg

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??esp_ProcessIdentifyTimeChange?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    esp_ProcessIdentifyTimeChange

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??esp_HandleKeys?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    esp_HandleKeys

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??esp_ValidateAttrDataCB?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    esp_ValidateAttrDataCB

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??esp_BasicResetCB?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    esp_BasicResetCB

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??esp_IdentifyCB?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    esp_IdentifyCB

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??esp_IdentifyQueryRspCB?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    esp_IdentifyQueryRspCB

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??esp_AlarmCB?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    esp_AlarmCB

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??esp_GetProfileCmdCB?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    esp_GetProfileCmdCB

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??esp_GetProfileRspCB?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    esp_GetProfileRspCB

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??esp_ReqMirrorCmdCB?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    esp_ReqMirrorCmdCB

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??esp_ReqMirrorRspCB?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    esp_ReqMirrorRspCB

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??esp_MirrorRemCmdCB?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    esp_MirrorRemCmdCB

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??esp_MirrorRemRspCB?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    esp_MirrorRemRspCB

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??esp_ReqFastPollModeCmdCB?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    esp_ReqFastPollModeCmdCB

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??esp_ReqFastPollModeRspCB?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    esp_ReqFastPollModeRspCB

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??esp_GetCurrentPriceCB?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    esp_GetCurrentPriceCB

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??esp_GetScheduledPriceCB?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    esp_GetScheduledPriceCB

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??esp_PriceAcknowledgementCB?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    esp_PriceAcknowledgementCB

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??esp_GetBlockPeriodCB?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    esp_GetBlockPeriodCB

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??esp_PublishPriceCB?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    esp_PublishPriceCB

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??esp_PublishBlockPeriodCB?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    esp_PublishBlockPeriodCB

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??esp_DisplayMessageCB?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    esp_DisplayMessageCB

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??esp_CancelMessageCB?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    esp_CancelMessageCB

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??esp_GetLastMessageCB?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    esp_GetLastMessageCB

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??esp_MessageConfirmationCB?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    esp_MessageConfirmationCB

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??esp_SendReportEventStatus?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    esp_SendReportEventStatus

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??esp_LoadControlEventCB?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    esp_LoadControlEventCB

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??esp_CancelLoadControlEventCB?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    esp_CancelLoadControlEventCB

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??esp_CancelAllLoadControlEventsCB?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    esp_CancelAllLoadControlEventsCB

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??esp_ReportEventStatusCB?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    esp_ReportEventStatusCB

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??esp_GetScheduledEventCB?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    esp_GetScheduledEventCB

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??esp_SelAvailEmergencyCreditCmdCB?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    esp_SelAvailEmergencyCreditCmdCB

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??esp_ChangeSupplyCmdCB?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    esp_ChangeSupplyCmdCB

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??esp_SupplyStatusRspCB?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    esp_SupplyStatusRspCB

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??esp_ProcessZDOMsg?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    esp_ProcessZDOMsg

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??esp_ProcessZCLMsg?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    esp_ProcessZCLMsg

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??esp_ProcessInReadRspCmd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    esp_ProcessInReadRspCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??esp_ProcessInWriteRspCmd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    esp_ProcessInWriteRspCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??esp_ProcessInConfigReportCmd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    esp_ProcessInConfigReportCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??esp_ProcessInConfigReportRspCmd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    esp_ProcessInConfigReportRspCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??esp_ProcessInReadReportCfgCmd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    esp_ProcessInReadReportCfgCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??esp_ProcessInReadReportCfgRspCmd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    esp_ProcessInReadReportCfgRspCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??esp_ProcessInReportCmd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    esp_ProcessInReportCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??esp_ProcessInDefaultRspCmd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    esp_ProcessInDefaultRspCmd

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant "TI IPD Test Msg!">`:
   \   000000   54492049     DB "TI IPD Test Msg!"
   \            50442054
   \            65737420
   \            4D736721
   \            00      

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant {10485761L, 10485762L, 10485763L, 1`:
   \   000000   0100A000     DD 10485761
   \   000004   0200A000     DD 10485762
   \   000008   0300A000     DD 10485763
   \   00000C   0400A000     DD 10485764
   \   000010   0500A000     DD 10485765

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant "Fast Polling">`:
   \   000000   46617374     DB "Fast Polling"
   \            20506F6C
   \            6C696E67
   \            00      

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant "Cur 0x">`:
   \   000000   43757220     DB "Cur 0x"
   \            307800  

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant "End 0x">`:
   \   000000   456E6420     DB "End 0x"
   \            307800  

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant "BASE">`:
   \   000000   42415345     DB "BASE"
   \            00      

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant {32, 33, 34, 35, 36, 37, 38, 39, 40`:
   \   000000   20           DB 32
   \   000001   21           DB 33
   \   000002   22           DB 34
   \   000003   23           DB 35
   \   000004   24           DB 36
   \   000005   25           DB 37
   \   000006   26           DB 38
   \   000007   27           DB 39
   \   000008   28           DB 40
   \   000009   29           DB 41

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant "Zigbee Coord esp">`:
   \   000000   5A696762     DB "Zigbee Coord esp"
   \            65652043
   \            6F6F7264
   \            20657370
   \            00      

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant "Curr Summ Dlvd">`:
   \   000000   43757272     DB "Curr Summ Dlvd"
   \            2053756D
   \            6D20446C
   \            766400  

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_ffffffff:
   \   000000   FFFFFFFF     DD 4294967295
   3079          
   3080          #if defined ( ZCL_DISCOVER )
   3081          /*********************************************************************
   3082           * @fn      esp_ProcessInDiscRspCmd
   3083           *
   3084           * @brief   Process the "Profile" Discover Response Command
   3085           *
   3086           * @param   pInMsg - incoming message to process
   3087           *
   3088           * @return  none
   3089           */
   3090          static uint8 esp_ProcessInDiscRspCmd( zclIncomingMsg_t *pInMsg )
   3091          {
   3092            zclDiscoverRspCmd_t *discoverRspCmd;
   3093            uint8 i;
   3094          
   3095            discoverRspCmd = (zclDiscoverRspCmd_t *)pInMsg->attrCmd;
   3096          
   3097            for ( i = 0; i < discoverRspCmd->numAttr; i++ )
   3098            {
   3099              // Device is notified of the result of its attribute discovery command.
   3100            }
   3101          
   3102            return TRUE;
   3103          }
   3104          #endif // ZCL_DISCOVER
   3105          
   3106          #if defined ( SE_UK_EXT ) && defined ( SE_MIRROR )
   3107          /*********************************************************************
   3108           * @fn      esp_MirrorInit
   3109           *
   3110           * @brief   Initialize the ESP Mirror Subsystem.
   3111           *
   3112           * @param   none
   3113           *
   3114           * @return  none
   3115           */
   3116          static void esp_MirrorInit( void )
   3117          {
   3118            osal_memset( &esp_MirrorControl, 0, sizeof( esp_MirrorControl ) );
   3119          
   3120            // set the attribute
   3121            espPhysicalEnvironment |= PHY_MIRROR_CAPACITY_ENV;
   3122          }
   3123          
   3124          /*********************************************************************
   3125           * @fn      esp_GetMirrorEndpoint
   3126           *
   3127           * @brief   Get the endpoint of a mirror using the Source Address and
   3128           *          source endpoint.
   3129           *
   3130           * @param   srcAddr - source address to lookup
   3131           *
   3132           * @return  Endpoint of the mirror or
   3133           *          ESP_MIRROR_INVALID_ENDPOINT if there is no space
   3134           */
   3135          static uint8 esp_GetMirrorEndpoint( afAddrType_t *srcAddr )
   3136          {
   3137            uint8 i;
   3138          
   3139            for ( i = 0; i < ESP_MAX_MIRRORS; i++ )
   3140            {
   3141              if ( ( esp_MirrorControl.mirrorMask & (1 << i) ) &&
   3142                   ( esp_MirrorControl.mirrorInfo[i].srcAddr == srcAddr->addr.shortAddr ) &&
   3143                   ( esp_MirrorControl.mirrorInfo[i].srcEndpoint == srcAddr->endPoint ) )
   3144              {
   3145                return ( i + ESP_MIRROR_EP_BASE );
   3146              }
   3147            }
   3148          
   3149            return ESP_MIRROR_INVALID_ENDPOINT;
   3150          }
   3151          
   3152          /*********************************************************************
   3153           * @fn      esp_GetMirrorInfo
   3154           *
   3155           * @brief   Get the control information for a mirror endpoint.
   3156           *
   3157           * @param   endpoint - to lookup
   3158           *
   3159           * @return  Pointer to Mirror Information or
   3160           *          NULL if no Mirror found for the Endpoint
   3161           */
   3162          static espMirrorInfo_t *esp_GetMirrorInfo( uint8 endpoint )
   3163          {
   3164            if ( esp_IsMirrorEndpoint( endpoint ) )
   3165            {
   3166              // Get the index to the mirror
   3167              uint8 index = endpoint - ESP_MIRROR_EP_BASE;
   3168          
   3169              // Return a pointer to the attributes
   3170              return &esp_MirrorControl.mirrorInfo[index];
   3171            }
   3172          
   3173            return NULL;
   3174          }
   3175          
   3176          /*********************************************************************
   3177           * @fn      esp_MirrorInitAttributeSet
   3178           *
   3179           * @brief   Adds notification attributes to the mirror endpoint
   3180           *
   3181           * @param   endpoint - Endpoint of the mirror
   3182           *
   3183           * @return  none
   3184           */
   3185          static void esp_MirrorInitAttributeSet( uint8 endpoint )
   3186          {
   3187            espMirrorInfo_t *pInfo = esp_GetMirrorInfo( endpoint );
   3188          
   3189            if ( pInfo != NULL )
   3190            {
   3191              zclAttrRec_t *pAttributes = pInfo->pAttr;
   3192          
   3193              if ( pAttributes != NULL )
   3194              {
   3195                // Note: Attributes 0 through ESP_MIRROR_USER_ATTRIBUTES_POSITION-1 are used for
   3196                // the mirror notify attribute set.  The rest of the attributes are reserved for
   3197                // the meter.  The meter creates attributes with a report attribute command.
   3198                pAttributes[0].clusterID = ZCL_CLUSTER_ID_SE_SIMPLE_METERING;
   3199                pAttributes[0].attr.attrId = ATTRID_SE_NOTIFICATION_CONTROL_FLAGS;
   3200                pAttributes[0].attr.dataType = ZCL_DATATYPE_BITMAP8;
   3201                pAttributes[0].attr.accessControl = ACCESS_CONTROL_READ | ACCESS_CONTROL_WRITE;
   3202                pAttributes[0].attr.dataPtr = &pInfo->notificationControl;
   3203          
   3204                pAttributes[1].clusterID = ZCL_CLUSTER_ID_SE_SIMPLE_METERING;
   3205                pAttributes[1].attr.attrId = ATTRID_SE_NOTIFICATION_FLAGS;
   3206                pAttributes[1].attr.dataType = ZCL_DATATYPE_BITMAP8;
   3207                pAttributes[1].attr.accessControl = ACCESS_CONTROL_READ;
   3208                pAttributes[1].attr.dataPtr = &pInfo->notificationSet.NotificationFlags;
   3209          
   3210                pAttributes[2].clusterID = ZCL_CLUSTER_ID_SE_SIMPLE_METERING;
   3211                pAttributes[2].attr.attrId = ATTRID_SE_PRICE_NOTIFICATION_FLAGS;
   3212                pAttributes[2].attr.dataType = ZCL_DATATYPE_BITMAP16;
   3213                pAttributes[2].attr.accessControl = ACCESS_CONTROL_READ;
   3214                pAttributes[2].attr.dataPtr = &pInfo->notificationSet.PriceNotificationFlags;
   3215          
   3216                pAttributes[3].clusterID = ZCL_CLUSTER_ID_SE_SIMPLE_METERING;
   3217                pAttributes[3].attr.attrId = ATTRID_SE_CALENDAR_NOTIFICATION_FLAGS;
   3218                pAttributes[3].attr.dataType = ZCL_DATATYPE_BITMAP8;
   3219                pAttributes[3].attr.accessControl = ACCESS_CONTROL_READ;
   3220                pAttributes[3].attr.dataPtr = &pInfo->notificationSet.CalendarNotificationFlags;
   3221          
   3222                pAttributes[4].clusterID = ZCL_CLUSTER_ID_SE_SIMPLE_METERING;
   3223                pAttributes[4].attr.attrId = ATTRID_SE_PRE_PAY_NOTIFICATION_FLAGS;
   3224                pAttributes[4].attr.dataType = ZCL_DATATYPE_BITMAP16;
   3225                pAttributes[4].attr.accessControl = ACCESS_CONTROL_READ;
   3226                pAttributes[4].attr.dataPtr = &pInfo->notificationSet.PrePayNotificationFlags;
   3227          
   3228                pAttributes[5].clusterID = ZCL_CLUSTER_ID_SE_SIMPLE_METERING;
   3229                pAttributes[5].attr.attrId = ATTRID_SE_DEVICE_MANAGEMENT_FLAGS;
   3230                pAttributes[5].attr.dataType = ZCL_DATATYPE_BITMAP8;
   3231                pAttributes[5].attr.accessControl = ACCESS_CONTROL_READ;
   3232                pAttributes[5].attr.dataPtr = &pInfo->notificationSet.DeviceMgmtNotificationFlags;
   3233              }
   3234            }
   3235          }
   3236          
   3237          /*********************************************************************
   3238           * @fn      esp_AllocMirror
   3239           *
   3240           * @brief   Allocate a mirror endpoint in the mirror control structure.
   3241           *
   3242           * @param   srcAddr - of the device requesting a Mirror
   3243           *
   3244           * @return  Endpoint of the mirror or
   3245           *          ESP_MIRROR_INVALID_ENDPOINT if there is no space
   3246           */
   3247          static uint8 esp_AllocMirror( afAddrType_t *srcAddr )
   3248          {
   3249            uint8 i;
   3250            zclAttrRec_t *pAttr;
   3251            uint8 endpoint;
   3252          
   3253            // Verify space is available for another mirror endpoint
   3254            if ( esp_MirrorControl.mirrorMask != ESP_MIRROR_FULL_MASK )
   3255            {
   3256              // Allocate memory for the attribute table
   3257              pAttr = osal_mem_alloc( sizeof( zclAttrRec_t ) * ESP_MIRROR_MAX_ATTRIBUTES );
   3258          
   3259              if ( pAttr != NULL )
   3260              {
   3261                // Initialize the attribute
   3262                osal_memset( pAttr, 0, sizeof( zclAttrRec_t ) * ESP_MIRROR_MAX_ATTRIBUTES );
   3263          
   3264                // Set the attribute clusters to 0xFFFF indicating they are not in use
   3265                for ( i = 0; i < ESP_MIRROR_MAX_ATTRIBUTES; i++ )
   3266                {
   3267                  pAttr[i].clusterID = 0xFFFF;
   3268                }
   3269          
   3270                // Find the next free endpoint slot
   3271                for ( i = 0; i < ESP_MAX_MIRRORS; i++ )
   3272                {
   3273                  if ( esp_MirrorControl.mirrorMask & (1 << i) )
   3274                  {
   3275                    continue;
   3276                  }
   3277          
   3278                  endpoint = i + ESP_MIRROR_EP_BASE;
   3279          
   3280                  // Zero out the info memory
   3281                  osal_memset( &esp_MirrorControl.mirrorInfo[i], 0, sizeof( espMirrorInfo_t ) );
   3282          
   3283                  // Setup mirror information
   3284                  esp_MirrorControl.mirrorMask |= 1 << i;
   3285                  esp_MirrorControl.mirrorInfo[i].srcAddr = srcAddr->addr.shortAddr;
   3286                  esp_MirrorControl.mirrorInfo[i].srcEndpoint = srcAddr->endPoint;
   3287                  esp_MirrorControl.mirrorInfo[i].pAttr = pAttr;
   3288          
   3289                  // Create attributes for the notification set
   3290                  esp_MirrorInitAttributeSet( endpoint );
   3291          
   3292                  // If all endpoints are in use, set the PhysicalEnvironment attribute
   3293                  // indicating all mirror slot are used
   3294                  if ( esp_MirrorControl.mirrorMask == ESP_MIRROR_FULL_MASK )
   3295                  {
   3296                    espPhysicalEnvironment &= ~PHY_MIRROR_CAPACITY_ENV;
   3297                  }
   3298          
   3299                  return endpoint;
   3300                }
   3301          
   3302                // Free the attribute memory if we could not allocate the endpoint
   3303                osal_mem_free( pAttr );
   3304              }
   3305            }
   3306          
   3307            return ESP_MIRROR_INVALID_ENDPOINT;
   3308          }
   3309          
   3310          /*********************************************************************
   3311           * @fn      esp_FreeMirror
   3312           *
   3313           * @brief   Free a mirror endpoint in the mirror control structure.
   3314           *
   3315           * @param   endPoint - Endpoint of the mirror to free
   3316           *
   3317           * @return  none
   3318           */
   3319          void esp_FreeMirror( uint8 endPoint )
   3320          {
   3321            if ( esp_IsMirrorEndpoint( endPoint ) )
   3322            {
   3323              // Get the index to the mirror
   3324              uint8 index = endPoint - ESP_MIRROR_EP_BASE;
   3325              uint8 i;
   3326          
   3327              // Clear the endpoint bit in the mask of allocated mirrors
   3328              esp_MirrorControl.mirrorMask &= ~(1 << index);
   3329          
   3330              if ( esp_MirrorControl.mirrorInfo[index].pAttr )
   3331              {
   3332                // Free the user attribute data
   3333                for ( i = ESP_MIRROR_USER_ATTRIBUTES_POSITION; i < ESP_MIRROR_MAX_ATTRIBUTES; i++ )
   3334                {
   3335                  if ( esp_MirrorControl.mirrorInfo[index].pAttr[i].attr.dataPtr )
   3336                  {
   3337                    osal_mem_free( esp_MirrorControl.mirrorInfo[index].pAttr[i].attr.dataPtr );
   3338                    esp_MirrorControl.mirrorInfo[index].pAttr[i].attr.dataPtr = NULL;
   3339                  }
   3340                }
   3341          
   3342                // Free the attribute table
   3343                osal_mem_free( esp_MirrorControl.mirrorInfo[index].pAttr );
   3344                esp_MirrorControl.mirrorInfo[index].pAttr = NULL;
   3345              }
   3346            }
   3347          }
   3348          
   3349          /*********************************************************************
   3350           * @fn      esp_IsMirrorEndpoint
   3351           *
   3352           * @brief   Check if the endpoint is in the mirror block of endpoints.
   3353           *
   3354           * @param   endpoint - Endpoint of the mirror to free
   3355           *
   3356           * @return  TRUE - if Endpoint is in the Mirror Block
   3357           *          FALSE - Otherwise
   3358           */
   3359          static uint8 esp_IsMirrorEndpoint( uint8 endpoint )
   3360          {
   3361            if ( (endpoint >= ESP_MIRROR_EP_BASE ) &&
   3362                 (endpoint <= ESP_MIRROR_EP_BASE + ESP_MAX_MIRRORS ) )
   3363            {
   3364              return TRUE;
   3365            }
   3366          
   3367            return FALSE;
   3368          }
   3369          
   3370          /*********************************************************************
   3371           * @fn      esp_MirrorUpdateAttribute
   3372           *
   3373           * @brief   Update Attributes in Mirror
   3374           *
   3375           * @param   endpoint - Endpoint of the mirror to free
   3376           *          cluster - Cluster ID
   3377           *          pReport - Pointer to reported attributes
   3378           *
   3379           * @return  TRUE - if Data updated
   3380           *          FALSE - Otherwise
   3381           */
   3382          static uint8 esp_MirrorUpdateAttribute( uint8 endpoint, uint16 cluster, zclReport_t *pReport )
   3383          {
   3384            espMirrorInfo_t *pInfo = esp_GetMirrorInfo( endpoint );
   3385          
   3386            if ( pInfo != NULL )
   3387            {
   3388              zclAttrRec_t *pAttributes = pInfo->pAttr;
   3389              uint8 i;
   3390          
   3391              if ( pAttributes != NULL )
   3392              {
   3393                // Check if the attribute already exists
   3394                for ( i = ESP_MIRROR_USER_ATTRIBUTES_POSITION; i < ESP_MIRROR_MAX_ATTRIBUTES; i++ )
   3395                {
   3396                  if ( pAttributes[i].clusterID == cluster )
   3397                  {
   3398                    if ( pAttributes[i].attr.attrId == pReport->attrID )
   3399                    {
   3400                      if ( pAttributes[i].attr.dataPtr )
   3401                      {
   3402                        // Update the attribute data
   3403                        zclSerializeData( pReport->dataType, pReport->attrData, pAttributes[i].attr.dataPtr );
   3404                        return TRUE;
   3405                      }
   3406                    }
   3407                  }
   3408                }
   3409          
   3410                // Look for a free attribute slot and add the attribute
   3411                for ( i = ESP_MIRROR_USER_ATTRIBUTES_POSITION; i < ESP_MIRROR_MAX_ATTRIBUTES; i++ )
   3412                {
   3413                  if ( pAttributes[i].attr.dataPtr == NULL )
   3414                  {
   3415                    uint8 dataLength = zclGetDataTypeLength( pReport->dataType );
   3416          
   3417                    if ( dataLength > 0 )
   3418                    {
   3419                      pAttributes[i].clusterID = cluster;
   3420                      pAttributes[i].attr.attrId = pReport->attrID;
   3421                      pAttributes[i].attr.dataType = pReport->dataType;
   3422                      pAttributes[i].attr.accessControl = ACCESS_CONTROL_READ;
   3423                      pAttributes[i].attr.dataPtr = osal_mem_alloc( dataLength );
   3424          
   3425                      if ( pAttributes[i].attr.dataPtr != NULL )
   3426                      {
   3427                        zclSerializeData( pReport->dataType, pReport->attrData, pAttributes[i].attr.dataPtr );
   3428                        return TRUE;
   3429                      }
   3430                    }
   3431                  }
   3432                }
   3433              }
   3434            }
   3435          
   3436            return FALSE;
   3437          }
   3438          
   3439          /*********************************************************************
   3440           * @fn      esp_MirrorProcessZCLMsg
   3441           *
   3442           * @brief   Process ZCL messages for mirror endpoints.
   3443           *
   3444           * @param   pInMsg - ZCL Message
   3445           *
   3446           * @return  none
   3447           */
   3448          static void esp_MirrorProcessZCLMsg( zclIncomingMsg_t *pInMsg )
   3449          {
   3450            uint8 i;
   3451          
   3452            if ( pInMsg->zclHdr.commandID == ZCL_CMD_REPORT )
   3453            {
   3454              zclReportCmd_t *reportCmd = (zclReportCmd_t *)pInMsg->attrCmd;
   3455          
   3456              if ( reportCmd != NULL)
   3457              {
   3458                for (i = 0; i < reportCmd->numAttr; i++)
   3459                {
   3460                  // Update the attribute
   3461                  esp_MirrorUpdateAttribute( pInMsg->endPoint, pInMsg->clusterId, &reportCmd->attrList[i] );
   3462                }
   3463              }
   3464          
   3465              // Build a response
   3466              espMirrorInfo_t *pInfo = esp_GetMirrorInfo( pInMsg->srcAddr.endPoint );
   3467          
   3468              if ( pInfo != NULL )
   3469              {
   3470                if ( pInfo->notificationControl & SE_NOTIFICATION_REPORT_ATTR_RSP_BIT )
   3471                {
   3472                  // Send a mirror report attr rsp using the notification set from the mirror info
   3473                  zclSE_SimpleMetering_Send_MirrorReportAttrRsp( pInMsg->endPoint, &pInMsg->srcAddr,
   3474                                                                 &pInfo->notificationSet, TRUE,
   3475                                                                 pInMsg->zclHdr.transSeqNum);
   3476                }
   3477              }
   3478            }
   3479          }
   3480          #endif  // SE_UK_EXT && SE_MIRROR
   3481          /****************************************************************************
   3482          ****************************************************************************/

   Maximum stack usage in bytes:

   ISTACK PSTACK XSTACK Function
   ------ ------ ------ --------
       0      0      0  esp_AlarmCB
       0      0      0  esp_BasicResetCB
       0      0      0  esp_CancelAllLoadControlEventsCB
       0      0     21  esp_CancelLoadControlEventCB
                          0 0 21 -> esp_SendReportEventStatus
       0      0      0  esp_CancelMessageCB
       0      0      0  esp_ChangeSupplyCmdCB
       0      0     11  esp_DisplayMessageCB
                          0 0 11 -> HalLcdWriteString
       0      0      0  esp_GetBlockPeriodCB
       1      0     62  esp_GetCurrentPriceCB
                          0 0 59 -> osal_getClock
                          0 0 59 -> osal_mem_alloc
                          0 0 59 -> osal_mem_free
                          0 0 62 -> osal_memcpy
                          0 0 59 -> osal_memset
                          0 0 61 -> zclSE_Pricing_Send_PublishPrice
       2      0     40  esp_GetLastMessageCB
                          0 0 40 -> zclSE_Message_Send_DisplayMessage
       2      0     51  esp_GetProfileCmdCB
                          0 0 51 -> zclSE_SimpleMetering_Send_GetProfileRsp
       0      0      0  esp_GetProfileRspCB
       0      0      0  esp_GetScheduledEventCB
       0      0     58  esp_GetScheduledPriceCB
                          0 0 56 -> osal_memset
                          0 0 58 -> zclSE_Pricing_Send_PublishPrice
       2      0     61  esp_HandleKeys
                          0 0 47 -> zclSE_LoadControl_Send_LoadControlEvent
                          0 0 47 -> zclSE_Message_Send_DisplayMessage
       0      0      9  esp_IdentifyCB
                          0 0  9 -> esp_ProcessIdentifyTimeChange
       0      0      0  esp_IdentifyQueryRspCB
       0      0     13  esp_Init
                          0 0 11 -> RegisterForKeys
                          0 0 11 -> StubAPS_RegisterApp
                          0 0 11 -> ZDO_RegisterForZDOMsg
                          0 0 11 -> osal_start_timerEx
                          0 0 11 -> zclGeneral_RegisterCmdCallbacks
                          0 0 11 -> zclSE_Init
                          0 0 11 -> zclSE_RegisterCmdCallbacks
                          0 0 11 -> zcl_registerAttrList
                          0 0 11 -> zcl_registerClusterOptionList
                          0 0 11 -> zcl_registerForMsg
                          0 0 11 -> zcl_registerValidateAttrData
                          0 0 13 -> zgSetItem
       0      0     24  esp_LoadControlEventCB
                          0 0 23 -> esp_SendReportEventStatus
       0      0      0  esp_MessageConfirmationCB
       0      0      0  esp_MirrorRemCmdCB
       0      0      0  esp_MirrorRemRspCB
       0      0      0  esp_PriceAcknowledgementCB
       0      0     14  esp_ProcessAppMsg
       2      0     14  esp_ProcessIdentifyTimeChange
                          2 0  0 -> HalLedBlink
                          2 0  0 -> HalLedSet
                          2 0  0 -> osal_start_timerEx
                          2 0  0 -> osal_stop_timerEx
       2      0     42  esp_ProcessInConfigReportCmd
                          0 0 28 -> osal_mem_alloc
                          0 0 28 -> osal_mem_free
                          0 0 30 -> zclFindAttrRec
                          0 0 33 -> zcl_SendConfigReportRspCmd
       0      0     33  esp_ProcessInConfigReportRspCmd
                          0 0 24 -> zclFindAttrRec
       0      0      9  esp_ProcessInDefaultRspCmd
       1      0     48  esp_ProcessInReadReportCfgCmd
                          0 0 34 -> osal_mem_alloc
                          0 0 34 -> osal_mem_free
                          0 0 34 -> zclAnalogDataType
                          0 0 36 -> zclFindAttrRec
                          0 0 34 -> zclGetDataTypeLength
                          0 0 39 -> zcl_SendReadReportCfgRspCmd
       0      0     19  esp_ProcessInReadReportCfgRspCmd
       0      0     18  esp_ProcessInReadRspCmd
       0      0     42  esp_ProcessInReportCmd
                          0 0 31 -> HalLcdWriteString
                          0 0 33 -> _ltoa
       0      0     18  esp_ProcessInWriteRspCmd
       0      0     23  esp_ProcessZCLMsg
                          0 0  9 -> esp_ProcessInConfigReportCmd
                          0 0  9 -> esp_ProcessInConfigReportRspCmd
                          0 0  9 -> esp_ProcessInDefaultRspCmd
                          0 0  9 -> esp_ProcessInReadReportCfgCmd
                          0 0  9 -> esp_ProcessInReadReportCfgRspCmd
                          0 0  9 -> esp_ProcessInReadRspCmd
                          0 0  9 -> esp_ProcessInReportCmd
                          0 0  9 -> esp_ProcessInWriteRspCmd
                          0 0  9 -> osal_mem_free
       0      0     37  esp_ProcessZDOMsg
                          0 0 23 -> ZDO_ParseDeviceAnnce
                          0 0 23 -> ZDO_ParseSimpleDescRsp
                          0 0 23 -> osal_mem_alloc
                          0 0 23 -> osal_mem_free
                          0 0 23 -> osal_set_event
       0      0      0  esp_PublishBlockPeriodCB
       0      0      0  esp_PublishPriceCB
       0      0      0  esp_ReportEventStatusCB
       1      0     31  esp_ReqFastPollModeCmdCB
                          0 0 29 -> HalLcdWriteString
                          0 0 30 -> HalLcdWriteStringValue
                          0 0 29 -> osal_getClock
                          0 0 29 -> osal_start_timerEx
                          0 0 31 -> zclSE_SimpleMetering_Send_ReqFastPollModeRsp
       0      0      0  esp_ReqFastPollModeRspCB
       0      0      0  esp_ReqMirrorCmdCB
       0      0      0  esp_ReqMirrorRspCB
       0      0      0  esp_SelAvailEmergencyCreditCmdCB
       1      0     51  esp_SendReportEventStatus
                          0 0 25 -> osal_mem_alloc
                          0 0 25 -> osal_mem_free
                          0 0 28 -> osal_memcpy
                          0 0 27 -> zclSE_LoadControl_Send_ReportEventStatus
       0      0      0  esp_SupplyStatusRspCB
       2      0      0  esp_ValidateAttrDataCB
       0      0     15  esp_event_loop
                          0 0 15 -> ZDP_SimpleDescReq
                          0 0 14 -> esp_HandleKeys
                          0 0 14 -> esp_ProcessAppMsg
                          0 0 14 -> esp_ProcessIdentifyTimeChange
                          0 0 14 -> esp_ProcessZCLMsg
                          0 0 14 -> esp_ProcessZDOMsg
                          0 0 14 -> osal_getClock
                          0 0 14 -> osal_msg_deallocate
                          0 0 14 -> osal_msg_receive
                          0 0 14 -> osal_start_timerEx


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       5  ?<Constant "BASE">
       7  ?<Constant "Cur 0x">
      15  ?<Constant "Curr Summ Dlvd">
       7  ?<Constant "End 0x">
      13  ?<Constant "Fast Polling">
      17  ?<Constant "TI IPD Test Msg!">
      17  ?<Constant "Zigbee Coord esp">
      20  ?<Constant {10485761L, 10485762L, 10485763L, 1
      10  ?<Constant {32, 33, 34, 35, 36, 37, 38, 39, 40
       6  ?<Initializer for espEp>
      30  ?<Initializer for esp_GenCmdCallbacks>
      66  ?<Initializer for esp_SECmdCallbacks>
       6  ??esp_AlarmCB?relay
       6  ??esp_BasicResetCB?relay
       6  ??esp_CancelAllLoadControlEventsCB?relay
       6  ??esp_CancelLoadControlEventCB?relay
       6  ??esp_CancelMessageCB?relay
       6  ??esp_ChangeSupplyCmdCB?relay
       6  ??esp_DisplayMessageCB?relay
       6  ??esp_GetBlockPeriodCB?relay
       6  ??esp_GetCurrentPriceCB?relay
       6  ??esp_GetLastMessageCB?relay
       6  ??esp_GetProfileCmdCB?relay
       6  ??esp_GetProfileRspCB?relay
       6  ??esp_GetScheduledEventCB?relay
       6  ??esp_GetScheduledPriceCB?relay
       6  ??esp_HandleKeys?relay
       6  ??esp_IdentifyCB?relay
       6  ??esp_IdentifyQueryRspCB?relay
       6  ??esp_Init?relay
       6  ??esp_LoadControlEventCB?relay
       6  ??esp_MessageConfirmationCB?relay
       6  ??esp_MirrorRemCmdCB?relay
       6  ??esp_MirrorRemRspCB?relay
       6  ??esp_PriceAcknowledgementCB?relay
       6  ??esp_ProcessAppMsg?relay
       6  ??esp_ProcessIdentifyTimeChange?relay
       6  ??esp_ProcessInConfigReportCmd?relay
       6  ??esp_ProcessInConfigReportRspCmd?relay
       6  ??esp_ProcessInDefaultRspCmd?relay
       6  ??esp_ProcessInReadReportCfgCmd?relay
       6  ??esp_ProcessInReadReportCfgRspCmd?relay
       6  ??esp_ProcessInReadRspCmd?relay
       6  ??esp_ProcessInReportCmd?relay
       6  ??esp_ProcessInWriteRspCmd?relay
       6  ??esp_ProcessZCLMsg?relay
       6  ??esp_ProcessZDOMsg?relay
       6  ??esp_PublishBlockPeriodCB?relay
       6  ??esp_PublishPriceCB?relay
       6  ??esp_ReportEventStatusCB?relay
       6  ??esp_ReqFastPollModeCmdCB?relay
       6  ??esp_ReqFastPollModeRspCB?relay
       6  ??esp_ReqMirrorCmdCB?relay
       6  ??esp_ReqMirrorRspCB?relay
       6  ??esp_SelAvailEmergencyCreditCmdCB?relay
       6  ??esp_SendReportEventStatus?relay
       6  ??esp_SupplyStatusRspCB?relay
       6  ??esp_ValidateAttrDataCB?relay
       6  ??esp_event_loop?relay
       4  __Constant_ffffffff
       6  espEp
       2  espFastPollModeDuration
       1  espTaskID
       3  esp_AlarmCB
       3  esp_BasicResetCB
       3  esp_CancelAllLoadControlEventsCB
      59  esp_CancelLoadControlEventCB
       3  esp_CancelMessageCB
       3  esp_ChangeSupplyCmdCB
      40  esp_DisplayMessageCB
      30  esp_GenCmdCallbacks
       3  esp_GetBlockPeriodCB
     488  esp_GetCurrentPriceCB
     180  esp_GetLastMessageCB
     152  esp_GetProfileCmdCB
       3  esp_GetProfileRspCB
       3  esp_GetScheduledEventCB
     123  esp_GetScheduledPriceCB
     258  esp_HandleKeys
      36  esp_IdentifyCB
       3  esp_IdentifyQueryRspCB
     327  esp_Init
     110  esp_LoadControlEventCB
       3  esp_MessageConfirmationCB
       3  esp_MirrorRemCmdCB
       3  esp_MirrorRemRspCB
       3  esp_PriceAcknowledgementCB
       3  esp_ProcessAppMsg
      76  esp_ProcessIdentifyTimeChange
     634  esp_ProcessInConfigReportCmd
     156  esp_ProcessInConfigReportRspCmd
       5  esp_ProcessInDefaultRspCmd
     737  esp_ProcessInReadReportCfgCmd
      94  esp_ProcessInReadReportCfgRspCmd
      47  esp_ProcessInReadRspCmd
     604  esp_ProcessInReportCmd
      47  esp_ProcessInWriteRspCmd
     186  esp_ProcessZCLMsg
     382  esp_ProcessZDOMsg
       3  esp_PublishBlockPeriodCB
       3  esp_PublishPriceCB
       3  esp_ReportEventStatusCB
     377  esp_ReqFastPollModeCmdCB
       3  esp_ReqFastPollModeRspCB
       3  esp_ReqMirrorCmdCB
       3  esp_ReqMirrorRspCB
      66  esp_SECmdCallbacks
       3  esp_SelAvailEmergencyCreditCmdCB
     319  esp_SendReportEventStatus
       3  esp_SupplyStatusRspCB
      64  esp_ValidateAttrDataCB
     353  esp_event_loop
      12  ipdAddr
      12  loadControlAddr
      24  loadControlCmd
      12  pctAddr
       9  simpleDescReqAddr

 
 5 920 bytes in segment BANKED_CODE
   282 bytes in segment BANK_RELAYS
   102 bytes in segment XDATA_I
   102 bytes in segment XDATA_ID
   115 bytes in segment XDATA_ROM_C
    72 bytes in segment XDATA_Z
 
 6 304 bytes of CODE  memory
   111 bytes of CONST memory (+ 4 bytes shared)
   174 bytes of XDATA memory

Errors: none
Warnings: none
